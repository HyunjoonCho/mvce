{
    "4693": {
        "similarity": 0.9984263181686401,
        "body": "a, b = map(int, input().split())\nif a + b >= 10:\n    print(\"error\")\nelse:\n    print(a + b)",
        "result": "passed",
        "similarities": [
            0.9951432943344116,
            0.9944997429847717,
            0.9977342486381531,
            0.9964261651039124,
            0.9984263181686401,
            0.9980653524398804,
            0.9977342486381531,
            0.9980653524398804,
            0.9977342486381531,
            0.9980653524398804,
            0.9984263181686401,
            0.994887113571167,
            0.9980653524398804,
            0.9984263181686401,
            0.9963732361793518,
            0.9977342486381531,
            0.9984263181686401,
            0.9984263181686401,
            0.9984263181686401,
            0.9984263181686401
        ]
    },
    "4077": {
        "similarity": 0.9968653321266174,
        "body": "from sortedcontainers import SortedList\n\n    left = SortedList()\n    right = SortedList(a)\n    count = 0\n    \n    for r in range(n):\n        right.remove(a[r])\n        if r % 2 == 0:\n            median = left[-1] if len(left) > len(right) else (left[-1] + right[0]) / 2\n            if median == m:\n                count += 1\n        left.add(a[r])\n    \n    return count\n\n# Read input from stdin\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_median_pairs(n, m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967868328094482,
            0.9938502311706543,
            0.9954973459243774,
            0.9944868683815002,
            0.9944778084754944,
            0.995566725730896,
            0.9968653321266174,
            0.9959725141525269,
            0.9966683983802795,
            0.9941557049751282,
            0.9954591393470764,
            0.99627286195755,
            0.9939681887626648,
            0.9965776205062866,
            0.9962573051452637,
            0.9958797097206116,
            0.996346116065979,
            0.9959893822669983,
            0.9884036183357239,
            0.9960755705833435
        ]
    },
    "4006": {
        "similarity": 0.9978436827659607,
        "body": "    reachable = set()\n    while n not in reachable:\n        reachable.add(n)\n        n += 1\n        while n % 10 == 0:\n            n //= 10\n    return len(reachable)\n\n# Read input from stdin\nn = int(input().strip())\n# Print the result\nprint(count_reachable_numbers(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966656565666199,
            0.9968031048774719,
            0.9975023865699768,
            0.9978436827659607,
            0.9970958232879639,
            0.9963505268096924,
            0.9962498545646667,
            0.9974383115768433,
            0.9978324770927429,
            0.9958711266517639,
            0.9970959424972534,
            0.997661292552948,
            0.99776691198349,
            0.9974949359893799,
            0.9976417422294617,
            0.9963736534118652,
            0.9974346160888672,
            0.9975355267524719,
            0.9978132843971252,
            0.9971579313278198
        ]
    },
    "4556": {
        "similarity": 0.9962350726127625,
        "body": "s = input().split()\nprint(s[1][0].upper())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933188557624817,
            0.9837620258331299,
            0.9958946108818054,
            0.9955055117607117,
            0.9953195452690125,
            0.9956249594688416,
            0.9955223798751831,
            0.9926562309265137,
            0.9876100420951843,
            0.9939320087432861,
            0.9958536028862,
            0.9959461688995361,
            0.9959461688995361,
            0.9962350726127625,
            0.9957678914070129,
            0.9952667951583862,
            0.9923733472824097,
            0.9950563311576843,
            0.9952976107597351,
            0.9926562309265137
        ]
    },
    "4571": {
        "similarity": 0.9971972107887268,
        "body": "import sys\n\n    fail_prob = 0.5 ** M\n    success_prob = 1 - fail_prob\n    total_time = 0\n    \n    for i in range(1, N + 1):\n        if i <= M:\n            total_time += (i * 1900) * fail_prob\n        else:\n            total_time += (i * 100)\n    \n    return int(total_time)\n\n# Read input from stdin\nN, M = map(int, input().split())\n\n# Calculate and print the expected time\nprint(expected_time(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995956301689148,
            0.9968659281730652,
            0.9965529441833496,
            0.9958755970001221,
            0.9963483214378357,
            0.9963562488555908,
            0.9962053894996643,
            0.9969151020050049,
            0.9961079955101013,
            0.9971577525138855,
            0.996070384979248,
            0.9970439076423645,
            0.9970024824142456,
            0.9971972107887268,
            0.9971534609794617,
            0.9947782158851624,
            0.9971548318862915,
            0.9967761635780334,
            0.9959021210670471,
            0.9967467784881592
        ]
    },
    "4019": {
        "similarity": 0.9978175759315491,
        "body": "    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    \n    if n - 1 != m:\n        print(\"NO\")\n        return\n    \n    from collections import defaultdict, deque\n    graph = defaultdict(list)\n    degree = [0] * (n + 1)\n    \n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n        degree[v] += 1\n        degree[u] += 1\n    \n    if degree[1] != D:\n        print(\"NO\")\n        return\n    \n        stack = [(node, parent)]\n        while stack:\n            node, parent = stack.pop()\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                dfs(neighbor, node)\n    \n    dfs(1, -1)\n    print(\"YES\")\n    for v, u in edges:\n        if degree[v] > 0 and degree[u] > 0:\n            print(v, u)\n            degree[v] -= 1\n            degree[u] -= 1\n\nn, m, D = map(int, input().split())\nfind_spanning_tree(n, m, D)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965570569038391,
            0.9973596334457397,
            0.9971479177474976,
            0.9973787069320679,
            0.9971398115158081,
            0.9973006248474121,
            0.9972723126411438,
            0.9969345927238464,
            0.997532308101654,
            0.9965175986289978,
            0.9970349669456482,
            0.9967619180679321,
            0.9968072772026062,
            0.9947599172592163,
            0.9976071715354919,
            0.9933218955993652,
            0.997484028339386,
            0.9961574077606201,
            0.9978175759315491,
            0.9976112246513367
        ]
    },
    "4265": {
        "similarity": 0.9951293468475342,
        "body": "    return sum(s != t for s, t in zip(S, T))\n\n# Read input from stdin\nimport sys\nS = input().strip()\nT = input().strip()\n\n# Print the result\nprint(min_operations(S, T))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933742880821228,
            0.99365234375,
            0.9922429919242859,
            0.9951293468475342,
            0.9931056499481201,
            0.9948365092277527,
            0.9922435283660889,
            0.9935399293899536,
            0.994912326335907,
            0.9947160482406616,
            0.9935902953147888,
            0.9929465055465698,
            0.9945744872093201,
            0.9939963817596436,
            0.9656800627708435,
            0.993902325630188,
            0.9950464367866516,
            0.9926402568817139,
            0.9918867349624634,
            0.9948859810829163
        ]
    },
    "4657": {
        "similarity": 0.998555064201355,
        "body": "    if n % 2 != k % 2:\n        return \"NO\"\n    \n    odd_indices = [i for i in range(n) if a[i] % 2 == 1]\n    if len(odd_indices) < k:\n        return \"NO\"\n    \n    result = []\n    start = 0\n    for i in range(k):\n        end = min(start + len(odd_indices), n)\n        while end > start and odd_indices[end - 1] >= end:\n            end -= 1\n        if end == start:\n            return \"NO\"\n        result.append(end)\n        start = end\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    q = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_divide_into_odd_subsegments(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927654266357422,
            0.9983474612236023,
            0.9980344176292419,
            0.9982655048370361,
            0.9973763227462769,
            0.9983996152877808,
            0.998304545879364,
            0.9981259703636169,
            0.9983122944831848,
            0.9982416033744812,
            0.998555064201355,
            0.9978485107421875,
            0.9979342222213745,
            0.9958921074867249,
            0.9982931017875671,
            0.9979587197303772,
            0.9984428286552429,
            0.9984136819839478,
            0.9980379343032837,
            0.9983395934104919
        ]
    },
    "4599": {
        "similarity": 0.9945787191390991,
        "body": "    alice_score = 0\n    bob_score = 0\n    for i in range(N):\n        if i % 2 == 0:\n            alice_score += max(a)\n            a.remove(max(a))\n        else:\n            bob_score += max(a)\n            a.remove(max(a))\n    return alice_score - bob_score\n\n# Read input from stdin\nN = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = game(N, a)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943334460258484,
            0.9929028749465942,
            0.9935412406921387,
            0.9904648661613464,
            0.9912794232368469,
            0.9913861155509949,
            0.9933540225028992,
            0.9945787191390991,
            0.9942815899848938,
            0.9941959381103516,
            0.9934583902359009,
            0.9938862323760986,
            0.99086993932724,
            0.9907038807868958,
            0.9907249808311462,
            0.9927929639816284,
            0.9938816428184509,
            0.9845476746559143,
            0.9873340129852295,
            0.9904987215995789
        ]
    },
    "4774": {
        "similarity": 0.9974538087844849,
        "body": "    operators = ['+', '-', '*', '/']\n    results = []\n\n    for op1 in operators:\n        for op2 in operators:\n            expr1 = f\"{a} {op1} {b}\"\n            expr2 = f\"{c} {op2} {d}\"\n            try:\n                if eval(expr1) == eval(expr2):\n                    results.append(f\"{expr1} = {expr2}\")\n            except ZeroDivisionError:\n                continue\n\n    if not results:\n        print(\"problems ahead\")\n    else:\n        for result in sorted(results):\n            print(result)\n\n# Read input from stdin\na, b, c, d = map(int, input().split())\n\nfind_valid_expressions(a, b, c, d)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970573782920837,
            0.9959324598312378,
            0.9971697926521301,
            0.9957385063171387,
            0.997161865234375,
            0.9909676313400269,
            0.997107982635498,
            0.9965132474899292,
            0.9966773986816406,
            0.9964417219161987,
            0.9967988729476929,
            0.9968011975288391,
            0.9964520335197449,
            0.9972262978553772,
            0.9904086589813232,
            0.9970540404319763,
            0.9968333840370178,
            0.9954625368118286,
            0.9974538087844849,
            0.9971945881843567
        ]
    },
    "4851": {
        "similarity": 0.998622477054596,
        "body": "    digit_sum = sum(int(digit) for digit in str(num))\n    return num % digit_sum == 0\n\n    while not is_harshad_number(n):\n        n += 1\n    return n\n\nn = int(input())\nprint(find_next_harshad(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9984371662139893,
            0.998622477054596,
            0.9984371662139893,
            0.9963328838348389,
            0.998622477054596,
            0.998126208782196,
            0.997391939163208,
            0.998622477054596,
            0.9983822703361511,
            0.9984371662139893,
            0.9984371662139893,
            0.9984371662139893,
            0.9982763528823853,
            0.9976379871368408,
            0.9972990155220032,
            0.9978618621826172,
            0.9985514283180237,
            0.9985514283180237,
            0.9977427124977112,
            0.9972305297851562
        ]
    },
    "4655": {
        "similarity": 0.9946413636207581,
        "body": "import sys\n\n    piles = sorted([a, b, c])\n    alice = 0\n    bob = 0\n    \n    if piles[2] - piles[1] <= piles[1]:\n        alice = (piles[1] + piles[2]) // 2\n        bob = (piles[1] + piles[2]) // 2\n    else:\n        alice = piles[1] + (piles[2] - piles[1]) // 2\n        bob = piles[1] + (piles[2] - piles[1]) // 2\n    \n    return max(alice, bob)\n\n    q = int(input().strip())\n    results = []\n    \n    for _ in range(q):\n        a, b, c = map(int, input().strip().split())\n        result = max_candies(a, b, c)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939035177230835,
            0.994054913520813,
            0.9937828779220581,
            0.9928067922592163,
            0.9933989644050598,
            0.9935202598571777,
            0.9851858019828796,
            0.9940834045410156,
            0.9934913516044617,
            0.9817315340042114,
            0.9854676127433777,
            0.9927665591239929,
            0.9920985698699951,
            0.9924145936965942,
            0.9895495176315308,
            0.9895167350769043,
            0.9946413636207581,
            0.9864688515663147,
            0.9941815733909607,
            0.9850853681564331
        ]
    },
    "4132": {
        "similarity": 0.9960888624191284,
        "body": "import sys\n\n    A.sort()\n    for i in range(N-2, -1, -1):\n        A[i] -= A[N-1]\n        if A[i] < 0:\n            A[i] = 0\n        A[-1] = max(A[-1], A[i])\n    return A[0]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    print(min_final_health(N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958096742630005,
            0.9950982928276062,
            0.9953036308288574,
            0.9952551126480103,
            0.9944943189620972,
            0.9935643076896667,
            0.99370938539505,
            0.993113100528717,
            0.9946901202201843,
            0.9954562187194824,
            0.9960888624191284,
            0.9955724477767944,
            0.9918519258499146,
            0.9956181049346924,
            0.9940528869628906,
            0.9960613250732422,
            0.9940442442893982,
            0.9904485940933228,
            0.9877243041992188,
            0.9942654967308044
        ]
    },
    "4085": {
        "similarity": 0.9978243112564087,
        "body": "    if n == 1:\n        return -1\n    \n    from math import isqrt\n    possible_numbers = set()\n    \n    for i in range(2, isqrt(divisors[-1]) + 1):\n        if all(d % i == 0 for d in divisors):\n            possible_numbers.add(i)\n            possible_numbers.add(divisors[-1] // i)\n    \n    if len(possible_numbers) != n:\n        return -1\n    \n    return min(possible_numbers)\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        divisors = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_minimum_number(n, divisors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973480105400085,
            0.9968883395195007,
            0.9964439272880554,
            0.9968070983886719,
            0.9976499676704407,
            0.9969406127929688,
            0.9978243112564087,
            0.9965277314186096,
            0.9977982044219971,
            0.9977898001670837,
            0.9911033511161804,
            0.9957096576690674,
            0.9977657794952393,
            0.9975101947784424,
            0.9961044192314148,
            0.9962499737739563,
            0.9973626732826233,
            0.9976420998573303,
            0.9961082935333252,
            0.9975460767745972
        ]
    },
    "4399": {
        "similarity": 0.996518075466156,
        "body": "    if 'A' in S and 'B' in S:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input\nS = input().strip()\n\n# Output the result\nprint(check_bus_service(S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996518075466156,
            0.996421217918396,
            0.9944005608558655,
            0.9965063333511353,
            0.992612361907959,
            0.992018461227417,
            0.9948058128356934,
            0.995578944683075,
            0.9936684370040894,
            0.9947834014892578,
            0.9944005608558655,
            0.9964591860771179,
            0.9950525164604187,
            0.9950001239776611,
            0.9963748455047607,
            0.9939956665039062,
            0.9957814812660217,
            0.9954597353935242,
            0.9955184459686279,
            0.9937772154808044
        ]
    },
    "4999": {
        "similarity": 0.9983020424842834,
        "body": "    operations = 0\n    while a < b:\n        if b % 2 == 1:\n            b += 1\n        else:\n            b //= 2\n        operations += 1\n    return operations + (a - b)\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982465505599976,
            0.9960853457450867,
            0.9965872764587402,
            0.9983020424842834,
            0.9974569082260132,
            0.9980779886245728,
            0.9982207417488098,
            0.9975254535675049,
            0.996141254901886,
            0.9973112344741821,
            0.9983020424842834,
            0.9983020424842834,
            0.9978581666946411,
            0.9963244199752808,
            0.9976529479026794,
            0.998221755027771,
            0.9975885152816772,
            0.9976838827133179,
            0.9973884224891663,
            0.9970809817314148
        ]
    },
    "4727": {
        "similarity": 0.998031735420227,
        "body": "    for row in grid:\n        non_zero = [x for x in row if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zero):\n            if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                merged.append(non_zero[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zero[i])\n                i += 1\n        row[:] = merged + [0] * (4 - len(merged))\n    return grid\n\n    for col in range(4):\n        non_zero = [grid[row][col] for row in range(4) if grid[row][col] != 0]\n        merged = []\n        i = 0\n        while i < len(non_zero):\n            if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                merged.append(non_zero[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zero[i])\n                i += 1\n        for row in range(4):\n            grid[row][col] = merged[row] if row < len(merged) else 0\n    return grid\n\n    for row in grid:\n        non_zero = [x for x in row if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zero):\n            if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                merged.append(non_zero[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zero[i])\n                i += 1\n        row[:] = [0] * (4 - len(merged)) + merged[::-1]\n    return grid\n\n    for col in range(4):\n        non_zero = [grid[row][col] for row in range(3, -1, -1) if grid[row][col] != 0]\n        merged = []\n        i = 0\n        while i < len(non_zero):\n            if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                merged.append(non_zero[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zero[i])\n                i += 1\n        for row in range(4):\n            grid[row][col] = merged[3 - row] if row < len(merged) else 0\n    return grid\n\n    grid = [list(map(int, input().split())) for _ in range(4)]\n    direction = int(input())\n    \n    if direction == 0:\n        move_left(grid)\n    elif direction == 1:\n        move_up(grid)\n    elif direction == 2:\n        move_right(grid)\n    elif direction == 3:\n        move_down(grid)\n    \n    for row in grid:\n        print(*row)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.998031735420227,
            0.9979585409164429,
            0.9975051879882812,
            0.9975616335868835,
            0.9950112104415894,
            0.9978033304214478,
            0.9960437417030334,
            0.9974216818809509,
            0.9962666034698486,
            0.9959079623222351,
            0.9978690147399902,
            0.995701253414154,
            0.9964942932128906,
            0.996765673160553,
            0.9970273375511169,
            0.9976484179496765,
            0.9971461296081543,
            0.9979886412620544,
            0.9973521828651428,
            0.9974249601364136
        ]
    },
    "4906": {
        "similarity": 0.9980697631835938,
        "body": "import sys\n\n    encoded = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            encoded.append(s[i-1])\n            encoded.append(str(count))\n            count = 1\n    encoded.append(s[-1])\n    encoded.append(str(count))\n    return ''.join(encoded)\n\n    decoded = []\n    i = 0\n    while i < len(s):\n        char = s[i]\n        i += 1\n        count = int(s[i])\n        decoded.extend([char] * count)\n        i += 1\n    return ''.join(decoded)\n\nif __name__ == \"__main__\":\n    input_data = input().strip()\n    command, message = input_data.split(' ', 1)\n    \n    if command == 'E':\n        result = run_length_encode(message)\n    elif command == 'D':\n        result = run_length_decode(message)\n    else:\n        raise ValueError(\"Invalid command\")\n    \n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975757598876953,
            0.9979639649391174,
            0.9971877932548523,
            0.9967983961105347,
            0.9975122213363647,
            0.9965023398399353,
            0.9971960186958313,
            0.9980697631835938,
            0.9971523284912109,
            0.9961004853248596,
            0.9980607628822327,
            0.9977832436561584,
            0.997825026512146,
            0.9971777200698853,
            0.9978185892105103,
            0.9959518313407898,
            0.9955337047576904,
            0.9968758821487427,
            0.9975967407226562,
            0.9967661499977112
        ]
    },
    "4011": {
        "similarity": 0.9974170327186584,
        "body": "    max_result = int(a)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment = a[i:j]\n            transformed_segment = ''.join(str(f[int(digit) - 1]) for digit in segment)\n            new_number = a[:i] + transformed_segment + a[j:]\n            max_result = max(max_result, int(new_number))\n    return max_result\n\n# Read input\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\n# Get the result and print it\nresult = max_number_after_operation(n, a, f)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968382120132446,
            0.9962071180343628,
            0.9958444237709045,
            0.996493399143219,
            0.996665358543396,
            0.9966335296630859,
            0.9970682263374329,
            0.9974170327186584,
            0.9961491823196411,
            0.9968992471694946,
            0.9962799549102783,
            0.9948432445526123,
            0.995410144329071,
            0.9967384338378906,
            0.9902701377868652,
            0.9962834715843201,
            0.9970796704292297,
            0.9960899353027344,
            0.9961392283439636,
            0.9966728687286377
        ]
    },
    "4099": {
        "similarity": 0.9986764788627625,
        "body": "    total_required = N * M\n    current_total = sum(A)\n    points_needed = total_required - current_total\n    \n    if points_needed > K or points_needed < 0:\n        return -1\n    else:\n        return points_needed\n\n# Read input from stdin\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(min_points_needed(N, K, M, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9985741972923279,
            0.9980053305625916,
            0.9986764788627625,
            0.998511552810669,
            0.9980593323707581,
            0.9968713521957397,
            0.997721254825592,
            0.9985771179199219,
            0.9978322386741638,
            0.998030424118042,
            0.9976736307144165,
            0.9985841512680054,
            0.9986211657524109,
            0.9978963136672974,
            0.9979742765426636,
            0.9986234903335571,
            0.9984886050224304,
            0.9971767067909241,
            0.9984864592552185,
            0.9985273480415344
        ]
    },
    "4465": {
        "similarity": 0.9941725730895996,
        "body": "    A, B = map(int, input().split())\n    area = (A - 1) * (B - 1)\n    print(area)\n\ncalculate_yard_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.990381121635437,
            0.9917030334472656,
            0.9941725730895996,
            0.9931201934814453,
            0.9896780252456665,
            0.9941725730895996,
            0.9941725730895996,
            0.9941102266311646,
            0.994110107421875,
            0.9937745928764343,
            0.9919049143791199,
            0.994110107421875,
            0.9941725730895996,
            0.9936925172805786,
            0.9895722270011902,
            0.9921007752418518,
            0.9937745928764343,
            0.9941725730895996,
            0.9900889992713928,
            0.9937745928764343
        ]
    },
    "4315": {
        "similarity": 0.9968861937522888,
        "body": "import math\n\nR = int(input())\ncircumference = 2 * math.pi * R\nprint(circumference)",
        "result": "passed",
        "similarities": [
            0.9968861937522888,
            0.9965946674346924,
            0.9963676929473877,
            0.9952327609062195,
            0.9963915944099426,
            0.9968861937522888,
            0.9968861937522888,
            0.9962409138679504,
            0.9947502017021179,
            0.9961418509483337,
            0.9968861937522888,
            0.9968861937522888,
            0.9961397051811218,
            0.9962409138679504,
            0.9949464201927185,
            0.996791660785675,
            0.9968861937522888,
            0.9968861937522888,
            0.9968861937522888,
            0.9968215823173523
        ]
    },
    "4633": {
        "similarity": 0.9979350566864014,
        "body": "    moves = 0\n    while sum(int(digit) for digit in str(n)) > s:\n        n += 1\n        moves += 1\n    return moves\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, s = map(int, input().split())\n    results.append(min_moves(n, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979350566864014,
            0.9979350566864014,
            0.9961713552474976,
            0.9965125918388367,
            0.9964561462402344,
            0.9973540902137756,
            0.9974762797355652,
            0.9979350566864014,
            0.9954227805137634,
            0.9966916441917419,
            0.9979259967803955,
            0.9969713091850281,
            0.9967121481895447,
            0.9971184134483337,
            0.9920405149459839,
            0.995688796043396,
            0.9959367513656616,
            0.9975572228431702,
            0.9974278807640076,
            0.9962202310562134
        ]
    },
    "4734": {
        "similarity": 0.9981107115745544,
        "body": "    if Y.endswith('ex'):\n        return Y + P\n    elif Y[-1] in 'aeiou':\n        return Y[:-1] + 'ex' + P\n    else:\n        return Y + 'ex' + P\n\nY, P = input().split()\nprint(extend_name(Y, P))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963240623474121,
            0.9967564940452576,
            0.9971905946731567,
            0.9972066283226013,
            0.9979546070098877,
            0.9966983795166016,
            0.9963145852088928,
            0.9962282776832581,
            0.9978262186050415,
            0.9978963136672974,
            0.9959537386894226,
            0.9977241158485413,
            0.9962055683135986,
            0.9978963136672974,
            0.9978232383728027,
            0.9966832995414734,
            0.9981107115745544,
            0.997412919998169,
            0.9979982972145081,
            0.9947326183319092
        ]
    },
    "4229": {
        "similarity": 0.9988203644752502,
        "body": "    total = 0\n    for i in range(1, N + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            continue\n        elif i % 3 == 0:\n            continue\n        elif i % 5 == 0:\n            continue\n        else:\n            total += i\n    print(total)\n\nN = int(input())\nfizzbuzz_sum(N)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9988203644752502,
            0.9970062971115112,
            0.9985572695732117,
            0.9988030791282654,
            0.9987921714782715,
            0.9987984895706177,
            0.9987609386444092,
            0.9984740018844604,
            0.9988203644752502,
            0.9988031983375549,
            0.9962610006332397,
            0.9981734752655029,
            0.9984970092773438,
            0.9985175132751465,
            0.9975196719169617,
            0.9988031983375549,
            0.9981046915054321,
            0.9985799193382263,
            0.9965029358863831,
            0.9982897043228149
        ]
    },
    "4321": {
        "similarity": 0.9964162707328796,
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\n# Read input\nn, k = map(int, input().split())\n\n# Print result\nprint(tanya_decrease(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9932773113250732,
            0.9942666888237,
            0.9932773113250732,
            0.9932773113250732,
            0.9942666888237,
            0.9957786202430725,
            0.9932773113250732,
            0.9942666888237,
            0.9932773113250732,
            0.9942666292190552,
            0.9932773113250732,
            0.9942666292190552,
            0.9932773113250732,
            0.9960054159164429,
            0.9960054159164429,
            0.9942666888237,
            0.9942666888237,
            0.9964162707328796,
            0.9932773113250732,
            0.9960054159164429
        ]
    },
    "4503": {
        "similarity": 0.9971519112586975,
        "body": "    moves = set()\n    for move in A:\n        if H % move == 0 and move not in moves:\n            return \"Yes\"\n        moves.add(move)\n    return \"No\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nH = int(data[0])\nN = int(data[1])\nA = list(map(int, data[2:]))\n\nresult = can_win(H, N, A)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971519112586975,
            0.9957149028778076,
            0.9961742758750916,
            0.995858371257782,
            0.9949948191642761,
            0.9961405396461487,
            0.996417224407196,
            0.9967461824417114,
            0.9971140027046204,
            0.9925748109817505,
            0.9961204528808594,
            0.9969169497489929,
            0.9960202574729919,
            0.9967635273933411,
            0.9970751404762268,
            0.9944199919700623,
            0.9962204694747925,
            0.9968985319137573,
            0.9963163137435913,
            0.9957979321479797
        ]
    },
    "4855": {
        "similarity": 0.994218647480011,
        "body": "import math\n\n    current_citations = A * (A - 1) // 2\n    required_citations = math.ceil(I * A)\n    additional_citations_needed = max(0, required_citations - current_citations)\n    return additional_citations_needed\n\n# Read input from stdin\nA, I = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_min_bribes(A, I))",
        "result": "failed: testcase 0",
        "similarities": [
            0.994218647480011,
            0.9924426674842834,
            0.9925237894058228,
            0.9938338398933411,
            0.991176426410675,
            0.9891932606697083,
            0.9927921295166016,
            0.9911618828773499,
            0.9933162331581116,
            0.9917051196098328,
            0.9926270246505737,
            0.9939834475517273,
            0.9936708211898804,
            0.9915175437927246,
            0.9939796328544617,
            0.9923003315925598,
            0.9869571328163147,
            0.9930538535118103,
            0.9902111887931824,
            0.9932249188423157
        ]
    },
    "4704": {
        "similarity": 0.9975253939628601,
        "body": "    total_sum = sum(a)\n    min_diff = float('inf')\n    \n    for i in range(1, N):\n        x = sum(a[:i])\n        y = total_sum - x\n        diff = abs(x - y)\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n# Read input from stdin\nN = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_abs_difference(N, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969335794448853,
            0.9974105358123779,
            0.9969335794448853,
            0.9971510171890259,
            0.9901217222213745,
            0.9974636435508728,
            0.9970093965530396,
            0.9970245361328125,
            0.9965117573738098,
            0.9961562156677246,
            0.9974128603935242,
            0.9974566102027893,
            0.9969300031661987,
            0.996512770652771,
            0.9965741038322449,
            0.9964838624000549,
            0.9968975782394409,
            0.9970396161079407,
            0.9964181184768677,
            0.9975253939628601
        ]
    },
    "4829": {
        "similarity": 0.9974098205566406,
        "body": "    if l == 0 and r == 0:\n        return \"Not a moose\"\n    elif l == r:\n        return f\"Even {2 * l}\"\n    else:\n        max_tines = max(l, r)\n        if max_tines - min(l, r) > 1:\n            return \"Not a moose\"\n        else:\n            return f\"Odd {2 * max_tines}\"\n\n# Read input\nl, r = map(int, input().split())\n\n# Print result\nprint(moose_points(l, r))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973263144493103,
            0.9964106678962708,
            0.9964583516120911,
            0.9970763325691223,
            0.9956827759742737,
            0.9963144063949585,
            0.9972643852233887,
            0.9971905946731567,
            0.9972954988479614,
            0.997107744216919,
            0.996714174747467,
            0.9967597126960754,
            0.9971514344215393,
            0.9921140074729919,
            0.9969121217727661,
            0.9963166117668152,
            0.9963536858558655,
            0.9974098205566406,
            0.9952309131622314,
            0.9969590902328491
        ]
    },
    "4730": {
        "similarity": 0.9983066916465759,
        "body": "    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    L = int(input())\n    program = input()\n    \n    for i, char in enumerate(program):\n        if char in \"([{\":\n            stack.append((char, i))\n        elif char in \")]}\":\n            if not stack or stack[-1][0] != mapping[char]:\n                print(char, i)\n                return\n            stack.pop()\n    \n    if stack:\n        last_open = stack[-1]\n        print(last_open[0], last_open[1])\n    else:\n        print(\"ok so far\")\n\nvalidate_delimiters()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980829954147339,
            0.9936674237251282,
            0.9974363446235657,
            0.9957992434501648,
            0.9978697896003723,
            0.9981265664100647,
            0.9972240924835205,
            0.9979098439216614,
            0.9981116056442261,
            0.9983066916465759,
            0.9979689717292786,
            0.9975520968437195,
            0.9980491995811462,
            0.9972202777862549,
            0.9982624053955078,
            0.9982396960258484,
            0.9979571104049683,
            0.9971056580543518,
            0.9975376129150391,
            0.9944214224815369
        ]
    },
    "4729": {
        "similarity": 0.9979661703109741,
        "body": "    password_set = set(password)\n    pos = 0\n    for char in password:\n        try:\n            pos = message.index(char, pos) + 1\n        except ValueError:\n            return \"FAIL\"\n    return \"PASS\"\n\n# Read input from stdin\npassword, message = input().split()\nprint(is_valid_message(password, message))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975718259811401,
            0.997392475605011,
            0.9971989989280701,
            0.995493471622467,
            0.9971967935562134,
            0.9968159198760986,
            0.9975587725639343,
            0.9969239830970764,
            0.9978794455528259,
            0.9973848462104797,
            0.9978513121604919,
            0.9967764019966125,
            0.9979661703109741,
            0.9969096779823303,
            0.9962961077690125,
            0.9977476000785828,
            0.9970899820327759,
            0.99697345495224,
            0.9979605674743652,
            0.9972326159477234
        ]
    },
    "4582": {
        "similarity": 0.996803879737854,
        "body": "a = input()\nb = input()\n\nif a == 'H':\n    if b == 'H':\n        print('H')\n    else:\n        print('D')\nelse:\n    if b == 'H':\n        print('D')\n    else:\n        print('H')",
        "result": "failed: testcase 0",
        "similarities": [
            0.996803879737854,
            0.9965858459472656,
            0.9965858459472656,
            0.9912107586860657,
            0.9953027963638306,
            0.996803879737854,
            0.996803879737854,
            0.9957205057144165,
            0.9967753887176514,
            0.996803879737854,
            0.9963456988334656,
            0.9965858459472656,
            0.9966870546340942,
            0.9927378296852112,
            0.9859928488731384,
            0.9965857267379761,
            0.9933041930198669,
            0.996803879737854,
            0.996803879737854,
            0.9865540266036987
        ]
    },
    "4910": {
        "similarity": 0.9978067278862,
        "body": "from collections import Counter\nimport sys\n\n    N = int(input())\n    costumes = [input().strip() for _ in range(N)]\n    costume_counts = Counter(costumes)\n    max_count = max(costume_counts.values())\n    winning_costumes = sorted([costume for costume, count in costume_counts.items() if count == max_count])\n    \n    print(\"\\n\".join(winning_costumes))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974925518035889,
            0.9950374960899353,
            0.9975333213806152,
            0.9975744485855103,
            0.9977647662162781,
            0.9961461424827576,
            0.9977126717567444,
            0.9953945875167847,
            0.9969691038131714,
            0.9877315163612366,
            0.9971215128898621,
            0.9975625872612,
            0.9977456331253052,
            0.9929498434066772,
            0.9978067278862,
            0.9972463846206665,
            0.9969783425331116,
            0.9939013123512268,
            0.9975425601005554,
            0.9973389506340027
        ]
    },
    "4323": {
        "similarity": 0.9964938759803772,
        "body": "import sys\n\n    a, b = zip(*songs)\n    total_size = sum(a)\n    \n    if total_size <= m:\n        return 0\n    \n    dp = [float('inf')] * (m + 1)\n    dp[0] = 0\n    \n    for size in a:\n        for j in range(m, size - 1, -1):\n            dp[j] = min(dp[j], dp[j - size] + 1)\n    \n    if dp[m] == float('inf'):\n        return -1\n    else:\n        return n - dp[m]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    songs = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(n)]\n    \n    result = min_compressions(n, m, songs)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959401488304138,
            0.9952782392501831,
            0.9953990578651428,
            0.9956708550453186,
            0.9952954649925232,
            0.9955759644508362,
            0.9961246848106384,
            0.9954354166984558,
            0.9924763441085815,
            0.9952398538589478,
            0.9937936663627625,
            0.9958497881889343,
            0.9963526725769043,
            0.9954763650894165,
            0.993416428565979,
            0.9933599233627319,
            0.9964128136634827,
            0.9950681924819946,
            0.9951099753379822,
            0.9964938759803772
        ]
    },
    "4626": {
        "similarity": 0.9949333071708679,
        "body": "    results = []\n    for _ in range(q):\n        a, b, c = map(int, input().split())\n        positions = sorted([a, b, c])\n        d1 = abs(positions[0] - positions[2])\n        d2 = abs(positions[1] - positions[2])\n        d3 = abs(positions[1] - positions[0])\n        results.append(min(d1, d2, d3))\n    for result in results:\n        print(result)\n\nq = int(input())\nmin_pairwise_distance(q)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933407306671143,
            0.9932591319084167,
            0.9930371642112732,
            0.9931120872497559,
            0.9920865893363953,
            0.9947437644004822,
            0.9947752952575684,
            0.991187572479248,
            0.9909723401069641,
            0.9942340850830078,
            0.9914543032646179,
            0.9941219687461853,
            0.9939665794372559,
            0.9864910840988159,
            0.9949333071708679,
            0.9912378191947937,
            0.9940619468688965,
            0.9936668872833252,
            0.9929620623588562,
            0.9907903075218201
        ]
    },
    "4400": {
        "similarity": 0.9902598857879639,
        "body": "    return S.count('R')\n\n# Read input from stdin\nS = input()\n\n# Print the result\nprint(max_consecutive_rainy_days(S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9782337546348572,
            0.9899394512176514,
            0.9846602082252502,
            0.9816436767578125,
            0.9823811054229736,
            0.980485737323761,
            0.9812448620796204,
            0.9898346662521362,
            0.9846978783607483,
            0.9782337546348572,
            0.9782337546348572,
            0.9870098829269409,
            0.9901721477508545,
            0.9895164966583252,
            0.9892616271972656,
            0.9871665835380554,
            0.9902598857879639,
            0.9782337546348572,
            0.974859356880188,
            0.974859356880188
        ]
    },
    "4794": {
        "similarity": 0.9967080950737,
        "body": "    grid = [list(input()) for _ in range(R)]\n    directions = [(0, 1), (1, 0), (1, 1)]\n\n        return 0 <= x < R and 0 <= y < C and grid[x][y] != '#'\n\n        count = 0\n        while is_valid(x + dx * count, y + dy * count) and grid[x + dx * count][y + dy * count] == 'X':\n            count += 1\n        return count\n\n    parking_counts = [0] * 5\n\n    for i in range(R):\n        for j in range(C):\n            if is_valid(i, j) and grid[i][j] != '#':\n                cars_squashed = 0\n                for dx, dy in directions:\n                    cars_squashed += count_cars(i, j, dx, dy)\n                parking_counts[cars_squashed] += 1\n\n    print(parking_counts[0])\n    print(parking_counts[1])\n    print(parking_counts[2])\n    print(parking_counts[3])\n    print(parking_counts[4])\n\nR, C = map(int, input().split())\ncount_parking_spaces(R, C)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934158325195312,
            0.995367169380188,
            0.9966651797294617,
            0.9960354566574097,
            0.9948133230209351,
            0.9947223663330078,
            0.9955835938453674,
            0.9962696433067322,
            0.9960070252418518,
            0.9965083599090576,
            0.9957003593444824,
            0.9962080717086792,
            0.9948492646217346,
            0.9946828484535217,
            0.9944779276847839,
            0.9955894351005554,
            0.9961643218994141,
            0.9967080950737,
            0.9938084483146667,
            0.9958329796791077
        ]
    },
    "4096": {
        "similarity": 0.9982019066810608,
        "body": "    a.sort(reverse=True)\n    days = 0\n    pages_written = 0\n    \n    for i in range(n):\n        if a[i] <= days:\n            continue\n        days += 1\n        pages_written += max(0, a[i] - days + 1)\n        if pages_written >= m:\n            return days\n    \n    return -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:]))\n\nresult = min_days(n, m, a)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964413046836853,
            0.9978632926940918,
            0.9966534376144409,
            0.9977893829345703,
            0.9979478716850281,
            0.9976439476013184,
            0.9968075156211853,
            0.9978058338165283,
            0.9964330792427063,
            0.996698260307312,
            0.9979258179664612,
            0.9972848296165466,
            0.9981180429458618,
            0.9974808096885681,
            0.9979962706565857,
            0.9980916380882263,
            0.9970065951347351,
            0.9982019066810608,
            0.9979327321052551,
            0.9960899353027344
        ]
    },
    "4530": {
        "similarity": 0.9975810647010803,
        "body": "from collections import Counter\n\n    skill_counts = Counter(skills)\n    unique_skills = set(skill_counts.keys())\n    \n    for size in range(n // 2, 0, -1):\n        if len(unique_skills) >= size:\n            remaining = [skill_count for skill_count in skill_counts.values() if skill_count >= size]\n            if sum(remaining[:size]) == size * size:\n                return size\n    return 0\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        skills = list(map(int, data[index:index + n]))\n        index += n\n        result = max_team_size(n, skills)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958385825157166,
            0.9970327615737915,
            0.9963241219520569,
            0.9975810647010803,
            0.997128963470459,
            0.9975151419639587,
            0.9974439740180969,
            0.9952484965324402,
            0.9974357485771179,
            0.9971763491630554,
            0.997258722782135,
            0.9961365461349487,
            0.9958867430686951,
            0.9966000914573669,
            0.9938119649887085,
            0.9931550621986389,
            0.9973556995391846,
            0.9955026507377625,
            0.9974578022956848,
            0.9964325428009033
        ]
    },
    "4724": {
        "similarity": 0.9968422651290894,
        "body": "R = int(input())\nG = int(input())\nperformance = (2 * G - R)\nprint(performance)",
        "result": "passed",
        "similarities": [
            0.9956895709037781,
            0.9960726499557495,
            0.9956895709037781,
            0.9968422651290894,
            0.9956895709037781,
            0.9968321919441223,
            0.9961820840835571,
            0.9968321919441223,
            0.9742913842201233,
            0.9967597126960754,
            0.9956895709037781,
            0.9956895709037781,
            0.9968422651290894,
            0.9956895709037781,
            0.9968321919441223,
            0.9968422651290894,
            0.9968422651290894,
            0.9968321919441223,
            0.9947363138198853,
            0.9798060059547424
        ]
    },
    "4276": {
        "similarity": 0.9967629313468933,
        "body": "import sys\n\n    min_cost = float('inf')\n    for cost, time in routes:\n        if time <= T and cost < min_cost:\n            min_cost = cost\n    return min_cost if min_cost != float('inf') else 'TLE'\n\nif __name__ == \"__main__\":\n    N, T = map(int, input().split())\n    routes = [tuple(map(int, input().split())) for _ in range(N)]\n    result = find_min_cost_route(N, T, routes)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962983727455139,
            0.9945634603500366,
            0.9959443807601929,
            0.9961748719215393,
            0.995802104473114,
            0.995985209941864,
            0.9914897084236145,
            0.9943246245384216,
            0.9967352151870728,
            0.9967629313468933,
            0.9961977601051331,
            0.9958125948905945,
            0.9958305358886719,
            0.9952841401100159,
            0.995644211769104,
            0.9961130023002625,
            0.9964232444763184,
            0.9961618185043335,
            0.9966450929641724,
            0.9957922101020813
        ]
    },
    "4708": {
        "similarity": 0.9946832060813904,
        "body": "import sys\n\n    N = int(input())\n    K = int(input())\n    X = int(input())\n    Y = int(input())\n    \n    total_fee = min(K, N) * X + max(0, N - K) * Y\n    print(total_fee)\n\ncalculate_accommodation_fee()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9932295083999634,
            0.9930946826934814,
            0.9932295083999634,
            0.9932295083999634,
            0.9946832060813904,
            0.9946832060813904,
            0.9932295083999634,
            0.9920666217803955,
            0.9939475059509277,
            0.9932296276092529,
            0.9946098327636719,
            0.9924370646476746,
            0.9916692972183228,
            0.9838083982467651,
            0.9926718473434448,
            0.9932295083999634,
            0.9942229390144348,
            0.9932295083999634,
            0.9905665516853333,
            0.9932295083999634
        ]
    },
    "4396": {
        "similarity": 0.9982279539108276,
        "body": "import sys\n\n    N = int(input())\n    total_value = 0.0\n    \n    for _ in range(N):\n        x, u = input().split()\n        x = float(x)\n        \n        if u == \"JPY\":\n            total_value += x\n        elif u == \"BTC\":\n            total_value += x * 380000.0\n    \n    print(total_value)\n\ntotal_gifts()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996437668800354,
            0.996490478515625,
            0.9979806542396545,
            0.9976941347122192,
            0.9979531168937683,
            0.9981212615966797,
            0.9966594576835632,
            0.9982053637504578,
            0.997952401638031,
            0.9949320554733276,
            0.9981602430343628,
            0.9969902038574219,
            0.9967674612998962,
            0.9975196719169617,
            0.9982279539108276,
            0.9969052672386169,
            0.9966880679130554,
            0.9976099133491516,
            0.9979768395423889,
            0.9976376891136169
        ]
    },
    "4155": {
        "similarity": 0.9978966116905212,
        "body": "import sys\n\n    operations = 0\n    current_heights = [0] * N\n    \n    for i in range(N):\n        if h[i] > current_heights[i]:\n            operations += (h[i] - current_heights[i])\n            current_heights[i] = h[i]\n    \n    return operations\n\nif __name__ == \"__main__\":\n    N = int(input())\n    h = list(map(int, input().split()))\n    print(min_watering_operations(N, h))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967072010040283,
            0.9970414042472839,
            0.9978966116905212,
            0.9970107078552246,
            0.9974379539489746,
            0.9974485635757446,
            0.9972409009933472,
            0.9971632957458496,
            0.9972044229507446,
            0.997589111328125,
            0.9964982867240906,
            0.9969710111618042,
            0.9937503337860107,
            0.9971592426300049,
            0.9970346689224243,
            0.9969754815101624,
            0.9958221316337585,
            0.9968149065971375,
            0.9974620342254639,
            0.9971901774406433
        ]
    },
    "4557": {
        "similarity": 0.9959970116615295,
        "body": "A, B, X = map(int, input().split())\nif A <= X <= A + B:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
        "result": "passed",
        "similarities": [
            0.994647204875946,
            0.995847225189209,
            0.9942532777786255,
            0.994382381439209,
            0.9946032166481018,
            0.9909707307815552,
            0.9929572939872742,
            0.994647204875946,
            0.99505215883255,
            0.9956534504890442,
            0.994382381439209,
            0.9929572939872742,
            0.9931337237358093,
            0.9955994486808777,
            0.9929572939872742,
            0.9959970116615295,
            0.9959970116615295,
            0.9947901368141174,
            0.9942532777786255,
            0.9959970116615295
        ]
    },
    "4930": {
        "similarity": 0.99725341796875,
        "body": "import sys\n\n    decoded_word = []\n    i = 0\n    while i < len(sentence):\n        char = sentence[i]\n        if char in 'aeiou':\n            decoded_word.append(char * 3)\n            i += 2\n        else:\n            decoded_word.append(char)\n            i += 1\n    return ''.join(decoded_word)\n\n# Read input from stdin\ncoded_sentence = input().strip()\n\n# Decode and print the sentence\nprint(decode_sentence(coded_sentence))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957006573677063,
            0.9972444772720337,
            0.9953438639640808,
            0.9967560172080994,
            0.9953603148460388,
            0.99725341796875,
            0.9900955557823181,
            0.9969609975814819,
            0.9966983795166016,
            0.9968541860580444,
            0.9961498975753784,
            0.9967729449272156,
            0.9966938495635986,
            0.9965547323226929,
            0.9965049624443054,
            0.9960764646530151,
            0.996555507183075,
            0.9953739643096924,
            0.9969818592071533,
            0.996794581413269
        ]
    },
    "4715": {
        "similarity": 0.9968366026878357,
        "body": "    colors = {a, b, c}\n    return len(colors)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Output the result\nprint(count_unique_colors(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967137575149536,
            0.9968366026878357,
            0.9967137575149536,
            0.9937527179718018,
            0.9966292381286621,
            0.9962696433067322,
            0.9951013326644897,
            0.9943010210990906,
            0.9968366026878357,
            0.9950745105743408,
            0.9951401948928833,
            0.9951664805412292,
            0.9885376691818237,
            0.9968366026878357,
            0.9966332316398621,
            0.9920955300331116,
            0.9958585500717163,
            0.9942697286605835,
            0.9964092969894409,
            0.9950332641601562
        ]
    },
    "4008": {
        "similarity": 0.997566819190979,
        "body": "    if n < k:\n        return \"NO\"\n    \n    colors = [0] * (n + 1)\n    used_colors = set()\n    \n    for i in range(n):\n        if len(used_colors) == k:\n            break\n        if a[i] not in used_colors:\n            used_colors.add(a[i])\n            colors[i + 1] = len(used_colors)\n    \n    if len(used_colors) != k:\n        return \"NO\"\n    \n    return \"YES\\n\" + \" \".join(map(str, colors[1:]))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print output\nprint(color_array(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955821633338928,
            0.9970042705535889,
            0.9963760375976562,
            0.997566819190979,
            0.9967116117477417,
            0.9970487356185913,
            0.9972680807113647,
            0.9967004060745239,
            0.9935396909713745,
            0.9950969219207764,
            0.9954384565353394,
            0.9946367144584656,
            0.9936486482620239,
            0.9970564842224121,
            0.9957496523857117,
            0.9970753192901611,
            0.9972211718559265,
            0.9973153471946716,
            0.9963221549987793,
            0.9969567656517029
        ]
    },
    "4257": {
        "similarity": 0.999541163444519,
        "body": "A, B = map(int, input().split())\nprint(A * B)",
        "result": "passed",
        "similarities": [
            0.9994583129882812,
            0.999541163444519,
            0.999541163444519,
            0.9994583129882812,
            0.9994583129882812,
            0.9987204670906067,
            0.9987204670906067,
            0.999541163444519,
            0.9987204670906067,
            0.999541163444519,
            0.9994583129882812,
            0.999541163444519,
            0.9987204670906067,
            0.9987204670906067,
            0.9994583129882812,
            0.999541163444519,
            0.999541163444519,
            0.9994583129882812,
            0.9994583129882812,
            0.999541163444519
        ]
    },
    "4584": {
        "similarity": 0.9985381960868835,
        "body": "import sys\n\n    subordinates = [0] * (N + 1)\n    for i in range(2, N + 1):\n        subordinates[A[i - 1]] += 1\n    return subordinates[1:]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    result = count_subordinates(N, A)\n    for r in result:\n        print(r)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9985381960868835,
            0.9970327615737915,
            0.9979621767997742,
            0.9982870221138,
            0.9985381960868835,
            0.9959186911582947,
            0.9970946907997131,
            0.9985381960868835,
            0.9971989989280701,
            0.9976689219474792,
            0.997990071773529,
            0.9972538352012634,
            0.9971687197685242,
            0.9985381960868835,
            0.9950882792472839,
            0.9956279397010803,
            0.9985381960868835,
            0.9980043172836304,
            0.9968109130859375,
            0.9973480105400085
        ]
    },
    "4195": {
        "similarity": 0.9978169202804565,
        "body": "    count = 0\n    num = 1\n    while True:\n        if D == 0 and num % 100 != 0:\n            count += 1\n        elif D == 1 and num % 100 == 0:\n            count += 1\n        elif D == 2 and (num % 100 == 0) and (num // 100) % 100 == 0:\n            count += 1\n        if count == N:\n            return num\n        num += 1\n\nif __name__ == \"__main__\":\n    D, N = map(int, input().split())\n    print(find_ringo_integer(D, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975600242614746,
            0.9968015551567078,
            0.9958295226097107,
            0.9978169202804565,
            0.9968502521514893,
            0.9974210858345032,
            0.9966521859169006,
            0.9967281818389893,
            0.9970020651817322,
            0.9976574778556824,
            0.9913728833198547,
            0.9973400831222534,
            0.9973180890083313,
            0.9972039461135864,
            0.9974186420440674,
            0.9972319602966309,
            0.9954065084457397,
            0.9976909160614014,
            0.9877530336380005,
            0.9975072145462036
        ]
    },
    "4176": {
        "similarity": 0.9948460459709167,
        "body": "import sys\n\n    return A * B\n\nA = int(input().strip())\nB = int(input().strip())\n\nprint(min_snack_pieces(A, B))",
        "result": "failed: testcase 0",
        "similarities": [
            0.994228184223175,
            0.9936796426773071,
            0.9936796426773071,
            0.9889779686927795,
            0.9895249605178833,
            0.9943214058876038,
            0.9934475421905518,
            0.9948460459709167,
            0.994228184223175,
            0.9931410551071167,
            0.9928167462348938,
            0.9942474365234375,
            0.9913321137428284,
            0.9931961894035339,
            0.9941689372062683,
            0.9928627014160156,
            0.9940988421440125,
            0.985644519329071,
            0.9941689372062683,
            0.9892608523368835
        ]
    },
    "4166": {
        "similarity": 0.9972512125968933,
        "body": "    digits = [0] * N\n    for s, c in conditions:\n        digits[s - 1] = c\n    \n        number_str = str(number)\n        if len(number_str) != N:\n            return False\n        for s, c in conditions:\n            if int(number_str[s - 1]) != c:\n                return False\n        return True\n    \n    start = 10**(N-1) if N > 1 else 0\n    end = 10**N\n    \n    for i in range(start, end):\n        if is_valid(i):\n            print(i)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n    \n    find_integer(N, M, conditions)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957897663116455,
            0.9972512125968933,
            0.9961864948272705,
            0.9962961077690125,
            0.9935584664344788,
            0.9954147338867188,
            0.9970022439956665,
            0.9966276288032532,
            0.9966315031051636,
            0.9967737793922424,
            0.9970575571060181,
            0.9955074787139893,
            0.9969347715377808,
            0.9965399503707886,
            0.996030330657959,
            0.9969131350517273,
            0.9967425465583801,
            0.9971070885658264,
            0.9964298605918884,
            0.9963874816894531
        ]
    },
    "4827": {
        "similarity": 0.9968637228012085,
        "body": "    if n == 0:\n        return \"zero\"\n    elif n < 10:\n        words = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n        return words[n - 1]\n    elif 10 <= n < 20:\n        teens = [\"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n        return teens[n - 11]\n    elif 20 <= n < 100:\n        tens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        ones = number_to_words(n % 10) if n % 10 != 0 else \"\"\n        return tens[n // 10 - 2] + (ones and (\"-\" + ones))\n    elif 100 <= n < 1000:\n        hundreds = [\"onehundred\", \"twohundred\", \"threehundred\", \"fourhundred\", \"fivehundred\", \"sixhundred\", \"sevenhundred\", \"eighthundred\", \"ninehundred\"]\n        remaining = n % 100\n        if remaining == 0:\n            return hundreds[n // 100 - 1]\n        else:\n            return hundreds[n // 100 - 1] + (\"and\" if remaining < 20 or remaining % 10 == 0 else \"\") + number_to_words(remaining)\n\n    N = int(input())\n    words = [input() for _ in range(N)]\n    for i, word in enumerate(words):\n        if word == '$':\n            number = sum(len(w) for w in words[:i] + words[i+1:])\n            words[i] = number_to_words(number)\n    print(' '.join(words))\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996615469455719,
            0.9925382733345032,
            0.9968637228012085,
            0.9966073632240295,
            0.9955724477767944,
            0.9966177940368652,
            0.9964143633842468,
            0.9965677857398987,
            0.99651038646698,
            0.9965158104896545,
            0.9935186505317688,
            0.9955704212188721,
            0.9952043294906616,
            0.9911297559738159,
            0.9953380227088928,
            0.9962310791015625,
            0.9952754974365234,
            0.9961094260215759,
            0.9963312745094299,
            0.9960814118385315
        ]
    },
    "4871": {
        "similarity": 0.9966791868209839,
        "body": "import sys\n\n    total_sum = sum(scores)\n    current_group_score = total_sum / n\n    average_new_group_score = 0.0\n    \n    for i in range(n):\n        remaining_sum = total_sum - scores[i]\n        new_group_score = remaining_sum / (n - 1) * ((4/5)**(i-1))\n        average_new_group_score += new_group_score\n    \n    average_new_group_score /= n\n    return current_group_score, average_new_group_score\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    scores = list(map(int, data[1:]))\n    \n    current_group_score, average_new_group_score = calculate_group_score(n, scores)\n    \n    print(current_group_score)\n    print(average_new_group_score)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948371052742004,
            0.9960435628890991,
            0.9956144094467163,
            0.9966791868209839,
            0.9944663643836975,
            0.9962831139564514,
            0.9957873821258545,
            0.9948712587356567,
            0.9943996071815491,
            0.9965478777885437,
            0.9953163862228394,
            0.9964643716812134,
            0.9926938414573669,
            0.9939676523208618,
            0.9953497052192688,
            0.9949612021446228,
            0.9961921572685242,
            0.9964345693588257,
            0.9949325919151306,
            0.9958921670913696
        ]
    },
    "4148": {
        "similarity": 0.9975638389587402,
        "body": "import sys\n\n    result = []\n    for char in S:\n        if 'A' <= char <= 'Z':\n            result.append(chr((ord(char) - ord('A') + N) % 26 + ord('A')))\n        else:\n            result.append(char)\n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(shift_string(N, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996681809425354,
            0.9972934722900391,
            0.9946834444999695,
            0.9957100749015808,
            0.9975638389587402,
            0.9969552755355835,
            0.9958394765853882,
            0.9973341226577759,
            0.9972934722900391,
            0.9970070719718933,
            0.9970616698265076,
            0.9946640729904175,
            0.9973835349082947,
            0.9969145059585571,
            0.9960240125656128,
            0.9965431094169617,
            0.9938657879829407,
            0.9921584129333496,
            0.9973667860031128,
            0.9967944622039795
        ]
    },
    "4316": {
        "similarity": 0.9957576394081116,
        "body": "    if len(set(s)) != 2:\n        return \"No\"\n    counts = [s.count(char) for char in set(s)]\n    return \"Yes\" if counts == [2, 2] else \"No\"\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(check_characters(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954056143760681,
            0.995123028755188,
            0.9842222332954407,
            0.9955945611000061,
            0.9925565123558044,
            0.9947893023490906,
            0.9957576394081116,
            0.9937523603439331,
            0.9939652681350708,
            0.9945188760757446,
            0.9955087900161743,
            0.9955562949180603,
            0.9933056235313416,
            0.9941819906234741,
            0.9908734560012817,
            0.9922005534172058,
            0.9920973777770996,
            0.9955235719680786,
            0.9953406453132629,
            0.9955245852470398
        ]
    },
    "4397": {
        "similarity": 0.9995329976081848,
        "body": "N, i = map(int, input().split())\nj = N - i + 1\nprint(j)",
        "result": "passed",
        "similarities": [
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9911248087882996,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848,
            0.9995329976081848
        ]
    },
    "4180": {
        "similarity": 0.9954695701599121,
        "body": "N = int(input())\nchange = N % 1000\nprint(change)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954695701599121,
            0.9917665123939514,
            0.9914939403533936,
            0.9919860363006592,
            0.994290292263031,
            0.9954695701599121,
            0.9954695701599121,
            0.9954695701599121,
            0.9898430705070496,
            0.9898430705070496,
            0.9946457743644714,
            0.9954695701599121,
            0.9917665123939514,
            0.9914939403533936,
            0.9954695701599121,
            0.9954695701599121,
            0.9946457743644714,
            0.9954695701599121,
            0.9864189028739929,
            0.9914939403533936
        ]
    },
    "4907": {
        "similarity": 0.9960660338401794,
        "body": "    if n % 2 == 0:\n        return \"Alice\\n1\"\n    else:\n        return \"Bob\\n\"\n\nn = int(input())\nprint(bob_and_alice_pastime_conundrum(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.992759108543396,
            0.9886475801467896,
            0.9960660338401794,
            0.9954034090042114,
            0.9933194518089294,
            0.9952695965766907,
            0.99516761302948,
            0.9943946003913879,
            0.9946364164352417,
            0.9953118562698364,
            0.9957945942878723,
            0.9952696561813354,
            0.994927167892456,
            0.9949742555618286,
            0.9957950115203857,
            0.9950876832008362,
            0.9929196238517761,
            0.995286762714386,
            0.9954962730407715,
            0.9915601015090942
        ]
    },
    "4839": {
        "similarity": 0.9978587627410889,
        "body": "    cans.sort()\n    balloons = list(range(1, n + 1))\n    balloons.sort(reverse=True)\n    \n    for i in range(n):\n        if cans[i] < balloons[i]:\n            return \"impossible\"\n    \n    total_can_capacity = sum(cans)\n    total_balloon_capacity = sum(balloons)\n    \n    min_fraction = total_can_capacity / total_balloon_capacity\n    return min_fraction\n\n# Read input from stdin\nn = int(input())\ncans = list(map(int, input().split()))\n\n# Print the result\nprint(max_fraction(n, cans))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974170327186584,
            0.9975070953369141,
            0.9969513416290283,
            0.9972245097160339,
            0.9976730346679688,
            0.9963349103927612,
            0.9969825744628906,
            0.996691882610321,
            0.9968880414962769,
            0.997009813785553,
            0.9962598085403442,
            0.9955374002456665,
            0.9978587627410889,
            0.9956538677215576,
            0.9970318675041199,
            0.9977981448173523,
            0.9964662194252014,
            0.9930917024612427,
            0.9973184466362,
            0.9966452717781067
        ]
    },
    "4665": {
        "similarity": 0.9989057183265686,
        "body": "from collections import namedtuple\n\n    N = int(input())\n    columns = input().split()\n    Student = namedtuple('Student', columns)\n    \n    total_marks = 0\n    for _ in range(N):\n        student_data = input().split()\n        student = Student(*student_data)\n        total_marks += int(student.MARKS)\n    \n    average_marks = total_marks / N\n    print(f\"{average_marks:.2f}\")\n\ncalculate_average_marks()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9988903403282166,
            0.9988903403282166,
            0.9988903403282166,
            0.9987985491752625,
            0.9988453388214111,
            0.9988158345222473,
            0.9988778829574585,
            0.9986987113952637,
            0.9981757998466492,
            0.9936143755912781,
            0.9988903403282166,
            0.9988126158714294,
            0.9977534413337708,
            0.9988903403282166,
            0.9988903403282166,
            0.9989057183265686,
            0.9987810850143433,
            0.992954671382904,
            0.998457670211792,
            0.9986451864242554
        ]
    },
    "4785": {
        "similarity": 0.9944955706596375,
        "body": "    word = input()\n    if 'ss' in word:\n        print('hiss')\n    else:\n        print('no hiss')\n\ncheck_hissing()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9919151663780212,
            0.9919151663780212,
            0.9919151663780212,
            0.9922605752944946,
            0.9941385984420776,
            0.9919151663780212,
            0.9919151663780212,
            0.9902547597885132,
            0.989181637763977,
            0.9942899346351624,
            0.9919151663780212,
            0.9910728931427002,
            0.9919151663780212,
            0.9919151663780212,
            0.9917859435081482,
            0.9907982349395752,
            0.9899630546569824,
            0.9944955706596375,
            0.9938684105873108,
            0.9919151663780212
        ]
    },
    "4272": {
        "similarity": 0.997541606426239,
        "body": "    N = int(input())\n    S = input()\n    count = 0\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            count += 1\n    print(count)\n\ncount_abc_occurrences()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9904056191444397,
            0.9956184029579163,
            0.9974631071090698,
            0.9974954724311829,
            0.9975210428237915,
            0.9975210428237915,
            0.9974631071090698,
            0.9975210428237915,
            0.9956021904945374,
            0.9975210428237915,
            0.9956021904945374,
            0.9975210428237915,
            0.9957911968231201,
            0.9975210428237915,
            0.9903692007064819,
            0.997541606426239,
            0.997521162033081,
            0.997521162033081,
            0.9974250793457031,
            0.9975210428237915
        ]
    },
    "4092": {
        "similarity": 0.9972969889640808,
        "body": "    prefix_sum = 0\n    insertions = 0\n    seen_sums = {0}\n    \n    for num in a:\n        prefix_sum += num\n        if prefix_sum in seen_sums:\n            insertions += 1\n            seen_sums.clear()\n        seen_sums.add(prefix_sum)\n    \n    return insertions\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_insertions_to_avoid_zero_subsegments(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995815098285675,
            0.9966213703155518,
            0.9905107617378235,
            0.9963218569755554,
            0.9970994591712952,
            0.9972969889640808,
            0.9963117837905884,
            0.9970510601997375,
            0.9967774152755737,
            0.9914238452911377,
            0.9967071413993835,
            0.9951755404472351,
            0.9962344765663147,
            0.9923850893974304,
            0.9965423941612244,
            0.9967036843299866,
            0.9967745542526245,
            0.9957993030548096,
            0.9969120025634766,
            0.9970363974571228
        ]
    },
    "4023": {
        "similarity": 0.9970241189002991,
        "body": "    max_height = max(a)\n    total_bricks_needed = 0\n    \n    for height in a:\n        if height < max_height:\n            total_bricks_needed += (max_height - height) // 2\n    \n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939554333686829,
            0.9924184083938599,
            0.995972216129303,
            0.9968892335891724,
            0.9968147277832031,
            0.9943628907203674,
            0.9970241189002991,
            0.9943012595176697,
            0.995936930179596,
            0.9970241189002991,
            0.994812548160553,
            0.996071457862854,
            0.9969418048858643,
            0.9969934225082397,
            0.9931824207305908,
            0.9958848357200623,
            0.9861849546432495,
            0.9939727783203125,
            0.9943012595176697,
            0.9917913675308228
        ]
    },
    "4160": {
        "similarity": 0.997369647026062,
        "body": "    X = int(input())\n    balance = 100\n    years = 0\n    \n    while balance < X:\n        balance += balance // 100\n        years += 1\n    \n    print(years)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972529411315918,
            0.9971339702606201,
            0.9972652792930603,
            0.996170163154602,
            0.9964393973350525,
            0.994809627532959,
            0.997369647026062,
            0.9969022870063782,
            0.9971339702606201,
            0.9971367716789246,
            0.9968701601028442,
            0.9972795248031616,
            0.9967553019523621,
            0.9931076765060425,
            0.9947202801704407,
            0.9972916841506958,
            0.9970777630805969,
            0.9971859455108643,
            0.9947202801704407,
            0.9967553019523621
        ]
    },
    "4815": {
        "similarity": 0.9972017407417297,
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = int(data[1])\n    m = int(data[2])\n    \n    players = data[3:3+n]\n    scores = {player: 0 for player in players}\n    \n    index = 3 + n\n    winners = []\n    \n    for _ in range(m):\n        player = data[index]\n        points = int(data[index + 1])\n        scores[player] += points\n        \n        if scores[player] >= p and player not in winners:\n            winners.append(player)\n        \n        index += 2\n    \n    if not winners:\n        print(\"No winner!\")\n    else:\n        for winner in winners:\n            print(f\"{winner} wins!\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933839440345764,
            0.9969460368156433,
            0.9961720705032349,
            0.9960964918136597,
            0.9951993823051453,
            0.99407559633255,
            0.9966493248939514,
            0.991603434085846,
            0.9961201548576355,
            0.9970022439956665,
            0.9962899088859558,
            0.9915612936019897,
            0.9963176250457764,
            0.995885968208313,
            0.9972017407417297,
            0.9964897632598877,
            0.9941352009773254,
            0.9944221377372742,
            0.9970201253890991,
            0.9955004453659058
        ]
    },
    "4514": {
        "similarity": 0.9965509176254272,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    for child in tree[node]:\n        if child != parent:\n            order.append(child)\n            dfs(child, node, order)\n\n    if u == 1 and k > len(order):\n        return -1\n    index = order.index(u) + k - 1\n    if index >= len(order):\n        return -1\n    return order[index]\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\ntree = defaultdict(list)\nfor i in range(2, n+1):\n    p = int(data[i-1])\n    tree[p].append(i)\n\norder = []\ndfs(1, -1, order)\n\nresults = []\nindex = 2 + n\nfor _ in range(q):\n    u = int(data[index])\n    k = int(data[index+1])\n    results.append(get_command_sequence(u, k))\n    index += 2\n\nprint(*results)",
        "result": "failed: testcase 0",
        "similarities": [
            0.993293046951294,
            0.9958045482635498,
            0.995731770992279,
            0.9930691123008728,
            0.9960981011390686,
            0.9958412051200867,
            0.9959473013877869,
            0.9954670667648315,
            0.9961208701133728,
            0.9965509176254272,
            0.9952344298362732,
            0.9955418109893799,
            0.9954401254653931,
            0.995793879032135,
            0.9961101412773132,
            0.9964280724525452,
            0.995236873626709,
            0.9962363243103027,
            0.9886413216590881,
            0.9955963492393494
        ]
    },
    "4585": {
        "similarity": 0.9967633485794067,
        "body": "import sys\n\n    t = 0\n    while X > 0:\n        t += 1\n        X -= t\n    return t if X == 0 else t + 1\n\nif __name__ == \"__main__\":\n    X = int(input())\n    print(min_time_to_reach_nest(X))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966059327125549,
            0.9966781139373779,
            0.9943962097167969,
            0.9958218932151794,
            0.9837929606437683,
            0.994073748588562,
            0.9967633485794067,
            0.9965613484382629,
            0.9967157244682312,
            0.9951329827308655,
            0.9967459440231323,
            0.9954912066459656,
            0.9965284466743469,
            0.9959699511528015,
            0.9959554076194763,
            0.9940599203109741,
            0.9882848858833313,
            0.9953603148460388,
            0.9966645836830139,
            0.9956305623054504
        ]
    },
    "4781": {
        "similarity": 0.9971727132797241,
        "body": "    players = list(range(1, 9))\n    current_index = K - 1\n    \n    for time, outcome in questions:\n        if outcome == 'N' or outcome == 'P':\n            continue\n        \n        current_index = (current_index + 1) % len(players)\n    \n    return players[current_index]\n\n# Read input\nK = int(input())\nN = int(input())\nquestions = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Find and print the exploding player\nprint(find_exploding_player(K, N, questions))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963220357894897,
            0.9967892169952393,
            0.9969034790992737,
            0.9968746900558472,
            0.9971727132797241,
            0.9963851571083069,
            0.9925436973571777,
            0.9971524477005005,
            0.9945731163024902,
            0.9959006309509277,
            0.9967222809791565,
            0.9971072673797607,
            0.9971674084663391,
            0.9965471029281616,
            0.996801495552063,
            0.9911290407180786,
            0.9964531660079956,
            0.9960759878158569,
            0.9966061115264893,
            0.9971574544906616
        ]
    },
    "4551": {
        "similarity": 0.9990459084510803,
        "body": "A, B, C, D = map(int, input().split())\nL = A + B\nR = C + D\nif L < R:\n    print(\"Left\")\nelif L > R:\n    print(\"Right\")\nelse:\n    print(\"Balanced\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9989126920700073,
            0.9965173006057739,
            0.9990351796150208,
            0.9976146221160889,
            0.9989820718765259,
            0.9947578310966492,
            0.9990459084510803,
            0.9990351796150208,
            0.9990350604057312,
            0.9989820718765259,
            0.9930839538574219,
            0.9990350604057312,
            0.9990350604057312,
            0.9990350604057312,
            0.9990350604057312,
            0.9989126920700073,
            0.9990350604057312,
            0.9990351796150208,
            0.9990351796150208,
            0.9990293383598328
        ]
    },
    "4345": {
        "similarity": 0.9967285990715027,
        "body": "    if n == 1:\n        return \"YES\\n0\"\n    \n    increasing = []\n    decreasing = []\n    i = 0\n    \n    while i < n:\n        if not increasing or a[i] >= increasing[-1]:\n            increasing.append(a[i])\n        else:\n            break\n        i += 1\n    \n    j = i\n    \n    while j < n:\n        if not decreasing or a[j] <= decreasing[-1]:\n            decreasing.append(a[j])\n        else:\n            break\n        j += 1\n    \n    if i == n and j == n:\n        result = [0] * i + [1] * (n - i)\n        return \"YES\\n\" + ' '.join(map(str, result))\n    else:\n        return \"NO\"\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Print the result\nprint(split_sequence(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957213401794434,
            0.9966211915016174,
            0.9946064352989197,
            0.9945213794708252,
            0.9952376484870911,
            0.9955131411552429,
            0.9953890442848206,
            0.9962790608406067,
            0.9948017597198486,
            0.9944592714309692,
            0.9949044585227966,
            0.9934199452400208,
            0.9961664080619812,
            0.9953956604003906,
            0.9948093295097351,
            0.9957967400550842,
            0.9927331805229187,
            0.9946472644805908,
            0.9953545331954956,
            0.9967285990715027
        ]
    },
    "4075": {
        "similarity": 0.9975610971450806,
        "body": "from itertools import product\n\n    count = 0\n    for switches in product([0, 1], repeat=N):\n        if all((sum(switches[j-1] for j in bulb) % 2 == p) for bulb, p in zip(switch_bulb_map, parity)):\n            count += 1\n    print(count)\n\n# Read input\nN, M = map(int, input().split())\nswitch_bulb_map = []\nparity = list(map(int, input().split()))\nfor _ in range(M):\n    k = int(input())\n    bulb_list = list(map(int, input().split()))\n    switch_bulb_map.append(bulb_list)\n\n# Call the function\ncount_lighted_combinations(N, M, switch_bulb_map, parity)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965425133705139,
            0.996160626411438,
            0.9958570599555969,
            0.996536374092102,
            0.9968724846839905,
            0.9960526823997498,
            0.9964095950126648,
            0.9967466592788696,
            0.9967960715293884,
            0.9961610436439514,
            0.9961682558059692,
            0.9950360655784607,
            0.996717631816864,
            0.9975610971450806,
            0.9973898530006409,
            0.9954923391342163,
            0.9971377849578857,
            0.9975455403327942,
            0.9941925406455994,
            0.9964825510978699
        ]
    },
    "4408": {
        "similarity": 0.9975345134735107,
        "body": "    card_counts = [0] * (10**5 + 1)\n    for i in range(k * n):\n        card_counts[cards[i]] += 1\n    \n    favorite_counts = [0] * n\n    for player in range(n):\n        favorite_count = sum(card_counts[favorites[player]])\n        if favorite_count > k:\n            favorite_count = k\n        favorite_counts[player] = favorite_count\n    \n    max_joy = 0\n    for i in range(k + 1):\n        count = sum(1 for fav_count in favorite_counts if fav_count == i)\n        max_joy += count * joy_levels[i]\n    \n    return max_joy\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ncards = list(map(int, data[2:2 + k * n]))\nfavorites = list(map(int, data[2 + k * n:2 + k * n + n]))\njoy_levels = list(map(int, data[2 + k * n + n:]))\n\n# Calculate and print the result\nresult = max_joy_levels(n, k, cards, favorites, joy_levels)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964677691459656,
            0.9955610036849976,
            0.9972102642059326,
            0.9962554574012756,
            0.9973242878913879,
            0.9963198304176331,
            0.994738757610321,
            0.9966807961463928,
            0.9963397979736328,
            0.9964491128921509,
            0.9955675005912781,
            0.9966623187065125,
            0.9961009621620178,
            0.9962317943572998,
            0.9975345134735107,
            0.9947437644004822,
            0.9972751140594482,
            0.9963428378105164,
            0.9958785176277161,
            0.9935646057128906
        ]
    },
    "4282": {
        "similarity": 0.9962780475616455,
        "body": "    graph = [[] for _ in range(n + 1)]\n    next_map = [0] * (n + 1)\n    \n    for i, (a1, a2) in enumerate(remembered, start=1):\n        graph[a1].append((i, a2))\n        graph[a2].append((i, a1))\n        next_map[i] = a1\n    \n    visited = [False] * (n + 1)\n    order = []\n    \n        if visited[node]:\n            return\n        visited[node] = True\n        for _, next_node in graph[node]:\n            dfs(next_node, path)\n        order.append(node)\n    \n    start = next(x for x in range(1, n + 1) if not visited[x])\n    dfs(start, [])\n    \n    result = [order[i] % n + 1 for i in range(n)]\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nremembered = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\n\nresult = restore_dance_order(n, remembered)\nprint(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940769672393799,
            0.9962576031684875,
            0.9956679344177246,
            0.9929426312446594,
            0.9939759969711304,
            0.9956535696983337,
            0.9942810535430908,
            0.9959608316421509,
            0.9957137703895569,
            0.9954842925071716,
            0.9956739544868469,
            0.9962780475616455,
            0.9935734272003174,
            0.9962511658668518,
            0.9952364563941956,
            0.9953067302703857,
            0.9910784363746643,
            0.9949405193328857,
            0.9958864450454712,
            0.9961196780204773
        ]
    },
    "4331": {
        "similarity": 0.9989680051803589,
        "body": "N = int(input())\nif '7' in str(N):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed",
        "similarities": [
            0.9988011121749878,
            0.9989680051803589,
            0.9988363981246948,
            0.9989680051803589,
            0.9989680051803589,
            0.9985074400901794,
            0.9989680051803589,
            0.9988363981246948,
            0.9989680051803589,
            0.9989680051803589,
            0.9989680051803589,
            0.9989680051803589,
            0.9989680051803589,
            0.9976083636283875,
            0.996071457862854,
            0.9985074400901794,
            0.9988363981246948,
            0.9989680051803589,
            0.9955360293388367,
            0.9955360293388367
        ]
    },
    "4550": {
        "similarity": 0.9958410859107971,
        "body": "    total = a + b + c\n    if total % 2 != 0:\n        return \"No\"\n    target = total // 2\n    for x in range(target + 1):\n        for y in range(target + 1 - x):\n            z = target - x - y\n            if a * x + b * y + c * z == target:\n                return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957004189491272,
            0.9943813681602478,
            0.9942641258239746,
            0.9947361350059509,
            0.9956255555152893,
            0.9951818585395813,
            0.9952958822250366,
            0.9953176379203796,
            0.9822946190834045,
            0.9950617551803589,
            0.9952728748321533,
            0.9940291047096252,
            0.9822946190834045,
            0.9957963228225708,
            0.9909386038780212,
            0.9958410859107971,
            0.9953309893608093,
            0.9928677082061768,
            0.9956007599830627,
            0.9949564933776855
        ]
    },
    "4271": {
        "similarity": 0.9971053600311279,
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    \n    total_points = 0\n    for i in range(N):\n        total_points += B[A[i] - 1]\n        if i < N - 1:\n            total_points += C[A[i] - 1]\n    \n    print(total_points)\n\ncalculate_satisfaction()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996923565864563,
            0.9970198273658752,
            0.9954544901847839,
            0.9950001239776611,
            0.9968137145042419,
            0.9968032836914062,
            0.993344783782959,
            0.9963037371635437,
            0.9923585653305054,
            0.9931016564369202,
            0.9958902597427368,
            0.9971053600311279,
            0.9957929849624634,
            0.996404230594635,
            0.9969261884689331,
            0.9970047473907471,
            0.9961574077606201,
            0.9924225211143494,
            0.995663583278656,
            0.9970198273658752
        ]
    },
    "4848": {
        "similarity": 0.9973868131637573,
        "body": "import math\nimport sys\n\n    for m in range(2, n):\n        if all((m * n) % (p ** 2) != 0 for p in range(2, int(math.sqrt(m * n)) + 1)):\n            return m\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(find_m(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960904717445374,
            0.9953755736351013,
            0.9949977397918701,
            0.997148334980011,
            0.9969832897186279,
            0.9952725768089294,
            0.9950463175773621,
            0.995507001876831,
            0.9967080950737,
            0.9968499541282654,
            0.9953069090843201,
            0.9973868131637573,
            0.9966213703155518,
            0.9972086548805237,
            0.9972564578056335,
            0.996250569820404,
            0.995945394039154,
            0.9962734580039978,
            0.997035562992096,
            0.9972714185714722
        ]
    },
    "4694": {
        "similarity": 0.9950401186943054,
        "body": "import sys\n\n    a.sort()\n    return a[-1] - a[0]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    a = list(map(int, input().split()))\n    print(min_distance(N, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937620759010315,
            0.9871958494186401,
            0.9950401186943054,
            0.9943451285362244,
            0.9899918437004089,
            0.9923714399337769,
            0.9899918437004089,
            0.9939316511154175,
            0.9931930899620056,
            0.9948962330818176,
            0.9927017688751221,
            0.9945093393325806,
            0.9948865175247192,
            0.99111407995224,
            0.9930903911590576,
            0.99111407995224,
            0.9902629852294922,
            0.9949852824211121,
            0.9946076273918152,
            0.9921485781669617
        ]
    },
    "4213": {
        "similarity": 0.9950852990150452,
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    min_val = min(A)\n    max_val = max(A)\n    \n    print(max_val - min_val)\n\nmax_abs_difference()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9903436303138733,
            0.99034583568573,
            0.9906227588653564,
            0.9909654259681702,
            0.9922400116920471,
            0.9906227588653564,
            0.9901725649833679,
            0.9932740926742554,
            0.990319013595581,
            0.9928910136222839,
            0.9950667023658752,
            0.9906227588653564,
            0.9932740926742554,
            0.9922164082527161,
            0.9950667023658752,
            0.9950852990150452,
            0.988829493522644,
            0.9906227588653564,
            0.9935810565948486,
            0.9930348992347717
        ]
    },
    "4471": {
        "similarity": 0.9971740245819092,
        "body": "import sys\n\n    while any(x > 0 for x in a):\n        placed = False\n        for i in range(n):\n            if a[i] <= 2:\n                a[i] += 2\n                placed = True\n                break\n        if not placed:\n            return \"NO\"\n        a = [max(0, x - 1) for x in a]\n    return \"YES\"\n\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        results.append(can_clear_field(n, a))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969410300254822,
            0.9971209168434143,
            0.9971740245819092,
            0.9960721731185913,
            0.9946615099906921,
            0.995792806148529,
            0.9971687197685242,
            0.995786190032959,
            0.9968216419219971,
            0.9969378113746643,
            0.9926806092262268,
            0.9969267845153809,
            0.9884943962097168,
            0.9967454671859741,
            0.9969385862350464,
            0.9962435364723206,
            0.9969184398651123,
            0.9955061078071594,
            0.9948462247848511,
            0.9963352680206299
        ]
    },
    "4802": {
        "similarity": 0.9940665364265442,
        "body": "import sys\n\n    H, M = map(int, input().split())\n    M -= 45\n    if M < 0:\n        H -= 1\n        M += 60\n    if H < 0:\n        H += 24\n    print(H, M)\n\nadjust_alarm_time()",
        "result": "failed: testcase 0",
        "similarities": [
            0.989263653755188,
            0.9927139282226562,
            0.9923083782196045,
            0.9911977052688599,
            0.991921603679657,
            0.9929165244102478,
            0.9938989281654358,
            0.9937066435813904,
            0.98907470703125,
            0.9913368225097656,
            0.9900773763656616,
            0.9926462769508362,
            0.9900773763656616,
            0.9927864074707031,
            0.9900773763656616,
            0.9940665364265442,
            0.9934696555137634,
            0.9929541349411011,
            0.9921101927757263,
            0.9918965101242065
        ]
    },
    "4890": {
        "similarity": 0.9964633584022522,
        "body": "import sys\nfrom collections import deque\n\n    total_bottles = sum(current)\n    if n > total_bottles:\n        return \"impossible\"\n    \n    remaining = n\n    optimal_refill = [0] * s\n    \n    for i in range(s):\n        if remaining == 0:\n            break\n        cold_slots = len([x for x in current if x > 0])\n        if cold_slots == 0:\n            return \"impossible\"\n        \n        refill_amount = min(remaining, current[i])\n        optimal_refill[i] = refill_amount\n        remaining -= refill_amount\n    \n    return optimal_refill\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\ns = int(data[2])\nd = int(data[3])\ncurrent = list(map(int, data[4:]))\n\nresult = refill_fridge(n, m, s, d, current)\nif result == \"impossible\":\n    print(result)\nelse:\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925268292427063,
            0.9959965944290161,
            0.9943094849586487,
            0.9944401979446411,
            0.9950625896453857,
            0.9950113892555237,
            0.9941110014915466,
            0.9959502220153809,
            0.9964633584022522,
            0.9947895407676697,
            0.9959259033203125,
            0.9962648153305054,
            0.9956811666488647,
            0.9949837923049927,
            0.9951881766319275,
            0.9923405051231384,
            0.9948531985282898,
            0.9954424500465393,
            0.9938415884971619,
            0.9939378499984741
        ]
    },
    "4286": {
        "similarity": 0.9980390667915344,
        "body": "import sys\nfrom typing import List\nimport heapq\n\n    edges = []\n    for x, y, w in offers:\n        edges.append((w, x-1, y-1))\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            cost = a[i] + a[j]\n            edges.append((cost, i, j))\n    \n    heapq.heapify(edges)\n    parent = list(range(n))\n    rank = [0] * n\n    \n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n        root_x = find(x)\n        root_y = find(y)\n        if root_x == root_y:\n            return False\n        if rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        elif rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        return True\n    \n    cost = 0\n    edges_used = 0\n    while edges and edges_used < n - 1:\n        w, x, y = heapq.heappop(edges)\n        if union(x, y):\n            cost += w\n            edges_used += 1\n    \n    return cost\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:2+n]))\noffers = [list(map(int, data[2+n+i*3:2+n+(i+1)*3])) for i in range(m)]\n\nprint(min_cost_to_connect_graph(n, m, a, offers))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972777366638184,
            0.9978764057159424,
            0.9969562888145447,
            0.9979202747344971,
            0.9977511167526245,
            0.9975175261497498,
            0.9972821474075317,
            0.9978117942810059,
            0.9977004528045654,
            0.9980390667915344,
            0.9970237612724304,
            0.9972887635231018,
            0.9972246885299683,
            0.9980378746986389,
            0.9977924227714539,
            0.9978368878364563,
            0.9976797699928284,
            0.9969500303268433,
            0.9978508353233337,
            0.9980035424232483
        ]
    },
    "4713": {
        "similarity": 0.9980901479721069,
        "body": "    N = int(input())\n    S = input()\n    x = 0\n    max_x = 0\n    for char in S:\n        if char == 'I':\n            x += 1\n        elif char == 'D':\n            x -= 1\n        if x > max_x:\n            max_x = x\n    print(max_x)\n\nmax_value_after_operations()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980901479721069,
            0.995928943157196,
            0.9977579712867737,
            0.9977387189865112,
            0.9974188804626465,
            0.9974303841590881,
            0.9971283674240112,
            0.9960612058639526,
            0.9938531517982483,
            0.9939639568328857,
            0.9968082308769226,
            0.9968229532241821,
            0.9977595806121826,
            0.9971150755882263,
            0.9978479146957397,
            0.997999370098114,
            0.9971016645431519,
            0.997755765914917,
            0.9973865151405334,
            0.9959398508071899
        ]
    },
    "4698": {
        "similarity": 0.9969072937965393,
        "body": "import sys\n\n    N = int(input())\n    T = list(map(int, input().split()))\n    M = int(input())\n    drinks = []\n    \n    for _ in range(M):\n        P, X = map(int, input().split())\n        drinks.append((P-1, X))\n    \n    results = []\n    for p, x in drinks:\n        total_time = sum(max(T[i], T[p] + x if i == p else T[i]) for i in range(N))\n        results.append(total_time)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    calculate_times()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958161115646362,
            0.9960680603981018,
            0.996089518070221,
            0.9951776266098022,
            0.9957156181335449,
            0.9967591166496277,
            0.9966480731964111,
            0.9968568086624146,
            0.9960759878158569,
            0.9964891672134399,
            0.9963167905807495,
            0.9962326884269714,
            0.9945346713066101,
            0.9967082142829895,
            0.9938809275627136,
            0.9961118102073669,
            0.9930931925773621,
            0.9963654279708862,
            0.9969072937965393,
            0.9935411214828491
        ]
    },
    "4841": {
        "similarity": 0.9973646402359009,
        "body": "    n = int(input())\n    bites = input().split()\n    \n    expected = 1\n    for bite in bites:\n        if bite == \"mumble\":\n            continue\n        bite = int(bite)\n        if bite != expected:\n            print(\"something is fishy\")\n            return\n        expected += 1\n    \n    print(\"makes sense\")\n\ncheck_counting()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950838685035706,
            0.9947023987770081,
            0.9959245324134827,
            0.995690107345581,
            0.9939419627189636,
            0.9948708415031433,
            0.9972015023231506,
            0.9961389303207397,
            0.9949057698249817,
            0.9968215823173523,
            0.9958590269088745,
            0.99664705991745,
            0.9965774416923523,
            0.9972126483917236,
            0.9939519166946411,
            0.9895704388618469,
            0.996315598487854,
            0.996905505657196,
            0.9960112571716309,
            0.9973646402359009
        ]
    },
    "4865": {
        "similarity": 0.9971185922622681,
        "body": "import sys\n\n    if direction == 'F':\n        new_minute = (minute + minutes) % 60\n        new_hour = (hour + (minute + minutes) // 60) % 24\n    else:\n        new_minute = (minute - minutes) % 60\n        new_hour = (hour - (minutes // 60)) % 24\n    return f\"{new_hour} {new_minute}\"\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    lines = input_data.split('\\n')\n    \n    N = int(lines[0])\n    results = []\n    \n    for i in range(1, N + 1):\n        parts = lines[i].split()\n        direction = parts[0]\n        minutes = int(parts[1])\n        hour = int(parts[2])\n        minute = int(parts[3])\n        new_time = adjust_time(direction, minutes, hour, minute)\n        results.append(new_time)\n    \n    for result in results:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961411356925964,
            0.995337724685669,
            0.9968490600585938,
            0.9955862164497375,
            0.9962150454521179,
            0.9967170357704163,
            0.9930600523948669,
            0.9962764382362366,
            0.9962670207023621,
            0.9965999126434326,
            0.9962784647941589,
            0.9967498779296875,
            0.994340717792511,
            0.9905281066894531,
            0.9951164126396179,
            0.9965232014656067,
            0.9953117370605469,
            0.9971185922622681,
            0.9968556761741638,
            0.993519127368927
        ]
    },
    "4957": {
        "similarity": 0.9959496259689331,
        "body": "        return 0 <= x < n and 0 <= y < m\n\n        if not is_valid(x, y) or grid[x][y] == '#':\n            return False\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and grid[nx][ny] == 'E':\n                return False\n        grid[x] = grid[x][:y] + 'E' + grid[x][y+1:]\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                if not place_shop(i, j) and not place_shop(i, j-1) and not place_shop(i, j+1) and not place_shop(i-1, j) and not place_shop(i+1, j):\n                    return 'No valid placement possible'\n    return '\\n'.join(grid)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn, m = int(data[0]), int(data[1])\ngrid = data[2:]\n\nresult = place_coffee_shops(n, m, grid)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.995772123336792,
            0.9959389567375183,
            0.9951450824737549,
            0.9950875639915466,
            0.9950313568115234,
            0.9956085681915283,
            0.9957635998725891,
            0.9955165386199951,
            0.9895296692848206,
            0.9950121641159058,
            0.9956234693527222,
            0.9938143491744995,
            0.9958614706993103,
            0.9950844645500183,
            0.994651198387146,
            0.99505615234375,
            0.993574857711792,
            0.9922518730163574,
            0.9953792095184326,
            0.9959496259689331
        ]
    },
    "4382": {
        "similarity": 0.9964190125465393,
        "body": "import sys\n\n    return N ** 3\n\nN = int(input().strip())\nprint(count_passwords(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964190125465393,
            0.9930333495140076,
            0.99579256772995,
            0.9958935976028442,
            0.99579256772995,
            0.9939366579055786,
            0.9958794116973877,
            0.9952070116996765,
            0.9937694072723389,
            0.992725670337677,
            0.995509922504425,
            0.99579256772995,
            0.995509922504425,
            0.9957929849624634,
            0.9958794116973877,
            0.9931421875953674,
            0.9947241544723511,
            0.992725670337677,
            0.99579256772995,
            0.99579256772995
        ]
    },
    "4456": {
        "similarity": 0.997460126876831,
        "body": "import sys\nfrom collections import defaultdict\n\n    if n < k or k > 26:\n        return \"NO\"\n    \n    # Create a mapping from indices to characters\n    char_map = defaultdict(int)\n    used_chars = set()\n    \n    for i in range(n):\n        if len(used_chars) >= k:\n            break\n        if s[p[i]] not in used_chars:\n            used_chars.add(s[p[i]])\n            char_map[p[i]] = s[p[i]]\n    \n    if len(used_chars) < k:\n        return \"NO\"\n    \n    # Fill the rest of the string\n    for i in range(n):\n        if p[i] not in char_map:\n            char_map[p[i]] = min(set('abcdefghijklmnopqrstuvwxyz') - used_chars)\n            used_chars.add(char_map[p[i]])\n    \n    result = ''.join(char_map[i] for i in range(1, n+1))\n    return \"YES\\n\" + result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\n\np = list(map(int, data[2:2+n]))\nq = list(map(int, data[2+n:]))\n\ns = ''.join(chr(ord('a') + i) for i in range(n))  # Initialize string with a to z\n\n# Restore the string\nresult = restore_string(n, k, p, q)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968934655189514,
            0.9928829073905945,
            0.9956852793693542,
            0.9966344237327576,
            0.9972704648971558,
            0.9971950054168701,
            0.997460126876831,
            0.9970391988754272,
            0.9970169067382812,
            0.9956173300743103,
            0.9968876242637634,
            0.9965764284133911,
            0.9972243905067444,
            0.9956899285316467,
            0.9974231719970703,
            0.9967708587646484,
            0.9974268674850464,
            0.9965382814407349,
            0.9968168139457703,
            0.9967342019081116
        ]
    },
    "4594": {
        "similarity": 0.9973899722099304,
        "body": "    diameters = sorted(map(int, input().split()))\n    max_layers = 1\n    current_diameter = diameters[-1]\n    \n    for diameter in reversed(diameters[:-1]):\n        if diameter < current_diameter:\n            max_layers += 1\n            current_diameter = diameter\n    \n    return max_layers\n\nN = int(input())\nprint(max_kagami_mochi_layers(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968858957290649,
            0.9965017437934875,
            0.9970424175262451,
            0.9951619505882263,
            0.9952687621116638,
            0.9970172047615051,
            0.9969204664230347,
            0.9965669512748718,
            0.9968657493591309,
            0.9972136616706848,
            0.9944148659706116,
            0.9973163604736328,
            0.9971845746040344,
            0.995387613773346,
            0.9973110556602478,
            0.9970651268959045,
            0.9954420328140259,
            0.9973899722099304,
            0.9968613386154175,
            0.993140459060669
        ]
    },
    "4560": {
        "similarity": 0.9970458149909973,
        "body": "    for i in range(A + 1):\n        if (N - 500 * i) % 1 == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\nN = int(input())\nA = int(input())\n\n# Print the result\nprint(can_pay_exactly(N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961367249488831,
            0.9958207011222839,
            0.9970458149909973,
            0.9948407411575317,
            0.985636293888092,
            0.9968382120132446,
            0.9963323473930359,
            0.9962300658226013,
            0.9955787658691406,
            0.9969815611839294,
            0.9961367249488831,
            0.9970458149909973,
            0.9966352581977844,
            0.9966332316398621,
            0.9969868063926697,
            0.9965312480926514,
            0.9878973960876465,
            0.9964165091514587,
            0.9970198273658752,
            0.9957389831542969
        ]
    },
    "4320": {
        "similarity": 0.9954642057418823,
        "body": "import sys\n\n    k = 2\n    while True:\n        total = sum(2**i for i in range(k))\n        if total > n:\n            break\n        x = n // total\n        if x * total == n:\n            return x\n        k += 1\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nfor i in range(1, t + 1):\n    n = int(data[i])\n    results.append(find_x(n))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936477541923523,
            0.993060290813446,
            0.9942278861999512,
            0.9920644164085388,
            0.994765043258667,
            0.9946079254150391,
            0.9946202039718628,
            0.9923620820045471,
            0.994401216506958,
            0.950528085231781,
            0.9954642057418823,
            0.994879961013794,
            0.9926342368125916,
            0.994271457195282,
            0.993510901927948,
            0.9940454363822937,
            0.9941472411155701,
            0.9951224327087402,
            0.9949748516082764,
            0.9940006136894226
        ]
    },
    "4500": {
        "similarity": 0.9983633160591125,
        "body": "A, B, C = map(int, input().split())\nif A + B >= C:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed",
        "similarities": [
            0.9970479607582092,
            0.9945782423019409,
            0.9983633160591125,
            0.9983633160591125,
            0.9982669353485107,
            0.9983633160591125,
            0.9962368011474609,
            0.9953019022941589,
            0.9970317482948303,
            0.9983633160591125,
            0.9970317482948303,
            0.9970479607582092,
            0.9983633160591125,
            0.9970479607582092,
            0.9960925579071045,
            0.9983633160591125,
            0.9983633160591125,
            0.9982669353485107,
            0.9983633160591125,
            0.9983633160591125
        ]
    },
    "4739": {
        "similarity": 0.9973980784416199,
        "body": "    speeds = set()\n    distances = set()\n\n    for i in range(1, M):\n        dt = T[i] - T[0]\n        dx = X[i+1] - X[0]\n        if dt > 0:\n            speed = dx / dt\n            distances.add(speed)\n\n    distinct_speeds = len(distances)\n    sorted_distances = sorted(distances)\n\n    print(distinct_speeds)\n    print(' '.join(map(str, sorted_distances)))\n\n# Read input from stdin\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\nfind_speeds_and_distances(M, N, T, X)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968129396438599,
            0.9959134459495544,
            0.9967168569564819,
            0.997247576713562,
            0.9941139221191406,
            0.9970582723617554,
            0.996726393699646,
            0.9971821308135986,
            0.9968762993812561,
            0.9961692690849304,
            0.9937728047370911,
            0.9973578453063965,
            0.9973980784416199,
            0.9968996644020081,
            0.99704509973526,
            0.9956773519515991,
            0.9964903593063354,
            0.9933204650878906,
            0.9967394471168518,
            0.9971221089363098
        ]
    },
    "4410": {
        "similarity": 0.9974614381790161,
        "body": "    count = 0\n    last_occupied = -k - 1\n    for i in range(n):\n        if s[i] == '0':\n            if i > last_occupied:\n                count += 1\n                last_occupied = i + k\n    return count\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    s = data[index + 2]\n    index += 3\n    results.append(max_occupied_tables(n, k, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967444539070129,
            0.9965417981147766,
            0.9969455599784851,
            0.9931743144989014,
            0.9964423179626465,
            0.9960076212882996,
            0.9972202777862549,
            0.9972997903823853,
            0.9971839785575867,
            0.9966164827346802,
            0.9968962669372559,
            0.9961292743682861,
            0.9974614381790161,
            0.9971176981925964,
            0.9967966675758362,
            0.9943916201591492,
            0.9945273399353027,
            0.995765209197998,
            0.9962465167045593,
            0.9967444539070129
        ]
    },
    "2441": {
        "similarity": 0.9984466433525085,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    MOD = 10**9 + 7\n    \n    # Build adjacency list\n    graph = defaultdict(list)\n    for u, v in roads:\n        graph[u].append(v)\n    \n    # Initialize distances and paths\n    min_cost = [float('inf')] * (n + 1)\n    num_ways = [0] * (n + 1)\n    min_cost[1] = 0\n    num_ways[1] = 1\n    \n    queue = deque([1])\n    \n    while queue:\n        current = queue.popleft()\n        \n        for neighbor in graph[current]:\n            new_cost = min_cost[current] + costs[neighbor - 1]\n            \n            if new_cost < min_cost[neighbor]:\n                min_cost[neighbor] = new_cost\n                num_ways[neighbor] = num_ways[current]\n                queue.append(neighbor)\n                \n            elif new_cost == min_cost[neighbor]:\n                num_ways[neighbor] += num_ways[current]\n                num_ways[neighbor] %= MOD\n    \n    return min_cost[n], num_ways[n]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    costs = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    roads = [(int(data[n+2+i*2])-1, int(data[n+3+i*2])) for i in range(m)]\n    \n    min_cost, num_ways = min_cost_and_ways(n, costs, roads)\n    \n    print(min_cost, num_ways)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979151487350464,
            0.9978662133216858,
            0.9984466433525085,
            0.9980232119560242,
            0.9982039928436279,
            0.9971919059753418,
            0.9982514977455139,
            0.9973248839378357,
            0.9983789324760437,
            0.9982184171676636,
            0.9973703026771545,
            0.996951162815094,
            0.9982768893241882,
            0.9978426694869995,
            0.9980445504188538,
            0.9981187582015991,
            0.9980389475822449,
            0.9961457848548889,
            0.9980989098548889,
            0.998055100440979
        ]
    },
    "276": {
        "similarity": 0.9961277842521667,
        "body": "    gems = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']\n    seen_colors = set(input().strip() for _ in range(int(input())))\n    absent_gems = [gem.capitalize() for gem in gems if gem not in seen_colors]\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948714375495911,
            0.9909977316856384,
            0.9924651980400085,
            0.9923517107963562,
            0.9938511252403259,
            0.9923830628395081,
            0.9951618909835815,
            0.9961277842521667,
            0.9961277842521667,
            0.9919650554656982,
            0.9937543272972107,
            0.9890754222869873,
            0.9955247640609741,
            0.9953105449676514,
            0.9930180907249451,
            0.9938957095146179,
            0.9937689900398254,
            0.9955846667289734,
            0.992868959903717,
            0.9955173134803772
        ]
    },
    "2635": {
        "similarity": 0.9960354566574097,
        "body": "    if not matrix:\n        return []\n    \n    result = []\n    while matrix:\n        result += matrix.pop(0)\n        if matrix and matrix[0]:\n            for row in matrix:\n                result.append(row.pop())\n        if matrix:\n            result += matrix.pop()[::-1]\n        if matrix and matrix[0]:\n            for row in matrix[::-1]:\n                result.append(row.pop(0))\n    \n    return result\n\n# Example usage\nmatrix = [\n    [int(num) for num in input().split()] for _ in range(int(input()))\n]\nprint(\" \".join(map(str, spiralOrder(matrix))))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951202273368835,
            0.9950571656227112,
            0.9924794435501099,
            0.9911854267120361,
            0.9942926168441772,
            0.993365466594696,
            0.9940617084503174,
            0.9940412640571594,
            0.9911854267120361,
            0.9934476613998413,
            0.9948559999465942,
            0.994795560836792,
            0.9958827495574951,
            0.9917316436767578,
            0.9960354566574097,
            0.9939199090003967,
            0.9949873089790344,
            0.994490385055542,
            0.9945405721664429,
            0.9936455488204956
        ]
    },
    "281": {
        "similarity": 0.9976175427436829,
        "body": "import math\n\n        if n == 0 or n == 1:\n            return 1\n        result = 2\n        for i in range(3, n + 1, 2):\n            result = (result * i) % 10\n        return result\n    \n    if a == b:\n        return 1\n    \n    numerator_last_digit = factorial(b)\n    denominator_last_digit = factorial(a)\n    \n    last_digit = (numerator_last_digit * pow(denominator_last_digit, -1, 10)) % 10\n    return last_digit\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(last_digit_of_factorial_ratio(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960090517997742,
            0.9972566366195679,
            0.996620774269104,
            0.9972409009933472,
            0.9963346719741821,
            0.9970568418502808,
            0.9951898455619812,
            0.9970967173576355,
            0.9953704476356506,
            0.9966942667961121,
            0.9972475171089172,
            0.9961597919464111,
            0.9970104694366455,
            0.9967930316925049,
            0.9972413778305054,
            0.9928776621818542,
            0.9944337606430054,
            0.9940738677978516,
            0.9969996213912964,
            0.9976175427436829
        ]
    },
    "2300": {
        "similarity": 0.9979952573776245,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    index = 2 + n\n    \n    results = []\n    \n    for _ in range(m):\n        t = int(data[index])\n        index += 1\n        \n        if t == 1:\n            x = int(data[index]) - 1\n            v = int(data[index + 1])\n            a[x] = v\n            index += 2\n        elif t == 2:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            f = [1, 1]\n            for i in range(2, r - l + 1):\n                f.append(f[i-1] + f[i-2] - 1)\n            s = sum(f[i] * a[l + i] for i in range(r - l + 1))\n            results.append(s % 1000000000)\n            index += 2\n        elif t == 3:\n            l = int(data[index]) - 1\n            r = int(data[index + 1])\n            d = int(data[index + 2])\n            for i in range(l, r + 1):\n                a[i] += d\n            index += 3\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977590441703796,
            0.9976693987846375,
            0.9978082776069641,
            0.997757077217102,
            0.9948921203613281,
            0.9974923729896545,
            0.9978693723678589,
            0.9974319934844971,
            0.9974247813224792,
            0.9977474212646484,
            0.9974243640899658,
            0.9977975487709045,
            0.9973068237304688,
            0.9975441694259644,
            0.9979952573776245,
            0.9977573752403259,
            0.9955573678016663,
            0.9976028800010681,
            0.9974501729011536,
            0.9954904317855835
        ]
    },
    "2104": {
        "similarity": 0.997779369354248,
        "body": "import sys\nfrom math import gcd\n\n    pairs = []\n    for i in range(l, r + 1):\n        if len(pairs) == (r - l + 1) // 2:\n            break\n        for j in range(i + 1, r + 1):\n            if gcd(i, j) == 1:\n                pairs.append((i, j))\n                i = j\n                break\n    return pairs\n\n    input = sys.stdin.read\n    data = input().split()\n    l = int(data[0])\n    r = int(data[1])\n    \n    pairs = find_pairs(l, r)\n    \n    if len(pairs) == (r - l + 1) // 2:\n        print(\"YES\")\n        for pair in pairs:\n            print(pair[0], pair[1])\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967824220657349,
            0.997725248336792,
            0.9937290549278259,
            0.9974180459976196,
            0.9951790571212769,
            0.9965171813964844,
            0.9967129230499268,
            0.9967354536056519,
            0.995989978313446,
            0.996207594871521,
            0.9966123700141907,
            0.9973993897438049,
            0.997779369354248,
            0.9964799284934998,
            0.9967225790023804,
            0.9963651895523071,
            0.9956510663032532,
            0.9975711703300476,
            0.996758222579956,
            0.996821939945221
        ]
    },
    "1995": {
        "similarity": 0.9978818297386169,
        "body": "    s = list(s)\n    for l, r, k in queries:\n        l -= 1\n        r -= 1\n        substring = s[l:r+1]\n        shift = k % len(substring)\n        s[l:r+1] = substring[shift:] + substring[:shift]\n    return ''.join(s)\n\n# Read input from stdin\ns = input().strip()\nm = int(input().strip())\nqueries = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Process the queries and print the result\nresult = cyclic_shift(s, queries)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968635439872742,
            0.9961016774177551,
            0.9972668886184692,
            0.9952039122581482,
            0.9967253804206848,
            0.9977114796638489,
            0.9973150491714478,
            0.9945781230926514,
            0.9964072704315186,
            0.9955121874809265,
            0.997802734375,
            0.9976485371589661,
            0.9976049661636353,
            0.9967799782752991,
            0.9978818297386169,
            0.9967855215072632,
            0.9975664019584656,
            0.9969106912612915,
            0.9977114796638489,
            0.9964096546173096
        ]
    },
    "2064": {
        "similarity": 0.9965978860855103,
        "body": "    if n < 2:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        digits = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n        result = []\n        while n > 0:\n            for i in range(9, -1, -1):\n                if n >= digits[i]:\n                    result.append(i)\n                    n -= digits[i]\n                    break\n        return int(''.join(map(str, result)))\n\nimport sys\nn = int(input())\nprint(max_number(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.994023859500885,
            0.9962487816810608,
            0.9918931722640991,
            0.9965978860855103,
            0.9959650635719299,
            0.9953905344009399,
            0.9957046508789062,
            0.9957098960876465,
            0.993849515914917,
            0.9948508739471436,
            0.9963619709014893,
            0.995507001876831,
            0.9943548440933228,
            0.9955926537513733,
            0.9959235191345215,
            0.9957045316696167,
            0.9925575256347656,
            0.9936884641647339,
            0.9956343770027161,
            0.9963346719741821
        ]
    },
    "1715": {
        "similarity": 0.9957751035690308,
        "body": "import sys\n\n    A, B, Q = map(int, input().split())\n    s = list(map(int, [input() for _ in range(A)]))\n    t = list(map(int, [input() for _ in range(B)]))\n    x = list(map(int, [input() for _ in range(Q)]))\n\n    results = []\n    for xi in x:\n        min_distance = float('inf')\n        for si in s:\n            if xi <= si:\n                distance_to_shrine = si - xi\n            else:\n                distance_to_shrine = xi - si\n\n            for ti in t:\n                if xi <= ti:\n                    distance_to_temple = ti - xi\n                else:\n                    distance_to_temple = xi - ti\n\n                min_distance = min(min_distance, distance_to_shrine + distance_to_temple)\n\n        results.append(min_distance)\n\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954435229301453,
            0.9949519634246826,
            0.9944968223571777,
            0.9954948425292969,
            0.9932789206504822,
            0.9954085350036621,
            0.9950529336929321,
            0.9956846833229065,
            0.9955646395683289,
            0.9955326914787292,
            0.9956120848655701,
            0.9950090050697327,
            0.9956775307655334,
            0.9948185682296753,
            0.991250216960907,
            0.9957751035690308,
            0.9954355955123901,
            0.9946696758270264,
            0.9955017566680908,
            0.9957564473152161
        ]
    },
    "2074": {
        "similarity": 0.9942959547042847,
        "body": "import sys\n\n    min_costs = [min(row) for row in costs]\n    return max(min_costs)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    costs = [list(map(int, input().split())) for _ in range(n)]\n    print(find_dinner_cost(n, m, costs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9889989495277405,
            0.9895139932632446,
            0.9926324486732483,
            0.9929214119911194,
            0.9942959547042847,
            0.9942959547042847,
            0.9942399859428406,
            0.9934343099594116,
            0.9852828979492188,
            0.9925684928894043,
            0.9889988303184509,
            0.9896396994590759,
            0.9933395385742188,
            0.9921521544456482,
            0.9852649569511414,
            0.9928866028785706,
            0.9901981353759766,
            0.9936710000038147,
            0.9879899621009827,
            0.9871048331260681
        ]
    },
    "2921": {
        "similarity": 0.996403157711029,
        "body": "from itertools import combinations_with_replacement\n\n    drinks = []\n    for _ in range(d):\n        name, strength, size, cost = input().split()\n        strength = float(strength)\n        if size == '1/1':\n            units_per_cost = (strength / 100) * 1\n        elif size == '1/2':\n            units_per_cost = (strength / 100) * 0.5\n        else:\n            units_per_cost = (strength / 100) * (1/3)\n        cost = float(cost)\n        drinks.append((name, units_per_cost, cost))\n\n    for i in range(1, d + 1):\n        for combo in combinations_with_replacement(drinks, i):\n            total_cost = sum(x[2] for x in combo)\n            total_units = sum(x[1] for x in combo)\n            if abs(total_cost - m) < 0.01 and abs(total_units - u) < 0.01:\n                return ' '.join(f\"{x[0]} {int(y)}\" for x, y in zip(combo, [total_units/x[1] for x in combo]))\n    return \"IMPOSSIBLE\"\n\nm, u, d = map(float, input().split())\nprint(find_drink_combinations(m, u, int(d)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.980474591255188,
            0.996403157711029,
            0.9952011108398438,
            0.9953421354293823,
            0.9947057366371155,
            0.9953095316886902,
            0.9950499534606934,
            0.9956293702125549,
            0.9960710406303406,
            0.9956213235855103,
            0.994205892086029,
            0.9948437213897705,
            0.9945313334465027,
            0.996346116065979,
            0.9956310987472534,
            0.9958550333976746,
            0.995347797870636,
            0.9898618459701538,
            0.9951888918876648,
            0.9955764412879944
        ]
    },
    "1642": {
        "similarity": 0.9971347451210022,
        "body": "import sys\n\n    min_distances = []\n    \n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        dx = x2 - x1\n        dy = y2 - y1\n        distance = (dx ** 2 + dy ** 2) ** 0.5\n        min_distances.append(distance / 2)\n    \n    return max(min_distances)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    points = [(int(data[i * 2 + 1]), int(data[i * 2 + 2])) for i in range(n)]\n    \n    result = max_distance(n, points)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963319897651672,
            0.9965444803237915,
            0.9954276084899902,
            0.9946926832199097,
            0.9966332316398621,
            0.9948917031288147,
            0.9969018697738647,
            0.9968960285186768,
            0.9956914782524109,
            0.9941878914833069,
            0.9961430430412292,
            0.9971347451210022,
            0.9945409893989563,
            0.9965437054634094,
            0.9964731335639954,
            0.9966886639595032,
            0.9952467679977417,
            0.9970016479492188,
            0.995069682598114,
            0.9968880414962769
        ]
    },
    "947": {
        "similarity": 0.9970837831497192,
        "body": "import sys\n\n    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return (n - 1) // 2, (n + 1) // 2\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a, b = min_lcm_pair(n)\n    print(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942192435264587,
            0.9938008189201355,
            0.9969598650932312,
            0.997012197971344,
            0.9965512156486511,
            0.9964814782142639,
            0.9934548139572144,
            0.9934042096138,
            0.9959011077880859,
            0.9967725872993469,
            0.9914135336875916,
            0.9929407835006714,
            0.997031569480896,
            0.9961491823196411,
            0.9964050650596619,
            0.9964537620544434,
            0.9961056113243103,
            0.9950548410415649,
            0.9961230754852295,
            0.9970837831497192
        ]
    },
    "743": {
        "similarity": 0.9975690245628357,
        "body": "    x.sort()\n    for i in range(1, n):\n        x[i] = x[i] - x[0]\n    return sum(x)\n\n# Read input\nn = int(input())\nx = list(map(int, input().split()))\n\n# Output the result\nprint(min_sum(n, x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973398447036743,
            0.9970942139625549,
            0.9972343444824219,
            0.994421124458313,
            0.9948487877845764,
            0.9972181916236877,
            0.9968273639678955,
            0.9956141114234924,
            0.9969995617866516,
            0.9974339008331299,
            0.9934385418891907,
            0.9970971941947937,
            0.9968400597572327,
            0.9973092675209045,
            0.9962007403373718,
            0.9942044019699097,
            0.9972619414329529,
            0.9975426197052002,
            0.9972318410873413,
            0.9975690245628357
        ]
    },
    "1397": {
        "similarity": 0.9968039989471436,
        "body": "from collections import defaultdict\nimport sys\n\n    graph = defaultdict(list)\n    \n    # Create a complete graph\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in forbidden and (j, i) not in forbidden:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    # Find the minimum number of roads needed\n    roads = []\n    visited = set()\n    \n        stack = [node]\n        while stack:\n            current = stack.pop()\n            if current not in visited:\n                visited.add(current)\n                for neighbor in graph[current]:\n                    if neighbor not in visited and (current, neighbor) not in forbidden and (neighbor, current) not in forbidden:\n                        roads.append((current, neighbor))\n                        dfs(neighbor)\n    \n    for i in range(1, n + 1):\n        if i not in visited:\n            dfs(i)\n    \n    return len(roads), roads\n\n# Read input\nn, m = map(int, input().split())\nforbidden = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get result\nresult_count, result_roads = minimum_roads(n, m, forbidden)\n\n# Print result\nprint(result_count)\nfor road in result_roads:\n    print(road[0], road[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940260052680969,
            0.9959094524383545,
            0.996060848236084,
            0.9962693452835083,
            0.9963007569313049,
            0.9955810904502869,
            0.9940775632858276,
            0.9964509606361389,
            0.9945817589759827,
            0.9952672719955444,
            0.9963055849075317,
            0.9968039989471436,
            0.9959365725517273,
            0.9940964579582214,
            0.995318591594696,
            0.9962548017501831,
            0.9951400756835938,
            0.9956799745559692,
            0.9943972229957581,
            0.9967755675315857
        ]
    },
    "1144": {
        "similarity": 0.9971646666526794,
        "body": "    target = 'ab' * (m // 2) + ('a' if m % 2 else '')\n    replacements = 0\n    \n    for i in range(n - m + 1):\n        current = s[i:i+m]\n        for j in range(m):\n            if current[j] != '?' and current[j] != target[j]:\n                replacements += 1\n                break\n    \n    return replacements\n\n# Read input\nn = int(input().strip())\ns = input().strip()\nm = int(input().strip())\n\n# Output the result\nprint(max_beauty_replacements(n, s, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970996379852295,
            0.9969953298568726,
            0.9952957034111023,
            0.9955913424491882,
            0.9948368072509766,
            0.9970711469650269,
            0.9944608807563782,
            0.995394766330719,
            0.9957371950149536,
            0.9971646666526794,
            0.9922773241996765,
            0.9910902976989746,
            0.9961704611778259,
            0.9962819814682007,
            0.9967888593673706,
            0.9952030181884766,
            0.9961662292480469,
            0.9968277812004089,
            0.9958605766296387,
            0.9966834187507629
        ]
    },
    "890": {
        "similarity": 0.998138964176178,
        "body": "    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_difficulty = min(difficulties[i], difficulties[j])\n            max_difficulty = max(difficulties[i], difficulties[j])\n            if l <= (difficulties[i] + difficulties[j]) <= r and (max_difficulty - min_difficulty) >= x:\n                count += 1\n    return count\n\n# Read input from stdin\nn, l, r, x = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Print the result\nprint(count_problemsets(n, l, r, x, difficulties))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969438314437866,
            0.998031497001648,
            0.9970754384994507,
            0.9976602792739868,
            0.9978141784667969,
            0.9971176981925964,
            0.997042715549469,
            0.9978150129318237,
            0.998138964176178,
            0.9976168274879456,
            0.9976454377174377,
            0.9966142773628235,
            0.9976456165313721,
            0.9959213137626648,
            0.9978079795837402,
            0.9970711469650269,
            0.9981364011764526,
            0.9959210157394409,
            0.9950769543647766,
            0.9958827495574951
        ]
    },
    "2410": {
        "similarity": 0.9970384240150452,
        "body": "import sys\n\n    yasser_total = sum(a)\n    adel_min_total = float('inf')\n    \n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j]\n            adel_min_total = min(adel_min_total, current_sum)\n    \n    return yasser_total > adel_min_total\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = \"YES\" if is_yasser_happy(n, a) else \"NO\"\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968838095664978,
            0.9959847331047058,
            0.9948328733444214,
            0.9957572817802429,
            0.996191143989563,
            0.9962080121040344,
            0.9964432120323181,
            0.99619060754776,
            0.9970384240150452,
            0.9969843029975891,
            0.9966127276420593,
            0.9967151284217834,
            0.9968293905258179,
            0.9964373707771301,
            0.9965925812721252,
            0.9964828491210938,
            0.9952133893966675,
            0.9950887560844421,
            0.994086503982544,
            0.9956699013710022
        ]
    },
    "1004": {
        "similarity": 0.9978953003883362,
        "body": "    stack = []\n    days = 0\n    events_count = 0\n    \n    for event in a:\n        if event > 0:\n            if not stack:\n                days += 1\n                events_count = 0\n            stack.append(event)\n        else:\n            if not stack or stack[-1] != -event:\n                return -1\n            stack.pop()\n        \n        events_count += 1\n    \n    if stack:\n        return -1\n    \n    return days, [events_count]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nresult = partition_events(n, a)\nif result == -1:\n    print(-1)\nelse:\n    days, events_counts = result\n    print(days)\n    print(' '.join(map(str, events_counts)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976119995117188,
            0.9961439371109009,
            0.9971317648887634,
            0.9972922801971436,
            0.9969002604484558,
            0.9961445331573486,
            0.9968593120574951,
            0.9947764873504639,
            0.997410237789154,
            0.9969687461853027,
            0.9960790872573853,
            0.9973300099372864,
            0.9945487976074219,
            0.9971596598625183,
            0.9978953003883362,
            0.9959078431129456,
            0.9960359334945679,
            0.9971941709518433,
            0.9973700642585754,
            0.9976328611373901
        ]
    },
    "531": {
        "similarity": 0.9975760579109192,
        "body": "import sys\n\n    min_x = min(x)\n    max_x = max(x)\n    total_sum = sum(x)\n    target_avg = total_sum // n\n    \n    if (total_sum % n) != 0:\n        target_avg += 1\n    \n    equal_count = 0\n    result = []\n    \n    for value in x:\n        if value == target_avg:\n            result.append(target_avg)\n        elif value < target_avg:\n            result.append(value + 1)\n            equal_count += 1\n        else:\n            result.append(value - 1)\n            equal_count += 1\n    \n    return equal_count, result\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nx = list(map(int, data[1:]))\n\nequal_count, y = adjust_measurements(n, x)\n\nprint(equal_count)\nprint(' '.join(map(str, y)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965585470199585,
            0.9960967898368835,
            0.9970353841781616,
            0.996715247631073,
            0.9974176287651062,
            0.997394859790802,
            0.9953685402870178,
            0.9928948283195496,
            0.9946748614311218,
            0.9958679676055908,
            0.9967387318611145,
            0.9968096017837524,
            0.9965822100639343,
            0.9967623353004456,
            0.9962056875228882,
            0.9975760579109192,
            0.9966302514076233,
            0.9970120191574097,
            0.9969209432601929,
            0.9952623248100281
        ]
    },
    "510": {
        "similarity": 0.9947773814201355,
        "body": "import sys\n\n    max_distance = max(abs(a - b), abs(b - c), abs(c - a))\n    return (max_distance + d - 1) // d\n\nif __name__ == \"__main__\":\n    input_data = input().split()\n    a = int(input_data[0])\n    b = int(input_data[1])\n    c = int(input_data[2])\n    d = int(input_data[3])\n    print(min_performance_duration(a, b, c, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9929345846176147,
            0.9938356280326843,
            0.9944173097610474,
            0.9939081072807312,
            0.9919095635414124,
            0.9932243824005127,
            0.9935267567634583,
            0.9931782484054565,
            0.9930058717727661,
            0.9947773814201355,
            0.9941396117210388,
            0.9933949708938599,
            0.9946341514587402,
            0.9936544299125671,
            0.9946341514587402,
            0.9915181398391724,
            0.988399088382721,
            0.9934622049331665,
            0.991855800151825,
            0.9932567477226257
        ]
    },
    "2555": {
        "similarity": 0.9970914125442505,
        "body": "from sys import stdin\n\n    a.sort()\n    if n % 2 == 0:\n        return sum(a[::2])\n    else:\n        return sum(a[1::2])\n\n    results = []\n    for n, q, a, ops in cases:\n        strengths = [max_strength(n, a[:])]\n        for l, r in ops:\n            a[l-1], a[r-1] = a[r-1], a[l-1]\n            strengths.append(max_strength(n, a[:]))\n        results.extend(strengths)\n    return results\n\n    input = stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    cases = []\n    for _ in range(t):\n        n = int(data[index + 1])\n        q = int(data[index + 2])\n        a = list(map(int, data[index + 3:index + 3 + n]))\n        ops = [(int(data[index + 3 + n + 2 * i]) - 1, int(data[index + 3 + n + 2 * i + 1]) - 1) for i in range(q)]\n        index += 3 + n + 2 * q\n        cases.append((n, q, a, ops))\n    \n    results = process_operations(t, cases)\n    print(' '.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970914125442505,
            0.995521068572998,
            0.9948999285697937,
            0.9939723610877991,
            0.9969430565834045,
            0.9967313408851624,
            0.9961361289024353,
            0.9934806823730469,
            0.9950021505355835,
            0.9954584836959839,
            0.996018648147583,
            0.9966066479682922,
            0.9958754181861877,
            0.9956550598144531,
            0.9962290525436401,
            0.9942092895507812,
            0.9966509938240051,
            0.9962501525878906,
            0.9957633018493652,
            0.9959648847579956
        ]
    },
    "324": {
        "similarity": 0.9975289702415466,
        "body": "        if num < 4:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return True\n        return False\n\n    a = n + 2\n    while not is_composite(a):\n        a += 1\n    \n    b = a - n\n    return a, b\n\nn = int(input())\na, b = find_composite_pair(n)\nprint(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974278807640076,
            0.9974609017372131,
            0.987503170967102,
            0.990351140499115,
            0.9964953064918518,
            0.9967679381370544,
            0.9970424175262451,
            0.9972497820854187,
            0.9965049624443054,
            0.9927958250045776,
            0.9969165325164795,
            0.9975289702415466,
            0.9962064623832703,
            0.9965419769287109,
            0.9974180459976196,
            0.9969450235366821,
            0.997262179851532,
            0.9964954853057861,
            0.9956725239753723,
            0.9972402453422546
        ]
    },
    "2912": {
        "similarity": 0.9956284761428833,
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nstrings = data[1:N+1]\noperations = [(int(data[N+i*2])-1, int(data[N+i*2+1])-1) for i in range(N-1)]\n\nfor a, b in operations:\n    strings[a] += strings[b]\n    strings[b] = \"\"\n\nprint(strings[0])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949777722358704,
            0.9949276447296143,
            0.9942082762718201,
            0.9938486218452454,
            0.9955046772956848,
            0.9868153929710388,
            0.9940813779830933,
            0.9956019520759583,
            0.9953591227531433,
            0.9942839741706848,
            0.9946507215499878,
            0.9956284761428833,
            0.9953256249427795,
            0.9950253367424011,
            0.9941755533218384,
            0.9932879209518433,
            0.9950075745582581,
            0.9945192933082581,
            0.9943803548812866,
            0.9954095482826233
        ]
    },
    "9": {
        "similarity": 0.9948334097862244,
        "body": "        return sum(1 for i in range(x - 1, x + 2) for j in range(y - 1, y + 2) if (i != x or j != y) and 1 <= i <= n and 1 <= j <= m and (i + dx, j + dy) not in sofas)\n\n    cnt_l, cnt_r, cnt_t, cnt_b = cnt_lr_tb\n    for i in range(d):\n        x1, y1, x2, y2 = sofas[i]\n        if len(set([x1 - 1, x2 - 1, x1 + 1, x2 + 1])) == 3 and len(set([y1 - 1, y2 - 1, y1 + 1, y2 + 1])) == 3:\n            if (count_neighbours(x1, y1, 0, -1) == cnt_l and\n                count_neighbours(x1, y1, 0, 1) == cnt_r and\n                count_neighbours(x1, y1, -1, 0) == cnt_t and\n                count_neighbours(x1, y1, 1, 0) == cnt_b):\n                return i + 1\n    return -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nd = int(data[0])\nn = int(data[1])\nm = int(data[2])\nsofas = []\nfor i in range(d):\n    x1, y1, x2, y2 = map(int, data[3 + 4 * i:3 + 4 * (i + 1)])\n    sofas.append((x1, y1, x2, y2))\ncnt_lr_tb = tuple(map(int, data[3 + 4 * d:]))\n\nprint(find_sofa(d, n, m, sofas, cnt_lr_tb))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948334097862244,
            0.9946653246879578,
            0.9931632876396179,
            0.9936665892601013,
            0.9934602975845337,
            0.9892157316207886,
            0.9938666820526123,
            0.992592453956604,
            0.99442058801651,
            0.9947152733802795,
            0.9903423190116882,
            0.9937459826469421,
            0.9943536520004272,
            0.9939871430397034,
            0.992564857006073,
            0.9945894479751587,
            0.9944695830345154,
            0.9899826049804688,
            0.9944826364517212,
            0.9929389953613281
        ]
    },
    "249": {
        "similarity": 0.9971715211868286,
        "body": "    required = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = a[j] - a[i]\n            if diff == x or diff == y:\n                continue\n            required.add(diff)\n    \n    additional_marks = []\n    for mark in sorted(required):\n        if mark not in a and mark <= l:\n            additional_marks.append(mark)\n    \n    return len(additional_marks), additional_marks\n\n# Read input\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get result\nv, p = min_additional_marks(n, l, x, y, a)\n\n# Print output\nprint(v)\nprint(\" \".join(map(str, p)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956415891647339,
            0.9965890645980835,
            0.9941334128379822,
            0.9951885938644409,
            0.996662974357605,
            0.9945027232170105,
            0.9951494336128235,
            0.9949709177017212,
            0.9964562654495239,
            0.9944950938224792,
            0.9929026365280151,
            0.9971715211868286,
            0.9961810111999512,
            0.9920077919960022,
            0.9951085448265076,
            0.9970008730888367,
            0.9948521852493286,
            0.9966389536857605,
            0.9944993853569031,
            0.9960007071495056
        ]
    },
    "2999": {
        "similarity": 0.9962323904037476,
        "body": "    bets = [b for _, b in participants]\n    total_bets = sum(bets)\n    \n        if target == 0:\n            return True\n        if idx == len(bets) or target < 0:\n            return False\n        return can_partition(target - bets[idx], idx + 1) or can_partition(target, idx + 1)\n    \n    winners = []\n    for i in range(n):\n        remaining_s = s - participants[i][1]\n        if remaining_s >= 0 and can_partition(remaining_s, i + 1):\n            winners.append(participants[i][0])\n    \n    return len(winners), winners\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ns = int(data[1])\n\nparticipants = []\nfor i in range(n):\n    t = data[2 + 2 * i]\n    b = int(data[3 + 2 * i])\n    participants.append((t, b))\n\nk, winners = find_winners(n, s, participants)\n\nprint(k)\nfor w in winners:\n    print(w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958097338676453,
            0.9943897128105164,
            0.9933308959007263,
            0.9962323904037476,
            0.9959883689880371,
            0.9959251284599304,
            0.99554044008255,
            0.9951398968696594,
            0.9954500794410706,
            0.9952688813209534,
            0.9947351217269897,
            0.9946796894073486,
            0.9918586611747742,
            0.9955813884735107,
            0.9954549670219421,
            0.9961161613464355,
            0.9957325458526611,
            0.9928314685821533,
            0.9951074719429016,
            0.9936612844467163
        ]
    },
    "2239": {
        "similarity": 0.9940817952156067,
        "body": "    if x <= 7:\n        return 1\n    elif x % 2 == 0:\n        return 3\n    else:\n        return 8\n\nt = int(input())\nresults = [min_rolls(int(input())) for _ in range(t)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936701059341431,
            0.9901456236839294,
            0.9917750954627991,
            0.9920545816421509,
            0.9939268231391907,
            0.9892516136169434,
            0.9926404356956482,
            0.9877572655677795,
            0.9894530773162842,
            0.9937066435813904,
            0.9904195666313171,
            0.9934240579605103,
            0.989408016204834,
            0.9900608062744141,
            0.9892011880874634,
            0.9907234907150269,
            0.992946207523346,
            0.9940817952156067,
            0.9861608743667603,
            0.9917483925819397
        ]
    },
    "2615": {
        "similarity": 0.9970673322677612,
        "body": "from math import gcd\nfrom functools import reduce\n\n        i = 2\n        factors = []\n        while i * i <= x:\n            if x % i:\n                i += 1\n            else:\n                x //= i\n                factors.append(i)\n        if x > 1:\n            factors.append(x)\n        return factors\n\n        return reduce(gcd, lst)\n\n    elegant_count = 0\n    for x in range(2, n + 1):\n        factors = prime_factors(x)\n        k_values = [factors.count(p) for p in set(factors)]\n        if gcd_list(k_values) == 1:\n            elegant_count += 1\n\n    return elegant_count\n\nT = int(input())\nresults = []\nfor _ in range(T):\n    n = int(input())\n    results.append(count_elegant_numbers(n))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969013929367065,
            0.9933782815933228,
            0.9970673322677612,
            0.9950689077377319,
            0.9966143369674683,
            0.9958894848823547,
            0.992588222026825,
            0.9913416504859924,
            0.9955080151557922,
            0.9967566132545471,
            0.9961674213409424,
            0.9970077872276306,
            0.9961185455322266,
            0.9970269799232483,
            0.9966594576835632,
            0.9958879351615906,
            0.9955510497093201,
            0.9966586232185364,
            0.9965159893035889,
            0.9968113303184509
        ]
    },
    "2542": {
        "similarity": 0.9981058835983276,
        "body": "    n = len(s)\n    for i in range(n):\n        if s[:i] == s[i+1:]:\n            return n - 2 * i\n    return n\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input().strip()\n    results.append(min_erasures_to_good_string(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976603984832764,
            0.9979003071784973,
            0.997281014919281,
            0.9980946779251099,
            0.997489333152771,
            0.9981058835983276,
            0.9979777336120605,
            0.9978398084640503,
            0.9949167370796204,
            0.9911075234413147,
            0.9974365234375,
            0.9966937899589539,
            0.9974778890609741,
            0.9972609281539917,
            0.9971722364425659,
            0.9971551299095154,
            0.9969541430473328,
            0.9980926513671875,
            0.9950215220451355,
            0.9966966509819031
        ]
    },
    "511": {
        "similarity": 0.9981619119644165,
        "body": "import math\n\n    if b == 0:\n        return 0\n    gcd = math.gcd(a, b)\n    return 1 + f(a, b - gcd)\n\nx, y = map(int, input().split())\nprint(f(x, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979364275932312,
            0.9978077411651611,
            0.9959704875946045,
            0.9964515566825867,
            0.9981619119644165,
            0.9975013732910156,
            0.9980013966560364,
            0.9976077675819397,
            0.9981619119644165,
            0.9976840615272522,
            0.9978849291801453,
            0.9977085590362549,
            0.9981229901313782,
            0.9961951375007629,
            0.9977085590362549,
            0.9972899556159973,
            0.9981619119644165,
            0.9977085590362549,
            0.9975823760032654,
            0.9974732995033264
        ]
    },
    "1409": {
        "similarity": 0.9975208640098572,
        "body": "from collections import Counter\n\n    count = Counter(y)\n    valid_teams = 0\n    \n    for i in range(6):\n        if count[i] >= k:\n            valid_teams += count[i] // k\n    \n    return valid_teams // 3\n\n# Read input\nn, k = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Print the result\nprint(max_teams(n, k, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997263491153717,
            0.9957929253578186,
            0.9974586963653564,
            0.9974550008773804,
            0.9975208640098572,
            0.9966581463813782,
            0.9967311024665833,
            0.9967595338821411,
            0.9934421181678772,
            0.9973656535148621,
            0.9971705079078674,
            0.995263934135437,
            0.9970492124557495,
            0.9974039793014526,
            0.9928176403045654,
            0.997055172920227,
            0.9960029125213623,
            0.996722400188446,
            0.9964926838874817,
            0.9966447949409485
        ]
    },
    "2274": {
        "similarity": 0.9971341490745544,
        "body": "import sys\n\n    changes = 0\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if (i == n-1 and j == m-1) or directions[i][j] == 'C':\n                continue\n            if i < n-1:\n                if directions[i+1][j] != 'D':\n                    changes += 1\n                    directions[i][j] = 'D'\n            elif j < m-1:\n                if directions[i][j+1] != 'R':\n                    changes += 1\n                    directions[i][j] = 'R'\n    return changes\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index+1])\n        index += 2\n        \n        directions = [list(data[index+i]) for i in range(n)]\n        index += n\n        \n        changes = min_changes_to_functional(n, m, directions)\n        results.append(changes)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964976906776428,
            0.9958513975143433,
            0.9971341490745544,
            0.9966914653778076,
            0.9960643649101257,
            0.9961146116256714,
            0.9961820244789124,
            0.9966779351234436,
            0.9967111349105835,
            0.9945955872535706,
            0.9962474703788757,
            0.9959763288497925,
            0.9965673089027405,
            0.9966502785682678,
            0.9965864419937134,
            0.9969096183776855,
            0.9963899254798889,
            0.9895198345184326,
            0.9961957335472107,
            0.9969651103019714
        ]
    },
    "2420": {
        "similarity": 0.9976391196250916,
        "body": "        count = 0\n        for x, y in points:\n            if abs(x - center_x) + abs(y - center_y) <= r:\n                count += 1\n        return count\n\n    max_points = 0\n    for x, y in points:\n        covered = can_cover(x, y)\n        if covered > max_points:\n            max_points = covered\n\n    return max_points\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nr = int(data[1])\npoints = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(n)]\n\n# Output the result\nprint(max_points_in_ball(n, r, points))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968134164810181,
            0.9968339800834656,
            0.9971314668655396,
            0.9972288012504578,
            0.9975470304489136,
            0.9939271807670593,
            0.9957005381584167,
            0.9961756467819214,
            0.9969916939735413,
            0.9963865876197815,
            0.9971941709518433,
            0.997080385684967,
            0.9971080422401428,
            0.9976391196250916,
            0.9976248741149902,
            0.9963117241859436,
            0.9948400259017944,
            0.9969674944877625,
            0.995814859867096,
            0.9959908723831177
        ]
    },
    "1267": {
        "similarity": 0.9974467754364014,
        "body": "    max_score = max(scores)\n    dp = [0] * (max_score + 1)\n    dp[0] = 1\n    \n    for score in scores:\n        if score != 0:\n            for j in range(max_score, score - 1, -1):\n                dp[j] += dp[j - score]\n    \n    return sum(dp)\n\n# Read input\nn = int(input())\nscores = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_diploma_ways(n, scores))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996712327003479,
            0.9966396689414978,
            0.9956242442131042,
            0.9962882995605469,
            0.9972334504127502,
            0.9963696002960205,
            0.9943957328796387,
            0.9953687787055969,
            0.9961382150650024,
            0.9961155652999878,
            0.9958828687667847,
            0.996918261051178,
            0.994992196559906,
            0.9969721436500549,
            0.9971632957458496,
            0.9974467754364014,
            0.9963685274124146,
            0.9951908588409424,
            0.9954119324684143,
            0.9962831139564514
        ]
    },
    "2356": {
        "similarity": 0.9981096982955933,
        "body": "import sys\nfrom random import shuffle\n\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if j - a[j] == i - a[i]:\n                return False\n    return True\n\n    while True:\n        indices = list(range(1, n + 1))\n        shuffle(indices)\n        a = [indices[i-1] for i in range(n)]\n        if is_good_array(a):\n            return a\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    good_a = generate_good_array(n)\n    results.append(good_a)\n\nfor result in results:\n    print(len(result))\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975987672805786,
            0.9952718615531921,
            0.9977256655693054,
            0.9949389100074768,
            0.9981096982955933,
            0.9980213642120361,
            0.9979173541069031,
            0.9978998899459839,
            0.9975248575210571,
            0.997772216796875,
            0.9972124695777893,
            0.9969173073768616,
            0.9937627911567688,
            0.9979193806648254,
            0.997758686542511,
            0.9980549216270447,
            0.9970299601554871,
            0.9976080060005188,
            0.9980864524841309,
            0.9971511363983154
        ]
    },
    "108": {
        "similarity": 0.9975085854530334,
        "body": "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    target_index = 0\n    result = []\n    \n    for char in s:\n        while target_index < len(alphabet) and alphabet[target_index] <= char:\n            result.append(alphabet[target_index])\n            target_index += 1\n            if target_index == len(alphabet):\n                break\n    \n    return ''.join(result) if target_index == len(alphabet) else \"-1\"\n\n# Read input from stdin\ns = input().strip()\nprint(can_form_alphabet(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970807433128357,
            0.9954408407211304,
            0.9972366690635681,
            0.9970003366470337,
            0.996010422706604,
            0.9957693219184875,
            0.9962484240531921,
            0.9965936541557312,
            0.9955475330352783,
            0.9954032897949219,
            0.9975085854530334,
            0.9973156452178955,
            0.9951133728027344,
            0.9968160390853882,
            0.9970956444740295,
            0.9967610239982605,
            0.9955624341964722,
            0.9967809915542603,
            0.9969906210899353,
            0.995278537273407
        ]
    },
    "1833": {
        "similarity": 0.998478353023529,
        "body": "MOD = 10**9 + 7\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in a:\n        new_dp = dp[:]\n        for i in range(1, n + 1):\n            if num % i == 0:\n                new_dp[i] = (new_dp[i] + dp[i-1]) % MOD\n        dp = new_dp\n    \n    return (sum(dp[1:]) - 1) % MOD\n\nn = int(input())\na = list(map(int, input().split()))\nprint(count_good_subsequences(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983228445053101,
            0.9981819987297058,
            0.998478353023529,
            0.9979951977729797,
            0.998151957988739,
            0.9979852437973022,
            0.9976977109909058,
            0.9983068704605103,
            0.9975788593292236,
            0.9976834654808044,
            0.997027575969696,
            0.9983546733856201,
            0.9984064698219299,
            0.9971212148666382,
            0.9980785250663757,
            0.9975413084030151,
            0.9982621073722839,
            0.9967127442359924,
            0.9981786608695984,
            0.9971880912780762
        ]
    },
    "2324": {
        "similarity": 0.9985411763191223,
        "body": "    n = len(s)\n    dp = [[[0] * (n + 1) for _ in range(n)] for _ in range(2)]\n    \n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[0][i][j] = 1\n            elif s[i] == s[j]:\n                dp[0][i][j] = dp[0][i + 1][j - 1] * 2 + 2\n            else:\n                dp[0][i][j] = dp[1][i + 1][j] + dp[1][i][j - 1] - dp[1][i + 1][j - 1]\n    \n    for i in range(n):\n        dp[1][i][i] = 1\n    \n    result = [0] * n\n    for i in range(n):\n        for j in range(i, n):\n            result[i] += dp[0][i][j]\n    \n    print(' '.join(map(str, result)))\n\npalindromic_characteristics(input().strip())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982011914253235,
            0.9976388216018677,
            0.997772216796875,
            0.9980210661888123,
            0.9981182813644409,
            0.9983422160148621,
            0.9982181191444397,
            0.9979965090751648,
            0.9939897656440735,
            0.9981608986854553,
            0.9971672892570496,
            0.9982414245605469,
            0.9969679117202759,
            0.9978755116462708,
            0.9978646636009216,
            0.9983733296394348,
            0.9984145164489746,
            0.9980632662773132,
            0.9985411763191223,
            0.998322069644928
        ]
    },
    "2372": {
        "similarity": 0.9980984926223755,
        "body": "import sys\nfrom collections import deque\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < H and 0 <= y < W and S[x][y] == '..'\n    \n    queue = deque([(C_h - 1, C_w - 1, 0)])\n    visited = set()\n    visited.add((C_h - 1, C_w - 1))\n    \n    while queue:\n        x, y, moves = queue.popleft()\n        \n        if (x, y) == (D_h - 1, D_w - 1):\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves))\n        \n        # Check 5x5 magic area\n        for i in range(max(0, x - 2), min(H, x + 3)):\n            for j in range(max(0, y - 2), min(W, y + 3)):\n                if is_valid(i, j) and (i, j) not in visited:\n                    visited.add((i, j))\n                    queue.append((i, j, moves + 1))\n    \n    return -1\n\n# Read input\nH, W = map(int, input().split())\nC_h, C_w = map(int, input().split())\nD_h, D_w = map(int, input().split())\nS = [input().strip() for _ in range(H)]\n\n# Output result\nprint(min_magic_moves(H, W, C_h, C_w, D_h, D_w, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980984926223755,
            0.9977079629898071,
            0.9958052635192871,
            0.9977249503135681,
            0.9978137016296387,
            0.9968435168266296,
            0.9975728392601013,
            0.996784508228302,
            0.9926623106002808,
            0.9978633522987366,
            0.9976746439933777,
            0.9972450137138367,
            0.9971012473106384,
            0.9979925751686096,
            0.9980486631393433,
            0.9973540306091309,
            0.9972211122512817,
            0.9976766705513,
            0.9965224862098694,
            0.9968597292900085
        ]
    },
    "1984": {
        "similarity": 0.9972903728485107,
        "body": "    levels = [input().strip() for _ in range(k)]\n    \n    # Function to calculate the difference between two levels\n        return sum(1 for i in range(n) for j in range(m) if level1[i][j] != level2[i][j])\n    \n    # Initialize transmission strategy\n    transmissions = [0] * k\n    \n    # Calculate the minimum number of transferred bytes\n    total_bytes = 0\n    for i in range(k):\n        if i == 0:\n            # First level is always transmitted as a whole\n            total_bytes += n * m\n            transmissions[i] = 0\n        else:\n            min_diff = float('inf')\n            best_prev_level = -1\n            for j in range(i):\n                diff_bytes = diff(levels[i], levels[j]) * w\n                if diff_bytes < min_diff:\n                    min_diff = diff_bytes\n                    best_prev_level = j + 1\n            total_bytes += min_diff\n            transmissions[i] = best_prev_level\n    \n    # Print the result\n    print(total_bytes)\n    for i in range(k):\n        print(transmissions[i], end=' ')\n\n# Read input from stdin\nn, m, k, w = map(int, input().split())\nmin_traffic_transmission(n, m, k, w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937950968742371,
            0.9965600371360779,
            0.9967595934867859,
            0.9970605969429016,
            0.9966169595718384,
            0.9970579743385315,
            0.9965806603431702,
            0.9972903728485107,
            0.9964396953582764,
            0.996845543384552,
            0.9958651661872864,
            0.9961832165718079,
            0.9970148205757141,
            0.9969929456710815,
            0.9964338541030884,
            0.9969526529312134,
            0.9966993927955627,
            0.9962956309318542,
            0.9961995482444763,
            0.9966804385185242
        ]
    },
    "1253": {
        "similarity": 0.9963045716285706,
        "body": "    negative_count = sum(1 for x in a if x < 0)\n    if negative_count <= k:\n        return sum(abs(x) for x in a)\n    changes_needed = negative_count - (k % 2 == 0)\n    return sum(max(abs(x), -x) for x in a) + changes_needed * 2\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948987364768982,
            0.9946982860565186,
            0.9963045716285706,
            0.9925943613052368,
            0.9956333637237549,
            0.993663489818573,
            0.9943690896034241,
            0.9947469830513,
            0.9958797097206116,
            0.994906485080719,
            0.9925013184547424,
            0.9959362745285034,
            0.9945515990257263,
            0.9959256052970886,
            0.9935728311538696,
            0.9951499104499817,
            0.9956921339035034,
            0.9923160076141357,
            0.9942902326583862,
            0.9960567951202393
        ]
    },
    "523": {
        "similarity": 0.9972485899925232,
        "body": "        return s == s[::-1]\n\n    max_length = 0\n    best_palindrome = \"\"\n\n    for i in range(1 << n):\n        selected = [strings[j] for j in range(n) if (i & (1 << j))]\n        length = sum(len(s) for s in selected)\n        if length % 2 != 0:\n            continue\n\n        half_length = length // 2\n        left_half = \"\"\n        right_half = \"\"\n\n        for s in selected:\n            left_half += s[:half_length]\n            right_half = s[-half_length:] + right_half\n\n        if is_palindrome(left_half + right_half):\n            if len(left_half + right_half) > max_length:\n                max_length = len(left_half + right_half)\n                best_palindrome = left_half + right_half\n\n    print(max_length)\n    if best_palindrome:\n        print(best_palindrome)\n\n# Read input\nn, m = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\n\n# Call the function with the input\nlongest_palindrome(n, m, strings)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962661266326904,
            0.9939924478530884,
            0.9943868517875671,
            0.996124804019928,
            0.9961041808128357,
            0.995747447013855,
            0.9957473278045654,
            0.9947044253349304,
            0.9956731200218201,
            0.995200514793396,
            0.9961409568786621,
            0.9965397715568542,
            0.9926671385765076,
            0.9920614361763,
            0.9966239929199219,
            0.9972485899925232,
            0.9949751496315002,
            0.9965526461601257,
            0.9961658120155334,
            0.9962906241416931
        ]
    },
    "2934": {
        "similarity": 0.998131513595581,
        "body": "    MOD = 10**9\n    if N == 1:\n        return (2 * (M // 2) + 1) % MOD\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        dp[i][0] = 1\n        for j in range(1, M + 1):\n            dp[i][j] = (dp[i - 1][j] + dp[i][j - 2]) % MOD if j >= 2 else dp[i - 1][j]\n    return dp[N][M]\n\nN = int(input())\nM = int(input())\nprint(count_tilings(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955546855926514,
            0.9974655508995056,
            0.9971449971199036,
            0.9976674318313599,
            0.9969074726104736,
            0.9973593354225159,
            0.9967820048332214,
            0.9976169466972351,
            0.9980981945991516,
            0.9974991679191589,
            0.9974085092544556,
            0.9975563883781433,
            0.9975833892822266,
            0.9969162344932556,
            0.998131513595581,
            0.9972509145736694,
            0.9973588585853577,
            0.9971118569374084,
            0.9975425601005554,
            0.9968880414962769
        ]
    },
    "1745": {
        "similarity": 0.9980350136756897,
        "body": "        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n        if (x, y, dx, dy, turns) in memo:\n            return memo[(x, y, dx, dy, turns)]\n        if not is_valid(x, y):\n            return 0\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            if turns <= 2 and (x == 0 or x == n - 1) != (y == 0 or y == m - 1):\n                return 1\n            else:\n                return 0\n        memo[(x, y, dx, dy, turns)] = dfs(x + dx, y + dy, dx, dy, turns)\n        if abs(dx * dy) == 0 and turns < 2:\n            for ndx, ndy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                if ndx != dx or ndy != dy:\n                    memo[(x, y, dx, dy, turns)] += dfs(x + ndx, y + ndy, ndx, ndy, turns + 1)\n        return memo[(x, y, dx, dy, turns)]\n\n    count = 0\n    memo = {}\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                    count += dfs(i + dx, j + dy, dx, dy, 0)\n    return count\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\ngrid = data[2:]\nprint(count_pipe_ways(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971986413002014,
            0.9974409341812134,
            0.9974618554115295,
            0.9958351850509644,
            0.9976483583450317,
            0.9971916079521179,
            0.996232271194458,
            0.9972227811813354,
            0.9949569702148438,
            0.9968289732933044,
            0.997707188129425,
            0.9976128339767456,
            0.9965415596961975,
            0.9974740743637085,
            0.9978134036064148,
            0.9966191053390503,
            0.9977625608444214,
            0.9980350136756897,
            0.9975457787513733,
            0.9972614645957947
        ]
    },
    "1422": {
        "similarity": 0.9962205290794373,
        "body": "    left_sum = 0\n    right_sum = 0\n    placed_weights = []\n    \n    for i in range(m):\n        if i % 2 == 0:\n            for weight in range(10, 0, -1):\n                if weights[weight] > 0 and weight not in placed_weights[-2:]:\n                    left_sum += weight\n                    placed_weights.append(weight)\n                    break\n            else:\n                return \"NO\"\n        else:\n            for weight in range(1, 11):\n                if weights[weight] > 0 and weight not in placed_weights[-2:]:\n                    right_sum += weight\n                    placed_weights.append(weight)\n                    break\n            else:\n                return \"NO\"\n    \n    if left_sum == right_sum:\n        return \"NO\"\n    elif left_sum > right_sum:\n        return f\"YES\\n{' '.join(map(str, placed_weights))}\"\n    else:\n        return \"NO\"\n\n# Read input from stdin\nweights = [0] * 11\nfor i in input().strip():\n    weights[int(i)] += 1\nm = int(input())\n\n# Print the result\nprint(can_place_weights(weights, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960821270942688,
            0.9937778115272522,
            0.9957700371742249,
            0.9953097105026245,
            0.9950306415557861,
            0.9939175844192505,
            0.9947126507759094,
            0.9961451292037964,
            0.9937591552734375,
            0.9954907298088074,
            0.9950491189956665,
            0.9945722818374634,
            0.9948987364768982,
            0.9948751330375671,
            0.9962205290794373,
            0.9957147240638733,
            0.9931842684745789,
            0.9948238730430603,
            0.9956879019737244,
            0.9947434663772583
        ]
    },
    "1763": {
        "similarity": 0.9961678385734558,
        "body": "import sys\nfrom typing import List\n\n    total_bricks = sum(heights)\n    target_height = total_bricks // N\n    cost = 0\n    \n    for height in heights:\n        if height > target_height:\n            diff = height - target_height\n            cost += diff * R\n        elif height < target_height:\n            diff = target_height - height\n            cost += diff * A\n    \n    return cost\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = int(data[1])\nR = int(data[2])\nM = int(data[3])\nheights = list(map(int, data[4:]))\n\n# Calculate and print the result\nresult = min_cost_to_restore_wall(N, A, R, M, heights)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947892427444458,
            0.9922868609428406,
            0.9952611327171326,
            0.9946686625480652,
            0.9943941235542297,
            0.9950452446937561,
            0.9911574125289917,
            0.9901100993156433,
            0.9932119250297546,
            0.9928498864173889,
            0.9920883178710938,
            0.9955713152885437,
            0.9954960346221924,
            0.995184063911438,
            0.995774507522583,
            0.9952322244644165,
            0.9950870871543884,
            0.9961678385734558,
            0.9958051443099976,
            0.9937440156936646
        ]
    },
    "974": {
        "similarity": 0.9980469942092896,
        "body": "    stack = []\n    reorders = 0\n    expected_box = 1\n    \n    for command in commands:\n        if command.startswith(\"add\"):\n            _, box = map(int, command.split())\n            stack.append(box)\n            while stack and stack[-1] == expected_box:\n                stack.pop()\n                expected_box += 1\n        elif command.startswith(\"remove\"):\n            if not stack or stack[-1] != expected_box:\n                reorders += 1\n                continue\n            stack.pop()\n            expected_box += 1\n    \n    return reorders\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncommands = data[1:]\n\nprint(min_reorders(n, commands))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973827004432678,
            0.9974108338356018,
            0.9980469942092896,
            0.9963208436965942,
            0.9973949790000916,
            0.9976174235343933,
            0.9963314533233643,
            0.9979540109634399,
            0.9979033470153809,
            0.997851550579071,
            0.9977625012397766,
            0.9962742328643799,
            0.9973932504653931,
            0.9970239400863647,
            0.9979603290557861,
            0.9957087635993958,
            0.9964033365249634,
            0.9962264895439148,
            0.9965710043907166,
            0.9966172575950623
        ]
    },
    "2343": {
        "similarity": 0.9972994923591614,
        "body": "import sys\n\n    if n == 1:\n        return k == 0, 0\n    operations = 4 * (2 ** (n - 2))\n    if k < operations or k % operations != 0:\n        return False, None\n    return True, n - 2\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        possible, size = can_split(n, k)\n        if possible:\n            results.append(f\"YES {size}\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966035485267639,
            0.9968632459640503,
            0.9947678446769714,
            0.9972994923591614,
            0.9889572858810425,
            0.9962974190711975,
            0.9960262775421143,
            0.9969673156738281,
            0.9965164661407471,
            0.9966456890106201,
            0.9957917928695679,
            0.9924061298370361,
            0.997251033782959,
            0.9963905215263367,
            0.9967607259750366,
            0.9970796704292297,
            0.9951620697975159,
            0.9954405426979065,
            0.9960440397262573,
            0.997199296951294
        ]
    },
    "627": {
        "similarity": 0.9987188577651978,
        "body": "    n = len(s)\n    for i in range(n):\n        if i == 0 or s[i] < s[i - 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\n\n# Read input from stdin\nn = int(input())\ns = input()\n\n# Print the result\nprint(remove_one_char_to_minimize(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9985108971595764,
            0.9985005259513855,
            0.9985277056694031,
            0.9974467754364014,
            0.9974424242973328,
            0.9983473420143127,
            0.9987009167671204,
            0.9987188577651978,
            0.9984514117240906,
            0.9986189007759094,
            0.9964077472686768,
            0.9986608624458313,
            0.997654139995575,
            0.9985250234603882,
            0.9948503375053406,
            0.9951306581497192,
            0.9983909130096436,
            0.9984497427940369,
            0.998634934425354,
            0.9982550740242004
        ]
    },
    "1655": {
        "similarity": 0.9988413453102112,
        "body": "    alive = [True] * n\n    for i in range(n):\n        if L[i] == 0:\n            continue\n        for j in range(i - L[i], i):\n            alive[j] = False\n    return sum(alive)\n\nn = int(input())\nL = list(map(int, input().split()))\nprint(count_alive_people(n, L))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9988252520561218,
            0.9974581003189087,
            0.9982390999794006,
            0.9984496235847473,
            0.9982824921607971,
            0.9980447888374329,
            0.9977384805679321,
            0.9983986616134644,
            0.9988252520561218,
            0.9986271262168884,
            0.9988135099411011,
            0.9988413453102112,
            0.9986279010772705,
            0.9985232949256897,
            0.9986889362335205,
            0.9985552430152893,
            0.9975173473358154,
            0.9984155893325806,
            0.9983147382736206,
            0.9983507394790649
        ]
    },
    "2124": {
        "similarity": 0.9979590177536011,
        "body": "import sys\n\n    for _ in range(t):\n        n = int(input())\n        users = input().split()\n        m = int(input())\n        messages = []\n        \n        for _ in range(m):\n            line = input()\n            if line.startswith(':'):\n                username, text = line[1:].split(':', 1)\n                messages.append((username, text.strip()))\n            else:\n                messages.append(('?', line.strip()))\n        \n        stack = []\n        result = []\n        \n            for word in message.split():\n                if sender == word or any(c.isalpha() and c.lower() == sender for c in word):\n                    return False\n            return True\n        \n        for username, text in messages:\n            if username != '?':\n                stack.append(username)\n                result.append(f\"{username}:{text}\")\n            else:\n                while stack and not can_send(stack[-1], text):\n                    stack.pop()\n                if not stack:\n                    print(\"Impossible\")\n                    break\n                result.append(f\"{stack[-1]}:{text}\")\n        else:\n            for _ in range(len(messages) - len(result)):\n                result.append(f\"{stack[-1]}:\")\n        \n        for line in result:\n            print(line)\n\nif __name__ == \"__main__\":\n    t = int(input())\n    recover_senders(t)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973368644714355,
            0.9974153637886047,
            0.9974714517593384,
            0.9973809123039246,
            0.9979590177536011,
            0.9975510835647583,
            0.9978148937225342,
            0.9972507953643799,
            0.9956979155540466,
            0.9973706603050232,
            0.9973945617675781,
            0.9977403283119202,
            0.9973654747009277,
            0.9973286986351013,
            0.997364342212677,
            0.9971657991409302,
            0.9964942932128906,
            0.9974279999732971,
            0.997705340385437,
            0.9972900748252869
        ]
    },
    "1093": {
        "similarity": 0.9976462125778198,
        "body": "    grid = [list(input()) for _ in range(n)]\n    \n    max_ascent = 0\n    max_descent = 0\n    \n    prev_height = n - 1\n    \n    for col in range(m):\n        current_height = None\n        for row in range(n):\n            if grid[row][col] == '*':\n                current_height = n - 1 - row\n                break\n        \n        if current_height is not None:\n            max_ascent = max(max_ascent, prev_height - current_height)\n            max_descent = max(max_descent, current_height - prev_height)\n            prev_height = current_height\n    \n    print(max_ascent, max_descent)\n\n# Read input and call the function\nn, m = map(int, input().split())\nfind_max_ascent_descent(n, m)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973260760307312,
            0.997429609298706,
            0.9974182844161987,
            0.9970594644546509,
            0.9974882006645203,
            0.9960477948188782,
            0.9975975751876831,
            0.9971604943275452,
            0.9972153902053833,
            0.9957880973815918,
            0.9969915151596069,
            0.9963990449905396,
            0.9955883026123047,
            0.9973698854446411,
            0.9969061017036438,
            0.9963480234146118,
            0.9949905276298523,
            0.9963838458061218,
            0.9976462125778198,
            0.996965229511261
        ]
    },
    "899": {
        "similarity": 0.9983742237091064,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heappush(pq, (distance, v))\n    \n    return dist\n\n    graph = [[] for _ in range(n)]\n    for a, b, c in edges:\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n    \n    total_edges = 0\n    non_shortest_path_edges = 0\n    \n    for i in range(n):\n        dist = dijkstra(graph, i)\n        for j in range(i+1, n):\n            if dist[j] != float('inf'):\n                total_edges += 1\n                non_shortest_path_edges += any(dist[u] + dist[v] == dist[j] and (u, v) not in edges and (v, u) not in edges for u in range(n) for v in range(u+1, n))\n    \n    return non_shortest_path_edges\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[3*i + 2]) - 1, int(data[3*i + 3]) - 1, int(data[3*i + 4])) for i in range(m)]\n    \n    result = count_non_shortest_path_edges(n, edges)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975981712341309,
            0.9973184466362,
            0.9976420998573303,
            0.9983119964599609,
            0.9980067014694214,
            0.9982734322547913,
            0.9981790781021118,
            0.9976732134819031,
            0.997920572757721,
            0.9983375072479248,
            0.9979262351989746,
            0.9979230761528015,
            0.9973222017288208,
            0.9978760480880737,
            0.9980061054229736,
            0.9982795715332031,
            0.9981920123100281,
            0.9983742237091064,
            0.9979051351547241,
            0.9976851940155029
        ]
    },
    "551": {
        "similarity": 0.9979316592216492,
        "body": "    if n == 3:\n        return \"Yes\"\n    \n    y.sort()\n    \n    for i in range(1, n-1):\n        if y[i] - y[0] == y[n-1] - y[i]:\n            return \"Yes\"\n    \n    return \"No\"\n\n# Read input\nn = int(input())\ny = list(map(int, input().split()))\n\n# Output result\nprint(can_draw_lines(n, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979167580604553,
            0.9971329569816589,
            0.9976927042007446,
            0.9978715777397156,
            0.9943315386772156,
            0.9976077079772949,
            0.9972833395004272,
            0.9939349293708801,
            0.9972735047340393,
            0.995650053024292,
            0.9960039258003235,
            0.9969652891159058,
            0.9974384307861328,
            0.9972500205039978,
            0.9979316592216492,
            0.9971837401390076,
            0.9962360858917236,
            0.9961365461349487,
            0.9955121278762817,
            0.997239887714386
        ]
    },
    "1772": {
        "similarity": 0.9970685243606567,
        "body": "    odd_count = sum(1 for f in bouquets if f % 2 != 0)\n    return min(odd_count, n - odd_count)\n\n# Read input from stdin\nn = int(input())\nbouquets = list(map(int, input().split()))\n\n# Print the result\nprint(max_large_bouquets(n, bouquets))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996630847454071,
            0.9951374530792236,
            0.9968371391296387,
            0.9952524304389954,
            0.9967554211616516,
            0.9967741966247559,
            0.9963007569313049,
            0.996252179145813,
            0.9970685243606567,
            0.9948649406433105,
            0.9946988821029663,
            0.9968969225883484,
            0.9970380067825317,
            0.9964809417724609,
            0.993066668510437,
            0.9954440593719482,
            0.9956377744674683,
            0.9964103698730469,
            0.9949113726615906,
            0.9946162700653076
        ]
    },
    "1339": {
        "similarity": 0.9973295331001282,
        "body": "    left_max = -1\n    right_min = float('inf')\n    index = -1\n    \n    for i in range(n):\n        l, r = segments[i]\n        if l > left_max:\n            left_max = l\n            index = i + 1\n        if r < right_min:\n            right_min = r\n    \n    return index if left_max <= right_min else -1\n\nn = int(input())\nsegments = [tuple(map(int, input().split())) for _ in range(n)]\nprint(find_covering_segment(n, segments))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973295331001282,
            0.9964119791984558,
            0.9956967234611511,
            0.9950543642044067,
            0.9954103231430054,
            0.9941887259483337,
            0.9950076937675476,
            0.9967615008354187,
            0.9966300129890442,
            0.9969558715820312,
            0.9968085289001465,
            0.9961260557174683,
            0.9956938028335571,
            0.9952302575111389,
            0.9963746666908264,
            0.9967535138130188,
            0.9957283735275269,
            0.9966932535171509,
            0.9963692426681519,
            0.9953412413597107
        ]
    },
    "440": {
        "similarity": 0.9979501366615295,
        "body": "    n = int(input())\n    s = input()\n    vowels = \"aeiouy\"\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            if i > 0 and s[i - 1] in vowels:\n                s = s[:i] + s[i + 1:]\n                i -= 1\n            else:\n                s = s[:i + 1] + s[i + 2:]\n        else:\n            i += 1\n    print(s)\n\ncorrect_word()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997062087059021,
            0.9975867867469788,
            0.9971653819084167,
            0.9954213500022888,
            0.9971957802772522,
            0.9970183372497559,
            0.9956488609313965,
            0.9971503019332886,
            0.9977838397026062,
            0.9975711703300476,
            0.9968255758285522,
            0.9977936148643494,
            0.9971070885658264,
            0.9975217580795288,
            0.9973642230033875,
            0.9971523284912109,
            0.9976665377616882,
            0.9964507222175598,
            0.9979501366615295,
            0.9971992373466492
        ]
    },
    "2801": {
        "similarity": 0.9977210164070129,
        "body": "import sys\nfrom typing import List\n\n    graph = [[] for _ in range(n)]\n    for s, t in connections:\n        graph[s].append(t)\n    \n        if not graph[stall]:\n            return c[stall]\n        \n        total_satisfaction = 0.0\n        for next_stall in graph[stall]:\n            fraction_eaten = 1 / (2 ** (graph[stall].index(next_stall) + 1))\n            total_satisfaction += fraction_eaten * dfs(next_stall)\n        \n        return c[stall] + total_satisfaction\n    \n    max_sat = 0.0\n    for i in range(n):\n        max_sat = max(max_sat, dfs(i))\n    \n    return max_sat\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    c = list(map(int, data[2:2+n]))\n    connections = [list(map(int, data[2+n+2*i:2+n+2*(i+1)])) for i in range(m)]\n    \n    result = max_satisfaction(n, m, c, connections)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975333213806152,
            0.9977210164070129,
            0.9970957040786743,
            0.9968167543411255,
            0.9973655343055725,
            0.997259259223938,
            0.9971417784690857,
            0.996063768863678,
            0.9964216351509094,
            0.9976354837417603,
            0.997349202632904,
            0.9966633319854736,
            0.9971429705619812,
            0.9970152974128723,
            0.9884265065193176,
            0.9974026083946228,
            0.9973766803741455,
            0.9968597292900085,
            0.997350811958313,
            0.9973230957984924
        ]
    },
    "2749": {
        "similarity": 0.9976032972335815,
        "body": "import sys\n\n    grid = [[0] * W for _ in range(H)]\n    colors = list(range(1, N + 1))\n    index = 0\n    \n        return 0 <= x < H and 0 <= y < W and grid[x][y] == 0\n    \n        grid[x][y] = color\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                dfs(nx, ny, color)\n    \n    for i in range(N):\n        count = a[i]\n        while count > 0:\n            found = False\n            for x in range(H):\n                for y in range(W):\n                    if grid[x][y] == 0:\n                        dfs(x, y, colors[i])\n                        found = True\n                        break\n                if found:\n                    break\n            count -= W\n    \n    for row in grid:\n        print(' '.join(map(str, row)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976032972335815,
            0.9972724914550781,
            0.9971815347671509,
            0.9971938133239746,
            0.9969271421432495,
            0.9953787922859192,
            0.9970873594284058,
            0.9948928356170654,
            0.9948326945304871,
            0.9974576234817505,
            0.9975919127464294,
            0.9963778257369995,
            0.9968276023864746,
            0.9961095452308655,
            0.9971067309379578,
            0.9964123964309692,
            0.9971847534179688,
            0.996343195438385,
            0.992354154586792,
            0.9968131184577942
        ]
    },
    "2319": {
        "similarity": 0.9986813068389893,
        "body": "    n = len(s)\n    if s == t:\n        return 0\n    for i in range(n):\n        rotated_s = s[-i:] + s[:-i]\n        if rotated_s == t:\n            return 1\n    return -1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        t = data[index + 2]\n        index += 3\n        \n        result = min_rotations(s, t)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949393272399902,
            0.9986050128936768,
            0.9985913038253784,
            0.9983044862747192,
            0.9981516003608704,
            0.9968169331550598,
            0.9985613822937012,
            0.9984817504882812,
            0.9984241127967834,
            0.9983492493629456,
            0.9979563355445862,
            0.9983259439468384,
            0.9968791604042053,
            0.9986036419868469,
            0.9981993436813354,
            0.9986813068389893,
            0.9970491528511047,
            0.9975989460945129,
            0.9977149963378906,
            0.9980153441429138
        ]
    },
    "2121": {
        "similarity": 0.9970871806144714,
        "body": "import sys\nfrom collections import defaultdict\n\n        nonlocal max_grade\n        if current_k == 0:\n            return min(times[node], float('inf'))\n        max_grade = min(max_grade, times[node])\n        for neighbor in sorted(edges[node] - {parent}):\n            current_k -= 1\n            current_k = dfs(neighbor, node, current_k)\n            if current_k < 0:\n                break\n        return current_k\n\n    edges = defaultdict(set)\n    for u, v in edges:\n        edges[u].add(v)\n        edges[v].add(u)\n\n    max_grade = float('inf')\n    for root in range(n):\n        dfs(root, -1, k)\n    \n    print(max_grade)\n\n# Read input\nn, k = map(int, input().split())\ntimes = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(n-1)]\n\nmax_grade(n, k, times, edges)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964954257011414,
            0.9967068433761597,
            0.9889834523200989,
            0.9964760541915894,
            0.9960213899612427,
            0.9959067106246948,
            0.9951972961425781,
            0.9968807697296143,
            0.9955331683158875,
            0.9970871806144714,
            0.996856689453125,
            0.9969783425331116,
            0.9962303638458252,
            0.9951112866401672,
            0.9965617656707764,
            0.9967024922370911,
            0.9964997172355652,
            0.9962087869644165,
            0.9966882467269897,
            0.9949085712432861
        ]
    },
    "2617": {
        "similarity": 0.9980394244194031,
        "body": "import sys\n\n    if n < 2:\n        return -1\n    \n    nights = 0\n    splits = []\n    \n    while n > 0:\n        if n & 1:\n            splits.append(1)\n            n += 1\n        else:\n            splits.append(0)\n        \n        n //= 2\n        nights += 1\n    \n    return nights, splits[:-1][::-1]\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        result = min_nights_and_splits(n)\n        if result == -1:\n            results.append(-1)\n        else:\n            nights, splits = result\n            results.append(nights)\n            results.extend(splits)\n    \n    for r in results:\n        print(r)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976894855499268,
            0.9979020357131958,
            0.9975804686546326,
            0.9979981184005737,
            0.9976087808609009,
            0.997702956199646,
            0.9978834390640259,
            0.9976356029510498,
            0.9979408979415894,
            0.9972953796386719,
            0.9961511492729187,
            0.9979940056800842,
            0.9977411031723022,
            0.9958779215812683,
            0.9975515604019165,
            0.9959760904312134,
            0.9962393045425415,
            0.9980394244194031,
            0.9975276589393616,
            0.997336745262146
        ]
    },
    "175": {
        "similarity": 0.9979825615882874,
        "body": "    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\n# Read input\na, b = map(int, input().split())\n\n# Process the variables\nresult_a, result_b = process(a, b)\n\n# Print the result\nprint(result_a, result_b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975688457489014,
            0.9974604249000549,
            0.9975695610046387,
            0.9964513182640076,
            0.9975112080574036,
            0.9943845868110657,
            0.9977507591247559,
            0.9972343444824219,
            0.997222900390625,
            0.9962748289108276,
            0.997222900390625,
            0.9979825615882874,
            0.9979183673858643,
            0.9977277517318726,
            0.9968382120132446,
            0.9971370697021484,
            0.9978209137916565,
            0.9972325563430786,
            0.997663676738739,
            0.9971566796302795
        ]
    },
    "995": {
        "similarity": 0.9969393014907837,
        "body": "import sys\n\n    n = len(A)\n    results = [0] * (n + 1)\n\n    for k in range(1, n + 1):\n        count = 0\n        for i in range(n - k + 1):\n            product = 1\n            valid = True\n            for j in range(i, i + k):\n                if A[j] < 0:\n                    if product & (A[j] & -A[j]):\n                        product &= A[j]\n                    else:\n                        valid = False\n                        break\n                else:\n                    product *= A[j]\n            if valid and (product == 1 or product**0.5 == int(product**0.5)):\n                count += 1\n        results[k] = count\n\n    return results[1:]\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    result = min_groups(A)\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955589175224304,
            0.9955687522888184,
            0.9953287839889526,
            0.9959346652030945,
            0.9953553080558777,
            0.9944444298744202,
            0.996445894241333,
            0.996121346950531,
            0.9953615069389343,
            0.994797945022583,
            0.9962472319602966,
            0.993014395236969,
            0.9958478212356567,
            0.9948708415031433,
            0.9960859417915344,
            0.9963139891624451,
            0.9964178204536438,
            0.994431734085083,
            0.994687557220459,
            0.9969393014907837
        ]
    },
    "582": {
        "similarity": 0.9974485635757446,
        "body": "    freq = [0] * n\n    for ai in a:\n        freq[ai % n] += 1\n\n    max_freq = max(freq)\n    total_time = 0\n\n    for i in range(n):\n        if freq[i] == max_freq:\n            target = max_freq - (i + 1)\n            if target > 0:\n                total_time += target * t[i]\n\n    return total_time\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:n+1]))\nt = list(map(int, data[n+1:2*n+1]))\n\nprint(min_time_to_balance_categories(n, a, t))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964597821235657,
            0.9969472289085388,
            0.9968594908714294,
            0.9953205585479736,
            0.9948784708976746,
            0.9971074461936951,
            0.9964982867240906,
            0.9972666501998901,
            0.9960989952087402,
            0.9974485635757446,
            0.9962937235832214,
            0.9968127012252808,
            0.9964128136634827,
            0.9972959756851196,
            0.9973182678222656,
            0.9963598847389221,
            0.9959707856178284,
            0.9970679879188538,
            0.9969201683998108,
            0.996433436870575
        ]
    },
    "1402": {
        "similarity": 0.996207594871521,
        "body": "MOD = 1000000007\n\n    if s == t:\n        return 1\n    \n    ways = 1\n    for i in range(n):\n        if s[i] != '?' and t[i] != '?':\n            if int(s[i]) > int(t[i]):\n                return 0\n        elif s[i] != '?' and t[i] == '?':\n            ways *= max(0, 9 - int(s[i]))\n        elif s[i] == '?' and t[i] != '?':\n            ways *= max(0, int(t[i]) - 1)\n        else:\n            ways *= 81\n    \n    return ways % MOD\n\n# Read input\nn = int(input())\ns = input().strip()\nt = input().strip()\n\n# Calculate and print result\nprint(count_ways(n, s, t))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996207594871521,
            0.9955230355262756,
            0.9956085681915283,
            0.9954673647880554,
            0.9951100945472717,
            0.9956737160682678,
            0.9961339235305786,
            0.9928262829780579,
            0.9950175285339355,
            0.9951555132865906,
            0.9956074953079224,
            0.9957036375999451,
            0.9954193830490112,
            0.9950419068336487,
            0.991177499294281,
            0.9957335591316223,
            0.994727611541748,
            0.9942672252655029,
            0.9958195090293884,
            0.9947822093963623
        ]
    },
    "1141": {
        "similarity": 0.9983115196228027,
        "body": "    for l, r, c1, c2 in operations:\n        s = s[:l-1] + s[l-1:r].replace(c1, c2) + s[r:]\n    return s\n\n# Read input\nn, m = map(int, input().split())\ns = input()\noperations = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(transform_string(n, m, s, operations))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9914213418960571,
            0.9958314299583435,
            0.9979313611984253,
            0.9922470450401306,
            0.9979366660118103,
            0.9983022809028625,
            0.9975939393043518,
            0.9979151487350464,
            0.9982914328575134,
            0.9980882406234741,
            0.9973050355911255,
            0.9983115196228027,
            0.9970946907997131,
            0.9983115196228027,
            0.9978659749031067,
            0.9982802867889404,
            0.9981811046600342,
            0.9978019595146179,
            0.9982212781906128,
            0.9983057975769043
        ]
    },
    "2836": {
        "similarity": 0.998254656791687,
        "body": "    max_distance = -1\n    best_name = None\n    \n    for X in range(A, B + 1):\n        if X % 2 != 0:\n            min_distance = min(abs(X - P) for P in boys)\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_name = X\n                \n    return best_name\n\n# Read input\nN = int(input())\nboys = list(map(int, input().split()))\nA, B = map(int, input().split())\n\n# Find and print the girl's name\nprint(find_girls_name(N, boys, A, B))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980986714363098,
            0.9978898763656616,
            0.9968518018722534,
            0.9969140291213989,
            0.9972313642501831,
            0.9974938631057739,
            0.9977126121520996,
            0.9969038963317871,
            0.997222900390625,
            0.9974192380905151,
            0.995123028755188,
            0.9976875185966492,
            0.9981051087379456,
            0.9966261982917786,
            0.9964019656181335,
            0.998254656791687,
            0.9977842569351196,
            0.9978785514831543,
            0.9973276853561401,
            0.9962683320045471
        ]
    },
    "1109": {
        "similarity": 0.997297465801239,
        "body": "    a = list(map(int, input().split()))\n    period = a[:k]\n    changes = 0\n    \n    for i in range(k, n, k):\n        if a[i:i+k] != period:\n            changes += sum(1 for x, y in zip(a[i:i+k], period) if x != y)\n    \n    return changes\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    print(min_changes_to_k_periodic(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965535998344421,
            0.9962611794471741,
            0.9969754815101624,
            0.9965804219245911,
            0.99673992395401,
            0.9965482354164124,
            0.9955123066902161,
            0.9943941235542297,
            0.9953296184539795,
            0.9942156076431274,
            0.9971296191215515,
            0.995758056640625,
            0.996467113494873,
            0.996131420135498,
            0.99627685546875,
            0.997297465801239,
            0.9905124306678772,
            0.9965744018554688,
            0.9953719973564148,
            0.995606005191803
        ]
    },
    "2125": {
        "similarity": 0.9978207349777222,
        "body": "    flags = 0\n    for i in range(n - 2):\n        for j in range(m):\n            if grid[i][j] == grid[i + 1][j] == grid[i + 2][j]:\n                continue\n            for k in range(j + 1, m):\n                if grid[i][k] == grid[i + 1][k] == grid[i + 2][k] and grid[i][k] != grid[i][j]:\n                    flags += 1\n    return flags\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(count_flags(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965080618858337,
            0.9976766705513,
            0.9978207349777222,
            0.9961726665496826,
            0.9972265362739563,
            0.9949589967727661,
            0.9972037076950073,
            0.9964067339897156,
            0.9959744811058044,
            0.9968852996826172,
            0.9967195391654968,
            0.9970152974128723,
            0.9976288676261902,
            0.9967741966247559,
            0.9970762133598328,
            0.9961152672767639,
            0.9972420930862427,
            0.9974114298820496,
            0.9950445294380188,
            0.9977672100067139
        ]
    },
    "1746": {
        "similarity": 0.9971859455108643,
        "body": "    children = [[] for _ in range(n + 1)]\n    leaf_count = [0] * (n + 1)\n    \n    for i in range(1, n):\n        parent = parents[i - 1]\n        children[parent].append(i + 1)\n    \n        if not children[node]:\n            return 1\n        count = 0\n        for child in children[node]:\n            count += count_leaves(child)\n        leaf_count[node] = count\n        return count\n    \n    count_leaves(1)\n    \n    for i in range(2, n + 1):\n        if not children[i] and leaf_count[i] < 3:\n            return \"No\"\n    \n    return \"Yes\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nparents = list(map(int, data[1:]))\n\nprint(is_spruce(n, parents))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965214133262634,
            0.994138240814209,
            0.9962642192840576,
            0.9968559145927429,
            0.9892921447753906,
            0.9966288208961487,
            0.9970072507858276,
            0.9952743053436279,
            0.9962969422340393,
            0.9955366253852844,
            0.99704509973526,
            0.9967767596244812,
            0.9959003329277039,
            0.9971859455108643,
            0.9968124032020569,
            0.9966703057289124,
            0.9970420002937317,
            0.9960643649101257,
            0.9955403208732605,
            0.994785726070404
        ]
    },
    "1294": {
        "similarity": 0.9973856210708618,
        "body": "    n = len(s)\n    working_buttons = set()\n    for i in range(n):\n        if s[i] not in working_buttons:\n            if i + 1 < n and s[i+1] == s[i]:\n                working_buttons.add(s[i])\n            else:\n                return \"\"\n    return ''.join(sorted(working_buttons))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    results = []\n    index = 1\n    for _ in range(t):\n        s = data[index]\n        result = find_working_buttons(s)\n        results.append(result)\n        index += 1\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968695640563965,
            0.997298002243042,
            0.996468186378479,
            0.9947861433029175,
            0.9964976906776428,
            0.9956780672073364,
            0.9961170554161072,
            0.9967971444129944,
            0.9967542886734009,
            0.9970102906227112,
            0.9973856210708618,
            0.9971433281898499,
            0.9965440630912781,
            0.9964842796325684,
            0.9970365762710571,
            0.9962763786315918,
            0.9963672161102295,
            0.9959465861320496,
            0.9955231547355652,
            0.9938414692878723
        ]
    },
    "1159": {
        "similarity": 0.9981833100318909,
        "body": "import sys\nfrom itertools import combinations\n\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n    max_edges = n * (n - 1) // 2\n    primes = [i for i in range(2, max_edges + 1) if is_prime(i)]\n    \n    for m in primes:\n        edges = []\n        vertices = set(range(1, n + 1))\n        \n        for u, v in combinations(vertices, 2):\n            if len(edges) == m:\n                break\n            if (u, v) not in edges and (v, u) not in edges:\n                degree_u = len([e for e in edges if e[0] == u or e[1] == u])\n                degree_v = len([e for e in edges if e[0] == v or e[1] == v])\n                if is_prime(degree_u + 1) and is_prime(degree_v + 1):\n                    edges.append((u, v))\n        \n        if len(edges) == m:\n            return m, edges\n    \n    return -1\n\n    n = int(input().strip())\n    result = find_prime_edges(n)\n    \n    if result == -1:\n        print(-1)\n    else:\n        m, edges = result\n        print(m)\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997715175151825,
            0.9976216554641724,
            0.9977852702140808,
            0.9967281818389893,
            0.9979567527770996,
            0.9973930716514587,
            0.9974284768104553,
            0.9975829124450684,
            0.9964608550071716,
            0.9976192116737366,
            0.997175931930542,
            0.9981833100318909,
            0.9972593188285828,
            0.9977344870567322,
            0.9979528188705444,
            0.9974382519721985,
            0.9975895285606384,
            0.9972823262214661,
            0.9972662925720215,
            0.9976797699928284
        ]
    },
    "2025": {
        "similarity": 0.9982226490974426,
        "body": "    if n < 4:\n        return -1\n    count = 0\n    while n >= 4:\n        if n % 2 == 0:\n            n -= 2\n        else:\n            n -= 3\n        count += 1\n    return count\n\nq = int(input())\nresults = []\nfor _ in range(q):\n    n = int(input())\n    results.append(max_composite_summands(n))\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.997898519039154,
            0.9929436445236206,
            0.9979220032691956,
            0.9978609681129456,
            0.9979764223098755,
            0.9979507327079773,
            0.9973351359367371,
            0.9979521036148071,
            0.9967660307884216,
            0.9982226490974426,
            0.9978663921356201,
            0.9982060194015503,
            0.9973577260971069,
            0.9978432059288025,
            0.9976692199707031,
            0.9976979494094849,
            0.9963607788085938,
            0.9972253441810608,
            0.9980049133300781,
            0.9979220032691956
        ]
    },
    "1429": {
        "similarity": 0.9978920817375183,
        "body": "import sys\nfrom collections import Counter\n\n        return sorted(T1) == sorted(T2)\n\n    count = 0\n    for start in range(N):\n        seen = set()\n        for end in range(start, N):\n            substring = S[start:end+1]\n            if (substring, substring[::-1]) not in seen:\n                complement = ''.join('T' if char == 'A' else 'A' if char == 'T' else 'G' if char == 'C' else 'C' for char in substring)\n                if is_complement(substring, complement):\n                    count += 1\n                    seen.add((substring, substring[::-1]))\n    return count\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    print(count_complementary_substrings(N, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973649382591248,
            0.9952643513679504,
            0.9974652528762817,
            0.9959125518798828,
            0.99700927734375,
            0.9971269369125366,
            0.9978920817375183,
            0.9968273639678955,
            0.9968842267990112,
            0.9971750974655151,
            0.9976338148117065,
            0.9970587491989136,
            0.9966709613800049,
            0.9963393807411194,
            0.9971065521240234,
            0.9967244863510132,
            0.9977975487709045,
            0.9976302981376648,
            0.9971004128456116,
            0.9972896575927734
        ]
    },
    "1950": {
        "similarity": 0.9954769015312195,
        "body": "import sys\n\n    a.sort()\n    return sum(a)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(min_penalty(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930850863456726,
            0.988889217376709,
            0.9949823617935181,
            0.9898228049278259,
            0.9911927580833435,
            0.9851559996604919,
            0.9937049746513367,
            0.995341956615448,
            0.9954769015312195,
            0.9936091899871826,
            0.9945834279060364,
            0.9947202801704407,
            0.9936091899871826,
            0.9951037168502808,
            0.9947989583015442,
            0.9946378469467163,
            0.9937049746513367,
            0.9945724010467529,
            0.9915874004364014,
            0.9939619302749634
        ]
    },
    "631": {
        "similarity": 0.9981328248977661,
        "body": "import sys\n\n    n = len(a)\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += a[j] / (j + 1)\n        if current_sum == m:\n            return True\n    return False\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        if can_reorder_to_sum(a, m):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964975118637085,
            0.9977816343307495,
            0.9967940449714661,
            0.997864305973053,
            0.9981162548065186,
            0.9980241656303406,
            0.9980161786079407,
            0.9945833086967468,
            0.9979854226112366,
            0.9976006746292114,
            0.9976021647453308,
            0.9972594380378723,
            0.9981328248977661,
            0.9974516034126282,
            0.9965206980705261,
            0.9974943399429321,
            0.9981080293655396,
            0.9962643980979919,
            0.9970164895057678,
            0.9964366555213928
        ]
    },
    "2480": {
        "similarity": 0.9981328845024109,
        "body": "from collections import defaultdict\n\n    remainder_count = defaultdict(int)\n    remainder_count[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(N):\n        current_sum += A[i]\n        target_remainder = (current_sum - i) % K\n        if target_remainder < 0:\n            target_remainder += K\n        count += remainder_count[target_remainder]\n        remainder_count[(current_sum + i) % K] += 1\n    \n    return count\n\n# Read input from stdin\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_subsequences(N, K, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978429079055786,
            0.9973979592323303,
            0.9978430867195129,
            0.9979510307312012,
            0.9973167777061462,
            0.9979077577590942,
            0.9970396161079407,
            0.9966070055961609,
            0.9981328845024109,
            0.9976692199707031,
            0.9978537559509277,
            0.9977299571037292,
            0.9980021119117737,
            0.9975490570068359,
            0.996234118938446,
            0.9971839785575867,
            0.9972507953643799,
            0.9963966012001038,
            0.994636058807373,
            0.9968045949935913
        ]
    },
    "2363": {
        "similarity": 0.9979344606399536,
        "body": "    results = []\n    for a, b in pairs:\n        operations = 0\n        while a > 0 and b > 0:\n            if a > b:\n                a -= b\n            elif a < b:\n                b -= a\n            else:\n                break\n            operations += 1\n        results.append(operations)\n    return results\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\nresults = count_operations(n, pairs)\nprint('\\n'.join(map(str, results)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969810843467712,
            0.997117280960083,
            0.9963851571083069,
            0.9976847767829895,
            0.9969086050987244,
            0.9977684020996094,
            0.9978324770927429,
            0.9971288442611694,
            0.9960827231407166,
            0.9975606203079224,
            0.996708333492279,
            0.9955747723579407,
            0.9964714050292969,
            0.9977142810821533,
            0.9970552325248718,
            0.9972301125526428,
            0.9965671896934509,
            0.997660219669342,
            0.9979344606399536,
            0.9967871308326721
        ]
    },
    "909": {
        "similarity": 0.999019205570221,
        "body": "a = int(input())\nb = int(input())\nc = int(input())\n\nmax_value = max(a + b * c, a * (b + c), a * b * c)\nprint(max_value)",
        "result": "failed: testcase 0",
        "similarities": [
            0.999019205570221,
            0.9978420734405518,
            0.999019205570221,
            0.999019205570221,
            0.9987384676933289,
            0.999019205570221,
            0.9989300966262817,
            0.9975485801696777,
            0.999019205570221,
            0.999019205570221,
            0.9985301494598389,
            0.999019205570221,
            0.9986592531204224,
            0.9978420734405518,
            0.9975485801696777,
            0.9943018555641174,
            0.999019205570221,
            0.9978420734405518,
            0.999019205570221,
            0.9986807107925415
        ]
    },
    "154": {
        "similarity": 0.9971033334732056,
        "body": "MOD = 998244353\n\n    if n % 2 == 0:\n        return 0\n    if n == 1:\n        return 1\n    \n    # Initialize DP tables\n    dp_odd = [0] * (n + 1)\n    dp_even = [0] * (n + 1)\n    dp_odd[1] = 1\n    dp_even[0] = 1\n    \n    for i in range(3, n + 1):\n        if i % 2 == 1:\n            dp_odd[i] = (dp_odd[i - 2] + dp_even[i - 1]) * i // 2 % MOD\n        else:\n            dp_even[i] = (dp_even[i - 2] + dp_odd[i - 1]) * i // 2 % MOD\n    \n    return dp_odd[n]\n\n# Read input\nn = int(input().strip())\n\n# Output result\nprint(count_balanced_striped_trees(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965718984603882,
            0.9966503977775574,
            0.9954391121864319,
            0.9945090413093567,
            0.9964132905006409,
            0.9963600039482117,
            0.9909775257110596,
            0.9963086843490601,
            0.9971033334732056,
            0.9962278604507446,
            0.9944757223129272,
            0.9966691732406616,
            0.9965537190437317,
            0.99350506067276,
            0.996795654296875,
            0.9970053434371948,
            0.9960286021232605,
            0.9928992390632629,
            0.9957728981971741,
            0.9935182332992554
        ]
    },
    "39": {
        "similarity": 0.9979370832443237,
        "body": "    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring != substring[::-1] and len(substring) > max_length:\n                max_length = len(substring)\n    \n    return max_length\n\n# Read input from stdin\ns = input().strip()\n\n# Print the result\nprint(longest_non_palindrome_substring(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996194064617157,
            0.997389554977417,
            0.9971132874488831,
            0.9979265332221985,
            0.997165858745575,
            0.9971571564674377,
            0.9975863099098206,
            0.9979370832443237,
            0.9963744282722473,
            0.9975368976593018,
            0.9961914420127869,
            0.9957717061042786,
            0.9978077411651611,
            0.9976513385772705,
            0.9957715272903442,
            0.9962491393089294,
            0.9976451396942139,
            0.9969877004623413,
            0.9956461191177368,
            0.9977712035179138
        ]
    },
    "1885": {
        "similarity": 0.9946199059486389,
        "body": "import math\n\n    total = 0\n    for i in range(5, 8):\n        total += math.comb(n, i)\n    return total\n\n# Read input from stdin\nn = int(input().strip())\n\n# Print the result\nprint(count_group_variants(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938276410102844,
            0.9936060905456543,
            0.994559645652771,
            0.9882325530052185,
            0.9926791191101074,
            0.9906805157661438,
            0.9894381165504456,
            0.9946199059486389,
            0.9876219034194946,
            0.9912844300270081,
            0.9943161010742188,
            0.9898426532745361,
            0.9934877157211304,
            0.9945558309555054,
            0.9923049807548523,
            0.9917524456977844,
            0.9943161010742188,
            0.9925302267074585,
            0.9899569153785706,
            0.9929147362709045
        ]
    },
    "1180": {
        "similarity": 0.9976674318313599,
        "body": "    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][0] = int(s[:i].lstrip('0') or '1')\n        \n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            total_sum = 0\n            current_number = ''\n            for l in range(i - 1, -1, -1):\n                current_number = s[l] + current_number\n                if len(current_number) > 1 and current_number[0] == '0':\n                    break\n                dp[i][j] += (total_sum + int(current_number)) * dp[l][j - 1]\n                dp[i][j] %= MOD\n                total_sum += int(current_number)\n    \n    return dp[n][k]\n\n# Read input\nn, k = map(int, input().split())\ns = input().strip()\n\n# Print result\nprint(sum_of_arithmetic_expressions(n, k, s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973934888839722,
            0.9937781095504761,
            0.9969744682312012,
            0.9952985048294067,
            0.9965416789054871,
            0.9945232272148132,
            0.9972437620162964,
            0.9970625042915344,
            0.9976620078086853,
            0.9976198077201843,
            0.9962497353553772,
            0.9976674318313599,
            0.9946272969245911,
            0.9970212578773499,
            0.9975274801254272,
            0.9972485899925232,
            0.9947933554649353,
            0.997023344039917,
            0.9970287680625916,
            0.9975150227546692
        ]
    },
    "1856": {
        "similarity": 0.9957923889160156,
        "body": "from collections import defaultdict\n\n    equivalences = set()\n    for password in passwords:\n        chars = set(password)\n        new_equivalences = set()\n        for eq in equivalences:\n            if any(char in eq for char in chars):\n                new_equivalences.add(eq)\n        new_equivalences.update(chars)\n        equivalences |= new_equivalences\n    return len(equivalences)\n\n# Read input from stdin\nn = int(input())\npasswords = [input().strip() for _ in range(n)]\n\n# Calculate the result\nresult = min_passwords(n, passwords)\n\n# Print the result\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9929335713386536,
            0.9924778342247009,
            0.9933624267578125,
            0.9955008625984192,
            0.9951249957084656,
            0.985874593257904,
            0.9922502636909485,
            0.9941504597663879,
            0.9956265687942505,
            0.9952361583709717,
            0.9934812784194946,
            0.9957923889160156,
            0.9939886331558228,
            0.9931702017784119,
            0.9938254356384277,
            0.9948240518569946,
            0.994465708732605,
            0.9944889545440674,
            0.9906681776046753,
            0.9935207366943359
        ]
    },
    "522": {
        "similarity": 0.9968883395195007,
        "body": "    MOD = 10**9 + 7\n    if n == 4:\n        return (c**2 * f1 * f2 * f3) % MOD\n    elif n == 5:\n        return (c**2 * f1 * f2 * f3 * (c**2 * f1 * f2 * f3)) % MOD\n    \n    # Initialize base cases\n    a, b, c = f1, f2, f3\n    \n    for _ in range(4, n):\n        next_val = (c**2 * a * b * c) % MOD\n        a, b, c = b, c, next_val\n    \n    return c\n\n# Read input from stdin\nn, f1, f2, f3, c = map(int, input().split())\n\n# Print the result\nprint(fibonacci_mod(n, f1, f2, f3, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957594871520996,
            0.996479868888855,
            0.996657133102417,
            0.9968883395195007,
            0.9961267113685608,
            0.9963492155075073,
            0.9955929517745972,
            0.9857956767082214,
            0.995799720287323,
            0.9959866404533386,
            0.9962535500526428,
            0.9952793121337891,
            0.9951927065849304,
            0.9946116209030151,
            0.9958243370056152,
            0.9955055117607117,
            0.9923902153968811,
            0.9956902861595154,
            0.9948694109916687,
            0.9959696531295776
        ]
    },
    "1719": {
        "similarity": 0.9950894713401794,
        "body": "import sys\n\nMOD = 10**9 + 7\n\n    if N == 3:\n        return 61\n    \n    dp = [[[0] * 4 for _ in range(4)] for _ in range(4)]\n    dp[0][0][0] = 1\n    \n    for n in range(1, N):\n        ndp = [[[0] * 4 for _ in range(4)] for _ in range(4)]\n        for a in range(4):\n            for b in range(4):\n                for c in range(4):\n                    if (a != 2 or b != 1 or c != 2) and (b != 2 or a != 1 or c != 2):\n                        ndp[a][b][c] = dp[(a+3)%4][(b+3)%4][(c+3)%4]\n        dp = ndp\n    \n    result = sum(dp[i][j][k] for i in range(4) for j in range(4) for k in range(4)) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    print(count_valid_strings(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941131472587585,
            0.9932142496109009,
            0.9947229623794556,
            0.9933270812034607,
            0.9925195574760437,
            0.9919572472572327,
            0.9931779503822327,
            0.9913233518600464,
            0.9940307140350342,
            0.9946671724319458,
            0.9946724772453308,
            0.9913954734802246,
            0.9935289025306702,
            0.9944890737533569,
            0.9927346110343933,
            0.993935763835907,
            0.9920793175697327,
            0.9950894713401794,
            0.994629442691803,
            0.9933850169181824
        ]
    },
    "1842": {
        "similarity": 0.9970285296440125,
        "body": "import sys\n\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + discriminant**0.5) / (2*a)\n    root2 = (-b - discriminant**0.5) / (2*a)\n    return max(root1, root2), min(root1, root2)\n\na, b, c = map(int, input().split())\nroot_optimistic, root_pessimistic = quadratic_roots(a, b, c)\nprint(f\"{root_optimistic:.10f}\")\nprint(f\"{root_pessimistic:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953460693359375,
            0.9935455322265625,
            0.9958130717277527,
            0.9949827790260315,
            0.9958298206329346,
            0.9935455322265625,
            0.9966318011283875,
            0.9964838624000549,
            0.9965063333511353,
            0.9946210980415344,
            0.9960567951202393,
            0.9955022931098938,
            0.9949272871017456,
            0.9968698620796204,
            0.9967302083969116,
            0.9954395294189453,
            0.9946210980415344,
            0.9948979616165161,
            0.9969674944877625,
            0.9970285296440125
        ]
    },
    "806": {
        "similarity": 0.996793270111084,
        "body": "    MOD = 10**9 + 7\n    if n * l > n * r:\n        return 0\n    if (n * l) % 3 != 0 or (n * r) % 3 != 0:\n        return 0\n    count = [0] * (r - l + 1)\n    for i in range(l, r + 1):\n        count[i - l] += 1\n    dp = [[0] * 3 for _ in range(n)]\n    dp[0][count[0]] = 1\n    for i in range(1, n):\n        dp[i][0] = (dp[i-1][0] + dp[i-1][2]) % MOD\n        dp[i][1] = (dp[i-1][1] + dp[i-1][0]) % MOD\n        dp[i][2] = (dp[i-1][2] + dp[i-1][1]) % MOD\n    return dp[-1][0]\n\n# Read input from stdin\nn, l, r = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, l, r))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965833425521851,
            0.9965507388114929,
            0.9949640035629272,
            0.9940436482429504,
            0.9956770539283752,
            0.9961149096488953,
            0.9963876008987427,
            0.9966366291046143,
            0.9964355826377869,
            0.9955108165740967,
            0.9949308037757874,
            0.9961368441581726,
            0.9954679608345032,
            0.9951760172843933,
            0.9913442730903625,
            0.9949873089790344,
            0.9962131977081299,
            0.9962897896766663,
            0.9967917203903198,
            0.996793270111084
        ]
    },
    "365": {
        "similarity": 0.9982835054397583,
        "body": "    total_length = sum(a)\n    if total_length != x:\n        return \"NO\"\n    \n    segment_count = len(a)\n    if segment_count == 1 and a[0] == x:\n        return \"YES\"\n    \n    for i in range(1, segment_count):\n        if a[i-1] + a[i] <= x:\n            return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(is_unique_crossword(n, x, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979555010795593,
            0.9982147216796875,
            0.9979130625724792,
            0.9982835054397583,
            0.9978432059288025,
            0.9978402853012085,
            0.9933533072471619,
            0.9974629282951355,
            0.9978587627410889,
            0.9971609711647034,
            0.9980559349060059,
            0.9979930520057678,
            0.9978954792022705,
            0.9975194334983826,
            0.9964452385902405,
            0.9974395632743835,
            0.9974146485328674,
            0.9963971376419067,
            0.9982212781906128,
            0.9973275065422058
        ]
    },
    "1158": {
        "similarity": 0.997156023979187,
        "body": "from collections import Counter\n\n    count = Counter(utensils)\n    unique_utensils = len(count)\n    dishes_per_guest = unique_utensils // k\n    if unique_utensils % k != 0:\n        dishes_per_guest += 1\n    return n - dishes_per_guest * k\n\n# Read input from stdin\nn, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\n# Print the result\nprint(min_stolen_utensils(n, k, utensils))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955770373344421,
            0.9935660362243652,
            0.997156023979187,
            0.9965530037879944,
            0.9957526326179504,
            0.9961352944374084,
            0.9966964721679688,
            0.99664306640625,
            0.9962825775146484,
            0.9959778189659119,
            0.995635986328125,
            0.9968622922897339,
            0.9955557584762573,
            0.9961214661598206,
            0.9964204430580139,
            0.9948030114173889,
            0.996439516544342,
            0.9937001466751099,
            0.9935587644577026,
            0.9957590699195862
        ]
    },
    "33": {
        "similarity": 0.9970703125,
        "body": "    if a1 == a2:\n        if (b2 - b1) % a1 == 0 and L <= b1 + (b2 - b1) // a1 * a1 <= R:\n            return 1\n        else:\n            return 0\n    \n    common_diff = abs(a1 - a2)\n    b_offset = abs((a1 * (-b1 / a1)) % common_diff) if a1 < 0 else (a1 * (b1 / a1)) % common_diff\n    start = max(L, ((L - b_offset + common_diff - 1) // common_diff) * common_diff)\n    end = min(R, ((R - b_offset) // common_diff) * common_diff)\n    \n    if start <= end:\n        return (end - start) // common_diff + 1\n    else:\n        return 0\n\n# Read input from stdin\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950794577598572,
            0.9951647520065308,
            0.9963076710700989,
            0.9964362978935242,
            0.9959426522254944,
            0.9959898591041565,
            0.9960364103317261,
            0.9942229390144348,
            0.9964845776557922,
            0.9949291944503784,
            0.9947410225868225,
            0.9970703125,
            0.9953275918960571,
            0.9969061017036438,
            0.9958768486976624,
            0.9956892132759094,
            0.9933362603187561,
            0.9949166178703308,
            0.9966899752616882,
            0.9962112307548523
        ]
    },
    "2498": {
        "similarity": 0.9975391030311584,
        "body": "    semi_common_multiples = set()\n    \n    for a in A:\n        p = 1\n        while True:\n            x = a * (p + 0.5)\n            if x > M:\n                break\n            semi_common_multiples.add(int(x))\n            p += 1\n    \n    return len(semi_common_multiples)\n\n# Read input from stdin\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_semi_common_multiples(N, M, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963638782501221,
            0.995395839214325,
            0.9939622282981873,
            0.995834231376648,
            0.9970681071281433,
            0.9973164796829224,
            0.9965487122535706,
            0.9951560497283936,
            0.9971750974655151,
            0.997092604637146,
            0.9952515363693237,
            0.9975391030311584,
            0.996860682964325,
            0.9972993731498718,
            0.9944032430648804,
            0.9975357055664062,
            0.9963722229003906,
            0.9963685870170593,
            0.9960660338401794,
            0.996457040309906
        ]
    },
    "2309": {
        "similarity": 0.9973801970481873,
        "body": "from collections import defaultdict\nimport sys\n\n    vowels = set('aeiou')\n    return sum(1 for char in word if char in vowels)\n\n    n = len(words)\n    counts = defaultdict(list)\n    \n    # Group words by vowel count and last vowel\n    for word in words:\n        v_count = count_vowels(word)\n        last_vowel = word[-1]\n        key = (v_count, last_vowel)\n        counts[key].append(word)\n    \n    beautiful_lyrics = []\n    used_words = defaultdict(int)\n    \n    # Try to form pairs of lines\n    for words_list in counts.values():\n        if len(words_list) >= 2:\n            for i in range(len(words_list)):\n                for j in range(i + 1, len(words_list)):\n                    word1, word2 = words_list[i], words_list[j]\n                    if used_words[word1] < words.count(word1) and used_words[word2] < words.count(word2):\n                        beautiful_lyrics.append((word1, word2))\n                        used_words[word1] += 1\n                        used_words[word2] += 1\n    \n    return beautiful_lyrics\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    words = data[1:]\n    \n    lyrics = find_beautiful_lyrics(words)\n    m = len(lyrics)\n    \n    print(m)\n    for line1, line2 in lyrics:\n        print(line1, line2)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967667460441589,
            0.9972301125526428,
            0.9969237446784973,
            0.9957360029220581,
            0.9973801970481873,
            0.996820330619812,
            0.9954342246055603,
            0.9970855712890625,
            0.9966587424278259,
            0.9958223104476929,
            0.9966853260993958,
            0.9960880279541016,
            0.9949221611022949,
            0.9969226717948914,
            0.9966989755630493,
            0.9964728951454163,
            0.9967567324638367,
            0.9970170855522156,
            0.996329665184021,
            0.9962567687034607
        ]
    },
    "1326": {
        "similarity": 0.9970946907997131,
        "body": "import sys\n\n    if k == 1:\n        return 1\n    count = 2\n    for i in range(2, int(k**0.5) + 1):\n        if k % i == 0:\n            count += 2 if i != k // i else 1\n    return k * count\n\n    N = int(input())\n    result = sum(sum_k_times_f(K) for K in range(1, N + 1))\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968479871749878,
            0.9953296184539795,
            0.9958329796791077,
            0.9961477518081665,
            0.9845184683799744,
            0.9968584775924683,
            0.9967483878135681,
            0.9967918395996094,
            0.9967135190963745,
            0.996683657169342,
            0.9968486428260803,
            0.9957699179649353,
            0.9969687461853027,
            0.9969891905784607,
            0.9958201050758362,
            0.9966199994087219,
            0.9968675374984741,
            0.9949230551719666,
            0.9970946907997131,
            0.9962043762207031
        ]
    },
    "2950": {
        "similarity": 0.99774569272995,
        "body": "    charges = 0\n    for height in sorted(heights, reverse=True):\n        if height > 0:\n            charges += 1\n            height -= 1\n            while height > 0:\n                height //= 2\n                charges += 1\n    return charges\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nheights = list(map(int, data[1:]))\nprint(min_charges(n, heights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971879720687866,
            0.9964891076087952,
            0.9964525103569031,
            0.9967764019966125,
            0.9938791990280151,
            0.9957908987998962,
            0.99774569272995,
            0.9952707886695862,
            0.9972131848335266,
            0.9976325035095215,
            0.9971004128456116,
            0.9968697428703308,
            0.9969906210899353,
            0.9972020983695984,
            0.9962064027786255,
            0.9969450235366821,
            0.997261643409729,
            0.9967542886734009,
            0.9966111779212952,
            0.9964608550071716
        ]
    },
    "1983": {
        "similarity": 0.9981517791748047,
        "body": "    if not a:\n        return 0\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    t = int(data[0])\n    index = 1\n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        new_a = a + a\n        result = lis(new_a)\n        results.append(result)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969462156295776,
            0.9981517791748047,
            0.9973512291908264,
            0.9980556964874268,
            0.9972925782203674,
            0.9976102709770203,
            0.9958134889602661,
            0.9949378967285156,
            0.9979583621025085,
            0.9975389242172241,
            0.9979914426803589,
            0.9969596862792969,
            0.9975925087928772,
            0.9966106414794922,
            0.997535228729248,
            0.996412992477417,
            0.9969193339347839,
            0.9974066019058228,
            0.9972516894340515,
            0.9973281025886536
        ]
    },
    "1767": {
        "similarity": 0.9988076090812683,
        "body": "    max_sum = 0\n    for l in range(n):\n        current_a = 0\n        current_b = 0\n        for r in range(l, n):\n            current_a |= a[r]\n            current_b |= b[r]\n            max_sum = max(max_sum, current_a + current_b)\n    return max_sum\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the result\nprint(max_bitwise_or_sum(n, a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980233907699585,
            0.9969096779823303,
            0.9988074898719788,
            0.9969698190689087,
            0.998587965965271,
            0.9988011121749878,
            0.9987837076187134,
            0.9985936880111694,
            0.9967889189720154,
            0.9959515333175659,
            0.9985936880111694,
            0.9986736178398132,
            0.9980619549751282,
            0.9976814985275269,
            0.9987736940383911,
            0.9985300302505493,
            0.9988076090812683,
            0.9986678957939148,
            0.9974018931388855,
            0.9987338185310364
        ]
    },
    "2382": {
        "similarity": 0.9973584413528442,
        "body": "    from collections import Counter\n    target = Counter(S)\n    \n        if time_left == 0:\n            return current_state == target\n        \n        for health in range(1, max(current_state.keys()) + 1):\n            new_state = current_state.copy()\n            new_state[health] += current_state[1]\n            del new_state[1]\n            if dfs(new_state, time_left - 1):\n                return True\n        return False\n    \n    initial_state = Counter({1: 1})\n    return dfs(initial_state, N)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nS = list(map(int, data[1:]))\n\nprint(\"Yes\" if can_reproduce(N, S) else \"No\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970219135284424,
            0.9967209696769714,
            0.9946010112762451,
            0.9966213703155518,
            0.9957295656204224,
            0.9970527291297913,
            0.9961364269256592,
            0.9973584413528442,
            0.9967764019966125,
            0.9957557320594788,
            0.9972303509712219,
            0.9969325661659241,
            0.995609700679779,
            0.9961374998092651,
            0.9967882037162781,
            0.9969416260719299,
            0.9965952038764954,
            0.9968453645706177,
            0.9971379041671753,
            0.9947841167449951
        ]
    },
    "3907": {
        "similarity": 0.9971411824226379,
        "body": "import sys\n\n    # Sort coupons by cost in descending order to prioritize cheaper coupons\n    coupons.sort(key=lambda x: -x[1])\n    \n    # Initialize a list to count occurrences of each number\n    count = [0] * (max(coupons)[0] + 2)\n    \n    total_money = 0\n    \n    for q, w in coupons:\n        if count[q] == n:\n            continue\n        \n        for _ in range(n - count[q]):\n            # Add the coupon number to the array\n            count[q] += 1\n            # Subtract the cost of the coupon from Sereja's money\n            total_money -= w\n    \n    return -total_money\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ncoupons = []\nfor i in range(m):\n    q = int(data[2 + 2 * i])\n    w = int(data[3 + 2 * i])\n    coupons.append((q, w))\n\n# Calculate and print the result\nprint(max_money_to_dima(n, m, coupons))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960777759552002,
            0.9944592714309692,
            0.9947956800460815,
            0.9944888949394226,
            0.9968409538269043,
            0.9945489764213562,
            0.9962096810340881,
            0.9959529042243958,
            0.995009183883667,
            0.9971411824226379,
            0.9968101382255554,
            0.9955595135688782,
            0.9951633810997009,
            0.9968867301940918,
            0.9937630891799927,
            0.9958589673042297,
            0.9971350431442261,
            0.9967814087867737,
            0.9964257478713989,
            0.9967469573020935
        ]
    },
    "3676": {
        "similarity": 0.997340977191925,
        "body": "    if R == 1 or C == 1:\n        return R * C + min(R, C) - 2\n    else:\n        return R * C + (R - 2) * (C - 2)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nR = int(data[0])\nC = int(data[1])\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960219860076904,
            0.9962617754936218,
            0.9969783425331116,
            0.996666669845581,
            0.9958720207214355,
            0.9972180724143982,
            0.997340977191925,
            0.9969470500946045,
            0.9970471262931824,
            0.9955959320068359,
            0.9971019625663757,
            0.9967888593673706,
            0.993984043598175,
            0.9958046674728394,
            0.9957371950149536,
            0.9956675171852112,
            0.9965326189994812,
            0.9941552877426147,
            0.9957665801048279,
            0.9969097971916199
        ]
    },
    "3293": {
        "similarity": 0.9973208904266357,
        "body": "    profit = 0\n    min_buy_price = float('inf')\n    \n    for i in range(n):\n        f, p, m, s = snacks[i]\n        if i + 1 == f:\n            profit += max(0, m - p)\n            min_buy_price = min(min_buy_price, p)\n        else:\n            profit += max(0, m - min_buy_price)\n    \n    return profit\n\n# Read input\nn = int(input())\nsnacks = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_profit(n, snacks))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996526300907135,
            0.9938623309135437,
            0.9957739114761353,
            0.9963585734367371,
            0.9931859374046326,
            0.9952080249786377,
            0.9965287446975708,
            0.9964975118637085,
            0.9971159100532532,
            0.9967796206474304,
            0.9965257048606873,
            0.9973208904266357,
            0.9961971640586853,
            0.9959238767623901,
            0.995111882686615,
            0.9960581064224243,
            0.9963025450706482,
            0.9969168305397034,
            0.9961639046669006,
            0.9943389892578125
        ]
    },
    "3587": {
        "similarity": 0.9969530701637268,
        "body": "    if N == 0:\n        return -1\n    \n    max_length = max(len(s) for s in taboo_strings)\n    if max_length * N >= 2**max_length:\n        return -1\n    \n        from itertools import product\n        for combo in product([0, 1], repeat=length):\n            binary_str = ''.join(map(str, combo))\n            if all(sub not in binary_str for sub in taboo_strings):\n                return True\n        return False\n    \n    low, high = max_length + 1, 2**max_length\n    while low < high:\n        mid = (low + high) // 2\n        if can_form_string(mid):\n            low = mid + 1\n        else:\n            high = mid\n    \n    if can_form_string(low - 1):\n        return str(bin(2**(low - 1) - 1))[2:]\n    else:\n        return \"-1\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\ntaboo_strings = data[1:N+1]\nresult = longest_non_taboo_clue(N, taboo_strings)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934131503105164,
            0.9969530701637268,
            0.9942941069602966,
            0.9950056672096252,
            0.9969488382339478,
            0.9966719746589661,
            0.9933294057846069,
            0.9962337017059326,
            0.9960885643959045,
            0.9959120750427246,
            0.9960150718688965,
            0.9963208436965942,
            0.9965377449989319,
            0.9946385622024536,
            0.9948736429214478,
            0.996012270450592,
            0.9958114624023438,
            0.9933057427406311,
            0.9957867860794067,
            0.996386706829071
        ]
    },
    "3530": {
        "similarity": 0.9965359568595886,
        "body": "        a_i, b_i = coasters[i]\n        return a_i - (k-1)**2 * b_i\n\n    results = []\n    for T in times:\n        total_fun = 0\n        for i in range(N):\n            k = 1\n            while True:\n                f = fun(i, k)\n                if f <= 0 or k * coasters[i][2] > T:\n                    break\n                total_fun += f\n                k += 1\n        results.append(total_fun)\n    return results\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    coasters = [(int(data[3*i+1]), int(data[3*i+2]), int(data[3*i+3])) for i in range(N)]\n    Q = int(data[3*N + 1])\n    times = [int(data[3*N + 2 + i]) for i in range(Q)]\n    \n    results = max_fun(N, coasters, Q, times)\n    for result in results:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945563077926636,
            0.9962242841720581,
            0.9946068525314331,
            0.9947134256362915,
            0.9958016276359558,
            0.9942412376403809,
            0.9955416321754456,
            0.9952565431594849,
            0.9887962341308594,
            0.9958177208900452,
            0.9951173067092896,
            0.9946863055229187,
            0.9953727722167969,
            0.9960564374923706,
            0.9955301880836487,
            0.994633138179779,
            0.9965359568595886,
            0.9962136149406433,
            0.9881269335746765,
            0.9945142865180969
        ]
    },
    "3900": {
        "similarity": 0.9963849782943726,
        "body": "from collections import defaultdict\n\n    graph = defaultdict(list)\n    for i in range(n):\n        x, y = choices[i]\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n\n        visited.add(node)\n        count = 1\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                count += dfs(neighbor, visited)\n        return count\n\n    suspects = []\n    for i in range(n):\n        visited = set()\n        count = dfs(i, visited)\n        if count >= p:\n            suspects.append(i)\n\n    m = len(suspects)\n    return m * (m - 1) // 2\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\n\nchoices = []\nfor i in range(n):\n    x = int(data[2 + 2 * i]) - 1\n    y = int(data[3 + 2 * i]) - 1\n    choices.append((x, y))\n\nresult = count_suspects(n, p, choices)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959330558776855,
            0.9949445128440857,
            0.9963849782943726,
            0.9932271242141724,
            0.9952607750892639,
            0.9944615960121155,
            0.9962655305862427,
            0.9957693219184875,
            0.9948886036872864,
            0.9958752989768982,
            0.9946979880332947,
            0.9955524802207947,
            0.9941579699516296,
            0.9951063394546509,
            0.9943488240242004,
            0.9937657713890076,
            0.9923993349075317,
            0.9933387637138367,
            0.9950957298278809,
            0.9954173564910889
        ]
    },
    "3996": {
        "similarity": 0.997127115726471,
        "body": "from fractions import Fraction\nimport sys\n\n    MOD = 10**9 + 7\n    k = int(input())\n    a = list(map(int, input().split()))\n    \n    prob = Fraction(1)\n    for ai in a:\n        prob *= Fraction(ai - 1, ai)\n        prob %= MOD\n    \n    num, den = prob.numerator, prob.denominator\n    gcd = num.gcd(den)\n    num //= gcd\n    den //= gcd\n    \n    print(f\"{num % MOD}/{den % MOD}\")\n\ncalculate_probability()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965705871582031,
            0.994920551776886,
            0.9966458678245544,
            0.9951796531677246,
            0.9948816895484924,
            0.9948794841766357,
            0.9967024922370911,
            0.9968223571777344,
            0.996860682964325,
            0.9954404234886169,
            0.9969056844711304,
            0.9957783222198486,
            0.993030846118927,
            0.997127115726471,
            0.9947314262390137,
            0.9955171346664429,
            0.994384765625,
            0.9963842034339905,
            0.9931187033653259,
            0.9964289665222168
        ]
    },
    "3276": {
        "similarity": 0.9965860247612,
        "body": "    for i in range(N - 2):\n        for j in range(M - 2):\n            if art[i][j] != 'W':\n                color = art[i][j]\n                for x in range(3):\n                    for y in range(3):\n                        if art[i + x][j + y] != color:\n                            return \"NO\"\n    return \"YES\"\n\n# Read input\nN, M = map(int, input().split())\nart = [input().strip() for _ in range(N)]\n\n# Output result\nprint(can_reproduce_art(N, M, art))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965780377388,
            0.9958289265632629,
            0.9960365295410156,
            0.992395281791687,
            0.9932066202163696,
            0.9962126016616821,
            0.9930437803268433,
            0.9927229881286621,
            0.9920744895935059,
            0.9954208731651306,
            0.9953334331512451,
            0.9956873655319214,
            0.9962778687477112,
            0.9955532550811768,
            0.9950271248817444,
            0.9965373873710632,
            0.9955335855484009,
            0.9965860247612,
            0.995771586894989,
            0.9914155602455139
        ]
    },
    "3834": {
        "similarity": 0.9964649677276611,
        "body": "        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == value and (nx, ny) not in visited:\n                    stack.append((nx, ny))\n                    visited.add((nx, ny))\n\n    changes_needed = 0\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                value = table[i][j]\n                visited = set()\n                dfs(i, j, value)\n                size = len(visited)\n                if size != value * (value + 1) // 2:\n                    changes_needed += abs(size - value * (value + 1) // 2)\n\n    return changes_needed if changes_needed <= k else -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ntable = [[int(data[3 + i * m + j]) for j in range(m)] for i in range(n)]\nprint(min_changes_to_meet_requirement(n, m, k, table))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956493377685547,
            0.9964649677276611,
            0.995806872844696,
            0.9961767792701721,
            0.9957696199417114,
            0.9964512586593628,
            0.9963679313659668,
            0.995572030544281,
            0.9949240684509277,
            0.9947476983070374,
            0.9962430596351624,
            0.9952061176300049,
            0.9927538633346558,
            0.9951435923576355,
            0.9961845874786377,
            0.9802743792533875,
            0.9963359832763672,
            0.9963144063949585,
            0.9949705004692078,
            0.996100902557373
        ]
    },
    "3012": {
        "similarity": 0.9968683123588562,
        "body": "    MOD = 1000000007\n    \n    if N == 0:\n        return 1\n    \n    total_players = a11 + a12 + a21 + a22\n    if total_players < 3 or total_players * (total_players - 1) < N:\n        return 0\n    \n    dp = [[[0] * 4 for _ in range(total_players)] for _ in range(total_players)]\n    \n    for i in range(total_players):\n        dp[i][i][0] = a12\n        dp[i][i][1] = a21\n    \n    for length in range(1, N + 1):\n        new_dp = [[[0] * 4 for _ in range(total_players)] for _ in range(total_players)]\n        \n        for i in range(total_players):\n            for j in range(total_players):\n                if i != j:\n                    for k in range(3):\n                        if dp[i][j][k]:\n                            new_dp[j][(i + (k + 1) % 2) % total_players][0] = (new_dp[j][(i + (k + 1) % 2) % total_players][0] + dp[i][j][k]) % MOD\n                            new_dp[(i + (k + 1) % 2) % total_players][j][1] = (new_dp[(i + (k + 1) % 2) % total_players][j][1] + dp[i][j][k]) % MOD\n        \n        dp = new_dp\n    \n    result = sum(sum(dp[i][j]) for i in range(total_players) for j in range(total_players)) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    a11, a12, a21, a22, N = map(int, input().split())\n    print(count_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9929582476615906,
            0.9939762949943542,
            0.9955611228942871,
            0.9935798645019531,
            0.9959114789962769,
            0.9958288073539734,
            0.9968683123588562,
            0.9948574900627136,
            0.996364176273346,
            0.9955307841300964,
            0.9957494139671326,
            0.996221661567688,
            0.9963949918746948,
            0.9962387084960938,
            0.9945666790008545,
            0.9938518404960632,
            0.9956060647964478,
            0.9928524494171143,
            0.9965589642524719,
            0.9962964653968811
        ]
    },
    "3745": {
        "similarity": 0.9978232383728027,
        "body": "    if n == 1:\n        return \"Yes\\na\"\n    \n    adj_list = [[] for _ in range(n + 1)]\n    degree = [0] * (n + 1)\n    \n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    if any(d != 2 for d in degree[1:]):\n        return \"No\"\n    \n    visited = [False] * (n + 1)\n    \n        if visited[node]:\n            return True\n        \n        visited[node] = True\n        graph[node].append(color)\n        \n        for neighbor in adj_list[node]:\n            if neighbor == parent:\n                continue\n            if not dfs(neighbor, node, (color + 1) % 3):\n                return False\n        \n        return True\n    \n    graph = [[] for _ in range(n)]\n    \n    for i in range(1, n + 1):\n        if degree[i] == 2 and not visited[i]:\n            if not dfs(i, -1, 0):\n                return \"No\"\n    \n    result = \"\".join(graph[1:])\n    \n    if len(result) != n:\n        return \"No\"\n    \n    return \"Yes\\n\" + result\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print output\nprint(can_form_string(n, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971855878829956,
            0.9971285462379456,
            0.9970269799232483,
            0.9970901012420654,
            0.9976729154586792,
            0.9978232383728027,
            0.9972837567329407,
            0.9971219301223755,
            0.9974260926246643,
            0.997299313545227,
            0.9974262714385986,
            0.9976617693901062,
            0.9974745512008667,
            0.9976473450660706,
            0.9977024793624878,
            0.9935028553009033,
            0.997049868106842,
            0.9971753358840942,
            0.9977362751960754,
            0.9974767565727234
        ]
    },
    "3028": {
        "similarity": 0.996372401714325,
        "body": "import sys\nfrom typing import List\n\n    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                moves.append(i * m + j + 1)\n                for k in range(n):\n                    board[k][j] = (board[k][j] + 1) % p\n                for k in range(m):\n                    board[i][k] = (board[i][k] + 1) % p\n\n    if all(board[i][j] == p for i in range(n) for j in range(m)):\n        print(len(moves))\n        print(' '.join(map(str, moves)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    p = int(data[2])\n    board = []\n    index = 3\n    for i in range(n):\n        row = list(map(int, data[index:index + m]))\n        board.append(row)\n        index += m\n\n    primonimo(n, m, p, board)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962536692619324,
            0.9958288073539734,
            0.990983247756958,
            0.996372401714325,
            0.9899755716323853,
            0.9959333539009094,
            0.9955335855484009,
            0.9957461953163147,
            0.995089590549469,
            0.9958553314208984,
            0.9960897564888,
            0.9946085214614868,
            0.9939264059066772,
            0.993069589138031,
            0.994809627532959,
            0.9956738352775574,
            0.9952690005302429,
            0.9950687885284424,
            0.9952524900436401,
            0.9931014180183411
        ]
    },
    "3196": {
        "similarity": 0.998075008392334,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for A, B in roads:\n        graph[A].append(B)\n    \n    if 2 not in graph[1]:\n        return 0\n    \n    queue = deque([(1, 1)])\n    visited = set()\n    total_routes = 0\n    while queue:\n        current, count = queue.popleft()\n        if count > N:\n            continue\n        for neighbor in graph[current]:\n            if (current, neighbor) not in visited:\n                visited.add((current, neighbor))\n                queue.append((neighbor, count + 1))\n                total_routes += 1\n    \n    if total_routes == float('inf'):\n        return \"inf\"\n    else:\n        return str(total_routes)[-9:]\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(M)]\n    result = count_routes(N, M, roads)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968998432159424,
            0.9968560934066772,
            0.9977571368217468,
            0.9971823692321777,
            0.9973651766777039,
            0.9969238638877869,
            0.9955176115036011,
            0.9979723691940308,
            0.9976025819778442,
            0.9966306090354919,
            0.9978850483894348,
            0.9967731833457947,
            0.9973594546318054,
            0.9965658783912659,
            0.998075008392334,
            0.9973536133766174,
            0.9969491362571716,
            0.9972794055938721,
            0.9978669881820679,
            0.9974538087844849
        ]
    },
    "3405": {
        "similarity": 0.9979503154754639,
        "body": "    X = int(X * 10)\n    results = []\n    for i in range(1, 10**8):\n        str_i = str(i)\n        if len(str_i) > 1:\n            first_digit = int(str_i[0])\n            rest_digits = int(str_i[1:])\n            new_number = rest_digits * 10 + first_digit\n            if new_number == i * X:\n                results.append(i)\n    return results\n\nX = input()\nnumbers = find_numbers(X)\nif numbers:\n    for number in numbers:\n        print(number)\nelse:\n    print(\"No solution\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969542622566223,
            0.9977306723594666,
            0.9974416494369507,
            0.9974772930145264,
            0.996669352054596,
            0.9974027872085571,
            0.9978212118148804,
            0.9975062012672424,
            0.9978454113006592,
            0.9976152181625366,
            0.9979503154754639,
            0.997917890548706,
            0.9979137778282166,
            0.9966877698898315,
            0.9967764019966125,
            0.9979303479194641,
            0.9973031878471375,
            0.9964099526405334,
            0.9974714517593384,
            0.9978185892105103
        ]
    },
    "3126": {
        "similarity": 0.9980686902999878,
        "body": "import sys\nfrom collections import deque\n\n    frogs.sort()\n    n = len(frogs)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(n):\n        dp[i + 1] = min(dp[i + 1], dp[i] + abs(frogs[i] - tower))\n    \n    return dp[-1]\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, t = map(int, data[0:2])\n    frogs = list(map(int, data[2:2+n]))\n    changes = int(data[2+n])\n    index = 2 + n\n    \n    results = []\n    \n    for _ in range(changes):\n        change = data[index]\n        index += 1\n        \n        if change == '+':\n            a = int(data[index])\n            frogs.append(a)\n        elif change == '-':\n            a = int(data[index])\n            frogs.remove(a)\n        else:\n            t = int(data[index])\n        \n        results.append(min_jumps_to_tower(frogs, t))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976768493652344,
            0.9977561831474304,
            0.9980686902999878,
            0.9968352317810059,
            0.9968769550323486,
            0.9970504641532898,
            0.9970642924308777,
            0.9972283244132996,
            0.9974552989006042,
            0.9974290132522583,
            0.9976819753646851,
            0.9972688555717468,
            0.9975449442863464,
            0.9938332438468933,
            0.9971057772636414,
            0.995212972164154,
            0.9978399872779846,
            0.9968629479408264,
            0.9979869723320007,
            0.9977786540985107
        ]
    },
    "3279": {
        "similarity": 0.996941328048706,
        "body": "        bars = [0] * (n + 1)\n        start = 0\n        for size in spec:\n            for i in range(size):\n                bars[start + i] = 1\n            start += size + 1\n        return bars\n\n        bars = [''] * (n + 1)\n        start = 0\n        for size in spec:\n            for i in range(size):\n                bars[start] += '1'\n            start += size + 1\n        return bars\n\n    vertical_bars = [place_vertical_bars(i, vertical_spec[i]) for i in range(n)]\n    horizontal_bars = [place_horizontal_bars(j, horizontal_spec[j]) for j in range(n)]\n\n        for col in range(n):\n            if any(bars[col] == '1' and bars[col + 1] == '1' for bars in horizontal_bars):\n                return False\n        for row in range(n):\n            if any(bars[row][col] == '1' and bars[row][col + 1] == '1' for bars in vertical_bars):\n                return False\n        return True\n\n        if row == n:\n            return check_validity()\n        if col == n:\n            return backtrack(row + 1, 0)\n        if vertical_bars[row][col] != 0:\n            return backtrack(row, col + 1)\n        for i in range(col + 1, n + 1):\n            if any(horizontal_bars[r][i - 1:i + 1].count('1') > 1 for r in range(n)):\n                continue\n            vertical_bars[row][col] = '1'\n            horizontal_bars[row][col] = '1' * (i - col)\n            if backtrack(row, i):\n                return True\n            vertical_bars[row][col] = 0\n            horizontal_bars[row][col] = ''\n        return False\n\n    backtrack(0, 0)\n\n    result = []\n    for row in range(n):\n        result.append(''.join(str(bars) for bars in vertical_bars[row]))\n    for col in range(n):\n        result.append(''.join(horizontal_bars[row][col] for row in range(n)))\n    return '\\n'.join(result)\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nvertical_spec = []\nhorizontal_spec = []\n\nindex = 1\nfor i in range(n):\n    vertical_spec.append(list(map(int, data[index:index + n])))\n    index += n\n\nindex += n\nfor j in range(n):\n    horizontal_spec.append(list(map(int, data[index:index + n])))\n    index += n\n\n# Print result\nprint(bar_code(n, vertical_spec, horizontal_spec))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996941328048706,
            0.9954245686531067,
            0.9961917400360107,
            0.9958727955818176,
            0.9960651397705078,
            0.9951900839805603,
            0.9955193400382996,
            0.9961480498313904,
            0.9957744479179382,
            0.9946214556694031,
            0.9957535266876221,
            0.9949586987495422,
            0.9955306649208069,
            0.9953231811523438,
            0.9956682324409485,
            0.9964624643325806,
            0.9924067258834839,
            0.9955633878707886,
            0.9960609078407288,
            0.9957433938980103
        ]
    },
    "3599": {
        "similarity": 0.9974632263183594,
        "body": "import sys\n\n    remaining_time = T\n    stage_times = [0] * N\n    \n    for i in range(N):\n        break_length = breaks[i]\n        if remaining_time >= break_length:\n            stage_times[i] = remaining_time - break_length\n            remaining_time -= break_length\n        else:\n            remaining_time = 0\n    \n    return stage_times\n\n# Read input from stdin\nT, N = map(int, input().split())\nbreaks = list(map(int, input().split()))\n\n# Calculate and print the result\nstage_times = schedule_breaks(T, N, breaks)\nprint(\" \".join(map(str, stage_times)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962997436523438,
            0.9939773082733154,
            0.9937633872032166,
            0.9973337054252625,
            0.9966474771499634,
            0.9971074461936951,
            0.9970369935035706,
            0.996164858341217,
            0.9956245422363281,
            0.9971626996994019,
            0.9969529509544373,
            0.9967440366744995,
            0.9955852031707764,
            0.9974632263183594,
            0.9971030354499817,
            0.9960092306137085,
            0.9964715242385864,
            0.9940446615219116,
            0.9918211698532104,
            0.9972257018089294
        ]
    },
    "3687": {
        "similarity": 0.9972855448722839,
        "body": "    for _ in range(n):\n        d, *a = map(int, input().split())\n        data_to_send = list(a)\n        queues = [0] * (q + 1)\n\n        for i in range(q):\n            queues[i + 1] = queue_sizes[i]\n\n        for i in range(s):\n            sensor_id = queue_assignments[i]\n            if data_to_send[i] <= queues[sensor_id]:\n                queues[sensor_id] -= data_to_send[i]\n            else:\n                return \"impossible\"\n\n        total_sent = sum(data_to_send)\n        if total_sent > d:\n            return \"impossible\"\n\n    for i in range(1, q + 1):\n        if queues[i] != 0:\n            return \"impossible\"\n\n    return \"possible\"\n\n# Read input\nn, q, s = map(int, input().split())\nqueue_assignments = list(map(int, input().split()))\nqueue_sizes = list(map(int, input().split()))\ndownlink_windows = []\n\nfor _ in range(n):\n    downlink_windows.append(list(map(int, input().split())))\n\n# Output the result\nprint(can_transfer_data(n, q, s, queue_assignments, queue_sizes, downlink_windows))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971696734428406,
            0.9969596862792969,
            0.9961399435997009,
            0.9967058897018433,
            0.9966899752616882,
            0.9971301555633545,
            0.9940634369850159,
            0.9958040118217468,
            0.9952428936958313,
            0.9959793090820312,
            0.9953389763832092,
            0.9963198304176331,
            0.9972855448722839,
            0.9968453645706177,
            0.9971874952316284,
            0.9943271279335022,
            0.9964093565940857,
            0.9968804121017456,
            0.9967089295387268,
            0.9961938261985779
        ]
    },
    "3864": {
        "similarity": 0.9942739605903625,
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n    \n    result = [0] * (n + 1)\n    result[n] = dp[n]\n    \n    for i in range(n - 1, 0, -1):\n        result[i] = (result[i + 1] * 2) % MOD\n        if i > 1:\n            result[i] = (result[i] - dp[i]) % MOD\n    \n    return result[1:]\n\n# Read input\nn = int(input())\n\n# Compute and print results\nresults = expected_black_stones(n)\nfor r in results:\n    print(r)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9922096729278564,
            0.9815704822540283,
            0.9906178712844849,
            0.9876677989959717,
            0.9940954446792603,
            0.9938676953315735,
            0.9925850629806519,
            0.9882278442382812,
            0.9885789752006531,
            0.9884728789329529,
            0.9942739605903625,
            0.9919236898422241,
            0.9862368702888489,
            0.9916933178901672,
            0.9938254952430725,
            0.994186520576477,
            0.9939438700675964,
            0.9933273196220398,
            0.9938876628875732,
            0.9861331582069397
        ]
    },
    "3504": {
        "similarity": 0.9953826069831848,
        "body": "    disintegration_points = [0] * len(droplets)\n    \n    for i, (x, y) in enumerate(droplets):\n        for x1, x2, y_sensor in sensors:\n            if x1 <= x <= x2 and y == y_sensor:\n                disintegration_points[i] = y_sensor\n                break\n    \n    return disintegration_points\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    D = int(data[0])\n    S = int(data[1])\n    \n    droplets = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(D)]\n    sensors = [(int(data[2 + 2 * D + 3 * i]), int(data[3 + 2 * D + 3 * i + 1]), int(data[4 + 2 * D + 3 * i + 2])) for i in range(S)]\n    \n    result = find_disintegration_points(droplets, sensors)\n    \n    for point in result:\n        print(point)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950312376022339,
            0.9950911998748779,
            0.9953826069831848,
            0.9936044812202454,
            0.9930877685546875,
            0.9950542449951172,
            0.9952888488769531,
            0.9929932355880737,
            0.9949603080749512,
            0.9935721158981323,
            0.993949294090271,
            0.9952961802482605,
            0.9934192299842834,
            0.9944193959236145,
            0.9921051859855652,
            0.9939114451408386,
            0.9934757947921753,
            0.9906954765319824,
            0.9937876462936401,
            0.9937321543693542
        ]
    },
    "3451": {
        "similarity": 0.9972817301750183,
        "body": "import sys\n\n        balance = 0\n        for char in seq:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    if k >= n // 2:\n        return min(costs)\n\n    max_cost = float('-inf')\n    for i in range(n):\n        if sequence[i] != (sequence[0] if i % 2 == 0 else sequence[-1]):\n            new_sequence = sequence[:i] + ('(' if sequence[i] == ')' else ')') + sequence[i+1:]\n            if not is_balanced(new_sequence):\n                max_cost = max(max_cost, costs[i])\n\n    return '?' if max_cost == float('-inf') else max_cost\n\nn, k = map(int, input().split())\nsequence = input().strip()\ncosts = [int(input()) for _ in range(n)]\nprint(min_effort_to_impossible(n, k, sequence, costs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969888925552368,
            0.9970431923866272,
            0.994651198387146,
            0.9945207238197327,
            0.9970638751983643,
            0.9956425428390503,
            0.9943917989730835,
            0.9969835877418518,
            0.9950920939445496,
            0.9955740571022034,
            0.9972435832023621,
            0.9958227872848511,
            0.9956102967262268,
            0.9963489174842834,
            0.9964988231658936,
            0.9950692057609558,
            0.9958343505859375,
            0.9970729351043701,
            0.9955645203590393,
            0.9972817301750183
        ]
    },
    "3156": {
        "similarity": 0.9975351095199585,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    in_degree = [0] * N\n    \n    for i in range(K):\n        store, item = store_items[i]\n        graph[store].append(item)\n        in_degree[item] += 1\n    \n    queue = deque([i for i in range(N) if in_degree[i] == 0])\n    \n    path = []\n    while queue:\n        if len(queue) > 1:\n            return \"ambiguous\"\n        current_store = queue.popleft()\n        path.append(current_store)\n        \n        for item in graph[current_store]:\n            in_degree[item] -= 1\n            if in_degree[item] == 0:\n                queue.append(item)\n    \n    if len(path) != N:\n        return \"impossible\"\n    \n    if bought_items[:N] == path:\n        return \"unique\"\n    else:\n        return \"impossible\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    K = int(input())\n    store_items = []\n    for _ in range(K):\n        i, S = input().split()\n        store_items.append((int(i), S))\n    \n    M = int(input())\n    bought_items = [input() for _ in range(M)]\n    \n    result = find_shopping_path(N, K, store_items, M, bought_items)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973099231719971,
            0.9970787763595581,
            0.9953659772872925,
            0.9965906739234924,
            0.9973849058151245,
            0.9960561990737915,
            0.994388997554779,
            0.9970170855522156,
            0.9972554445266724,
            0.9975351095199585,
            0.9969472289085388,
            0.9971989989280701,
            0.9963124990463257,
            0.9951551556587219,
            0.9966437816619873,
            0.9956502318382263,
            0.9950471520423889,
            0.9972752928733826,
            0.9964065551757812,
            0.9963394999504089
        ]
    },
    "3697": {
        "similarity": 0.9982333183288574,
        "body": "    votes = [0] * (n + 1)\n    last_votes = [-1] * (n + 1)\n    \n    for j in range(a):\n        candidate = int(input())\n        votes[candidate] += 1\n        if last_votes[candidate] == -1:\n            last_votes[candidate] = a - j\n    \n    sorted_candidates = sorted(range(1, n + 1), key=lambda x: (-votes[x], last_votes[x]))\n    \n    outcomes = [0] * (n + 1)\n    remaining_seats = k\n    for candidate in sorted_candidates:\n        if votes[candidate] + remaining_seats > k and remaining_seats > 0:\n            outcomes[candidate] = 1\n            remaining_seats -= 1\n    \n    for i in range(1, n + 1):\n        if outcomes[i] == 0:\n            if last_votes[i] < a - m:\n                outcomes[i] = 3\n            else:\n                outcomes[i] = 2\n    \n    return ' '.join(map(str, outcomes[1:]))\n\n# Read input from stdin and print the result\nprint(determine_outcomes(*map(int, input().split())))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971188902854919,
            0.9955690503120422,
            0.997611403465271,
            0.9980241656303406,
            0.9978970885276794,
            0.996853768825531,
            0.9975327253341675,
            0.9970876574516296,
            0.9982320666313171,
            0.9982333183288574,
            0.9978992938995361,
            0.9974652528762817,
            0.9966260194778442,
            0.997625470161438,
            0.9974033236503601,
            0.9980769753456116,
            0.9979231953620911,
            0.998054027557373,
            0.9979150891304016,
            0.9974488615989685
        ]
    },
    "3647": {
        "similarity": 0.9984362721443176,
        "body": "import sys\nfrom collections import deque\n\n    R, C = len(maze), len(maze[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < R and 0 <= y < C\n    \n        if maze[x][y] == '#':\n            return float('inf')\n        elif maze[x][y] == '.':\n            return 1\n        else:\n            return 0\n    \n    dist = [[float('inf')] * C for _ in range(R)]\n    dist[start[0]][start[1]] = 0\n    queue = deque([start])\n    \n    while queue:\n        x, y = queue.popleft()\n        \n        if maze[x][y] == 'M':\n            break\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            \n            if can_move(nx, ny):\n                if dist[nx][ny] > dist[x][y] + get_distance(nx, ny):\n                    dist[nx][ny] = dist[x][y] + get_distance(nx, ny)\n                    queue.append((nx, ny))\n    \n    return dist\n\ninput = sys.stdin.read\ndata = input().split()\nR = int(data[0])\nC = int(data[1])\nmaze = [data[i+2] for i in range(R)]\n\nstart_pos = None\nfor i in range(R):\n    for j in range(C):\n        if maze[i][j] == 'M':\n            start_pos = (i, j)\n            break\n    if start_pos:\n        break\n\ndistances = min_moves_to_goal(maze, start_pos)\n\nfor row in distances:\n    print(' '.join(map(str, row)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982474446296692,
            0.9976251721382141,
            0.9984362721443176,
            0.9969702363014221,
            0.9982115030288696,
            0.9982104301452637,
            0.9979473948478699,
            0.9983954429626465,
            0.9982526898384094,
            0.9976115822792053,
            0.9982794523239136,
            0.9984220266342163,
            0.9982223510742188,
            0.9980776906013489,
            0.9972909688949585,
            0.9980818033218384,
            0.9966741800308228,
            0.9981085062026978,
            0.9979023337364197,
            0.9983468651771545
        ]
    },
    "3699": {
        "similarity": 0.9958594441413879,
        "body": "import sys\nfrom typing import List\n\n    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    n = len(bottles)\n    \n        adil_distance = 0\n        bera_distance = 0\n        \n        for i in range(n):\n            if assignment[i] == 1:\n                adil_distance += distance(a_x, a_y, bottles[i][0], bottles[i][1])\n                adil_distance += distance(bottles[i][0], bottles[i][1], t_x, t_y)\n            else:\n                bera_distance += distance(b_x, b_y, bottles[i][0], bottles[i][1])\n                bera_distance += distance(bottles[i][0], bottles[i][1], t_x, t_y)\n        \n        return adil_distance + bera_distance\n    \n    from itertools import combinations\n    min_dist = float('inf')\n    \n    for r in range(1, n + 1):\n        for assignment in combinations(range(n), r):\n            current_dist = total_distance(list(assignment))\n            if current_dist < min_dist:\n                min_dist = current_dist\n    \n    return min_dist\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    a_x, a_y, b_x, b_y, t_x, t_y = int(data[0]), int(data[1]), int(data[2]), int(data[3]), int(data[4]), int(data[5])\n    n = int(data[6])\n    \n    bottles = []\n    for i in range(n):\n        x, y = int(data[7 + 2 * i]), int(data[8 + 2 * i])\n        bottles.append([x, y])\n    \n    result = min_distance_to_recycle(a_x, a_y, b_x, b_y, t_x, t_y, bottles)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937666654586792,
            0.9935346841812134,
            0.9941685199737549,
            0.9941861033439636,
            0.9958594441413879,
            0.9945053458213806,
            0.9953932762145996,
            0.9946590065956116,
            0.9953952431678772,
            0.9873313903808594,
            0.9949670433998108,
            0.9942721128463745,
            0.9928709268569946,
            0.9943128824234009,
            0.9944301247596741,
            0.9948922991752625,
            0.9955750703811646,
            0.9944809675216675,
            0.9920914173126221,
            0.9939368367195129
        ]
    },
    "3145": {
        "similarity": 0.9976140260696411,
        "body": "    count = 0\n    for num in range(A, B + 1):\n        if num % X == 0:\n            str_num = str(num)\n            if all(digit in allowed_digits for digit in str_num):\n                count += 1\n    return count\n\n# Read input from stdin\nX, A, B = map(int, input().split())\nallowed_digits = input().strip()\n\n# Output the result\nprint(count_multiples(X, A, B, allowed_digits))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961754679679871,
            0.9976140260696411,
            0.997412919998169,
            0.9960339069366455,
            0.997170090675354,
            0.9973845481872559,
            0.9974877238273621,
            0.9975672364234924,
            0.9953573942184448,
            0.9972261190414429,
            0.9967603087425232,
            0.9964774250984192,
            0.989654541015625,
            0.99755859375,
            0.9970502257347107,
            0.9973068237304688,
            0.9942666888237,
            0.9964635968208313,
            0.9967456459999084,
            0.9961336851119995
        ]
    },
    "3795": {
        "similarity": 0.9962614178657532,
        "body": "    # Initialize the minimum rubles to a large number\n    min_rubles = float('inf')\n    \n    # Iterate over all possible combinations of euros and dollars\n    for euros in range(n // 50 + 1):\n        for dollars in range(n // 200 + 1):\n            # Calculate the total cost of the current combination\n            total_cost = euros * e + dollars * d\n            # Check if the total cost is within the initial amount and update the minimum rubles\n            if total_cost <= n:\n                min_rubles = min(min_rubles, n - total_cost)\n    \n    return min_rubles\n\n# Read input from stdin\nn = int(input())\nd = int(input())\ne = int(input())\n\n# Print the result\nprint(min_rubles(n, d, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952272176742554,
            0.9947808980941772,
            0.992806077003479,
            0.9957562685012817,
            0.9952448606491089,
            0.9946949481964111,
            0.9955551028251648,
            0.9951900839805603,
            0.9952569603919983,
            0.9961104989051819,
            0.9953905344009399,
            0.9912533164024353,
            0.9823358654975891,
            0.9944170713424683,
            0.9960206747055054,
            0.9956227540969849,
            0.9959377646446228,
            0.9962614178657532,
            0.9959744215011597,
            0.9928426146507263
        ]
    },
    "3353": {
        "similarity": 0.9980326294898987,
        "body": "from collections import defaultdict\nimport heapq\n\n    graph = defaultdict(list)\n    for E1, E2 in logs:\n        graph[E1].append(E2)\n        graph[E2].append(E1)\n\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            time, node = heapq.heappop(queue)\n            if node == end:\n                return time\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        heapq.heappush(queue, (time + 1, neighbor))\n        return float('inf')\n\n    left_to_right = bfs(-2, -1)\n    if left_to_right == float('inf'):\n        print(P)\n        return\n\n    right_to_left = [bfs(R, i) for i in range(R)]\n    min_cross_time = float('inf')\n    for people in range(P + 1):\n        left_time = left_to_right\n        right_time = sum(right_to_left[i] for i in range(people, P))\n        if left_time != float('inf') and right_time != float('inf'):\n            min_cross_time = min(min_cross_time, left_time + right_time)\n\n    if min_cross_time == float('inf'):\n        print(P)\n    else:\n        print(min_cross_time)\n\n# Read input\nP, R, L = map(int, input().split())\nlogs = [tuple(map(int, input().split())) for _ in range(L)]\n\nmin_time_to_cross(P, R, L, logs)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967272877693176,
            0.9975433349609375,
            0.9974594116210938,
            0.9969372153282166,
            0.9967566132545471,
            0.9972403645515442,
            0.997694730758667,
            0.9980326294898987,
            0.9978821277618408,
            0.9980033040046692,
            0.9973072409629822,
            0.9977635741233826,
            0.9978448748588562,
            0.9974979758262634,
            0.9978119730949402,
            0.9915055632591248,
            0.9975584745407104,
            0.9959225058555603,
            0.9978631734848022,
            0.996097981929779
        ]
    },
    "3065": {
        "similarity": 0.997294008731842,
        "body": "import sys\nfrom fractions import Fraction\n\n    visited = [False] * n\n    queue = [(0, 1)]\n    while queue:\n        node, prob = queue.pop(0)\n        if node == len(walk) - 1:\n            return prob\n        for neighbor in range(n):\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append((neighbor, prob * Fraction(1, n)))\n    return Fraction(0)\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    i = 0\n    N = int(data[i])\n    i += 1\n    L = int(data[i])\n    i += 1\n    walk = list(map(int, data[i:i+L]))\n    i += L\n    \n    graph = [[] for _ in range(N)]\n    for j in range(N):\n        n_neighbors = int(data[i])\n        i += 1\n        for k in range(n_neighbors):\n            neighbor = int(data[i])\n            i += 1\n            graph[j].append(neighbor)\n    \n    result = bfs(N, walk)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968967437744141,
            0.9957499504089355,
            0.9971249103546143,
            0.995805025100708,
            0.9970371723175049,
            0.9969247579574585,
            0.9972367882728577,
            0.9960630536079407,
            0.9948847889900208,
            0.9965824484825134,
            0.9958899617195129,
            0.9960903525352478,
            0.997294008731842,
            0.9963908195495605,
            0.9959231019020081,
            0.9969897270202637,
            0.9969008564949036,
            0.9969115257263184,
            0.9939764142036438,
            0.9927619099617004
        ]
    },
    "3250": {
        "similarity": 0.9931129813194275,
        "body": "    for m in range(1, b):\n        if all((pow(n, b, b) - pow(n, 2 * m + 1, b)) % d == 0 for n in range(d)):\n            return \"yes\"\n    return \"no\"\n\n# Read input from stdin\nb, d = map(int, input().split())\n\n# Print the result\nprint(is_valid_divisibility_hack(b, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920446276664734,
            0.9926310181617737,
            0.9826037883758545,
            0.9931129813194275,
            0.9898970723152161,
            0.9905118346214294,
            0.9755265116691589,
            0.9880188703536987,
            0.9808202385902405,
            0.9920477867126465,
            0.9905580282211304,
            0.9927055835723877,
            0.989658534526825,
            0.9929124712944031,
            0.9909790754318237,
            0.9831796288490295,
            0.9846078157424927,
            0.9902085661888123,
            0.9863059520721436,
            0.9925958514213562
        ]
    },
    "3306": {
        "similarity": 0.9970012307167053,
        "body": "    calls = [0] * (M + 1)\n    for P, C in detectors:\n        calls[P] += C\n        calls[P + 1] -= C\n    \n    prefix_sum = [0]\n    for i in range(M):\n        prefix_sum.append(prefix_sum[-1] + calls[i + 1])\n    \n    return max(prefix_sum)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\ndetectors = []\n\nindex = 2\nfor _ in range(N):\n    P = int(data[index])\n    C = int(data[index + 1])\n    detectors.append((P, C))\n    index += 2\n\nprint(min_phone_calls(N, M, detectors))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952785968780518,
            0.9969749450683594,
            0.9937050342559814,
            0.9931764006614685,
            0.9970012307167053,
            0.9966614246368408,
            0.9967855215072632,
            0.9961760640144348,
            0.9964574575424194,
            0.9958749413490295,
            0.9965949058532715,
            0.9956105947494507,
            0.9964844584465027,
            0.9959083199501038,
            0.9922767281532288,
            0.9967974424362183,
            0.9968048930168152,
            0.9966467022895813,
            0.9945659637451172,
            0.9946243166923523
        ]
    },
    "3970": {
        "similarity": 0.9978702068328857,
        "body": "    a.sort()\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0 and a[i] // a[j] == k:\n                break\n        else:\n            dp[i] = dp[j] + 1\n    return max(dp)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\na = list(map(int, data[2:]))\n\nprint(largest_k_multiple_free_subset(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969701170921326,
            0.9962592124938965,
            0.9969976544380188,
            0.9963180422782898,
            0.9972299337387085,
            0.9954647421836853,
            0.9963380098342896,
            0.9978702068328857,
            0.9970056414604187,
            0.9978702068328857,
            0.9966529011726379,
            0.9959774017333984,
            0.9968712329864502,
            0.9944491982460022,
            0.9968712329864502,
            0.9976401329040527,
            0.9958042502403259,
            0.9959586262702942,
            0.9954210519790649,
            0.9964219331741333
        ]
    },
    "3655": {
        "similarity": 0.9979203939437866,
        "body": "import sys\n\n    robot_w, robot_h = len(robot_image[0]), len(robot_image)\n    floor_w, floor_h = len(floor_image[0]), len(floor_image)\n    \n    max_matches = 0\n    candidates = []\n    \n    for y in range(floor_h - robot_h + 1):\n        for x in range(floor_w - robot_w + 1):\n            matches = 0\n            for i in range(robot_h):\n                for j in range(robot_w):\n                    if robot_image[i][j] == floor_image[y+i][x+j]:\n                        matches += 1\n            if matches > max_matches:\n                max_matches = matches\n                candidates = [(x, y)]\n            elif matches == max_matches:\n                candidates.append((x, y))\n    \n    return candidates\n\n    # Read input from stdin\n    robot_w, robot_h = map(int, input().split())\n    robot_image = [list(map(int, input().split())) for _ in range(robot_h)]\n    floor_w, floor_h = map(int, input().split())\n    floor_image = [list(map(int, input().split())) for _ in range(floor_h)]\n    \n    # Find and print the candidates\n    candidates = find_candidates(robot_image, floor_image)\n    for x, y in sorted(candidates):\n        print(x, y)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972291588783264,
            0.9975540041923523,
            0.9971367716789246,
            0.9969753623008728,
            0.9979203939437866,
            0.9972875714302063,
            0.9951967000961304,
            0.9971572756767273,
            0.996505618095398,
            0.9960067272186279,
            0.9975574016571045,
            0.9973251223564148,
            0.9967828392982483,
            0.9971702098846436,
            0.9972572326660156,
            0.9968466758728027,
            0.9962098002433777,
            0.9958170652389526,
            0.9958202838897705,
            0.9963927268981934
        ]
    },
    "3589": {
        "similarity": 0.9983329772949219,
        "body": "    while x >= 10:\n        product = 1\n        for digit in str(x):\n            if digit != '0':\n                product *= int(digit)\n        x = product\n    return x\n\n    count = [0] * 9\n    for i in range(L, R + 1):\n        result = repeated_digit_product(i)\n        if 1 <= result <= 9:\n            count[result - 1] += 1\n    return count\n\nL, R = map(int, input().split())\nresult = count_products(L, R)\nprint(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979350566864014,
            0.9979398846626282,
            0.9982768893241882,
            0.998083233833313,
            0.9976149201393127,
            0.9977104663848877,
            0.9970844984054565,
            0.9980910420417786,
            0.9977765679359436,
            0.9966355562210083,
            0.9971897006034851,
            0.9971010088920593,
            0.9979936480522156,
            0.9974445700645447,
            0.998002827167511,
            0.9983329772949219,
            0.9974694848060608,
            0.9982480406761169,
            0.9982292652130127,
            0.998060941696167
        ]
    },
    "3257": {
        "similarity": 0.9973214864730835,
        "body": "import sys\n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return area\n\nif __name__ == \"__main__\":\n    line = input().strip()\n    a, b, c = map(float, line.split())\n    result = calculate_triangle_area(a, b, c)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939687848091125,
            0.9964338541030884,
            0.9962193369865417,
            0.9963955283164978,
            0.9963569641113281,
            0.9963409304618835,
            0.9965008497238159,
            0.9959919452667236,
            0.9963662028312683,
            0.9951529502868652,
            0.9973214864730835,
            0.9969202280044556,
            0.9957755208015442,
            0.9973203539848328,
            0.9970727562904358,
            0.993142306804657,
            0.9963547587394714,
            0.9968741536140442,
            0.9939476847648621,
            0.9968632459640503
        ]
    },
    "3927": {
        "similarity": 0.9967547059059143,
        "body": "    from itertools import combinations\n    \n    max_revealed = 0\n    for k in range(1, n + 1):\n        for m in range(2, sum(weights) // k + 1):\n            for subset in combinations(weights, k):\n                if sum(subset) == m:\n                    remaining_weights = [w for w in weights if w not in subset]\n                    max_revealed = max(max_revealed, len(set(subset)))\n    return max_revealed\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(max_weights_revealed(n, weights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996067464351654,
            0.9964067339897156,
            0.9960606098175049,
            0.9958437085151672,
            0.995633602142334,
            0.9959054589271545,
            0.9945070147514343,
            0.9964914917945862,
            0.994560956954956,
            0.9961949586868286,
            0.9958927035331726,
            0.9939491152763367,
            0.9967547059059143,
            0.9930652976036072,
            0.9963293671607971,
            0.9960683584213257,
            0.9892391562461853,
            0.9956512451171875,
            0.9942248463630676,
            0.9958054423332214
        ]
    },
    "3319": {
        "similarity": 0.9959437847137451,
        "body": "import sys\nfrom collections import defaultdict\n\n    grid = defaultdict(lambda: None)\n    \n    for i, (m, x, y, z, v_x, v_y, v_z) in enumerate(planetoids):\n        key = (x % n_x, y % n_y, z % n_z)\n        if grid[key] is not None:\n            m_new = grid[key][0] + m\n            v_x_new = (grid[key][1] + v_x) // 2\n            v_y_new = (grid[key][2] + v_y) // 2\n            v_z_new = (grid[key][3] + v_z) // 2\n            grid[key] = (m_new, v_x_new, v_y_new, v_z_new)\n        else:\n            grid[key] = (m, v_x, v_y, v_z)\n    \n    planets = sorted([(mass, x, y, z, v_x, v_y, v_z) for (x, y, z), (mass, v_x, v_y, v_z) in grid.items()], reverse=True, key=lambda x: (-x[0], x[1], x[2], x[3]))\n    \n    return len(planets), planets\n\n    n, n_x, n_y, n_z = map(int, input().split())\n    planetoids = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    num_planets, planets = simulate_collisions(n, n_x, n_y, n_z, planetoids)\n    \n    print(num_planets)\n    for i, (mass, x, y, z, v_x, v_y, v_z) in enumerate(planets):\n        print(f\"P{i}: {mass} {x} {y} {z} {v_x} {v_y} {v_z}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995712399482727,
            0.9951450824737549,
            0.9942870140075684,
            0.9942123889923096,
            0.9946383237838745,
            0.9912313222885132,
            0.9933882355690002,
            0.9951591491699219,
            0.9954107999801636,
            0.9937418699264526,
            0.9945464730262756,
            0.9959437847137451,
            0.9931638836860657,
            0.9957880973815918,
            0.9959006905555725,
            0.9946687817573547,
            0.9950476288795471,
            0.9949415326118469,
            0.9953344464302063,
            0.9958246946334839
        ]
    },
    "3009": {
        "similarity": 0.9966832399368286,
        "body": "import sys\nfrom itertools import combinations\n\n    points = []\n    for x, y, e in lamps:\n        points.append((x, y, e))\n\n    min_length = float('inf')\n    for p1, p2 in combinations(points, 2):\n        x1, y1, e1 = p1\n        x2, y2, e2 = p2\n\n        # Check if the line through p1 and p2 divides the energy equally\n        inside_energy = 0\n        outside_energy = 0\n        for px, py, pe in points:\n            if (x1 * (y2 - py) + x2 * (py - y1) + px * (y1 - y2)) * (px * (y2 - py) + x2 * (py - y1) + x1 * (py - y2)) <= 0:\n                inside_energy += pe\n            else:\n                outside_energy += pe\n\n        if abs(inside_energy - outside_energy) < 1e-6:\n            length = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n            min_length = min(min_length, length)\n\n    return min_length if min_length != float('inf') else \"IMPOSSIBLE\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    lamps = [tuple(map(int, input().split())) for _ in range(n)]\n    result = shortest_dividing_line(n, lamps)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962913393974304,
            0.9906871318817139,
            0.9947639107704163,
            0.9962108135223389,
            0.9961172342300415,
            0.9953522086143494,
            0.9954047203063965,
            0.9927541613578796,
            0.995458722114563,
            0.9961638450622559,
            0.9963317513465881,
            0.9933338165283203,
            0.9963335990905762,
            0.9961847066879272,
            0.9955410361289978,
            0.9961949586868286,
            0.9951756000518799,
            0.9936845898628235,
            0.9960233569145203,
            0.9966832399368286
        ]
    },
    "3896": {
        "similarity": 0.9967221617698669,
        "body": "    n = len(x)\n    count_ones = x.count('1')\n    count_zeros = n - count_ones\n    \n    complexity = (count_ones * count_zeros) % 1000000007\n    return complexity\n\nif __name__ == \"__main__\":\n    x = input().strip()\n    result = dance_complexity(x)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965927600860596,
            0.9967221617698669,
            0.9962556958198547,
            0.9965282082557678,
            0.9944591522216797,
            0.9892258048057556,
            0.9949833750724792,
            0.9956861138343811,
            0.9952735900878906,
            0.995958149433136,
            0.9933156371116638,
            0.996462881565094,
            0.9966376423835754,
            0.9954145550727844,
            0.9946497082710266,
            0.9950157999992371,
            0.9965534210205078,
            0.9939603209495544,
            0.9967161417007446,
            0.9957703351974487
        ]
    },
    "3509": {
        "similarity": 0.9989678263664246,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    n = len(graph)\n    distances = [float('inf')] * n\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        dist, u = heappop(pq)\n        if dist > distances[u]:\n            continue\n        for v, t in graph[u]:\n            new_dist = dist + t\n            if new_dist < distances[v]:\n                distances[v] = new_dist\n                heappush(pq, (new_dist, v))\n    \n    return distances\n\n    graph = [[] for _ in range(n)]\n    for u, v, t in roads:\n        graph[u-1].append((v-1, t))\n    \n    from_home = dijkstra(graph, 0)\n    to_home = [float('inf')] * n\n    for i in range(n):\n        if i != 0:\n            to_home[i] = min(to_home[i], from_home[i])\n    \n    max_wait = 0\n    for t in range(a, b + 1):\n        wait_time = float('inf')\n        for u in range(n):\n            if from_home[u] <= t and t < from_home[u] + to_home[u]:\n                wait_time = min(wait_time, t - from_home[u])\n        max_wait = max(max_wait, wait_time)\n    \n    return max_wait\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    n, m = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    result = min_worst_case_wait(a, b, n, m, roads)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9988872408866882,
            0.998285174369812,
            0.9981554746627808,
            0.9976083636283875,
            0.9975698590278625,
            0.9987921714782715,
            0.9988758563995361,
            0.9986039400100708,
            0.9986833333969116,
            0.9988052845001221,
            0.998449444770813,
            0.9982187151908875,
            0.9973744750022888,
            0.9989678263664246,
            0.9986648559570312,
            0.9987961649894714,
            0.9984625577926636,
            0.9989579916000366,
            0.9989330768585205,
            0.9989011883735657
        ]
    },
    "3547": {
        "similarity": 0.9957990050315857,
        "body": "import sys\n\n    n = int(input().strip())\n    plots = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().strip().split())\n        plots.append(((x1, y1), (x2, y2)))\n    \n    covered_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            (x1_i, y1_i), (x2_i, y2_i) = plots[i]\n            (x1_j, y1_j), (x2_j, y2_j) = plots[j]\n            overlap_x = max(0, min(x2_i, x2_j) - max(x1_i, x1_j))\n            overlap_y = max(0, min(y2_i, y2_j) - max(y1_i, y1_j))\n            overlap_area = overlap_x * overlap_y\n            if overlap_area > 0:\n                covered_area += (x2_i - x1_i) * (y2_i - y1_i) - overlap_area\n    \n    print(f\"{covered_area:.2f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941524863243103,
            0.9947553277015686,
            0.9863343834877014,
            0.9941909313201904,
            0.9941522479057312,
            0.9951854348182678,
            0.9920319318771362,
            0.9943692088127136,
            0.9928938150405884,
            0.9933885335922241,
            0.9944697022438049,
            0.9936959147453308,
            0.9929676055908203,
            0.9930819272994995,
            0.9928263425827026,
            0.9926344156265259,
            0.9957990050315857,
            0.9944078326225281,
            0.9926248788833618,
            0.9943931102752686
        ]
    },
    "3017": {
        "similarity": 0.998016357421875,
        "body": "    power_of_two = str(2 ** e)\n    count = 0\n    for i in range(n + 1):\n        if str(i).find(power_of_two) != -1:\n            count += 1\n    return count\n\n# Read input from stdin\nn, e = map(int, input().split())\n\n# Print the result\nprint(count_numbers_with_power_of_two(n, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971877932548523,
            0.9964647889137268,
            0.9979715943336487,
            0.9959847331047058,
            0.9960444569587708,
            0.9972943067550659,
            0.9973289370536804,
            0.9959887266159058,
            0.9964662194252014,
            0.9977117776870728,
            0.9950411915779114,
            0.9975097179412842,
            0.997791588306427,
            0.9967440366744995,
            0.9973536133766174,
            0.9967790246009827,
            0.9976696372032166,
            0.998016357421875,
            0.9978073835372925,
            0.9979434609413147
        ]
    },
    "3076": {
        "similarity": 0.9981004595756531,
        "body": "    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        s, v = jewels[i - 1]\n        for w in range(1, k + 1):\n            if s <= w:\n                dp[i][w] = max(dp[i-1][w], dp[i-1][w-s] + v)\n            else:\n                dp[i][w] = dp[i-1][w]\n    \n    return [dp[n][w] for w in range(1, k + 1)]\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    jewels = [(int(data[2*i+2]), int(data[2*i+3])) for i in range(n)]\n    \n    result = knapsack_max_value(n, k, jewels)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978668093681335,
            0.9979994893074036,
            0.9977654814720154,
            0.9968076944351196,
            0.9970712065696716,
            0.9963252544403076,
            0.9974268674850464,
            0.9952676892280579,
            0.9951938986778259,
            0.9978417754173279,
            0.9976041913032532,
            0.9967296123504639,
            0.9979541301727295,
            0.996850848197937,
            0.9978166222572327,
            0.9961215853691101,
            0.9974516034126282,
            0.9971245527267456,
            0.9981004595756531,
            0.9966590404510498
        ]
    },
    "3923": {
        "similarity": 0.9972768425941467,
        "body": "    if abs(A - B) > 1 or N % (A + B) != 0:\n        return -1\n    \n    perm = list(range(1, N + 1))\n    i, j = 1, 2 * N // (A + B)\n    \n    for _ in range(N):\n        if i <= A:\n            perm[i - 1] = j\n            i += 1\n        else:\n            perm[j - 1] = i\n            j -= 1\n    \n    return perm\n\nN, A, B = map(int, input().split())\nresult = find_permutation(N, A, B)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970809817314148,
            0.9961029887199402,
            0.9967256188392639,
            0.9960748553276062,
            0.9956472516059875,
            0.9964298605918884,
            0.9966734647750854,
            0.9969994425773621,
            0.9972768425941467,
            0.996881365776062,
            0.9952380657196045,
            0.9968826174736023,
            0.9964778423309326,
            0.9959508180618286,
            0.9971851706504822,
            0.9944673776626587,
            0.9956760406494141,
            0.9963895082473755,
            0.9968113303184509,
            0.9960283041000366
        ]
    },
    "3332": {
        "similarity": 0.9970255494117737,
        "body": "import sys\nfrom typing import List, Tuple\n\n    streams.sort(key=lambda x: (x[0], -x[2]))\n    \n    stack = []\n    total_priority = 0\n    \n    for start, duration, priority in streams:\n        if not stack or start >= stack[-1][0] + stack[-1][1]:\n            stack.append((start, duration))\n            total_priority += priority\n        elif stack and stack[-1][2] < priority:\n            stack.pop()\n            stack.append((start, duration))\n            total_priority -= stack[-2][2]\n            total_priority += priority\n    \n    return total_priority\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    streams = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    print(max_priority(n, streams))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930093884468079,
            0.9961927533149719,
            0.996724009513855,
            0.9961502552032471,
            0.9914502501487732,
            0.9966306090354919,
            0.9963526725769043,
            0.9960102438926697,
            0.9959590435028076,
            0.9938125610351562,
            0.9968709349632263,
            0.9948778748512268,
            0.9970255494117737,
            0.9960663318634033,
            0.9964715838432312,
            0.9963583946228027,
            0.9969024658203125,
            0.9963864684104919,
            0.9956445097923279,
            0.9961126446723938
        ]
    },
    "3240": {
        "similarity": 0.9964592456817627,
        "body": "import sys\nfrom typing import List\n\n    total_votes = 1 << k\n    expected_positions = [0] * total_votes\n    \n    for p, b in probabilities_and_ballots:\n        prob_vote = p / (p + 1)\n        prob_not_vote = 1 - prob_vote\n        for i in range(total_votes):\n            if i & b == 0:\n                expected_positions[i] += prob_vote * (i >> k & 1) * prob_not_vote ** (k - (i >> k).bit_length())\n            else:\n                expected_positions[i] += prob_vote * (not (i >> k & 1)) * prob_not_vote ** (k - (i >> k).bit_length())\n    \n    max_expected = -1\n    optimal_ballots = 0\n    for b in range(total_votes):\n        if b == 0:\n            continue\n        total_balls = b | (1 << k) - 1\n        expected_yraglac = sum(expected_positions[i] * ((total_balls & (1 << i)) != 0) for i in range(k))\n        if expected_yraglac > max_expected:\n            max_expected = expected_yraglac\n            optimal_ballots = b\n    \n    return optimal_ballots\n\nif __name__ == \"__main__\":\n    k, v = map(int, input().split())\n    probabilities_and_ballots = [list(map(float, input().split())) for _ in range(v - 1)]\n    print(maximize_yraglac_positions(k, v, probabilities_and_ballots))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954890012741089,
            0.9964592456817627,
            0.9940683245658875,
            0.9958815574645996,
            0.9875712990760803,
            0.9960713982582092,
            0.9957923889160156,
            0.9956831932067871,
            0.9950035810470581,
            0.995822012424469,
            0.9953296184539795,
            0.9939017295837402,
            0.9961563944816589,
            0.9957863688468933,
            0.9964469075202942,
            0.9961867332458496,
            0.9957706332206726,
            0.9963732361793518,
            0.9959551095962524,
            0.9952560067176819
        ]
    },
    "3368": {
        "similarity": 0.9963782429695129,
        "body": "    correct_enclosures = {i: [] for i in range(n)}\n    \n    # Determine the correct enclosures for each animal type\n    for i in range(n):\n        _, count, *animals = input().split()\n        correct_enclosures[i] = animals\n    \n    current_enclosures = {}\n    \n    # Count the animals currently in each enclosure\n    for _ in range(m):\n        _, enclosure_id, animal_type = input().split()\n        enclosure_id = int(enclosure_id)\n        if enclosure_id not in current_enclosures:\n            current_enclosures[enclosure_id] = []\n        current_enclosures[enclosure_id].append(animal_type)\n    \n    # Check if we can move animals to correct enclosures\n    for enclosure_id, animals in current_enclosures.items():\n        for animal in animals:\n            if animal not in correct_enclosures[enclosure_id]:\n                return \"POSSIBLE\"\n    \n    return \"FALSE ALARM\"\n\n# Read input\nn, m = map(int, input().split())\nresult = can_restore_animals(n, m, [None] * n)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.995977520942688,
            0.9945350289344788,
            0.9953869581222534,
            0.9947752952575684,
            0.9958315491676331,
            0.9959223866462708,
            0.9963782429695129,
            0.9961212873458862,
            0.9949353933334351,
            0.9956914782524109,
            0.9871968626976013,
            0.9928006529808044,
            0.9943476319313049,
            0.9958468079566956,
            0.9956823587417603,
            0.9949732422828674,
            0.9933815002441406,
            0.9958235025405884,
            0.9950720071792603,
            0.9956843852996826
        ]
    },
    "3538": {
        "similarity": 0.9970166087150574,
        "body": "    frogs.sort(key=lambda x: (-x[2], -x[0]))\n    total_weight = 0\n    stack = []\n    \n    for l, w, h in frogs:\n        if total_weight + w <= w:\n            stack.append((h, l))\n            total_weight += w\n    \n    escape_count = len(stack)\n    while stack and stack[-1][0] + sum(frog[1] for frog in stack) > d:\n        escape_count -= 1\n        h, l = stack.pop()\n        total_weight -= h\n    \n    return escape_count\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nd = int(data[1])\nfrogs = [(int(data[i*3+2]), int(data[i*3+3]), int(data[i*3+4])) for i in range(n)]\n\nprint(max_frogs_escaping(n, d, frogs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949741363525391,
            0.9957829713821411,
            0.9951908588409424,
            0.9941667318344116,
            0.9970166087150574,
            0.9956122040748596,
            0.9965085387229919,
            0.9969781637191772,
            0.9968644976615906,
            0.9966569542884827,
            0.9954330325126648,
            0.9965732097625732,
            0.9889512658119202,
            0.9965396523475647,
            0.9947861433029175,
            0.9969388842582703,
            0.9968906044960022,
            0.9962270855903625,
            0.9953653216362,
            0.9963573813438416
        ]
    },
    "3183": {
        "similarity": 0.9986119866371155,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    graph = [[] for _ in range(n)]\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))  # Reverse edge with negative cost\n\n        dist = [float('inf')] * n\n        dist[s] = 0\n        prev = [-1] * n\n        queue = [(0, s)]\n        while queue:\n            d, u = heappop(queue)\n            if d != dist[u]:\n                continue\n            for v, c, w in graph[u]:\n                if c > 0 and dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    prev[v] = (u, c, w)\n                    heappush(queue, (dist[v], v))\n        return prev\n\n    flow = 0\n    cost = 0\n    while True:\n        prev = bfs()\n        if prev[t] == -1:\n            break\n        path_flow = float('inf')\n        s_node = t\n        while s_node != s:\n            u, c, w = prev[s_node]\n            path_flow = min(path_flow, c)\n            s_node = u\n\n        flow += path_flow\n        cost += path_flow * dist[t]\n\n        s_node = t\n        while s_node != s:\n            u, c, w = prev[s_node]\n            graph[u][next(i for i, (v, _, _) in enumerate(graph[u]) if v == s_node)][1] -= path_flow\n            graph[s_node][next(i for i, (v, _, _) in enumerate(graph[s_node]) if v == u)][1] += path_flow\n            s_node = u\n\n    return flow, cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    m = int(data[1])\n    s = int(data[2])\n    t = int(data[3])\n    edges = []\n    index = 4\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        c = int(data[index + 2])\n        w = int(data[index + 3])\n        edges.append((u, v, c, w))\n        index += 4\n\n    result = min_cost_max_flow(n, m, s, t, edges)\n    print(result[0], result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976996183395386,
            0.9984287619590759,
            0.9978318810462952,
            0.9981479644775391,
            0.9984358549118042,
            0.9986119866371155,
            0.9981720447540283,
            0.9983998537063599,
            0.9975989460945129,
            0.9974344968795776,
            0.9982976317405701,
            0.9980894327163696,
            0.9983137249946594,
            0.9971540570259094,
            0.9986014366149902,
            0.997859537601471,
            0.9969395399093628,
            0.9975446462631226,
            0.9973854422569275,
            0.9985361695289612
        ]
    },
    "3916": {
        "similarity": 0.9976150393486023,
        "body": "import sys\n\n    max_k = max(k_values)\n    factorial = [0] * (max_k + 1)\n    factorial[0] = factorial[1] = 1\n    for i in range(2, max_k + 1):\n        factorial[i] = factorial[i - 1] * i\n\n        if x % 2 == 0:\n            return 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return i\n        return x\n\n    graph = {}\n    for k in range(1, max_k + 1):\n        node = factorial[k]\n        divisor = find_lowest_prime_divisor(node)\n        next_node = node // divisor\n        if next_node not in graph:\n            graph[next_node] = set()\n        graph[node].add(next_node)\n\n        from collections import deque\n        queue = deque([start])\n        distance = {node: float('inf') for node in graph}\n        distance[start] = 0\n        while queue:\n            current = queue.popleft()\n            for neighbor in graph[current]:\n                if distance[neighbor] > distance[current] + 1:\n                    distance[neighbor] = distance[current] + 1\n                    queue.append(neighbor)\n        return distance\n\n    distances = []\n    for k in k_values:\n        node = factorial[k]\n        distance = bfs(node)\n        max_distance = max(distance.values())\n        distances.extend([max_distance] * k)\n\n    return sum(distances)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    k_values = list(map(int, input().strip().split()))\n    result = min_path_sum(n, k_values)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996077299118042,
            0.9970782399177551,
            0.9963770508766174,
            0.9971714019775391,
            0.9975762963294983,
            0.9964320659637451,
            0.995976984500885,
            0.995509684085846,
            0.9972462058067322,
            0.9971040487289429,
            0.9969492554664612,
            0.9957505464553833,
            0.99664306640625,
            0.997260332107544,
            0.9976150393486023,
            0.9965705871582031,
            0.9971678853034973,
            0.9965593218803406,
            0.9973595142364502,
            0.9973852038383484
        ]
    },
    "3195": {
        "similarity": 0.9965475797653198,
        "body": "import sys\n\n    T = observations[0][0]\n    cycle_length = Tg + Ty + Tr\n    \n    start_indices = []\n    for i in range(n):\n        if observations[i][1] == cq:\n            start_indices.append(i)\n    \n    probabilities = [0] * (n - len(start_indices) + 1)\n    \n    for index in start_indices:\n        time_since_start = observations[index][0] - T\n        cycle_index = time_since_start % cycle_length\n        \n        if cq == 'green':\n            if cycle_index < Tg:\n                probabilities[index - start_indices[0]] += 1\n        elif cq == 'yellow':\n            if Tg <= cycle_index < Tg + Ty:\n                probabilities[index - start_indices[0]] += 1\n        elif cq == 'red':\n            if Tg + Ty <= cycle_index < cycle_length:\n                probabilities[index - start_indices[0]] += 1\n    \n    total_observations = n - len(start_indices) + 1\n    probability = sum(probabilities) / total_observations\n    \n    return probability\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    Tg = int(data[index])\n    index += 1\n    Ty = int(data[index])\n    index += 1\n    Tr = int(data[index])\n    index += 1\n    \n    n = int(data[index])\n    index += 1\n    \n    observations = []\n    for _ in range(n):\n        t = int(data[index])\n        index += 1\n        c = data[index]\n        index += 1\n        observations.append((t, c))\n    \n    tq = int(data[index])\n    index += 1\n    cq = data[index]\n    \n    probability = traffic_light_probability(Tg, Ty, Tr, n, observations, tq, cq)\n    print(f\"{probability:.3f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959009885787964,
            0.9950028657913208,
            0.9965066313743591,
            0.9952872395515442,
            0.9953859448432922,
            0.9965475797653198,
            0.9926454424858093,
            0.9947509765625,
            0.9951551556587219,
            0.9952235221862793,
            0.9955982565879822,
            0.9960371255874634,
            0.9954704642295837,
            0.9960616230964661,
            0.9900619387626648,
            0.9959822297096252,
            0.9957360625267029,
            0.9958173632621765,
            0.9959314465522766,
            0.9957521557807922
        ]
    },
    "3998": {
        "similarity": 0.997564435005188,
        "body": "import sys\n\n    n = int(input().strip())\n    ratings = list(map(int, input().strip().split()))\n    \n    max_rating = min(ratings)\n    matches = []\n    \n    for _ in range(n):\n        current_ratings = ratings[:]\n        match_count = 0\n        while sum(current_ratings) > n * max_rating:\n            match = [i for i, r in enumerate(current_ratings) if r == max_rating and len([j for j in current_ratings if j < max_rating]) >= 5 - len(match)]\n            if not match:\n                break\n            for m in match:\n                current_ratings[m] -= 1\n                match_count += 1\n        matches.append((match_count, ''.join('1' if i in match else '0' for i in range(n))))\n    \n    print(max_rating)\n    print(len(matches))\n    for count, pattern in matches:\n        print(pattern)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971347451210022,
            0.9973641633987427,
            0.9966346621513367,
            0.9972345232963562,
            0.9966830015182495,
            0.9971088767051697,
            0.9966763257980347,
            0.9968000054359436,
            0.9964287281036377,
            0.9973229765892029,
            0.9965513944625854,
            0.995448887348175,
            0.9949896931648254,
            0.997564435005188,
            0.9971656799316406,
            0.996531069278717,
            0.9972288012504578,
            0.9974104166030884,
            0.9970541596412659,
            0.9975009560585022
        ]
    },
    "3150": {
        "similarity": 0.9964986443519592,
        "body": "import sys\nfrom collections import defaultdict\n\n    x1, y1, x2, y2 = trench\n    gx, gy = guard\n    if (gx == x1 or gx == x2) and (gy == y1 or gy == y2):\n        return True\n    return False\n\n    guards = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if can_see_each_other(trenches[i], trenches[j]):\n                guards.add(tuple(trenches[i]))\n                guards.add(tuple(trenches[j]))\n    \n    count = defaultdict(int)\n    for guard1, guard2 in guards:\n        x1, y1 = guard1\n        x2, y2 = guard2\n        if (x1 == x2 or y1 == y2):\n            line = sorted([guard1, guard2])\n            count[tuple(line)] += 1\n    \n    return sum(count.values())\n\nN = int(input())\ntrenches = [tuple(map(int, input().split())) for _ in range(N)]\nprint(count_ways(N, trenches))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963403344154358,
            0.9949037432670593,
            0.994327962398529,
            0.9958724975585938,
            0.9961602091789246,
            0.9946284890174866,
            0.9962309002876282,
            0.9920152425765991,
            0.9928911924362183,
            0.9962123036384583,
            0.9964986443519592,
            0.9959983825683594,
            0.9955785870552063,
            0.9938596487045288,
            0.9954022765159607,
            0.9952864646911621,
            0.9957746267318726,
            0.9952796101570129,
            0.9934673309326172,
            0.9960036873817444
        ]
    },
    "3566": {
        "similarity": 0.9966025352478027,
        "body": "import sys\n\n    for _ in range(q):\n        i, x = map(int, input().split())\n        a[i] = x\n        \n        left_sum = 0\n        right_sum = sum(a) - a[i]\n        \n        min_diff = float('inf')\n        optimal_pos = -1\n        \n        for j in range(n):\n            left_sum += a[j]\n            right_sum -= a[j]\n            diff = abs(left_sum - right_sum)\n            if diff < min_diff:\n                min_diff = diff\n                optimal_pos = j + 1\n        \n        print(optimal_pos)\n\n# Read input from stdin\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\nfind_optimal_position(n, q, a)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966025352478027,
            0.9965616464614868,
            0.9953250885009766,
            0.9955679178237915,
            0.9929155111312866,
            0.9949809908866882,
            0.9920511841773987,
            0.9961744546890259,
            0.9959668517112732,
            0.9914829730987549,
            0.9913341999053955,
            0.9959686994552612,
            0.9961739778518677,
            0.9945477843284607,
            0.9956566691398621,
            0.9957318902015686,
            0.99591064453125,
            0.9938772320747375,
            0.9964191913604736,
            0.9942732453346252
        ]
    },
    "3401": {
        "similarity": 0.997077465057373,
        "body": "import sys\nfrom typing import List\n\n    from heapq import heappop, heappush\n    \n        distances = [float('inf')] * (n + 1)\n        distances[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_distance, u = heappop(pq)\n            if current_distance > distances[u]:\n                continue\n            for v in graph[u]:\n                distance = current_distance + abs(hills[v-1][2] - hills[u-1][2])\n                if distance < distances[v]:\n                    distances[v] = distance\n                    heappush(pq, (distance, v))\n        \n        return distances\n    \n    if s != t:\n        return 'IMPOSSIBLE'\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for u, v, w in zip(hills[:-1], hills[1:], hills[2:]):\n        graph[u[0]].append(v[0])\n        graph[v[0]].append(w[0])\n    \n    min_length = float('inf')\n    \n    for s_hill in springs:\n        dist_spring = dijkstra(s_hill)\n        for t_hill in towns:\n            if dist_spring[t_hill] < min_length:\n                min_length = dist_spring[t_hill]\n    \n    return round(min_length, 6) if min_length != float('inf') else 'IMPOSSIBLE'\n\n# Read input from stdin\ndata = sys.stdin.read().split()\nindex = 0\n\nn = int(data[index])\ns = int(data[index + 1])\nt = int(data[index + 2])\nq = int(data[index + 3])\n\nhills = []\nfor _ in range(n):\n    x = int(data[index + 4])\n    y = int(data[index + 5])\n    h = int(data[index + 6])\n    hills.append([x, y, h])\n    index += 7\n\nsprings = list(map(int, data[index:index + s]))\nindex += s\n\ntowns = list(map(int, data[index:]))\n\n# Output the result\nprint(min_aqueduct_length(n, s, t, q, hills, springs, towns))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963808655738831,
            0.9967620372772217,
            0.9964954853057861,
            0.993973970413208,
            0.9968705773353577,
            0.9967211484909058,
            0.995033860206604,
            0.9969683289527893,
            0.9945486783981323,
            0.9966753721237183,
            0.9953299164772034,
            0.9948344826698303,
            0.9933128356933594,
            0.9969201683998108,
            0.9961381554603577,
            0.9940882325172424,
            0.997077465057373,
            0.9966229796409607,
            0.9955912232398987,
            0.9957411885261536
        ]
    },
    "3660": {
        "similarity": 0.9976370930671692,
        "body": "    message = input().strip()\n    n = int(input().strip())\n    stickers = []\n    for _ in range(n):\n        word, price = input().strip().split()\n        stickers.append((word, int(price)))\n    \n    m = len(message)\n    dp = [[float('inf')] * (m + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, m + 1):\n        for j in range(i):\n            if i - j <= 2:\n                for word, price in stickers:\n                    if message[j:i] == word:\n                        dp[i][j] = min(dp[i][j], dp[j][i-1] + price)\n    \n    if dp[m][0] == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        print(dp[m][0])\n\nmin_cost_message()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952268004417419,
            0.996134340763092,
            0.9957868456840515,
            0.9961214661598206,
            0.9951441884040833,
            0.9958546161651611,
            0.9972267150878906,
            0.9973006248474121,
            0.9967831373214722,
            0.9971894025802612,
            0.993583083152771,
            0.9957765340805054,
            0.9965616464614868,
            0.9970808625221252,
            0.9969265460968018,
            0.9971533417701721,
            0.9969014525413513,
            0.9976370930671692,
            0.9970273375511169,
            0.9964087605476379
        ]
    },
    "3721": {
        "similarity": 0.9955155253410339,
        "body": "    rows = set()\n    cols = set()\n    \n    for r, c in elements:\n        rows.add(r)\n        cols.add(c)\n    \n    total_required = n * m\n    already_have = len(rows) * len(cols)\n    \n    return max(0, total_required - already_have)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nq = int(data[2])\n\nelements = [(int(data[i*3+3]), int(data[i*3+4])) for i in range(q)]\n\nprint(min_elements_to_purchase(n, m, q, elements))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99370938539505,
            0.9932613372802734,
            0.9919064044952393,
            0.9935858845710754,
            0.9914263486862183,
            0.9927952289581299,
            0.993728756904602,
            0.991108775138855,
            0.9931954145431519,
            0.9941366314888,
            0.9915216565132141,
            0.9947961568832397,
            0.9934678673744202,
            0.9955155253410339,
            0.9947130084037781,
            0.9921914935112,
            0.9952543377876282,
            0.9943400025367737,
            0.9942877888679504,
            0.9932586550712585
        ]
    },
    "3811": {
        "similarity": 0.9975807070732117,
        "body": "import math\n\n    while b:\n        a, b = b, a % b\n    return a\n\n    current_wcd = 1\n    for a, b in pairs:\n        current_wcd = gcd(current_wcd, a)\n        current_wcd = gcd(current_wcd, b)\n    if current_wcd == 1:\n        return -1\n    return current_wcd\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    pairs = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    print(wcd(pairs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975311756134033,
            0.9968864321708679,
            0.9974504709243774,
            0.9965516924858093,
            0.9971954226493835,
            0.9959632754325867,
            0.9975807070732117,
            0.9972680807113647,
            0.995395839214325,
            0.9963082671165466,
            0.9971919655799866,
            0.9956793785095215,
            0.9968368411064148,
            0.9970272779464722,
            0.9968239665031433,
            0.9970853924751282,
            0.9973582029342651,
            0.996910810470581,
            0.9967708587646484,
            0.9970692992210388
        ]
    },
    "3528": {
        "similarity": 0.9977840781211853,
        "body": "import sys\nfrom typing import List, Tuple\n\n    x_sorted = sorted(nails)\n    y_sorted = sorted(nails, key=lambda p: -p[1])\n    return 0.5 * (x_sorted[-1][0] - x_sorted[0][0]) * (y_sorted[0][1] - y_sorted[-1][1])\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    nails = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    choices = data[N+1:N+N-2]\n    \n    areas = []\n    while len(nails) > 3:\n        area = calculate_area(nails)\n        areas.append(area)\n        \n        if choices.pop(0) == 'L':\n            nails.remove(min(nails))\n        elif choices.pop(0) == 'R':\n            nails.remove(max(nails, key=lambda p: p[0]))\n        elif choices.pop(0) == 'U':\n            nails.remove(max(nails, key=lambda p: p[1]))\n        else:\n            nails.remove(min(nails, key=lambda p: p[1]))\n    \n    for area in areas:\n        print(f\"{area:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976805448532104,
            0.9958885908126831,
            0.9964897632598877,
            0.9965875744819641,
            0.9942920207977295,
            0.9968762993812561,
            0.9952103495597839,
            0.9976772665977478,
            0.9976910948753357,
            0.9964978098869324,
            0.9969325065612793,
            0.9968588948249817,
            0.9969096183776855,
            0.9973134398460388,
            0.9977840781211853,
            0.996148943901062,
            0.9974626302719116,
            0.9950653910636902,
            0.9969863891601562,
            0.9975193738937378
        ]
    },
    "3890": {
        "similarity": 0.9975320100784302,
        "body": "    MOD = 10**9 + 7\n    if k == n:\n        return 1\n    elif k == 1:\n        return (n - 1) * (n - 2) // 2 % MOD\n    \n    dp = [0] * (k + 1)\n    dp[1] = 1\n    for i in range(2, k + 1):\n        dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    \n    result = 0\n    for i in range(k, n + 1):\n        result = (result + dp[k - 1]) % MOD\n    return result\n\n# Read input from stdin\nn, k = map(int, input().split())\nprint(count_plaque_arrangements(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973006248474121,
            0.9958949685096741,
            0.996724009513855,
            0.9975320100784302,
            0.9966314435005188,
            0.9966579079627991,
            0.9957249164581299,
            0.9951475858688354,
            0.996986985206604,
            0.9959427714347839,
            0.9945587515830994,
            0.9953324198722839,
            0.996799886226654,
            0.9971771240234375,
            0.9946849346160889,
            0.9943649172782898,
            0.9971691966056824,
            0.9967139363288879,
            0.9951242208480835,
            0.9966964721679688
        ]
    },
    "3534": {
        "similarity": 0.9986469745635986,
        "body": "import sys\n\n    max_correct = 0\n    best_K = 0\n    \n    for K in range(2 * 10**9 + 1):\n        correct_count = N\n        current_key = a[0]\n        \n        for i in range(1, N):\n            if a[i] > a[i - 1]:\n                next_key = current_key + K\n            elif a[i] < a[i - 1]:\n                next_key = current_key - K\n            else:\n                next_key = current_key\n        \n            if abs(next_key - a[i]) > 2 * 10**9:\n                correct_count -= 1\n            \n            current_key = next_key\n        \n        if correct_count > max_correct:\n            max_correct = correct_count\n            best_K = K\n    \n    return max_correct, best_K\n\n# Read input\nN = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Find and print the result\nresult = find_max_correct_keys(N, a)\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981934428215027,
            0.9985302686691284,
            0.9983077645301819,
            0.9967221021652222,
            0.995634913444519,
            0.9986464977264404,
            0.9978616833686829,
            0.9983392357826233,
            0.9981109499931335,
            0.9983022809028625,
            0.9982265830039978,
            0.9980669617652893,
            0.9980480074882507,
            0.9982349872589111,
            0.9985153675079346,
            0.9977914690971375,
            0.9983940124511719,
            0.9984235167503357,
            0.9984725117683411,
            0.9986469745635986
        ]
    },
    "3371": {
        "similarity": 0.9977830648422241,
        "body": "import sys\n\n    participants = set(range(1, n + 1))\n    graph = {i: [] for i in participants}\n    \n    for a, b, y in encounters:\n        graph[a].append((b, y))\n        graph[b].append((a, y))\n    \n        stack = [(node, year)]\n        while stack:\n            current, current_year = stack.pop()\n            if current not in visited:\n                visited.add(current)\n                for neighbor, neighbor_year in graph[current]:\n                    if neighbor not in visited and (neighbor_year < current_year or neighbor_year == 2008):\n                        stack.append((neighbor, neighbor_year))\n    \n        return len(visited1) <= 2 * n // 3 and len(visited2) <= 2 * n // 3\n    \n    for year in range(1948, 2008):\n        visited1 = set()\n        dfs(1, year, visited1)\n        \n        visited2 = participants - visited1\n        if can_divide(visited1, visited2):\n            return year\n    \n    return \"Impossible\"\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    c = int(data[1])\n    encounters = [(int(data[i * 3 + 2]), int(data[i * 3 + 3]), int(data[i * 3 + 4])) for i in range(c)]\n    \n    result = find_division(n, c, encounters)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977018237113953,
            0.9975134134292603,
            0.9973649382591248,
            0.9976391196250916,
            0.9976302981376648,
            0.9974397420883179,
            0.9977300763130188,
            0.9972048401832581,
            0.9975007772445679,
            0.9973058104515076,
            0.9972927570343018,
            0.9968349933624268,
            0.9974859356880188,
            0.9977830648422241,
            0.9961543083190918,
            0.9975587725639343,
            0.9966214895248413,
            0.997205913066864,
            0.9965513944625854,
            0.9975596070289612
        ]
    },
    "3621": {
        "similarity": 0.9974865317344666,
        "body": "MOD = 10**9 + 7\n\n        size = 1\n        for neighbor in range(n):\n            if colors[node][neighbor] == color:\n                if neighbor != parent:\n                    size += dfs(neighbor, node, color)\n        return size\n    \n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors[i][j] > 0:\n                size_i = dfs(i, j, colors[i][j])\n                size_j = dfs(j, i, colors[i][j])\n                total_sum += (size_i * size_j)\n    return total_sum % MOD\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    index = 1\n    colors = []\n    for i in range(n):\n        row = [int(data[index + j]) for j in range(n)]\n        colors.append(row)\n        index += n\n    \n    result = max_subset_size(n, colors)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971656799316406,
            0.9972356557846069,
            0.9965928792953491,
            0.9965090751647949,
            0.996468186378479,
            0.9958295226097107,
            0.9971550703048706,
            0.9968581795692444,
            0.9973779320716858,
            0.9966069459915161,
            0.9971442818641663,
            0.9974865317344666,
            0.9968088865280151,
            0.9965984225273132,
            0.9972072243690491,
            0.9974822998046875,
            0.9971978068351746,
            0.9962884783744812,
            0.9963883757591248,
            0.9972679615020752
        ]
    },
    "3392": {
        "similarity": 0.9979361295700073,
        "body": "import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10**6)\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < N and 0 <= y < N\n    \n        queue = deque([(start_x, start_y)])\n        visited = set()\n        visited.add((start_x, start_y))\n        group_size = 1\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited and heights[nx][ny] == heights[x][y]:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    group_size += 1\n        \n        return group_size\n    \n    max_group_size = 0\n    for i in range(N):\n        for j in range(N):\n            if (i, j) not in visited:\n                max_group_size = max(max_group_size, bfs(i, j))\n    \n    return max_group_size\n\nN = int(input().strip())\nheights = []\ngrowth_speeds = []\n\nfor _ in range(N):\n    heights.append(list(map(int, input().strip().split())))\n\nfor _ in range(N):\n    growth_speeds.append(list(map(int, input().strip().split())))\n\nprint(largest_connected_group(N, heights, growth_speeds))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978001117706299,
            0.997767984867096,
            0.996535062789917,
            0.9964105486869812,
            0.9967988729476929,
            0.9972052574157715,
            0.9979361295700073,
            0.9975079298019409,
            0.9956687092781067,
            0.9974313974380493,
            0.99779212474823,
            0.9971825480461121,
            0.9968311190605164,
            0.9971283674240112,
            0.9950025677680969,
            0.9967473745346069,
            0.9975935220718384,
            0.9971200823783875,
            0.9962242841720581,
            0.9965354800224304
        ]
    },
    "3095": {
        "similarity": 0.9963963031768799,
        "body": "        r = len(submatrix)\n        s = len(submatrix[0])\n        if r < 2 or s < 2:\n            return False\n        return submatrix[0][0] + submatrix[r-1][s-1] <= submatrix[0][s-1] + submatrix[r-1][0]\n\n    max_elements = 0\n\n    for i in range(R):\n        for j in range(S):\n            for k in range(i+1, R):\n                for l in range(j+1, S):\n                    submatrix = [row[j:l] for row in matrix[i:k]]\n                    if is_cool(submatrix):\n                        max_elements = max(max_elements, (k-i)*(l-j))\n\n    return max_elements\n\n# Read input\nR, S = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(R)]\n\n# Output the result\nprint(max_elements_in_extremely_cool_submatrix(R, S, matrix))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961305260658264,
            0.9963836669921875,
            0.9944931864738464,
            0.9947397112846375,
            0.9952398538589478,
            0.9959738850593567,
            0.9928058981895447,
            0.9937641024589539,
            0.995283842086792,
            0.9926995635032654,
            0.9963963031768799,
            0.9961826801300049,
            0.9946372509002686,
            0.9946088194847107,
            0.9933832287788391,
            0.9949114918708801,
            0.9956005811691284,
            0.9947176575660706,
            0.9955576062202454,
            0.9949197173118591
        ]
    },
    "3769": {
        "similarity": 0.9966159462928772,
        "body": "MOD = 10**9 + 7\n\n    if k == 0:\n        return p % MOD\n    else:\n        return pow(p, k, MOD)\n\np, k = map(int, input().split())\nprint(count_functions(p, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948061108589172,
            0.9850167036056519,
            0.9950209259986877,
            0.9957991242408752,
            0.994945228099823,
            0.9963066577911377,
            0.9936039447784424,
            0.9960625171661377,
            0.996131181716919,
            0.9930431842803955,
            0.9942876696586609,
            0.9932993650436401,
            0.996073305606842,
            0.9959940910339355,
            0.9963930249214172,
            0.9941537976264954,
            0.9959909319877625,
            0.9961563944816589,
            0.9944642782211304,
            0.9966159462928772
        ]
    },
    "3563": {
        "similarity": 0.996638834476471,
        "body": "import sys\n\n    # Sort holes by x-coordinate\n    holes.sort(key=lambda x: (x[0], x[1]))\n    \n    lines = 0\n    i = 0\n    \n    while i < n:\n        # Find the rightmost hole in the current line\n        rightmost = i + 1\n        for j in range(i + 2, n):\n            if holes[j][0] > holes[rightmost][0]:\n                rightmost = j\n        \n        # Increment the number of lines and move to the next set of holes\n        lines += 1\n        i = rightmost + 1\n    \n    return lines\n\n# Read input from stdin\ninput_data = sys.stdin.read()\ndata = list(map(int, input_data.split()))\n\nn = data[0]\nholes = [(data[2 * i + 1], data[2 * i + 2]) for i in range(n)]\n\n# Calculate and print the result\nprint(min_lines_to_cover_holes(n, holes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957680106163025,
            0.9951242208480835,
            0.9924135804176331,
            0.9911801218986511,
            0.9937061667442322,
            0.9942699074745178,
            0.9931668639183044,
            0.9954491853713989,
            0.9963701367378235,
            0.996029794216156,
            0.996638834476471,
            0.9888381958007812,
            0.9934101104736328,
            0.9962376356124878,
            0.9960415363311768,
            0.9964253306388855,
            0.99628084897995,
            0.9912492632865906,
            0.9961562156677246,
            0.9959487915039062
        ]
    },
    "3618": {
        "similarity": 0.9960682392120361,
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 10\n    \n    dp = [0] * (n + 1)\n    dp[1] = 10\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * 3) % MOD\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    print(count_best_friend_pairs(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949813485145569,
            0.989219069480896,
            0.9960682392120361,
            0.9879464507102966,
            0.9944839477539062,
            0.9929406046867371,
            0.9942776560783386,
            0.9937244057655334,
            0.9884291291236877,
            0.9941045045852661,
            0.9908617734909058,
            0.9951661825180054,
            0.9954960346221924,
            0.9959056377410889,
            0.9949231743812561,
            0.9950079917907715,
            0.9942785501480103,
            0.9945295453071594,
            0.9953211545944214,
            0.993741512298584
        ]
    },
    "3830": {
        "similarity": 0.9973459839820862,
        "body": "import sys\n\n    returnable = [True] * n\n    \n    for i in range(n):\n        if s[i] == '>':\n            continue\n        elif s[i] == '<':\n            j = (i - 1) % n\n            while returnable[j]:\n                if s[j] == '<':\n                    j = (j - 1) % n\n                else:\n                    break\n            returnable[j] = False\n        else:  # s[i] == '-'\n            continue\n    \n    return sum(returnable)\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        index += 2\n        results.append(count_returnable_rooms(n, s))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995308518409729,
            0.9972156882286072,
            0.9971874952316284,
            0.996307373046875,
            0.9968715310096741,
            0.9971036314964294,
            0.995394766330719,
            0.9970990419387817,
            0.9942888021469116,
            0.9944006204605103,
            0.9973459839820862,
            0.9965868592262268,
            0.9971182942390442,
            0.9965017437934875,
            0.9963017702102661,
            0.9953278303146362,
            0.9967460632324219,
            0.997104823589325,
            0.9967233538627625,
            0.9969657063484192
        ]
    },
    "3912": {
        "similarity": 0.9970008730888367,
        "body": "    n = len(s)\n    count = 0\n    palindromes = []\n    \n        counts = [0] * 256\n        for char in sub:\n            counts[ord(char)] += 1\n        odd_count = sum(1 for c in counts if c % 2 != 0)\n        return odd_count <= 1\n    \n    i = 0\n    while i < n:\n        j = n - 1\n        while j >= i:\n            sub = s[i:j+1]\n            if can_form_palindrome(sub):\n                palindromes.append(sub)\n                i = j + 1\n                break\n            j -= 1\n    \n    count = len(palindromes)\n    return count, palindromes\n\n# Read input from stdin\nn = int(input().strip())\ns = input().strip()\n\n# Generate and print the output\ncount, palindromes = min_palindromes(s)\nprint(count)\nprint(\" \".join(palindromes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9917930960655212,
            0.9964505434036255,
            0.994392991065979,
            0.9963681101799011,
            0.9960005879402161,
            0.9969105124473572,
            0.9956387877464294,
            0.9952373504638672,
            0.995915949344635,
            0.9963983297348022,
            0.9955659508705139,
            0.9948102235794067,
            0.9969243407249451,
            0.9954286813735962,
            0.996271014213562,
            0.9952344298362732,
            0.9970008730888367,
            0.9957887530326843,
            0.9959637522697449,
            0.9962618947029114
        ]
    },
    "3878": {
        "similarity": 0.9972016215324402,
        "body": "import sys\nfrom collections import defaultdict\n\n    graph = defaultdict(list)\n    for u, v in friendships:\n        graph[u].append(v)\n        graph[v].append(u)\n\n        if node in visited:\n            return 0\n        visited.add(node)\n        size = 1\n        for neighbor in graph[node]:\n            size += find_group_size(neighbor, visited)\n        return size\n\n        max_size = 0\n        best_node = -1\n        for node in range(1, n + 1):\n            if node not in visited:\n                size = find_group_size(node, set())\n                if size > max_size:\n                    max_size = size\n                    best_node = node\n        return best_node\n\n    visited = set()\n    steps = []\n    while len(visited) < n:\n        selected_guest = select_guest()\n        for neighbor in graph[selected_guest]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                steps.append(selected_guest)\n\n    print(len(steps))\n    for step in steps:\n        print(step, end=' ')\n    print()\n\n# Read input\nn, m = map(int, input().split())\nfriendships = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Call function and output result\nmin_steps_to_make_friends(n, m, friendships)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965932965278625,
            0.9970264434814453,
            0.9960339069366455,
            0.9966621398925781,
            0.996099591255188,
            0.9964843392372131,
            0.9965883493423462,
            0.9963770508766174,
            0.9969109892845154,
            0.995879054069519,
            0.9969916343688965,
            0.9971344470977783,
            0.9955947399139404,
            0.9969950318336487,
            0.9959468841552734,
            0.9967252016067505,
            0.996506929397583,
            0.9972016215324402,
            0.9970488548278809,
            0.9969823956489563
        ]
    },
    "3010": {
        "similarity": 0.9953141808509827,
        "body": "    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        if x0 == x1:\n            min_y = min(y0, y1)\n            max_y = max(y0, y1)\n            for y in range(min_y, max_y + 1):\n                points.add((x0, y))\n        else:\n            slope = (y1 - y0) / (x1 - x0)\n            intercept = y0 - slope * x0\n            for j in range(i + 1, n):\n                x2, y2, x3, y3 = lines[j]\n                if x2 == x3:\n                    min_x = min(x2, x3)\n                    max_x = max(x2, x3)\n                    if min_x <= slope * max_x + intercept <= max_x:\n                        points.add((int(slope * max_x + intercept), max_x))\n    return len(points) if -1 not in points else -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nlines = [(int(data[4*i+1]), int(data[4*i+2]), int(data[4*i+3]), int(data[4*i+4])) for i in range(n)]\nprint(count_intersections(n, lines))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995029866695404,
            0.991949200630188,
            0.9951331615447998,
            0.9947031736373901,
            0.994491696357727,
            0.9949031472206116,
            0.9941145181655884,
            0.9931200742721558,
            0.9948373436927795,
            0.9946352243423462,
            0.980424165725708,
            0.9950055480003357,
            0.9930739402770996,
            0.9949684143066406,
            0.9936752319335938,
            0.9941793084144592,
            0.9948139190673828,
            0.9942137002944946,
            0.9953141808509827,
            0.9939892292022705
        ]
    },
    "3068": {
        "similarity": 0.997666597366333,
        "body": "import sys\nfrom itertools import combinations\n\n    N = int(input().strip())\n    investigations = []\n    \n    for _ in range(N):\n        line = input().strip()\n        suspect1, suspect2, player, reply = line.split()\n        investigations.append((suspect1, suspect2, int(reply), int(player)))\n    \n    suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    total_solutions = 0\n    \n    for black_vienna in combinations(suspects, 3):\n        valid_solution = True\n        for suspect1, suspect2, reply, player in investigations:\n            count_in_hand = (suspect1 in black_vienna) + (suspect2 in black_vienna)\n            if count_in_hand != reply:\n                valid_solution = False\n                break\n        if valid_solution:\n            total_solutions += 1\n    \n    print(total_solutions)\n\ncount_solutions()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976428151130676,
            0.9973518252372742,
            0.9973354339599609,
            0.9962476491928101,
            0.997666597366333,
            0.9966826438903809,
            0.9905968904495239,
            0.9967581033706665,
            0.9976356029510498,
            0.9964075684547424,
            0.996515691280365,
            0.9976549744606018,
            0.9968085289001465,
            0.9973472952842712,
            0.9899014234542847,
            0.9962173104286194,
            0.9966834187507629,
            0.9963063597679138,
            0.9968964457511902,
            0.9975556135177612
        ]
    },
    "3030": {
        "similarity": 0.9970251321792603,
        "body": "    heap_size = [1] * n\n    \n    for i in range(2, n + 1):\n        parent = parents[i - 1]\n        while parent > 0:\n            if values[parent - 1] <= values[i - 1]:\n                break\n            heap_size[parent - 1] += heap_size[i - 1]\n            i = parent\n            parent = parents[i - 1]\n    \n    return sum(heap_size)\n\n# Read input\nn = int(input())\nvalues = []\nparents = []\nfor _ in range(n):\n    v, p = map(int, input().split())\n    values.append(v)\n    parents.append(p)\n\n# Output result\nprint(max_heap_subset(n, values, parents))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939243793487549,
            0.9955399036407471,
            0.9949261546134949,
            0.9966503977775574,
            0.99587482213974,
            0.9967314004898071,
            0.9969574809074402,
            0.9960853457450867,
            0.9964583516120911,
            0.9949464201927185,
            0.9965541362762451,
            0.9964043498039246,
            0.9946076273918152,
            0.9965635538101196,
            0.9966429471969604,
            0.9968267679214478,
            0.9970251321792603,
            0.9948266744613647,
            0.9967097043991089,
            0.9962397217750549
        ]
    },
    "3630": {
        "similarity": 0.9980613589286804,
        "body": "    n = len(s1)\n    moves = 0\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            diff = ord(s2[i]) - ord(s1[i])\n            if diff < 0:\n                diff += 26\n            moves += diff\n    \n    return moves\n\n# Read input from stdin\ns1, s2 = input().strip().split()\nprint(min_moves_to_modify(s1, s2))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967150688171387,
            0.9974784851074219,
            0.997888445854187,
            0.9976128935813904,
            0.9972154498100281,
            0.9963653087615967,
            0.9973916411399841,
            0.9971599578857422,
            0.9973540306091309,
            0.9975262880325317,
            0.9901067018508911,
            0.9979965090751648,
            0.9973677396774292,
            0.997801661491394,
            0.9972516298294067,
            0.9977647662162781,
            0.9980613589286804,
            0.9961066246032715,
            0.9976540803909302,
            0.9979312419891357
        ]
    },
    "3133": {
        "similarity": 0.9961244463920593,
        "body": "    n, A, B = map(int, input().split())\n    intersections = [tuple(map(int, input().split())) for _ in range(n)]\n    \n        stack = [(start, 0)]\n        seen = set()\n        \n        while stack:\n            current, turns = stack.pop()\n            if current in seen:\n                continue\n            seen.add(current)\n            \n            if intersections[current][2] == 1:\n                return True, turns\n            \n            left, right = intersections[current][:2]\n            if left not in seen and left != -1:\n                stack.append((left, turns + 1))\n            if right not in seen and right != -1:\n                stack.append((right, turns + 1))\n        \n        return False, float('inf')\n    \n    alice_sees_tower, alice_turns = can_see_tower(A)\n    bob_sees_tower, bob_turns = can_see_tower(B)\n    \n    if alice_sees_tower and not bob_sees_tower:\n        print(alice_turns)\n    elif not alice_sees_tower and bob_sees_tower:\n        print(bob_turns)\n    else:\n        print(\"indistinguishable\")\n\nmin_turns_to_distinguish()",
        "result": "failed: testcase 0",
        "similarities": [
            0.99538654088974,
            0.9951278567314148,
            0.9903711080551147,
            0.9956581592559814,
            0.9952362775802612,
            0.9946161508560181,
            0.9956068992614746,
            0.9946391582489014,
            0.9953262209892273,
            0.9918224811553955,
            0.9938971996307373,
            0.9933128356933594,
            0.9954599142074585,
            0.9950872659683228,
            0.9957239031791687,
            0.9955595135688782,
            0.9953087568283081,
            0.9942843914031982,
            0.9961244463920593,
            0.9931172728538513
        ]
    },
    "3480": {
        "similarity": 0.9965886473655701,
        "body": "    for i in range(L):\n        first_voice_line = lines[i * 2].replace(' ', '_')\n        second_voice_line = lines[i * 2 + 1]\n        first_voice_syllables = first_voice_line.split('_')\n        second_voice_syllables = [second_voice_line[j] for j, time in enumerate(map(int, second_voice_line.split())) if j >= D]\n\n        max_length = max(len(s) for s in first_voice_syllables + second_voice_syllables)\n        output_first = []\n        output_second = []\n\n        first_index = 0\n        second_index = 0\n\n        for time in map(int, second_voice_line.split()):\n            if first_index < len(first_voice_syllables):\n                syllable = first_voice_syllables[first_index]\n                output_first.append(syllable.ljust(max_length))\n                first_index += 1\n\n            if second_index < len(second_voice_syllables) and second_voice_index * time >= D:\n                syllable = second_voice_syllables[second_index]\n                output_second.append('_' * (max_length - len(syllable)) + syllable)\n                second_index += 1\n\n        for j in range(first_index, len(first_voice_syllables)):\n            syllable = first_voice_syllables[j]\n            output_first.append(syllable.ljust(max_length))\n\n        if not output_second:\n            output_second.append('/'.ljust(max_length))\n\n        print('\\n'.join(output_first))\n        print('\\n'.join(output_second))\n\nif __name__ == \"__main__\":\n    L, D = map(int, input().split())\n    lines = [input() for _ in range(2 * L)]\n    print_round(L, D, lines)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949569702148438,
            0.9958745241165161,
            0.9911671876907349,
            0.9962735772132874,
            0.9963324666023254,
            0.9934941530227661,
            0.9960357546806335,
            0.9956073760986328,
            0.9945345520973206,
            0.9959797263145447,
            0.9952839612960815,
            0.9962284564971924,
            0.9963924288749695,
            0.9956530332565308,
            0.99608314037323,
            0.9950901865959167,
            0.9955306649208069,
            0.9964083433151245,
            0.9960928559303284,
            0.9965886473655701
        ]
    },
    "3389": {
        "similarity": 0.9975534677505493,
        "body": "    current_type = None\n    clicks = 0\n    for video in video_types:\n        if video != current_type:\n            current_type = video\n            clicks += 1\n    return clicks\n\n# Read input\nn, k = map(int, input().split())\nvideo_types = input().strip()\n\n# Compute and print the result\nprint(min_clicks_to_watch_all_videos(n, k, video_types))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968833923339844,
            0.9968723654747009,
            0.9974987506866455,
            0.995384931564331,
            0.9970267415046692,
            0.9955366253852844,
            0.9964430928230286,
            0.9958952069282532,
            0.9972301125526428,
            0.9952244162559509,
            0.9953374266624451,
            0.990641176700592,
            0.9959813356399536,
            0.9975534677505493,
            0.9967821836471558,
            0.9973817467689514,
            0.9965431690216064,
            0.9970369935035706,
            0.9928988218307495,
            0.9974847435951233
        ]
    },
    "3925": {
        "similarity": 0.9973807334899902,
        "body": "    n = len(s)\n    dp = [[0, 0] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        if s[i - 1] == 'b':\n            dp[i][0] = dp[i - 1][1] + 1\n            dp[i][1] = max(dp[i - 1][0], dp[i - 1][1])\n        else:\n            dp[i][1] = dp[i - 1][0] + 1\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])\n    \n    return max(max(dp[-1]))\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    print(max_zebra_length(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972566366195679,
            0.9961760640144348,
            0.9967305064201355,
            0.996610164642334,
            0.9962945580482483,
            0.9967895150184631,
            0.9968003630638123,
            0.9958540201187134,
            0.9967068433761597,
            0.9919455647468567,
            0.9962976574897766,
            0.9973807334899902,
            0.9953821897506714,
            0.9966099262237549,
            0.9944520592689514,
            0.996811032295227,
            0.9966534972190857,
            0.9956501722335815,
            0.9967974424362183,
            0.9972859621047974
        ]
    },
    "3700": {
        "similarity": 0.9968719482421875,
        "body": "    ways = 0\n    for i in range(1, n + 1):\n        if i > k:\n            break\n        if (k - i) <= i:\n            continue\n        ways += 1\n    return ways\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943656921386719,
            0.9951186776161194,
            0.994859516620636,
            0.9947100281715393,
            0.9945671558380127,
            0.9946556091308594,
            0.9943807721138,
            0.9961983561515808,
            0.9953098297119141,
            0.9957249164581299,
            0.9968392252922058,
            0.9954950213432312,
            0.9962537884712219,
            0.9968719482421875,
            0.9948564767837524,
            0.9943655729293823,
            0.9949063062667847,
            0.9943656921386719,
            0.9953701496124268,
            0.9945740103721619
        ]
    },
    "3944": {
        "similarity": 0.995410144329071,
        "body": "    MOD = 10**9 + 7\n    if N == 0:\n        return 3 * (M * K) % MOD\n    elif M == 0:\n        return 3 * (N * K) % MOD\n    elif K == 0:\n        return 3 * (N * M) % MOD\n    else:\n        return ((3 * N * M * K) % MOD + (2 * (M * K + N * K + N * M)) % MOD) % MOD\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN, M, K = map(int, data)\nprint(count_alice_victory(N, M, K))",
        "result": "failed: testcase 0",
        "similarities": [
            0.994242250919342,
            0.995410144329071,
            0.9876608848571777,
            0.9917359948158264,
            0.995268702507019,
            0.9931982159614563,
            0.9891237020492554,
            0.9953082203865051,
            0.9947314262390137,
            0.9949222207069397,
            0.9907898306846619,
            0.9883405566215515,
            0.9934796690940857,
            0.9936974048614502,
            0.9917674660682678,
            0.9931167960166931,
            0.9943827390670776,
            0.993537425994873,
            0.9951599836349487,
            0.9943439960479736
        ]
    },
    "3821": {
        "similarity": 0.9964714050292969,
        "body": "import sys\n\n    n = int(input())\n    p = list(map(float, input().split()))\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1.0\n    \n    for i in range(n):\n        new_dp = dp[:]\n        for j in range(i + 1, -1, -1):\n            new_dp[j] += dp[j] * p[i]\n            if j > 0:\n                new_dp[j] -= dp[j - 1] * p[i]\n        dp = new_dp\n    \n    print(dp[1])\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995741605758667,
            0.9964714050292969,
            0.9960959553718567,
            0.9954016804695129,
            0.9953283071517944,
            0.9961357116699219,
            0.9934037923812866,
            0.9956576824188232,
            0.9960214495658875,
            0.9957935810089111,
            0.9959900379180908,
            0.9953637719154358,
            0.9961118102073669,
            0.9958990216255188,
            0.9952082633972168,
            0.9941745400428772,
            0.9954060316085815,
            0.9954191446304321,
            0.995554506778717,
            0.9931759238243103
        ]
    },
    "3667": {
        "similarity": 0.9970196485519409,
        "body": "    from collections import defaultdict\n\n    # Build adjacency list for intersections\n    graph = defaultdict(list)\n    for s, x, y in pipes:\n        well = None\n        for i, (wx, wy) in enumerate(wells):\n            if abs(x - wx)**2 + abs(y - wy)**2 < 1e-6:\n                well = i + 1\n                break\n        if well is not None:\n            graph[well].append((s, x, y))\n\n    # Check for conflicts at each intersection\n    visited = set()\n        stack = [well]\n        while stack:\n            current = stack.pop()\n            if current in visited:\n                return False\n            visited.add(current)\n            for neighbor in graph[current]:\n                if not dfs(neighbor[0]):\n                    return False\n        return True\n\n    for well in range(1, w + 1):\n        if well not in visited and not dfs(well):\n            return \"impossible\"\n\n    return \"possible\"\n\n# Read input\nw, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for _ in range(w)]\npipes = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output result\nprint(can_clean_intersections(w, p, wells, pipes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954166412353516,
            0.9965453743934631,
            0.9970196485519409,
            0.9962081909179688,
            0.9962818026542664,
            0.9961713552474976,
            0.9957555532455444,
            0.9947823286056519,
            0.9929935932159424,
            0.9957274198532104,
            0.9958259463310242,
            0.996364176273346,
            0.996101975440979,
            0.9968424439430237,
            0.9955392479896545,
            0.9957273602485657,
            0.99431973695755,
            0.9964376091957092,
            0.9961863160133362,
            0.9951374530792236
        ]
    },
    "3959": {
        "similarity": 0.997511625289917,
        "body": "from collections import Counter\nimport sys\n\nsys.setrecursionlimit(10**6)\n\nMOD = 10**9 + 7\n\n    # Count the frequency of each Pokemon type in all gyms\n    total_count = Counter()\n    for gym in pokemons:\n        for p in gym:\n            total_count[p] += 1\n    \n    # Calculate the factorial modulo MOD\n        if x == 0 or x == 1:\n            return 1\n        result = 1\n        for i in range(2, x + 1):\n            result = (result * i) % MOD\n        return result\n    \n    # Calculate the number of valid evolution plans\n        numerator = factorial(sum(total_count.values()))\n        denominator = 1\n        for count in total_count.values():\n            denominator = (denominator * factorial(count)) % MOD\n        return (numerator * pow(denominator, MOD - 2, MOD)) % MOD\n    \n    return count_plan(total_count)\n\n# Read input from stdin\nn, m = map(int, input().split())\npokemons = [list(map(int, input().split()))[1:] for _ in range(n)]\n\n# Output the result\nprint(count_valid_evolution_plans(n, m, pokemons))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962765574455261,
            0.9964542388916016,
            0.9968101382255554,
            0.9955558776855469,
            0.9956032633781433,
            0.997511625289917,
            0.9969456195831299,
            0.996059238910675,
            0.9968647360801697,
            0.9970514178276062,
            0.9969149231910706,
            0.9975072145462036,
            0.9963647723197937,
            0.9969223737716675,
            0.9970405101776123,
            0.9965870380401611,
            0.9971085786819458,
            0.9972313642501831,
            0.996933102607727,
            0.9971393942832947
        ]
    },
    "3692": {
        "similarity": 0.9951949119567871,
        "body": "import math\n\n    if n == 1:\n        return 2\n    elif n == 2:\n        x1, y1, r1 = circles[0]\n        x2, y2, r2 = circles[1]\n        d = math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n        if d > r1 + r2:\n            return 4\n        elif d < abs(r1 - r2):\n            return 2\n        else:\n            return 3\n    else:\n        regions = 1\n        for i in range(n):\n            x, y, r = circles[i]\n            is_inside_any_circle = any(\n                (x - xi) ** 2 + (y - yi) ** 2 <= ri ** 2\n                for xi, yi, ri in circles[:i] + circles[i+1:]\n            )\n            if not is_inside_any_circle:\n                regions += 1\n        return regions\n\n    n = int(input())\n    circles = [tuple(map(int, input().split())) for _ in range(n)]\n    print(number_of_regions(n, circles))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950005412101746,
            0.9924103617668152,
            0.9911109805107117,
            0.9915120005607605,
            0.993666410446167,
            0.99471515417099,
            0.9944397807121277,
            0.9949995279312134,
            0.9937089681625366,
            0.9945245385169983,
            0.9943873882293701,
            0.9925838112831116,
            0.9935057759284973,
            0.9935949444770813,
            0.9741094708442688,
            0.9942123293876648,
            0.993705153465271,
            0.9937905669212341,
            0.9937322735786438,
            0.9951949119567871
        ]
    },
    "3894": {
        "similarity": 0.9977043867111206,
        "body": "    total_cows = sum(a)\n    if total_cows % 2 == 0:\n        return \"Kevin\"\n    else:\n        return \"Nicky\"\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(determine_winner(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976766705513,
            0.9976897239685059,
            0.9964460134506226,
            0.9976885914802551,
            0.9973957538604736,
            0.9943499565124512,
            0.9966142773628235,
            0.9967698454856873,
            0.9970965385437012,
            0.9968214631080627,
            0.9977043867111206,
            0.9954262971878052,
            0.9976766705513,
            0.9958522319793701,
            0.9962479472160339,
            0.9962328672409058,
            0.9967673420906067,
            0.995830237865448,
            0.9962531924247742,
            0.9954649209976196
        ]
    },
    "3856": {
        "similarity": 0.9968886375427246,
        "body": "import sys\n\n    widths = [f[0] for f in friends]\n    heights = [f[1] for f in friends]\n    \n    # Sort by width to try and minimize the total width\n    widths.sort()\n    heights.sort(reverse=True)\n    \n    min_area = float('inf')\n    \n    for i in range(n // 2 + 1):\n        lying_widths = widths[i:]\n        standing_heights = heights[:n - i]\n        area = sum(lying_widths) * max(heights) + sum(standing_heights) * max(lying_widths)\n        min_area = min(min_area, area)\n    \n    return min_area\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nfriends = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\n# Calculate and print the result\nresult = min_photo_area(n, friends)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962092041969299,
            0.9945728182792664,
            0.9961848855018616,
            0.9966464042663574,
            0.9935792684555054,
            0.9952848553657532,
            0.9951595664024353,
            0.9968886375427246,
            0.9953784942626953,
            0.9932453632354736,
            0.9940295219421387,
            0.9964828491210938,
            0.9914726614952087,
            0.9965701699256897,
            0.9940616488456726,
            0.9948377013206482,
            0.9954603314399719,
            0.9956221580505371,
            0.9961879253387451,
            0.9964593648910522
        ]
    },
    "3282": {
        "similarity": 0.9980960488319397,
        "body": "import sys\n\n    bills = []\n    for b in range(1, P):\n        if P % b == 0:\n            m = P // b\n            total = b + m\n            digits = set(str(b) + str(m) + str(total))\n            if len(digits) == len(set('0123456789')) and b < m:\n                bills.append((b, m))\n    return len(bills), sorted(bills[:5000])\n\nif __name__ == \"__main__\":\n    P = int(input())\n    num_bills, free_desserts = count_free_desserts(P)\n    print(num_bills)\n    for b, m in free_desserts:\n        print(b, m)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975428581237793,
            0.9973961710929871,
            0.9980960488319397,
            0.9975389242172241,
            0.9978747367858887,
            0.9972707033157349,
            0.9978313446044922,
            0.9926848411560059,
            0.9978264570236206,
            0.9972094297409058,
            0.9978165030479431,
            0.9973682761192322,
            0.9977336525917053,
            0.9974603056907654,
            0.997778058052063,
            0.9977971911430359,
            0.9978901743888855,
            0.9979908466339111,
            0.9970522522926331,
            0.9970889687538147
        ]
    },
    "3596": {
        "similarity": 0.9979066252708435,
        "body": "import sys\nfrom math import erf, pi, exp, factorial, cos, sin, ceil, log, floor\nfrom scipy.special import gamma, jv\n\n    return c * integral(lambda x: t1 * gamma(x) + (log(erf(t3 * x)))**(1/t2) - jv(k, x)**t4, a, b)\n\n    h = (b - a) / n\n    return h * sum(func(a + i * h) for i in range(n + 1))\n\n    return sum(f**(i)(x) / factorial(i) * x**i for i in range(r + 1))\n\n    return sum(P[i](x) * x**i for i in range(n + r + 1))\n\n    for _ in range(times):\n        poly = [poly[i] * i / (i - 1) for i in range(1, len(poly))]\n    return poly\n\n    a, b, c = map(float, input().split())\n    t1, t2, t3, t4 = map(int, input().split())\n    n, k, r, s, l = map(int, input().split())\n\n    f_func = lambda x: f(x, t1, t2, t3, t4)\n    P0 = lambda x: taylor_poly(f_func, 0, r)\n    Pn = P0\n    for _ in range(s):\n        Pn = recursive_poly(Pn, x=0, n=1)\n\n    g = differentiate([Pn(i) for i in range(ceil(log2(s+1)) + 1)], ceil(log2(s+1)))\n    \n    result = ((g(n) + l)**2 / (pi * exp(1))) + (1 / (l + 1))\n    print(f\"{result:.4f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967637658119202,
            0.9978827238082886,
            0.9973406791687012,
            0.9974526762962341,
            0.9971209168434143,
            0.9976551532745361,
            0.9977968335151672,
            0.996496319770813,
            0.9968744516372681,
            0.9979066252708435,
            0.9959016442298889,
            0.9968808889389038,
            0.9972168803215027,
            0.9975278973579407,
            0.9977306723594666,
            0.9954378008842468,
            0.9970667958259583,
            0.9968799948692322,
            0.9977986216545105,
            0.9976768493652344
        ]
    },
    "3540": {
        "similarity": 0.9964508414268494,
        "body": "    grid = [list(input().strip()) for _ in range(4)]\n    \n        return all(grid[i][0] == 'R' and grid[i][1] == 'G' and grid[i][2] == 'B' and grid[i][3] == 'Y' for i in range(4))\n    \n    min_moves = float('inf')\n    \n        nonlocal min_moves\n        if is_solved(grid):\n            min_moves = min(min_moves, moves)\n            return\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = (x + dx) % 4, (y + dy) % 4\n            if grid[nx][ny] != 'R' and grid[nx][ny] != 'G' and grid[nx][ny] != 'B' and grid[nx][ny] != 'Y':\n                continue\n            grid[nx][ny], grid[x][y] = grid[x][y], grid[nx][ny]\n            dfs(nx, ny, moves + 1)\n            grid[nx][ny], grid[x][y] = grid[x][y], grid[nx][ny]\n    \n    for i in range(4):\n        for j in range(4):\n            dfs(i, j, 0)\n    \n    print(min_moves)\n\nmin_moves_to_solve_puzzle()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964276552200317,
            0.9959609508514404,
            0.9964508414268494,
            0.9952820539474487,
            0.9887544512748718,
            0.9962668418884277,
            0.9955611824989319,
            0.9949708580970764,
            0.992897629737854,
            0.9943124055862427,
            0.9953023195266724,
            0.9959791302680969,
            0.9953186511993408,
            0.9943564534187317,
            0.9955984354019165,
            0.9958034157752991,
            0.9961991906166077,
            0.9950433969497681,
            0.9958258271217346,
            0.9960072040557861
        ]
    },
    "3354": {
        "similarity": 0.9965903759002686,
        "body": "import math\n\n    area_of_sandwich = math.pi * s**2\n    max_area_covered = area_of_sandwich * (z / 100)\n    num_pickles = 0\n    \n    while True:\n        if num_pickles == n or sum(math.pi * r**2 for _ in range(num_pickles)) > max_area_covered:\n            break\n        num_pickles += 1\n    \n    return num_pickles - 1\n\ns, r, n, z = map(float, input().split())\nn, z = map(int, input().split())\n\nprint(max_pickles_on_sandwich(s, r, n, z))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963229298591614,
            0.9959105253219604,
            0.9953972697257996,
            0.9930934906005859,
            0.9960634112358093,
            0.99261474609375,
            0.994301438331604,
            0.9954524636268616,
            0.9930829405784607,
            0.9958630800247192,
            0.9957072734832764,
            0.9961324334144592,
            0.9919584393501282,
            0.9960902333259583,
            0.9943881034851074,
            0.9956938028335571,
            0.9962288737297058,
            0.9962413311004639,
            0.9965903759002686,
            0.9962974190711975
        ]
    },
    "3217": {
        "similarity": 0.994939923286438,
        "body": "    x_min, y_min, z_min = float('inf'), float('inf'), float('inf')\n    x_max, y_max, z_max = 0, 0, 0\n    \n    for cell in defective_cells:\n        x, y, z = cell\n        x_min = min(x_min, x)\n        y_min = min(y_min, y)\n        z_min = min(z_min, z)\n        x_max = max(x_max, x)\n        y_max = max(y_max, y)\n        z_max = max(z_max, z)\n    \n    return 2 * ((x_max - x_min + 1) + (y_max - y_min + 1) + (z_max - z_min + 1)) - 3\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nprint(min_panels(defective_cells))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948959350585938,
            0.9926066994667053,
            0.994107186794281,
            0.9930506348609924,
            0.9940751791000366,
            0.9913177490234375,
            0.9939372539520264,
            0.9938159584999084,
            0.9929807782173157,
            0.9934125542640686,
            0.9930686950683594,
            0.9947176575660706,
            0.9922693967819214,
            0.9862453937530518,
            0.9935899376869202,
            0.9943553805351257,
            0.994939923286438,
            0.9922693967819214,
            0.9941644072532654,
            0.9892073273658752
        ]
    },
    "3520": {
        "similarity": 0.9966496229171753,
        "body": "    # Initialize variables\n    end_time = n\n    current_time = 0\n    last_pill_age = 0\n    \n    for t, x, y in pills:\n        if current_time < t:\n            age_increase = min(t - current_time, last_pill_age)\n            current_time = t\n            last_pill_age += c + age_increase\n        \n        age_increase = min(x, last_pill_age)\n        end_time = max(end_time, current_time + y - age_increase)\n        last_pill_age += c + age_increase\n    \n    return end_time\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\nc = int(data[2])\n\npills = []\nfor i in range(p):\n    t = int(data[3 + 3 * i])\n    x = int(data[4 + 3 * i])\n    y = int(data[5 + 3 * i])\n    pills.append((t, x, y))\n\n# Calculate and print the result\nprint(max_life(n, p, c, pills))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927878379821777,
            0.9923976063728333,
            0.9962011575698853,
            0.9964812397956848,
            0.99663245677948,
            0.9956761598587036,
            0.9919694662094116,
            0.9955919981002808,
            0.995436429977417,
            0.9964922666549683,
            0.9966496229171753,
            0.9960659742355347,
            0.9953616261482239,
            0.9949834942817688,
            0.9953050017356873,
            0.9960159659385681,
            0.9957423806190491,
            0.9963542819023132,
            0.9966318011283875,
            0.9964224100112915
        ]
    },
    "3475": {
        "similarity": 0.9971599578857422,
        "body": "import sys\n\n    if n == 1:\n        return 0\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        current_min_switches = float('inf')\n        for j in range(i):\n            distance_sum = sum(distances_angles[k][0] for k in range(j, i + 1))\n            if distance_sum >= transportation_types[i % t][0]:\n                angle_diff = abs(distances_angles[j][1] - distances_angles[i][1])\n                angle_diff = min(angle_diff, 360 - angle_diff)\n                if angle_diff <= transportation_types[i % t][1]:\n                    current_min_switches = min(current_min_switches, dp[j])\n        if current_min_switches != float('inf'):\n            dp[i] = current_min_switches + 1\n    \n    return dp[n-1] if dp[n-1] != float('inf') else -1\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    n = int(data[1])\n    \n    transportation_types = []\n    index = 2\n    for _ in range(t):\n        d_min = int(data[index])\n        a_max = int(data[index + 1])\n        transportation_types.append((d_min, a_max))\n        index += 2\n    \n    distances_angles = []\n    for _ in range(n-1):\n        d_i = int(data[index])\n        h_i = int(data[index + 1])\n        distances_angles.append((d_i, h_i))\n        index += 2\n    \n    result = min_transportation_switches(t, n, transportation_types, distances_angles)\n    \n    if result == -1:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971504211425781,
            0.9966508150100708,
            0.9906408190727234,
            0.9963028430938721,
            0.994195818901062,
            0.9966065287590027,
            0.9966229796409607,
            0.9965122938156128,
            0.9954990744590759,
            0.9940022230148315,
            0.9953140616416931,
            0.9959376454353333,
            0.9967930316925049,
            0.9963063597679138,
            0.9963945150375366,
            0.9971599578857422,
            0.9966636300086975,
            0.9950159788131714,
            0.9960991740226746,
            0.9963365197181702
        ]
    },
    "3977": {
        "similarity": 0.9967052936553955,
        "body": "    # Create a set of government nodes for quick lookup\n    government_nodes = set(c)\n    \n    # Initialize the edge count\n    current_edges = m\n    \n    # Iterate through all possible pairs of non-government nodes\n    for i in range(1, n + 1):\n        if i not in government_nodes:\n            for j in range(i + 1, n + 1):\n                if j not in government_nodes:\n                    # Check if there is no path between the two nodes\n                    if (i, j) not in edges and (j, i) not in edges:\n                        current_edges += 1\n    \n    return current_edges\n\n# Read input from stdin\nn = int(input().strip())\nm = int(input().strip())\nk = int(input().strip())\nc = list(map(int, input().strip().split()))\nedges = set()\nfor _ in range(m):\n    u, v = map(int, input().strip().split())\n    edges.add((u, v))\n    edges.add((v, u))\n\n# Calculate and print the result\nresult = max_edges(n, m, k, c, edges)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958049654960632,
            0.9945072531700134,
            0.9950562715530396,
            0.9954663515090942,
            0.9945785403251648,
            0.9945141673088074,
            0.9961568713188171,
            0.9953681826591492,
            0.9964442849159241,
            0.9961240887641907,
            0.9962260723114014,
            0.996151864528656,
            0.9927871227264404,
            0.9947887063026428,
            0.9966565370559692,
            0.9936220049858093,
            0.9936341047286987,
            0.9962931275367737,
            0.9965821504592896,
            0.9967052936553955
        ]
    },
    "3626": {
        "similarity": 0.9984638690948486,
        "body": "    for i in range(n):\n        x1, y1, x2, y2 = rectangles[i]\n        for j in range(i + 1, n):\n            x3, y3, x4, y4 = rectangles[j]\n            if not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1):\n                return 1\n    return 0\n\nif __name__ == \"__main__\":\n    n = int(input())\n    rectangles = [tuple(map(int, input().split())) for _ in range(n)]\n    print(check_intersections(n, rectangles))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973101615905762,
            0.9973671436309814,
            0.9982473254203796,
            0.9984638690948486,
            0.9980194568634033,
            0.9978868365287781,
            0.9978581666946411,
            0.998062252998352,
            0.9980763792991638,
            0.9980959892272949,
            0.9977830648422241,
            0.9983196258544922,
            0.9966723918914795,
            0.9980699419975281,
            0.9982936382293701,
            0.9984638690948486,
            0.9980695843696594,
            0.9964140057563782,
            0.9983369708061218,
            0.9982415437698364
        ]
    },
    "3584": {
        "similarity": 0.9964224100112915,
        "body": "import itertools\nimport math\nfrom typing import List, Tuple\n\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\n    n = len(points)\n    points.sort()\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and orientation(lower[-2], lower[-1], p) != 2:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and orientation(upper[-2], upper[-1], p) != 2:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\n    hull = convex_hull(fence_posts)\n    n = len(hull)\n    \n        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n    \n    max_protected = 0\n    \n    for subset in itertools.combinations(hull, k):\n        protected = sum(1 for onion in onions if all(distance(onion, post) > distance(post, other_post) for post, other_post in zip(subset, subset[1:] + subset[:1])))\n        max_protected = max(max_protected, protected)\n    \n    return max_protected\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    onions = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(N)]\n    fence_posts = [(int(data[3 + 2 * N + 2 * i]), int(data[4 + 2 * N + 2 * i])) for i in range(M)]\n    \n    result = max_onions_protected(onions, fence_posts, K)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957869648933411,
            0.9955303072929382,
            0.9959034323692322,
            0.9961644411087036,
            0.99541836977005,
            0.9963975548744202,
            0.9962109327316284,
            0.9939171671867371,
            0.9951657056808472,
            0.9942610859870911,
            0.9964224100112915,
            0.9946712851524353,
            0.9937801361083984,
            0.9954527020454407,
            0.9950800538063049,
            0.9946937561035156,
            0.995141863822937,
            0.9961012005805969,
            0.9887396097183228,
            0.9950785636901855
        ]
    },
    "3950": {
        "similarity": 0.9967456459999084,
        "body": "    if any(x > 0 and x != q for x in a) or all(x == 0 for x in a):\n        return \"NO\"\n    \n    res = [0] * n\n    changes = []\n    \n    for i in range(q, 0, -1):\n        segment = (i + 1, i)\n        if a[segment[0] - 1] != i:\n            changes.append(segment)\n        res[segment[0] - 1] = i\n    \n    for l, r in changes:\n        for j in range(l - 1, r):\n            if res[j] == 0:\n                res[j] = q\n    \n    return \"YES\\n\" + ' '.join(map(str, res))\n\n# Read input\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Process and print output\nresult = can_obtain_array(n, q, a)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940147399902344,
            0.9927340149879456,
            0.9937679767608643,
            0.9944339394569397,
            0.9963009357452393,
            0.9964087605476379,
            0.9965115785598755,
            0.9967456459999084,
            0.996703028678894,
            0.9928512573242188,
            0.9944108724594116,
            0.9965115785598755,
            0.9963895678520203,
            0.9963670372962952,
            0.9909167289733887,
            0.996286928653717,
            0.996483564376831,
            0.99605792760849,
            0.9927099347114563,
            0.9949422478675842
        ]
    },
    "3075": {
        "similarity": 0.9975557923316956,
        "body": "import sys\n\n    stations.sort()\n    total_cost = 0\n    current_fuel = g\n    \n    for i in range(n):\n        distance = stations[i][0]\n        cost_per_gallon = stations[i][1]\n        \n        if current_fuel < distance:\n            return \"cancel road trip\"\n        \n        fuel_needed = distance - (stations[i-1][0] if i > 0 else 0)\n        if fuel_needed > current_fuel:\n            fuel_to_refill = g\n        else:\n            fuel_to_refill = fuel_needed\n        \n        total_cost += fuel_to_refill * cost_per_gallon\n        current_fuel -= distance\n    \n    return total_cost\n\n# Read input from stdin\nn, g = map(int, input().split())\nstations = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_cost_to_travel(n, g, stations))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953712821006775,
            0.9919912219047546,
            0.9961774945259094,
            0.9975557923316956,
            0.9967526793479919,
            0.9974036812782288,
            0.9964781403541565,
            0.996436357498169,
            0.996852457523346,
            0.9955954551696777,
            0.9956343770027161,
            0.9965342283248901,
            0.9972355365753174,
            0.9965070486068726,
            0.9961276650428772,
            0.9972041249275208,
            0.9967621564865112,
            0.9964523315429688,
            0.9965585470199585,
            0.9946172833442688
        ]
    },
    "3711": {
        "similarity": 0.9968221783638,
        "body": "    if k >= n * m - 1:\n        return -1\n    if n > m:\n        n, m = m, n\n    min_piece = (m + k // (n - 1)) // (k // (n - 1) + 1)\n    return min_piece\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\nprint(max_min_piece_area(n, m, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961035847663879,
            0.9962220788002014,
            0.9955442547798157,
            0.9953292012214661,
            0.9967408776283264,
            0.9960001707077026,
            0.9968221783638,
            0.9959586262702942,
            0.996677577495575,
            0.9940797686576843,
            0.9963001608848572,
            0.9964379072189331,
            0.9925161004066467,
            0.9963634014129639,
            0.9948602318763733,
            0.9936372637748718,
            0.9946096539497375,
            0.9965104460716248,
            0.9947938323020935,
            0.9953507781028748
        ]
    }
}