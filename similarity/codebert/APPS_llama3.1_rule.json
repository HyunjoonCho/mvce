{
    "4693": {
        "similarity": 0.9954908490180969,
        "body": "import sys\n\n    a = int(input())\n    b = int(input())\n\n    sum_ab = a + b\n\n    if sum_ab <= 10:\n        print(sum_ab)\n    else:\n        print(\"error\")\n\nadd_numbers()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9926967620849609,
            0.9953111410140991,
            0.9952679872512817,
            0.995249330997467,
            0.9951268434524536,
            0.9927268028259277,
            0.9903134703636169,
            0.99313884973526,
            0.9952824115753174,
            0.9951235055923462,
            0.9894492626190186,
            0.9902136921882629,
            0.9938332438468933,
            0.9911805987358093,
            0.9936071038246155,
            0.9874167442321777,
            0.9953120350837708,
            0.9954908490180969,
            0.990206778049469,
            0.9953721761703491
        ]
    },
    "4077": {
        "similarity": 0.9954952597618103,
        "body": "import sys\nfrom collections import deque\n\n    result = 0\n    for i in range(len(sequence)):\n        left = deque()\n        right = deque()\n        for j in range(i + 1, n):\n            if len(left) < len(right):\n                right.appendleft(sequence[j])\n            else:\n                left.append(sequence[j])\n\n            while left and left[-1] > m:\n                left.pop()\n\n            while right and right[0] > m:\n                right.popleft()\n\n            if min(len(left), len(right)) >= (m - 1) + 1:\n                result += 1\n\n    return result\n\nn, m = map(int, input().split())\nsequence = list(map(int, input().split()))\nresult = count_pairs_of_indices(n, m, sequence)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9916126132011414,
            0.9916342496871948,
            0.9927980303764343,
            0.9937520623207092,
            0.9948031902313232,
            0.9946837425231934,
            0.9922465085983276,
            0.9951997399330139,
            0.9951421022415161,
            0.9954952597618103,
            0.993631899356842,
            0.992357075214386,
            0.9947655200958252,
            0.9947291016578674,
            0.9949184060096741,
            0.9938237071037292,
            0.9941972494125366,
            0.9949800372123718,
            0.9940299987792969,
            0.9922642111778259
        ]
    },
    "4006": {
        "similarity": 0.9964268207550049,
        "body": "    while num > 0 and num % 10 == 0:\n        num //= 10\n    return num + 1\n\n    reachable = {n}\n    for _ in range(10000):  # arbitrary limit, but large enough to cover all possibilities\n        new_reachables = set()\n        for i in reachable:\n            new_i = f(i)\n            if new_i not in reachable and new_i > 0:\n                new_reachables.add(new_i)\n        if len(reachable) == len(new_reachables):\n            break\n        reachable |= new_reachables\n    return len(reachable)\n\nn = int(input())\nprint(count_reachable(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937509298324585,
            0.9964268207550049,
            0.9928374290466309,
            0.9956281781196594,
            0.9935796856880188,
            0.9955891966819763,
            0.9947026968002319,
            0.9949541687965393,
            0.9944301247596741,
            0.9936121702194214,
            0.9949116110801697,
            0.9943843483924866,
            0.9947128295898438,
            0.9954924583435059,
            0.9940472841262817,
            0.9951057434082031,
            0.9946584105491638,
            0.9948274493217468,
            0.9952948689460754,
            0.9950787425041199
        ]
    },
    "4556": {
        "similarity": 0.9940811991691589,
        "body": "import re\n\n    s = input()\n    x = re.search(r'[A-Z]', s).group()\n    return f\"AT{ord(x) - 64}C\"\n\nprint(get_abbreviation())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9894593954086304,
            0.9940811991691589,
            0.993967592716217,
            0.9910845756530762,
            0.9925139546394348,
            0.9933298230171204,
            0.9925042986869812,
            0.9922935366630554,
            0.9899319410324097,
            0.9930610656738281,
            0.9908934235572815,
            0.9922510385513306,
            0.9931917786598206,
            0.9886958599090576,
            0.9915395975112915,
            0.9896203875541687,
            0.9935346245765686,
            0.9894397258758545,
            0.9869208335876465,
            0.9910807609558105
        ]
    },
    "4571": {
        "similarity": 0.9952038526535034,
        "body": "    n, m = sorted(input().split(), key=lambda x: int(x))\n    n = int(n)\n    m = int(m)\n\n    total_time = 0\n    for i in range(1, m + 1):\n        total_time += i * 1900\n\n    for i in range(1, n - m + 1):\n        total_time += i * 100\n\n    return 2 * total_time\n\n\nprint(calculate_expected_time())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936180114746094,
            0.9940651655197144,
            0.9922367930412292,
            0.9946805238723755,
            0.9952038526535034,
            0.9931832551956177,
            0.9914697408676147,
            0.9951280355453491,
            0.9933325052261353,
            0.9930093884468079,
            0.9936034679412842,
            0.9919537901878357,
            0.9876990914344788,
            0.9947977662086487,
            0.985787570476532,
            0.9937527179718018,
            0.9950481057167053,
            0.9951600432395935,
            0.9950884580612183,
            0.9920508861541748
        ]
    },
    "4019": {
        "similarity": 0.997955322265625,
        "body": "import sys\n\n    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    adj = [[] for _ in range(n+1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    visited = [False] * (n + 1)\n    visited[0] = True\n\n    parent = [-1] * (n + 1)\n\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                parent[neighbor] = node\n                dfs(neighbor)\n\n    dfs(1)\n    for i in range(n+1):\n        if len(adj[i]) > D:\n            return 'NO'\n        elif len(adj[i]) < D and i != 1:\n            u, v = edges.pop()\n            while adj[u]:\n                adj[u].pop()\n                adj[v].append(u)\n                v = u\n                u = parent[u]\n            edges.append((u, v))\n\n    result = []\n    for i in range(2, n + 1):\n        if len(adj[i]) == 0:\n            continue\n        for j in range(len(edges)):\n            u, v = edges[j]\n            if (parent[i] == u or parent[i] == v) and adj[u].count(i) > 0:\n                result.append((u, i))\n                adj[u].remove(i)\n                break\n\n    print('YES')\n    for u, v in sorted(result):\n        print(u, v)\n\nif __name__ == '__main__':\n    find_spanning_tree()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976314902305603,
            0.9974656701087952,
            0.9974497556686401,
            0.9976262450218201,
            0.9979368448257446,
            0.996194064617157,
            0.9969127178192139,
            0.9962969422340393,
            0.9977045655250549,
            0.997955322265625,
            0.9976481199264526,
            0.9976547956466675,
            0.9976473450660706,
            0.9969006776809692,
            0.996250331401825,
            0.9978514313697815,
            0.9965322613716125,
            0.9975752830505371,
            0.996038019657135,
            0.9968253970146179
        ]
    },
    "4265": {
        "similarity": 0.9958199262619019,
        "body": "from collections import Counter\n\n    sa = Counter()\n    ta = Counter()\n\n    for i, c in enumerate(S):\n        sa[c] += 1\n        ta[c] += 0\n\n    ops = 0\n    for c, count in sa.items():\n        if ta[c] < count:\n            ops += count - ta[c]\n\n    return ops\n\nS = input()\nT = input()\n\nprint(min_operations(S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953981637954712,
            0.9955365061759949,
            0.9882070422172546,
            0.9943097829818726,
            0.9953870177268982,
            0.9937677979469299,
            0.9956399202346802,
            0.9957229495048523,
            0.9938836693763733,
            0.9931150674819946,
            0.9914173483848572,
            0.9951607584953308,
            0.9948479533195496,
            0.9949356913566589,
            0.9911300539970398,
            0.9944837689399719,
            0.9949687123298645,
            0.9958199262619019,
            0.9955058693885803,
            0.9956213235855103
        ]
    },
    "4657": {
        "similarity": 0.9977455139160156,
        "body": "    prefix_sum = [0] * n\n    for i in range(n):\n        if a[i] % 2 == 1:\n            prefix_sum[i] = 1\n        prefix_sum[i] += prefix_sum[i - 1] if i > 0 else 0\n\n    ans = [-1] * k\n    idx = 0\n    for i in range(n):\n        if (prefix_sum[n - 1] - prefix_sum[i]) % 2 == 0:\n            continue\n        num_odd_subsegments_needed = (prefix_sum[n - 1] - prefix_sum[i] + 1) // 2\n        if num_odd_subsegments_needed <= k and idx < i:\n            ans[k - num_odd_subsegments_needed] = i + 1\n            idx += 1\n        if idx == k:\n            break\n\n    if idx != k:\n        return \"NO\"\n    else:\n        return \"YES\\n\" + \" \".join(str(x) for x in ans)\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(divide_array_into_subsegments(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956783652305603,
            0.9971034526824951,
            0.9973616600036621,
            0.9959379434585571,
            0.9950063824653625,
            0.9963802695274353,
            0.9973708987236023,
            0.9960809350013733,
            0.9964486956596375,
            0.9971514344215393,
            0.9963817596435547,
            0.9964609742164612,
            0.9973351359367371,
            0.9961568713188171,
            0.9974828958511353,
            0.9974846243858337,
            0.9975010752677917,
            0.9964581727981567,
            0.9975282549858093,
            0.9977455139160156
        ]
    },
    "4599": {
        "similarity": 0.9970330595970154,
        "body": "import sys\n\n    n = int(input())\n    cards = [0] + list(map(int, input().split()))\n\n    alice_score = 0\n    bob_score = 0\n\n    for i in range(1, n+1):\n        if i % 2 == 1:\n            alice_score += max(cards[1], cards[i])\n            del cards[i]\n        else:\n            bob_score += min(cards[1], cards[-1])\n            del cards[-1]\n\n    return alice_score - bob_score\n\nprint(optimal_game_score())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933666586875916,
            0.9968095421791077,
            0.9950125813484192,
            0.9969807863235474,
            0.9961186647415161,
            0.9955852031707764,
            0.9967948794364929,
            0.9959437847137451,
            0.9964001178741455,
            0.9935744404792786,
            0.9940916299819946,
            0.990831196308136,
            0.9969697594642639,
            0.9944940805435181,
            0.9970330595970154,
            0.9949297904968262,
            0.9961125254631042,
            0.9966951012611389,
            0.996428370475769,
            0.9963587522506714
        ]
    },
    "4774": {
        "similarity": 0.9959672689437866,
        "body": "import sys\n\n    ops = ['+', '-', '*', '/']\n\n    for op1 in ops:\n        for op2 in ops:\n            if op1 == '/' and d == 0 or op2 == '/' and d == 0:\n                continue\n            res1 = eval(f'{a} {op1} {b}')\n            res2 = eval(f'{c} {op2} {d}')\n\n            if res1 <= res2:\n                print(f'{a} {op1} {b} = {c} {op2} {d}')\n            else:\n                print(f'{a} {op2} {b} = {c} {op1} {d}')\n\n    a, b, c, d = map(int, input().split())\n    solve(a, b, c, d)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946319460868835,
            0.9955822825431824,
            0.9939926862716675,
            0.9946033358573914,
            0.9950748085975647,
            0.9945695996284485,
            0.9957994222640991,
            0.9959672689437866,
            0.9885872602462769,
            0.9955674409866333,
            0.9949609637260437,
            0.9952605366706848,
            0.9902525544166565,
            0.993669331073761,
            0.9952774047851562,
            0.9948199391365051,
            0.9955434203147888,
            0.9957150816917419,
            0.9945570230484009,
            0.9826491475105286
        ]
    },
    "4851": {
        "similarity": 0.9979175925254822,
        "body": "    i = n\n    while True:\n        digits_sum = sum(int(digit) for digit in str(i))\n        if i % digits_sum == 0:\n            return i\n        i += 1\n\nn = int(input())\nprint(smallest_harshad(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977752566337585,
            0.9954316020011902,
            0.9959937930107117,
            0.9972068667411804,
            0.9978031516075134,
            0.9969735741615295,
            0.9969608187675476,
            0.9969608187675476,
            0.9970573782920837,
            0.9976426959037781,
            0.9978750348091125,
            0.9973646402359009,
            0.9978953003883362,
            0.9950740337371826,
            0.9979175925254822,
            0.9954060912132263,
            0.997156023979187,
            0.9977308511734009,
            0.9969680309295654,
            0.9961298704147339
        ]
    },
    "4655": {
        "similarity": 0.9942108988761902,
        "body": "    alice, bob, last = map(int, input().split())\n    total = sum([alice, bob, last])\n    max_last = max(alice, bob)\n    if max_last > total // 2:\n        return total // 2\n    else:\n        return min(alice + (last - max_last) // 2, total // 2)\n\nfor _ in range(int(input())):\n    print(max_candies())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9906225800514221,
            0.9936128854751587,
            0.9936698079109192,
            0.9923336505889893,
            0.9932170510292053,
            0.9933737516403198,
            0.9889701008796692,
            0.9924141764640808,
            0.9941293597221375,
            0.9906238913536072,
            0.9899818301200867,
            0.9942108988761902,
            0.978166401386261,
            0.9893568158149719,
            0.9926165342330933,
            0.9931278228759766,
            0.9863881468772888,
            0.993558406829834,
            0.9931289553642273,
            0.993955135345459
        ]
    },
    "4132": {
        "similarity": 0.9958081841468811,
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = sorted(A)\n    i = 1\n    while len(B) > 1 and B[-1] != B[-2]:\n        if B[-i] <= B[-(i + 1)]:\n            B[-i] -= B[-(i + 1)]\n        else:\n            B[-(i + 1)] -= B[-i]\n        i += 1\n    return B[-1]\n\nprint(findMinHealth())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954886436462402,
            0.9935595989227295,
            0.9876691699028015,
            0.9956406354904175,
            0.9937480092048645,
            0.9934316873550415,
            0.9939175844192505,
            0.9925500750541687,
            0.9958081841468811,
            0.994301438331604,
            0.9873249530792236,
            0.9936461448669434,
            0.994348406791687,
            0.9950665831565857,
            0.9952420592308044,
            0.9950528740882874,
            0.9952008128166199,
            0.9947264790534973,
            0.9937630891799927,
            0.9951215982437134
        ]
    },
    "4085": {
        "similarity": 0.9963951110839844,
        "body": "import sys\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        divisors = sorted([int(x) for x in input().split()])\n        if divisors[0] != 2 or divisors[-1] == divisors[0]:\n            print(-1)\n            continue\n        max_d = divisors[-1]\n        min_x = (divisors[0] - 1) * max_d\n        for i in range(n):\n            if divisors[i] * divisors[i] > min_x:\n                break\n            x = divisors[i] * ((min_x // divisors[i]) + 1)\n            if x % divisors[i] == 0 and x != min_x:\n                min_x = x\n        print(min_x)\n\nfind_min_x()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996201753616333,
            0.9961887001991272,
            0.9956893920898438,
            0.9954251646995544,
            0.9940902590751648,
            0.9947865009307861,
            0.9945777058601379,
            0.9955586791038513,
            0.9963951110839844,
            0.9941800832748413,
            0.9951701164245605,
            0.9957488179206848,
            0.9886113405227661,
            0.9954946637153625,
            0.9956641793251038,
            0.9962740540504456,
            0.9871667623519897,
            0.9958365559577942,
            0.9955803751945496,
            0.9950502514839172
        ]
    },
    "4399": {
        "similarity": 0.9964976906776428,
        "body": "    a_count = 0\n    b_count = 0\n    for char in S:\n        if char == 'A':\n            a_count += 1\n        else:\n            b_count += 1\n    return a_count > 0 and b_count > 0\n\nS = input()\nprint('Yes' if are_connected(S) else 'No')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927672147750854,
            0.9954864382743835,
            0.996433675289154,
            0.9957884550094604,
            0.9952554106712341,
            0.9949268698692322,
            0.9964976906776428,
            0.9947136640548706,
            0.9960648417472839,
            0.9950407147407532,
            0.9920446276664734,
            0.9963810443878174,
            0.9957972168922424,
            0.9952451586723328,
            0.9938027262687683,
            0.9961498975753784,
            0.9954050779342651,
            0.9961073994636536,
            0.994205892086029,
            0.9961308836936951
        ]
    },
    "4999": {
        "similarity": 0.9971951842308044,
        "body": "import sys\n\n    steps = 0\n    while a != b:\n        if a > b:\n            return -1\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a += 1\n        steps += 1\n    return steps\n\na, b = map(int, input().split())\nprint(min_operations(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966567158699036,
            0.9963427186012268,
            0.9940609335899353,
            0.9962186217308044,
            0.9925897717475891,
            0.9965431094169617,
            0.9962486624717712,
            0.9942556619644165,
            0.9967696666717529,
            0.9929014444351196,
            0.9971951842308044,
            0.9961805939674377,
            0.9963291883468628,
            0.9968004822731018,
            0.9970378875732422,
            0.9970741271972656,
            0.9930598735809326,
            0.9969242811203003,
            0.9968807101249695,
            0.9963924884796143
        ]
    },
    "4727": {
        "similarity": 0.9968271851539612,
        "body": "import sys\n\n    i = 0\n    while i < len(row) - 1:\n        if row[i] > 0 and row[i + 1] > 0 and row[i] == row[i + 1]:\n            grid[row[0]].append(2 * row[i])\n            del row[i]\n            del row[i]\n            row.insert(i, 0)\n        elif row[i] <= 0:\n            i += 1\n        else:\n            i += 1\n\n    global temp_grid\n    temp_grid = [[0 for _ in range(4)] for _ in range(4)]\n    for r in range(4):\n        for c in range(4):\n            temp_grid[r][c] = grid[r][c]\n    \n    if direction == 0: # left\n        for row in temp_grid:\n            merge(row, [])\n            row[:] = [x for x in row if x > 0]\n    elif direction == 1: # up\n        for col in range(4):\n            row = []\n            for r in range(4):\n                row.append(temp_grid[r][col])\n            merge(row, [])\n            row[:] = [x for x in row if x > 0]\n            for r in range(4):\n                temp_grid[r][col] = row[r]\n    elif direction == 2: # right\n        for row in temp_grid:\n            row.reverse()\n            merge(row, [])\n            row.reverse()\n            row[:] = [x for x in row if x > 0]\n            row.reverse()\n    else: # down\n        for col in range(4):\n            row = []\n            for r in range(3, -1, -1):\n                row.append(temp_grid[r][col])\n            merge(row, [])\n            row[:] = [x for x in row if x > 0]\n            for r in range(3, -1, -1):\n                temp_grid[r][col] = row[r]\n\n    for row in grid:\n        sys.stdout.write(' '.join(map(str, row)) + '\\n')\n\ngrid = []\nfor _ in range(4):\n    row = list(map(int, input().split()))\n    grid.append(row)\ndirection = int(input())\n\nslide(grid, direction)\n\nprint_result(grid)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967440366744995,
            0.9966264963150024,
            0.9963943958282471,
            0.9949108958244324,
            0.9954612255096436,
            0.9951789379119873,
            0.9965272545814514,
            0.9957802295684814,
            0.9968271851539612,
            0.9958808422088623,
            0.9940639138221741,
            0.9951421022415161,
            0.9938605427742004,
            0.9962615966796875,
            0.9957385659217834,
            0.9965174794197083,
            0.9952245354652405,
            0.9957373738288879,
            0.9966028928756714,
            0.9961907267570496
        ]
    },
    "4906": {
        "similarity": 0.9974968433380127,
        "body": "import sys\n\n    encoded = ''\n    prev_char = message[0]\n    count = 1\n    for i in range(1, len(message)):\n        if message[i] == prev_char:\n            count += 1\n        else:\n            encoded += prev_char + str(count)\n            prev_char = message[i]\n            count = 1\n    encoded += prev_char + str(count)\n    return encoded\n\n    decoded = ''\n    i = 0\n    while i < len(encoded_message):\n        char = encoded_message[i]\n        run_length = int(encoded_message[i+1])\n        for j in range(run_length):\n            decoded += char\n            i += 2\n    return decoded\n\naction, message = input().split()\nif action == 'E':\n    print(encode(message))\nelse:\n    print(decode(message))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972931742668152,
            0.9965153932571411,
            0.9965401887893677,
            0.9959080219268799,
            0.9961679577827454,
            0.9972325563430786,
            0.9966131448745728,
            0.9971361756324768,
            0.9974968433380127,
            0.9924140572547913,
            0.996618390083313,
            0.9971420168876648,
            0.996017575263977,
            0.996698260307312,
            0.9974285960197449,
            0.9931225180625916,
            0.9960260987281799,
            0.9963921308517456,
            0.9948276877403259,
            0.9959362745285034
        ]
    },
    "4011": {
        "similarity": 0.9956994652748108,
        "body": "    n = int(input())\n    a = [int(x) for x in input()]\n    f = [0] + [int(x) - 1 for x in input().split()]\n\n    b = [[f[i]] * (n - i + 1) for i in range(9)]\n\n    ans = ''\n    for d in range(n, 0, -1):\n        max_val = 0\n        max_d = None\n\n        for i in range(d):\n            for j in range(f[a[i]]):\n                if b[j][i] > max_val:\n                    max_val = b[j][i]\n                    max_d = j\n\n        ans += str(max_d + 1)\n\n        for i in range(d, n):\n            b[max_d].pop(i)\n\n    print(ans[::-1])\n\nmax_num()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951766133308411,
            0.9944034218788147,
            0.9956994652748108,
            0.9915717244148254,
            0.9944494366645813,
            0.9950300455093384,
            0.9927780032157898,
            0.9932152628898621,
            0.9951189756393433,
            0.9947206377983093,
            0.9937493205070496,
            0.9936202168464661,
            0.9941630959510803,
            0.9936916828155518,
            0.9936029314994812,
            0.9898039102554321,
            0.9930487275123596,
            0.9951326251029968,
            0.994728684425354,
            0.9938523173332214
        ]
    },
    "4099": {
        "similarity": 0.9967526793479919,
        "body": "import sys\n    total = sum(A)\n    avg = total / N\n    if avg >= M:\n        return 0\n    else:\n        need = (M * N) - total\n        return max(need, 1)\n\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\nprint(min_score(N, K, M, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967526793479919,
            0.9949764609336853,
            0.9965431690216064,
            0.9934003949165344,
            0.9951168894767761,
            0.9952512979507446,
            0.9949848651885986,
            0.9959652423858643,
            0.996497631072998,
            0.9964013695716858,
            0.9933570027351379,
            0.9960936307907104,
            0.9963210225105286,
            0.9948365092277527,
            0.9957863688468933,
            0.996016263961792,
            0.9962049722671509,
            0.9890660643577576,
            0.9954012632369995,
            0.9935746788978577
        ]
    },
    "4465": {
        "similarity": 0.9951657652854919,
        "body": "import sys\n\n    A, B = map(int, input().split())\n    total_area = A * B\n    road_area = 2 + 2 * (A - 2) + 2 + 2 * (B - 2)\n    return total_area - road_area\n\nprint(farm_area())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9916269183158875,
            0.9912217855453491,
            0.9940816164016724,
            0.9886641502380371,
            0.9856271147727966,
            0.9926711916923523,
            0.9905627369880676,
            0.992612361907959,
            0.9938974976539612,
            0.9933840036392212,
            0.9947468638420105,
            0.9918538331985474,
            0.9925860166549683,
            0.9943868517875671,
            0.9931642413139343,
            0.988592267036438,
            0.9848191142082214,
            0.9951657652854919,
            0.9939599633216858,
            0.9925376772880554
        ]
    },
    "4315": {
        "similarity": 0.9938157796859741,
        "body": "    R = int(input())\n    circumference = 2 * 3.14159265 * R\n    for i in range(10):\n        circumference *= 1 - (circumference ** (-2)) / (2 * 24)\n    return circumference",
        "result": "failed: testcase 0",
        "similarities": [
            0.9923396706581116,
            0.9885329008102417,
            0.9904688596725464,
            0.9922530651092529,
            0.9920799732208252,
            0.9915534853935242,
            0.9928916096687317,
            0.9938157796859741,
            0.9874348044395447,
            0.992712140083313,
            0.9918470978736877,
            0.9891897439956665,
            0.991615891456604,
            0.9928876161575317,
            0.9928420186042786,
            0.9928008913993835,
            0.9925395846366882,
            0.9934185743331909,
            0.992142915725708,
            0.985154390335083
        ]
    },
    "4633": {
        "similarity": 0.9982199668884277,
        "body": "import sys\n\n    moves = 0\n    while True:\n        sum_digits = 0\n        for digit in str(n):\n            sum_digits += int(digit)\n        if sum_digits <= s:\n            return moves\n        n += 1\n        moves += 1\n\nt = int(input())\nfor _ in range(t):\n    n, s = map(int, input().split())\n    print(min_moves(n, s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997908353805542,
            0.9978423118591309,
            0.9976940155029297,
            0.9970356822013855,
            0.997988760471344,
            0.9976499676704407,
            0.9966515898704529,
            0.9971311688423157,
            0.9978501200675964,
            0.9974669218063354,
            0.9946995973587036,
            0.9975857138633728,
            0.9975857138633728,
            0.9959669709205627,
            0.9971694946289062,
            0.9982199668884277,
            0.995469331741333,
            0.9975600838661194,
            0.9974204897880554,
            0.9971222281455994
        ]
    },
    "4734": {
        "similarity": 0.9964113831520081,
        "body": "    vowels = \"aiou\"\n    if y[-1] == 'e':\n        return y + 'x' + p\n    elif y[-1] in vowels:\n        return y[:-1] + 'ex' + p\n    elif y.endswith('ex'):\n        return y + p\n    else:\n        return y + 'ex' + p\n\ny, p = input().split()\nprint(extend_name(y, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939651489257812,
            0.9929502606391907,
            0.9941079020500183,
            0.9955718517303467,
            0.993393063545227,
            0.9912850260734558,
            0.9936128258705139,
            0.9955621361732483,
            0.9935680031776428,
            0.9941255450248718,
            0.9953328967094421,
            0.9927344918251038,
            0.9919432401657104,
            0.9948270916938782,
            0.9950481057167053,
            0.9962501525878906,
            0.9954748749732971,
            0.9897386431694031,
            0.9934298992156982,
            0.9964113831520081
        ]
    },
    "4229": {
        "similarity": 0.9976117014884949,
        "body": "import sys\n\n    total = 0\n    i = 1\n    for _ in range(n):\n        if i % 15 == 0:\n            total += 'FizzBuzz'\n        elif i % 3 == 0:\n            total += 'Fizz'\n        elif i % 5 == 0:\n            total += 'Buzz'\n        else:\n            total += str(i)\n        i += 1\n    fizz_buzz_numbers = [int(num) for num in str(total).split(',') if num != 'Fizz' and num != 'Buzz']\n    return sum(fizz_buzz_numbers)\n\nn = int(input())\nprint(fizz_buzz_sum(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961439371109009,
            0.9967929720878601,
            0.9976117014884949,
            0.9971120953559875,
            0.9970887899398804,
            0.9957929253578186,
            0.9975438714027405,
            0.9959292411804199,
            0.9975243806838989,
            0.9973965883255005,
            0.9960567951202393,
            0.9967550039291382,
            0.9972040057182312,
            0.9945084452629089,
            0.9966976642608643,
            0.9955624938011169,
            0.9971830248832703,
            0.9956325888633728,
            0.9975581765174866,
            0.9949212670326233
        ]
    },
    "4321": {
        "similarity": 0.9964844584465027,
        "body": "import sys\n\n    for _ in range(k):\n        last_digit = n % 10\n        if last_digit > 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\nn, k = map(int, input().split())\nprint(tanya(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936907887458801,
            0.9960542321205139,
            0.9951376914978027,
            0.9935494661331177,
            0.9938467144966125,
            0.9951836466789246,
            0.9949098825454712,
            0.9952759146690369,
            0.995737612247467,
            0.9944123029708862,
            0.9964044690132141,
            0.9943975210189819,
            0.9946370720863342,
            0.9949760437011719,
            0.9964844584465027,
            0.995945155620575,
            0.9960203766822815,
            0.9958271384239197,
            0.993741512298584,
            0.9962055683135986
        ]
    },
    "4503": {
        "similarity": 0.9970864057540894,
        "body": "import sys\n\n    used = [False] * N\n    health_left = H\n    for i in range(N):\n        if health_left <= 0:\n            return True\n        used[i] = True\n        health_left -= A[i]\n        for j in range(N):\n            if not used[j]:\n                if health_left - A[j] <= 0:\n                    return True\n    return False\n\nH, N = map(int, input().split())\nA = list(map(int, input().split()))\nprint('Yes' if can_win_without_repeating(H, N, A) else 'No')",
        "result": "failed: testcase 0",
        "similarities": [
            0.995701253414154,
            0.9958592653274536,
            0.996596097946167,
            0.9939818382263184,
            0.9952112436294556,
            0.9968827962875366,
            0.9959395527839661,
            0.9967508912086487,
            0.9965971112251282,
            0.9969834089279175,
            0.9941737651824951,
            0.9969570636749268,
            0.9933648705482483,
            0.9970864057540894,
            0.9925830364227295,
            0.9958114624023438,
            0.9964760541915894,
            0.9966773986816406,
            0.9965497255325317,
            0.9959309101104736
        ]
    },
    "4855": {
        "similarity": 0.9948767423629761,
        "body": "import math\n\n    articles, impact_factor = [int(x) for x in input().split()]\n    total_citations = math.ceil(articles * impact_factor)\n    return total_citations - articles\n\nprint(calculate_min_scientists())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9899339079856873,
            0.9900444746017456,
            0.9889494180679321,
            0.9917494058609009,
            0.9948767423629761,
            0.9940444827079773,
            0.9906417727470398,
            0.9934628009796143,
            0.9940080046653748,
            0.9934260845184326,
            0.9940344095230103,
            0.9937927722930908,
            0.9888295531272888,
            0.9931684136390686,
            0.9940553903579712,
            0.9944106936454773,
            0.9904076457023621,
            0.9927526116371155,
            0.9944076538085938,
            0.9903074502944946
        ]
    },
    "4704": {
        "similarity": 0.9968153238296509,
        "body": "import sys\n\n    n = int(input())\n    arr = list(map(int, input().split()))\n    \n    prefix_sum = [0]\n    for num in arr:\n        prefix_sum.append(prefix_sum[-1] + num)\n        \n    min_diff = float('inf')\n    for i in range(1, n):\n        x = prefix_sum[i] - prefix_sum[1]\n        y = prefix_sum[n] - prefix_sum[i+1]\n        diff = abs(x-y)\n        if diff < min_diff:\n            min_diff = diff\n            \n    return min_diff\n\nprint(min_abs_diff())",
        "result": "failed: testcase 0",
        "similarities": [
            0.991295576095581,
            0.9965448975563049,
            0.9958274364471436,
            0.996313214302063,
            0.9958032369613647,
            0.9956406950950623,
            0.996082603931427,
            0.9956063628196716,
            0.9960881471633911,
            0.9954613447189331,
            0.9965077638626099,
            0.9968153238296509,
            0.9957124590873718,
            0.9960533976554871,
            0.99547278881073,
            0.9960945844650269,
            0.9942245483398438,
            0.9958969950675964,
            0.9966804385185242,
            0.9968022704124451
        ]
    },
    "4829": {
        "similarity": 0.9965025186538696,
        "body": "    left, right = sorted(map(int, input().split()))\n    if left == 0 and right == 0:\n        return \"Not a moose\"\n    elif left == right:\n        return f\"Even {2 * left}\"\n    else:\n        return f\"Odd {2 * max(left, right)}\"\n\nprint(moose_points())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965025186538696,
            0.9939475059509277,
            0.9950467348098755,
            0.9933093190193176,
            0.9958820343017578,
            0.9938433766365051,
            0.9961385130882263,
            0.9950541257858276,
            0.9944051504135132,
            0.9951589703559875,
            0.996120274066925,
            0.9939402341842651,
            0.9933650493621826,
            0.9937666058540344,
            0.9961679577827454,
            0.9922372698783875,
            0.9960336089134216,
            0.9941134452819824,
            0.9959684610366821,
            0.9949933290481567
        ]
    },
    "4730": {
        "similarity": 0.9971665740013123,
        "body": "import sys\n    line_length = int(input())\n    program = input().strip()\n    opening_count = {'(': 0, '[': 0, '{': 0}\n    closing_count = {')': 0, ']': 0, '}': 0}\n    current_stack = []\n    for i in range(line_length):\n        char = program[i]\n        if char in opening_count:\n            current_stack.append((char, i))\n            opening_count[char] += 1\n        elif char in closing_count:\n            if not current_stack:\n                return f'\\n{char} {i}'\n            last_opening_char, last_index = current_stack.pop()\n            closing_count[char] += 1\n            if (last_opening_char == '(' and char != ')') or \\\n               (last_opening_char == '[' and char != ']') or \\\n               (last_opening_char == '{' and char != '}'):\n                return f'\\n{char} {i}'\n    if sum(opening_count.values()) < sum(closing_count.values()):\n        return 'ok so far'\n    for opening_char, _ in current_stack:\n        closing_count[char] += 1\n    for opening_char, count in opening_count.items():\n        if count != closing_count[matching_closing_char(opening_char)]:\n            return f'\\n{matching_closing_char(opening_char)} {line_length - 1}'\n    if char == '(':\n        return ')'\n    elif char == '[':\n        return ']'\n    else:\n        return '}'\n\nprint(validate_delimiters())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948694109916687,
            0.9955548048019409,
            0.9970940351486206,
            0.9968572854995728,
            0.9967675805091858,
            0.9971665740013123,
            0.9970912933349609,
            0.9960315227508545,
            0.9969966411590576,
            0.9944412112236023,
            0.9954804182052612,
            0.9962206482887268,
            0.9963605999946594,
            0.9971104860305786,
            0.9959971904754639,
            0.9968015551567078,
            0.9960201978683472,
            0.9953737854957581,
            0.996181070804596,
            0.9955746531486511
        ]
    },
    "4729": {
        "similarity": 0.9969894289970398,
        "body": "import sys\n\n    password_chars = sorted(list(password))\n    found_chars = {}\n    for i in range(len(message)):\n        if message[i] not in found_chars:\n            for char in password_chars:\n                if char == message[i]:\n                    found_chars[char] = i\n                    break\n            else:\n                return False\n        if i < len(found_chars) and message[i] != password_chars[found_chars.keys().index(next((c for c in password_chars if c not in found_chars), ''))]:\n            return False\n    return True\n\np, m = input().split()\nif is_valid_message(p, m):\n    print('PASS')\nelse:\n    print('FAIL')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959839582443237,
            0.9969872832298279,
            0.9958362579345703,
            0.9968243837356567,
            0.9965641498565674,
            0.9969894289970398,
            0.994716227054596,
            0.9962378144264221,
            0.9965082406997681,
            0.9960566163063049,
            0.9962021708488464,
            0.9910779595375061,
            0.9965547323226929,
            0.9901004433631897,
            0.9961427450180054,
            0.9963129758834839,
            0.9944337606430054,
            0.9960373640060425,
            0.9966856241226196,
            0.9968404173851013
        ]
    },
    "4582": {
        "similarity": 0.994022786617279,
        "body": "a = input()\nb = input()\n\n    if a == 'H':\n        if b == 'D':\n            return 'D'\n        else:\n            return 'H'\n\nprint(game(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9908816814422607,
            0.9890723824501038,
            0.9938226342201233,
            0.994022786617279,
            0.9938256144523621,
            0.989939272403717,
            0.9939087629318237,
            0.9846700429916382,
            0.9935048818588257,
            0.9934969544410706,
            0.9887193441390991,
            0.9854958057403564,
            0.9916612505912781,
            0.9871774315834045,
            0.991784930229187,
            0.9925224781036377,
            0.9917873740196228,
            0.9884781241416931,
            0.9894696474075317,
            0.989785373210907
        ]
    },
    "4910": {
        "similarity": 0.996017336845398,
        "body": "import sys\nfrom collections import defaultdict\n\nbest_cats = []\nmax_count = 0\n\nfor i in range(int(input())):\n    cat = input().strip()\n    counts[cat] += 1\n    if counts[cat] > max_count:\n        best_cats.clear()\n        max_count = counts[cat]\n        best_cats.append(cat)\n    elif counts[cat] == max_count:\n        best_cats.append(cat)\n\nbest_cats.sort()\n\nfor cat in best_cats:\n    print(cat)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953884482383728,
            0.9923320412635803,
            0.994942307472229,
            0.9954833984375,
            0.9945388436317444,
            0.9946818947792053,
            0.992104172706604,
            0.9915193319320679,
            0.996017336845398,
            0.9950820803642273,
            0.9938706755638123,
            0.994343638420105,
            0.9941510558128357,
            0.9939253926277161,
            0.9949067831039429,
            0.9925569295883179,
            0.9936216473579407,
            0.992561936378479,
            0.9958345293998718,
            0.9954646229743958
        ]
    },
    "4323": {
        "similarity": 0.9974266886711121,
        "body": "import sys\nn, m = map(int, input().split())\na = []\nb = []\nfor i in range(n):\n    a_i, b_i = map(int, input().split())\n    a.append(a_i)\n    b.append(b_i)\n\n    count = 0\n    for i in range(n - 1, -1, -1):\n        compressed = True\n        total = sum([a[j] if j != i else b[i] for j in range(n)])\n        for j in range(i + 1, n):\n            if a[j] > m - total:\n                compressed = False\n                break\n        if not compressed:\n            count += 1\n    return count\n\nprint(solve() if sum(a) <= m else -1)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953752160072327,
            0.9968424439430237,
            0.9967374205589294,
            0.996504008769989,
            0.9968392252922058,
            0.9968034029006958,
            0.9967516660690308,
            0.9971010088920593,
            0.9966980814933777,
            0.9965745806694031,
            0.9968452453613281,
            0.9974266886711121,
            0.9963228106498718,
            0.9971476197242737,
            0.9972243309020996,
            0.9963597655296326,
            0.9960748553276062,
            0.9942247271537781,
            0.9967004060745239,
            0.9965468049049377
        ]
    },
    "4626": {
        "similarity": 0.9947982430458069,
        "body": "import sys\n\n    q = int(input())\n    for _ in range(q):\n        a, b, c = sorted(map(int, input().split()))\n        min_dist = abs(a - b) + abs(b - c)\n        if a == b or b == c:\n            print(min_dist)\n        else:\n            print(min_dist + 2 * max(0, (a - b) // 2, (b - c) // 2))\n\nif __name__ == \"__main__\":\n    min_total_pairwise_distance()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930576682090759,
            0.994158923625946,
            0.9914615154266357,
            0.9945521354675293,
            0.9947982430458069,
            0.9908495545387268,
            0.9940145611763,
            0.9924609661102295,
            0.9936517477035522,
            0.9906312823295593,
            0.9924687743186951,
            0.9943354725837708,
            0.9915205240249634,
            0.994626522064209,
            0.9921292662620544,
            0.9921770691871643,
            0.9935543537139893,
            0.992949366569519,
            0.9944006204605103,
            0.9928914308547974
        ]
    },
    "4400": {
        "similarity": 0.9978892803192139,
        "body": "import sys\n\n    s = input()\n    rainy_days = 0\n    current_rainy_days = 0\n\n    for char in s:\n        if char == 'R':\n            current_rainy_days += 1\n            rainy_days = max(rainy_days, current_rainy_days)\n        else:\n            current_rainy_days = 0\n\n    return rainy_days\n\nprint(max_consecutive_rainy_days())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978892803192139,
            0.9975203275680542,
            0.9964810609817505,
            0.9960410594940186,
            0.9977019429206848,
            0.9973121285438538,
            0.9962841868400574,
            0.9966822266578674,
            0.9968498945236206,
            0.9962743520736694,
            0.9976913928985596,
            0.9958571195602417,
            0.9968829154968262,
            0.9975724816322327,
            0.9971577525138855,
            0.9971058368682861,
            0.9976850152015686,
            0.9963685274124146,
            0.997356116771698,
            0.9975572228431702
        ]
    },
    "4794": {
        "similarity": 0.9966580271720886,
        "body": "    r, c = map(int, input().split())\n    parking_map = []\n    for _ in range(r):\n        parking_map.append(input())\n\n    possible_squash_counts = [0] * 5\n    for i in range(0, r - 1):\n        for j in range(0, c - 1):\n            if parking_map[i][j] != '#' and parking_map[i][j + 1] != '#' \\\n                    and parking_map[i + 1][j] != '#' and parking_map[i + 1][j + 1] != '#':\n                space_squashed = 0\n                for x in range(2):\n                    for y in range(2):\n                        if parking_map[i + x][j + y] == 'X':\n                            space_squashed += 1\n                possible_squash_counts[space_squashed] += 1\n\n    print(possible_squash_counts[0])\n    print(possible_squash_counts[1])\n    print(possible_squash_counts[2])\n    print(possible_squash_counts[3])\n    print(possible_squash_counts[4])",
        "result": "passed",
        "similarities": [
            0.994891345500946,
            0.9956543445587158,
            0.9958617687225342,
            0.9937381744384766,
            0.9940374493598938,
            0.9945875406265259,
            0.9962083101272583,
            0.9950011372566223,
            0.9962988495826721,
            0.9958652853965759,
            0.9956877827644348,
            0.9956186413764954,
            0.9963206052780151,
            0.995009183883667,
            0.9951314330101013,
            0.9966580271720886,
            0.994098961353302,
            0.9962278604507446,
            0.9956007599830627,
            0.9963812828063965
        ]
    },
    "4096": {
        "similarity": 0.9965466856956482,
        "body": "import sys\n    total = 0\n    days = 0\n    for i in sorted(a, reverse=True):\n        if i <= days:\n            continue\n        else:\n            diff = i - (days + 1)\n            if total + diff > m:\n                return False\n            total += diff\n            days += 1\n    return True\n\n    for i in range(len(a), 0, -1):\n        a.sort(reverse=True)\n        if can_finish(m, a[:i]):\n            return i\n    return -1\n\nm, n = map(int, input().split())\na = list(map(int, input().split()))\nprint(min_days(m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.994415819644928,
            0.9927275776863098,
            0.9960469603538513,
            0.9941112995147705,
            0.9954386353492737,
            0.9931190013885498,
            0.9963235259056091,
            0.9959638714790344,
            0.9940902590751648,
            0.9949433207511902,
            0.9965466856956482,
            0.9953453540802002,
            0.9961374998092651,
            0.995733380317688,
            0.9942812919616699,
            0.9957076907157898,
            0.9931353330612183,
            0.9954327940940857,
            0.9933016896247864,
            0.9946180582046509
        ]
    },
    "4530": {
        "similarity": 0.9966785907745361,
        "body": "    n = int(input())\n    skills = sorted(map(int, input().split()))\n\n    unique_skills = set()\n    repeated_skills = {}\n    for skill in skills:\n        if skill not in unique_skills:\n            unique_skills.add(skill)\n            if skill not in repeated_skills:\n                repeated_skills[skill] = 1\n            else:\n                repeated_skills[skill] += 1\n\n    max_size = 0\n    i = len(unique_skills) - 1\n    while i >= 0:\n        size = min(repeated_skills.get(skills[i], 0), n // 2)\n        for _ in range(size):\n            del unique_skills[skills.pop(i)]\n\n        if len(unique_skills) + size <= n // 2 and all(val == 1 for val in repeated_skills.values()):\n            max_size += size\n\n        i -= 1\n    return max_size\n\nimport sys\nt = int(input())\nfor _ in range(t):\n    print(max_team_size())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954093098640442,
            0.9962658286094666,
            0.9943884611129761,
            0.994626522064209,
            0.9959820508956909,
            0.9950138926506042,
            0.9950724244117737,
            0.9959524273872375,
            0.9910693168640137,
            0.9952825307846069,
            0.9954317808151245,
            0.9960793256759644,
            0.9962752461433411,
            0.9960294961929321,
            0.9961508512496948,
            0.9941140413284302,
            0.9946974515914917,
            0.9959331154823303,
            0.9966785907745361,
            0.9953208565711975
        ]
    },
    "4724": {
        "similarity": 0.995581865310669,
        "body": "    performance = R + (G - R) * 2\n    return int(performance)\n\nR = int(input())\nG = int(input())\n\nprint(required_performance(R, G))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934355020523071,
            0.9940669536590576,
            0.9943121671676636,
            0.9891262054443359,
            0.9954909086227417,
            0.9942468404769897,
            0.9920564889907837,
            0.994242250919342,
            0.9890351891517639,
            0.9942641854286194,
            0.9912129640579224,
            0.995581865310669,
            0.9954798817634583,
            0.9911052584648132,
            0.992845356464386,
            0.9925123453140259,
            0.993945300579071,
            0.9932686686515808,
            0.9938313364982605,
            0.9946486949920654
        ]
    },
    "4276": {
        "similarity": 0.9976774454116821,
        "body": "    n, t = map(int, input().split())\n    routes = []\n    for i in range(n):\n        cost, time = map(int, input().split())\n        if time <= t:\n            routes.append((cost, time))\n    if not routes:\n        return 'TLE'\n    min_cost = float('inf')\n    for route in sorted(routes):\n        if route[1] <= t and route[0] < min_cost:\n            min_cost = route[0]\n    return min_cost\n\nprint(find_min_cost())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960030317306519,
            0.9969635009765625,
            0.9957879781723022,
            0.9969397187232971,
            0.9971078634262085,
            0.9972104430198669,
            0.9976774454116821,
            0.9971042275428772,
            0.9976090788841248,
            0.9972525238990784,
            0.9976216554641724,
            0.9971580505371094,
            0.9971426725387573,
            0.9952585101127625,
            0.9950204491615295,
            0.9973678588867188,
            0.9969972372055054,
            0.9963600039482117,
            0.9966768026351929,
            0.9961216449737549
        ]
    },
    "4708": {
        "similarity": 0.9967122673988342,
        "body": "    n = int(input())\n    k = int(input())\n    x = int(input())\n    y = int(input())\n\n    fee = 0\n    for i in range(1, min(n, k) + 1):\n        fee += x\n\n    if n > k:\n        for i in range(k + 1, n + 1):\n            fee += y\n\n    print(fee)\n\nhotel_fee()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961913228034973,
            0.9946940541267395,
            0.9964442849159241,
            0.9964154958724976,
            0.9929052591323853,
            0.9960277080535889,
            0.9958550333976746,
            0.9933750629425049,
            0.9961555004119873,
            0.996123194694519,
            0.9965083599090576,
            0.9953073263168335,
            0.9932885766029358,
            0.9955416321754456,
            0.9952818155288696,
            0.9960456490516663,
            0.9959722757339478,
            0.9967122673988342,
            0.9930034279823303,
            0.9939805865287781
        ]
    },
    "4396": {
        "similarity": 0.9975195527076721,
        "body": "import sys\n\n    n = int(input())\n    total_value = 0.0\n    for i in range(n):\n        x, u = input().split()\n        if u == \"JPY\":\n            total_value += float(x)\n        elif u == \"BTC\":\n            total_value += float(x) * 380000.0\n    print(total_value)\n\nconvert_otoshidama()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969721436500549,
            0.9939284920692444,
            0.9974344372749329,
            0.9968127012252808,
            0.9969052672386169,
            0.9974786639213562,
            0.9973564147949219,
            0.9968870282173157,
            0.9971417784690857,
            0.9938300251960754,
            0.9975195527076721,
            0.9956788420677185,
            0.9970688223838806,
            0.9951409101486206,
            0.9962736368179321,
            0.996271014213562,
            0.9968301653862,
            0.996399462223053,
            0.9961581230163574,
            0.9963035583496094
        ]
    },
    "4155": {
        "similarity": 0.9975457787513733,
        "body": "import sys\n\n    n = int(input())\n    heights = list(map(int, input().split()))\n\n    max_heights = [0] * (n + 1)\n    for i in range(n):\n        if heights[i] > max_heights[i]:\n            max_heights[i+1] = heights[i]\n\n    operations = 0\n    current_max = 0\n    for i in range(1, n+1):\n        if max_heights[i] > current_max:\n            operations += 1\n            current_max = max_heights[i]\n\n    return operations\n\nprint(min_watering_operations())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957988262176514,
            0.997236430644989,
            0.9964218139648438,
            0.9942098259925842,
            0.9949337840080261,
            0.9967207908630371,
            0.9967787861824036,
            0.9973662495613098,
            0.995096743106842,
            0.9968253970146179,
            0.9961531758308411,
            0.9961454272270203,
            0.9949723482131958,
            0.9937023520469666,
            0.9954077005386353,
            0.9975457787513733,
            0.9964565634727478,
            0.995322585105896,
            0.9953277111053467,
            0.9972438812255859
        ]
    },
    "4557": {
        "similarity": 0.9967983961105347,
        "body": "    for num_cats in range(X + 1):\n        if A >= num_cats <= A + B:\n            return \"YES\"\n    return \"NO\"\n\nA, B, X = map(int, input().split())\nprint(can_have_exactly_x_cats(A, B, X))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963828921318054,
            0.9962523579597473,
            0.9964388608932495,
            0.9956604838371277,
            0.9952480792999268,
            0.990356981754303,
            0.9957118630409241,
            0.9964134097099304,
            0.9963698387145996,
            0.9960170388221741,
            0.9959149956703186,
            0.9966065287590027,
            0.9965274333953857,
            0.9967983961105347,
            0.9948884844779968,
            0.9941693544387817,
            0.9964005351066589,
            0.9956788420677185,
            0.9925667643547058,
            0.9967029094696045
        ]
    },
    "4930": {
        "similarity": 0.9968519806861877,
        "body": "import re\n\n    words = s.split()\n    decoded_words = []\n    \n    for word in words:\n        vowels = 'aeiou'\n        decoded_word = ''\n        \n        i = 0\n        while i < len(word):\n            if word[i] in vowels:\n                decoded_word += word[i:i+3]\n                i += 3\n            else:\n                decoded_word += word[i]\n                i += 1\n                \n        decoded_words.append(decoded_word)\n        \n    return ' '.join(decoded_words)\n\nprint(decode_sentence(input()))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959873557090759,
            0.9954923391342163,
            0.9968519806861877,
            0.9948267936706543,
            0.9955341219902039,
            0.9963349103927612,
            0.9928737282752991,
            0.9954961538314819,
            0.9908341765403748,
            0.9960771799087524,
            0.9952549338340759,
            0.9961081147193909,
            0.9914142489433289,
            0.9964424967765808,
            0.9958879351615906,
            0.99505215883255,
            0.9956831932067871,
            0.9927071332931519,
            0.9926115274429321,
            0.9962373375892639
        ]
    },
    "4715": {
        "similarity": 0.9961336255073547,
        "body": "import sys\n\n    a, b, c = map(int, input().split())\n    colors = [a, b, c]\n    unique_colors = []\n    \n    for color in colors:\n        if color not in unique_colors:\n            unique_colors.append(color)\n            \n    return len(unique_colors)\n\nprint(count_different_colors())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958829283714294,
            0.9961336255073547,
            0.9953347444534302,
            0.9947094321250916,
            0.9957455992698669,
            0.9957717061042786,
            0.9876532554626465,
            0.992122232913971,
            0.9914643168449402,
            0.9956822991371155,
            0.9942562580108643,
            0.9934740662574768,
            0.9923061728477478,
            0.9932586550712585,
            0.9946063160896301,
            0.9875895977020264,
            0.9956845045089722,
            0.9923005700111389,
            0.9958333373069763,
            0.9937593340873718
        ]
    },
    "4008": {
        "similarity": 0.996974766254425,
        "body": "    a_count = [0] * 5001\n    color_map = [-1] * n\n    sorted_a = sorted((a[i], i) for i in range(n))\n    \n    for val, idx in sorted_a:\n        for i in range(1, k + 1):\n            if a_count[val - i] < i:\n                a_count[val - i] += 1\n                color_map[idx] = i\n                \n                for j in range(val - i + 1, val + 1):\n                    a_count[j] = 0\n                    \n                break\n    else:\n        return \"NO\"\n        \n    return \"YES\\n\" + ' '.join(map(str, color_map))\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(coloring(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946566224098206,
            0.9954853057861328,
            0.9942554831504822,
            0.9954739809036255,
            0.9968175292015076,
            0.996956467628479,
            0.9960141777992249,
            0.9963905811309814,
            0.9962186217308044,
            0.9963089823722839,
            0.9954772591590881,
            0.9953334331512451,
            0.9953874349594116,
            0.9964499473571777,
            0.9947413206100464,
            0.9957032799720764,
            0.995854914188385,
            0.996974766254425,
            0.9958512187004089,
            0.9953503012657166
        ]
    },
    "4257": {
        "similarity": 0.9936816692352295,
        "body": "import sys\n\n    a = int(input())\n    b = int(input())\n\n    product = 0\n    for i in range(b):\n        product += a\n\n    print(product)\n\nmultiply_A_by_B()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9878309369087219,
            0.9906651377677917,
            0.9903169274330139,
            0.9932610392570496,
            0.9819048643112183,
            0.9875885844230652,
            0.9920479655265808,
            0.9922776818275452,
            0.9895829558372498,
            0.984796404838562,
            0.9830201864242554,
            0.9880212545394897,
            0.9931878447532654,
            0.9927904009819031,
            0.9936816692352295,
            0.9902861714363098,
            0.9922627806663513,
            0.991676926612854,
            0.9872807860374451,
            0.986059308052063
        ]
    },
    "4584": {
        "similarity": 0.9964077472686768,
        "body": "import sys\n\n    count = [0] * n\n    for i in range(1, n):\n        if A[i - 1] != 1:\n            count[A[i - 1] - 1] += 1\n            count[i - 1] += 1\n    return '\\n'.join(map(str, count))\n\nN = int(input())\nA = list(map(int, input().split()))\nprint(solve(N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938286542892456,
            0.9948363304138184,
            0.9941741824150085,
            0.9964077472686768,
            0.9950288534164429,
            0.9946526885032654,
            0.992936372756958,
            0.9958266019821167,
            0.9960189461708069,
            0.9951645731925964,
            0.9959110617637634,
            0.9949780702590942,
            0.9934426546096802,
            0.9958008527755737,
            0.9959220886230469,
            0.9949880838394165,
            0.9959390759468079,
            0.9959937930107117,
            0.9962118268013,
            0.9933839440345764
        ]
    },
    "4195": {
        "similarity": 0.9958313703536987,
        "body": "import sys\n\n    integers = []\n    i = 1\n    while len(integers) < N:\n        is_divisible = True\n        for k in range(D + 1):\n            if i % (10**k * 100) != 0:\n                is_divisible = False\n                break\n        if is_divisible:\n            integers.append(i)\n        i += 1\n    return integers[-1]\n\nN, D = map(int, input().split())\nprint(get_smallest(N, D))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947900176048279,
            0.9958313703536987,
            0.9940723776817322,
            0.9929105043411255,
            0.9948377013206482,
            0.9929429292678833,
            0.9956719279289246,
            0.9945706725120544,
            0.9868608117103577,
            0.9948520660400391,
            0.987361490726471,
            0.9946401715278625,
            0.9909853935241699,
            0.9952298998832703,
            0.9945282340049744,
            0.9946921467781067,
            0.9937857389450073,
            0.9944689869880676,
            0.995045006275177,
            0.9954180717468262
        ]
    },
    "4176": {
        "similarity": 0.993251621723175,
        "body": "import math\n\n    lcm = 0\n    for a in range(1, A + 1):\n        for b in range(1, B + 1):\n            if (a * b) % (A * B) == 0 and ((a / B) <= 1 or (b / A) <= 1):\n                lcm = max(lcm, a * b)\n    return lcm\n\nA, B = map(int, input().split())\nprint(min_snacks(A, B))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9913671612739563,
            0.9887592792510986,
            0.9902074933052063,
            0.9929628968238831,
            0.9862878918647766,
            0.99211585521698,
            0.988092839717865,
            0.9821150898933411,
            0.9920312166213989,
            0.9900794625282288,
            0.9865853190422058,
            0.9919745922088623,
            0.9924125671386719,
            0.993251621723175,
            0.9897142052650452,
            0.9870446920394897,
            0.9895339608192444,
            0.9896203279495239,
            0.9929566979408264,
            0.9736620187759399
        ]
    },
    "4166": {
        "similarity": 0.9967300295829773,
        "body": "import sys\n\n    N, M = map(int, input().split())\n    digits = []\n    for _ in range(M):\n        s_i, c_i = map(int, input().split())\n        digits.append((s_i - 1, c_i))\n    digits.sort()\n    number = [0] * N\n    for i, (index, digit) in enumerate(digits):\n        number[index] = digit\n    answer = ''\n    for n in number:\n        answer += str(n)\n    if int(answer) >= 0:\n        print(int(answer))\n    else:\n        print(-1)\n\nsmallest_number()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9881384968757629,
            0.9961660504341125,
            0.9948878884315491,
            0.9958989024162292,
            0.9956517815589905,
            0.9955592155456543,
            0.9965447187423706,
            0.9951054453849792,
            0.9963195323944092,
            0.9929822683334351,
            0.9955714344978333,
            0.9955131411552429,
            0.9967077374458313,
            0.9965674877166748,
            0.9951001405715942,
            0.9939088225364685,
            0.9967300295829773,
            0.9963842630386353,
            0.9962146282196045,
            0.9951017498970032
        ]
    },
    "4827": {
        "similarity": 0.994912326335907,
        "body": "    num_words = int(input())\n    words = []\n    for i in range(num_words):\n        word = input()\n        if word == \"$\":\n            words.append(\"$$$\")\n        else:\n            words.append(word)\n    total_length = sum(len(word) for word in words)\n    ones_names = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\"]\n    teens_names = [\"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens_names = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    hundreds_names = [\"onehundred\", \"twohundred\", \"threehundred\", \"fourhundred\", \"fivehundred\", \"sixhundred\", \"sevenhundred\", \"eighthundred\", \"ninehundred\"]\n    \n        if n < 10:\n            return ones_names[n-1]\n        elif n < 20:\n            return teens_names[n-11]\n        else:\n            tens_digit = (n // 10) % 10\n            ones_digit = n % 10\n            if ones_digit == 0:\n                return tens_names[tens_digit-2]\n            else:\n                return tens_names[tens_digit-2] + ones_names[ones_digit-1]\n\n        hundreds_digit = (n // 100) % 10\n        remaining = n % 100\n        if hundreds_digit == 0:\n            return name_number(remaining)\n        else:\n            return hundreds_names[hundreds_digit-1] + name_number(remaining)\n\n    sentence_length = total_length\n    for i in range(1, total_length+1):\n        candidate = i\n        new_sentence_length = len(\" \".join(words)) - 2 + len(name_number_nice(candidate))\n        if new_sentence_length <= total_length and new_sentence_length < sentence_length:\n            sentence_length = new_sentence_length\n    sentence = \" \".join(words)\n    index = sentence.index(\"$\")\n    new_word = name_number_nice(sentence_length)\n    sentence = sentence[:index] + new_word + sentence[index+1:]\n    return sentence",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938511252403259,
            0.994002103805542,
            0.9933263659477234,
            0.9947056174278259,
            0.9924012422561646,
            0.9852074384689331,
            0.9940458536148071,
            0.9941539764404297,
            0.99335116147995,
            0.9911943674087524,
            0.9945839643478394,
            0.9938141703605652,
            0.9948514699935913,
            0.9940295219421387,
            0.9944510459899902,
            0.994912326335907,
            0.9916317462921143,
            0.9923523664474487,
            0.9912276268005371,
            0.9920064806938171
        ]
    },
    "4871": {
        "similarity": 0.9977394938468933,
        "body": "    n = len(scores)\n    group_score = 0\n    for i in range(n):\n        group_score += scores[i] * ((4 / 5) ** i)\n    return group_score / 5.0\n\n    new_scores_sum = 0\n    for i in range(n):\n        other_scores = scores[:i] + scores[i+1:]\n        group_score = calc_group_score(other_scores)\n        new_scores_sum += group_score\n    return new_scores_sum / n\n\nn = int(input())\nscores = [float(input()) for _ in range(n)]\ngroup_score = calc_group_score(scores)\naverage_new_score = average_new_scores(n, scores)\n\nprint(\"%f\" % group_score)\nprint(\"%f\" % average_new_score)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960439801216125,
            0.9975296854972839,
            0.9972400665283203,
            0.9967854022979736,
            0.9965322613716125,
            0.9962803721427917,
            0.9956865906715393,
            0.9962652325630188,
            0.9970592856407166,
            0.9963065981864929,
            0.9965723752975464,
            0.9976414442062378,
            0.9974759817123413,
            0.9976320862770081,
            0.9970951080322266,
            0.9975257515907288,
            0.9968044757843018,
            0.9970556497573853,
            0.9977394938468933,
            0.9967875480651855
        ]
    },
    "4148": {
        "similarity": 0.9973322153091431,
        "body": "import sys\n\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    shifted_S = ''\n    for s in S:\n        index = (alphabet.index(s) + N) % 26\n        shifted_S += alphabet[index]\n    return shifted_S\n\nN = int(input())\nS = input()\nprint(shift_string(N, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9922143220901489,
            0.996490478515625,
            0.9963729381561279,
            0.9959456920623779,
            0.9956813454627991,
            0.9956837892532349,
            0.9971306324005127,
            0.9968581199645996,
            0.9963292479515076,
            0.9968081116676331,
            0.9966555237770081,
            0.9964001178741455,
            0.9968934655189514,
            0.9973322153091431,
            0.9961864352226257,
            0.9973079562187195,
            0.996931791305542,
            0.995012104511261,
            0.9933935403823853,
            0.997330904006958
        ]
    },
    "4316": {
        "similarity": 0.9971017241477966,
        "body": "    count = {}\n    for char in S:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    kinds = len(count)\n    return kinds == 2 and 2 in count.values()\n\nS = input()\nprint('Yes' if has_two_kinds(S) else 'No')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970278739929199,
            0.9967633485794067,
            0.994229793548584,
            0.9948461651802063,
            0.9961706399917603,
            0.9961734414100647,
            0.9954621195793152,
            0.9967575073242188,
            0.9962158203125,
            0.9951310753822327,
            0.9964460134506226,
            0.9966515898704529,
            0.9926640391349792,
            0.9971017241477966,
            0.9954071044921875,
            0.9965978860855103,
            0.9969825744628906,
            0.9948621392250061,
            0.9967109560966492,
            0.9955205321311951
        ]
    },
    "4397": {
        "similarity": 0.995275616645813,
        "body": "    N, i = map(int, input().split())\n    j = N - i + 1\n    return j\n\nprint(find_car())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9900220632553101,
            0.9940443634986877,
            0.9926932454109192,
            0.993965744972229,
            0.9942554831504822,
            0.9947728514671326,
            0.9936162233352661,
            0.9919606447219849,
            0.9925154447555542,
            0.995275616645813,
            0.988718569278717,
            0.9901617169380188,
            0.9949529767036438,
            0.9906222820281982,
            0.9944320321083069,
            0.9909266233444214,
            0.9949529767036438,
            0.9946216940879822,
            0.9913232922554016,
            0.988034725189209
        ]
    },
    "4180": {
        "similarity": 0.9954888224601746,
        "body": "    num_bills = 0\n    for i in range(N, 0, -1000):\n        num_bills += N // i\n        N -= (N // i) * i\n    return N\n\nN = int(input())\nprint(min_change(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931581616401672,
            0.9948455691337585,
            0.9941012859344482,
            0.9949470162391663,
            0.9943976998329163,
            0.994454026222229,
            0.9933066368103027,
            0.9950668215751648,
            0.995175838470459,
            0.9927781820297241,
            0.9954888224601746,
            0.9885660409927368,
            0.9942660927772522,
            0.9930528402328491,
            0.9939243793487549,
            0.9950331449508667,
            0.9944965839385986,
            0.994480311870575,
            0.9796828031539917,
            0.9937669038772583
        ]
    },
    "4907": {
        "similarity": 0.9955641031265259,
        "body": "n = int(input())\n\nalice_wins = True\nfor i in range(2, n + 1):\n    bob_wins = False\n    for j in range(1, i - 1):\n        if (j <= n // 3) and ((i - j) <= n // 3 * 2):\n            bob_wins = True\n            break\n\n    if not bob_wins:\n        print(\"Alice\")\n        print(i)\n        exit()\n\nif alice_wins:\n    print(\"Bob\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9921770691871643,
            0.9955641031265259,
            0.9935548901557922,
            0.9941662549972534,
            0.9944489002227783,
            0.9949674010276794,
            0.995337963104248,
            0.9903658628463745,
            0.9946997761726379,
            0.9946274161338806,
            0.991624116897583,
            0.9938575625419617,
            0.9946522116661072,
            0.9830760955810547,
            0.9946918487548828,
            0.9951309561729431,
            0.991037905216217,
            0.9944237470626831,
            0.9915181398391724,
            0.994452953338623
        ]
    },
    "4839": {
        "similarity": 0.9956879019737244,
        "body": "    c = sorted(canisters)\n    total = sum(c)\n    for i in range(1, n + 1):\n        if total < i:\n            return \"impossible\"\n        total -= c.pop()\n    min_frac = float('inf')\n    for i in range(n - 1, 0, -1):\n        frac = (i * c[i] - total) / (n * i)\n        min_frac = min(min_frac, frac)\n        total += c[i]\n    return \"{:.6f}\".format(1.0 - min_frac)\n\nn = int(input())\ncanisters = list(map(int, input().split()))\nprint(max_fill(n, canisters))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9914321899414062,
            0.9943667054176331,
            0.9923584461212158,
            0.9944513440132141,
            0.9923151731491089,
            0.9924908876419067,
            0.9942637085914612,
            0.99404376745224,
            0.9947477579116821,
            0.9920884966850281,
            0.9935812950134277,
            0.9937210083007812,
            0.9923020601272583,
            0.9943404793739319,
            0.9909914135932922,
            0.9956879019737244,
            0.9947960376739502,
            0.9919527769088745,
            0.9934642314910889,
            0.9894510507583618
        ]
    },
    "4665": {
        "similarity": 0.9976417422294617,
        "body": "from collections import namedtuple\nimport sys\n\n    n = int(input())\n    column_names = list(map(str, input().split()))\n    marks_index = -1\n    for i in range(len(column_names)):\n        if 'MARKS' == column_names[i]:\n            marks_index = i\n            break\n    student_info = []\n    for _ in range(n):\n        info = namedtuple('StudentInfo', ', '.join(column_names))(input())\n        student_info.append(info)\n    total_marks = sum(getattr(student, 'MARKS') for student in student_info)\n    average_mark = (total_marks / n) if n != 0 else 0\n    print(f'{average_mark:.2f}')\n\ncalculate_average_marks()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968104958534241,
            0.9974664449691772,
            0.9971793293952942,
            0.9971984028816223,
            0.9974359273910522,
            0.9967931509017944,
            0.9957389831542969,
            0.9972069263458252,
            0.9932418465614319,
            0.9973002076148987,
            0.9954079389572144,
            0.9976417422294617,
            0.9970540404319763,
            0.9970514178276062,
            0.9970535635948181,
            0.9936074614524841,
            0.9970798492431641,
            0.9953024983406067,
            0.9961823225021362,
            0.9971025586128235
        ]
    },
    "4785": {
        "similarity": 0.9972469806671143,
        "body": "import sys\n\n    i = 0\n    while i < len(input_str) - 1:\n        if input_str[i] == 's' and input_str[i + 1] == 's':\n            return True\n        i += 1\n    return False\n\ninput_str = input()\nif check_for_hissing_s(input_str):\n    print('hiss')\nelse:\n    print('no hiss')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955357313156128,
            0.995238184928894,
            0.9968442320823669,
            0.9972469806671143,
            0.9952976703643799,
            0.9956676363945007,
            0.9953973889350891,
            0.9944452047348022,
            0.9968801736831665,
            0.9965187907218933,
            0.9960845112800598,
            0.9951549172401428,
            0.9969604015350342,
            0.9942187070846558,
            0.9969552755355835,
            0.9937020540237427,
            0.9963535666465759,
            0.9943773150444031,
            0.9957829713821411,
            0.9960880279541016
        ]
    },
    "4272": {
        "similarity": 0.995987057685852,
        "body": "import sys\n\n    count = 0\n    abc_count = 0\n    for i in range(N - 2):\n        if S[i] == 'A' and S[i + 1] == 'B' and S[i + 2] == 'C':\n            abc_count += 1\n        else:\n            abc_count = 0\n        count += abc_count\n    return count\n\nN = int(input())\nS = input()\nprint(count_abc(N, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9889453053474426,
            0.9956425428390503,
            0.995987057685852,
            0.9948824048042297,
            0.9959184527397156,
            0.9914711713790894,
            0.9948031902313232,
            0.9854828715324402,
            0.9951418042182922,
            0.9892449975013733,
            0.9925251007080078,
            0.9948254823684692,
            0.9953632354736328,
            0.9914989471435547,
            0.9952300190925598,
            0.995361328125,
            0.9952899813652039,
            0.9941177368164062,
            0.9948515892028809,
            0.9951193928718567
        ]
    },
    "4092": {
        "similarity": 0.9965142607688904,
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    ans = 0\n    for i in range(n):\n        if abs(a[i]) <= abs(a[0]):\n            ans += 1\n            prev = a[i]\n            a.insert(i + 1, -prev)\n        elif i < n and (a[i] <= -a[i - 1] or a[i] >= a[i - 1]):\n            ans += 1\n            a.insert(i, -a[i])\n    return ans\n\nprint(min_insertions())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959480166435242,
            0.9928126931190491,
            0.9954259991645813,
            0.9965142607688904,
            0.9964543581008911,
            0.9931977987289429,
            0.9963099956512451,
            0.9936088919639587,
            0.9962126016616821,
            0.9957582354545593,
            0.9950031638145447,
            0.9954882264137268,
            0.9952121376991272,
            0.9962919354438782,
            0.9941510558128357,
            0.9953159689903259,
            0.9946648478507996,
            0.9949662089347839,
            0.9957867860794067,
            0.9914940595626831
        ]
    },
    "4023": {
        "similarity": 0.996801495552063,
        "body": "import sys\n\n    max_height = max(a)\n    min_height = min(a)\n    if min_height == max_height:\n        return 'YES'\n    \n    heights = [min_height]\n    for i in range(1, n):\n        if a[i] > heights[-1]:\n            heights.append(a[i])\n        \n    for i in range(len(heights) - 2, -1, -1):\n        if (heights[i + 1] - heights[i]) % 2 != 0:\n            return 'NO'\n    \n    return 'YES'\n\nn = int(input())\na = list(map(int, input().split()))\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9922069907188416,
            0.9962733387947083,
            0.9960877299308777,
            0.9939808249473572,
            0.9949448108673096,
            0.9957077503204346,
            0.9946391582489014,
            0.996728777885437,
            0.9951428174972534,
            0.9961296916007996,
            0.9939218759536743,
            0.9966343641281128,
            0.9957427978515625,
            0.9954832196235657,
            0.9950803518295288,
            0.9945599436759949,
            0.9940706491470337,
            0.9952172040939331,
            0.996801495552063,
            0.9947372078895569
        ]
    },
    "4160": {
        "similarity": 0.9977318644523621,
        "body": "    x = int(input())\n    year = 0\n    balance = 100\n    while True:\n        year += 1\n        balance *= 101\n        if balance >= x:\n            return year\n\nprint(calculate_years())",
        "result": "failed: testcase 0",
        "similarities": [
            0.995448648929596,
            0.9970141053199768,
            0.9972255229949951,
            0.9963358640670776,
            0.9975237846374512,
            0.9970219135284424,
            0.9971954226493835,
            0.9967580437660217,
            0.9970532655715942,
            0.9966250061988831,
            0.9969891309738159,
            0.9975160360336304,
            0.996403157711029,
            0.997338056564331,
            0.9977318644523621,
            0.9976363778114319,
            0.9961432218551636,
            0.9943243265151978,
            0.9968450665473938,
            0.9969492554664612
        ]
    },
    "4815": {
        "similarity": 0.9969237446784973,
        "body": "    n, p, m = [int(x) for x in input().split()]\n    player_scores = {}\n    min_reach = {}\n\n    for _ in range(n):\n        name = input()\n        if name not in min_reach:\n            min_reach[name] = 0\n\n    for _ in range(m):\n        name, score = input().split()\n        score = int(score)\n        player_name = input()\n        if player_name not in player_scores:\n            player_scores[player_name] = 0\n        if name not in min_reach or min_reach[name] < player_scores[player_name]:\n            min_reach[name] = player_scores[player_name]\n\n    winners = []\n    for name, score in player_scores.items():\n        if score >= p and (name not in winners or min_reach[name] <= min_reach[winners[-1]]):\n            print(f'{name} wins!')\n            winners.append(name)\n\n    for winner in winners:\n        print(winner)\n\n\nfind_winners()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963505268096924,
            0.9932270050048828,
            0.9946433901786804,
            0.9960294961929321,
            0.9969237446784973,
            0.9945671558380127,
            0.9943422079086304,
            0.9960843324661255,
            0.99495929479599,
            0.9953898191452026,
            0.9947559237480164,
            0.9962859153747559,
            0.9969140887260437,
            0.996193528175354,
            0.9949570894241333,
            0.9968393445014954,
            0.9940488934516907,
            0.9929589033126831,
            0.9965039491653442,
            0.9959869384765625
        ]
    },
    "4514": {
        "similarity": 0.9965683817863464,
        "body": "    subordinates = [[] for _ in range(n + 1)]\n    for i in range(2, n + 1):\n        subordinates[parents[i]].append(i)\n    return subordinates\n\n    visited = [False] * (n + 1)\n    stack = [[u, 0]]\n    result = []\n    while stack:\n        v, index = stack.pop()\n        if not visited[v]:\n            result.append(v)\n            visited[v] = True\n            for w in sorted(subordinates[v]):\n                if not visited[w]:\n                    stack.append([w, len(result)])\n    return -1 if k > len(result) else result[k - 1]\n\nn, q = map(int, input().split())\nparents = list(map(int, input().split()))\nsubordinates = get_subordinates(n, parents)\nfor _ in range(q):\n    u, k = map(int, input().split())\n    print(solve(u, k, subordinates))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954553246498108,
            0.9952782988548279,
            0.994468092918396,
            0.995093822479248,
            0.9951196312904358,
            0.995855450630188,
            0.9955357313156128,
            0.9944362640380859,
            0.9965683817863464,
            0.9930936098098755,
            0.9950655102729797,
            0.9948300123214722,
            0.9863660931587219,
            0.9954690337181091,
            0.9951589703559875,
            0.995880126953125,
            0.994083821773529,
            0.9943538308143616,
            0.9954972863197327,
            0.9961022734642029
        ]
    },
    "4585": {
        "similarity": 0.9954875111579895,
        "body": "import sys\n\n    x = int(input())\n    for t in range(1, 10**9 + 1):\n        if abs(x - t) % t == 0:\n            return t\n    return None\n\nprint(find_earliest_time())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9935926198959351,
            0.9938352704048157,
            0.9945050477981567,
            0.9933620095252991,
            0.9876889586448669,
            0.9873968362808228,
            0.9940241575241089,
            0.9949499368667603,
            0.9929313659667969,
            0.9951818585395813,
            0.9950788617134094,
            0.993800699710846,
            0.9953497052192688,
            0.9940998554229736,
            0.9952903389930725,
            0.9948903918266296,
            0.9934696555137634,
            0.9946893453598022,
            0.9947333335876465,
            0.9954875111579895
        ]
    },
    "4781": {
        "similarity": 0.9967156648635864,
        "body": "    time_for_passing = 0\n    for i in range(len(questions)):\n        player = initial_player - 1\n        time, answer = questions[i]\n        if answer == 'P':\n            continue\n        while True:\n            player -= 1\n            if player < 0:\n                player += 8\n            if (time + time_for_passing) % 210 >= time:\n                break\n        if answer != 'T' or time > 180:\n            player = (player - 1) % 8 + 1\n        initial_player = player\n    return initial_player\n\ninitial_player = int(input())\nnum_questions = int(input())\n\nquestions = []\nfor i in range(num_questions):\n    _, answer = input().split()\n    questions.append((int(answer), answer))\n\nprint(get_player_with_box(initial_player, questions))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99596107006073,
            0.9954900145530701,
            0.9920622110366821,
            0.9960422515869141,
            0.9955255389213562,
            0.996174693107605,
            0.9956067800521851,
            0.9941168427467346,
            0.9947941303253174,
            0.9957567453384399,
            0.9967156648635864,
            0.9935734272003174,
            0.996351957321167,
            0.9958161115646362,
            0.9950729012489319,
            0.9955024719238281,
            0.9934417605400085,
            0.9950900673866272,
            0.9935849905014038,
            0.9963937401771545
        ]
    },
    "4551": {
        "similarity": 0.9963527321815491,
        "body": "    L = A + B\n    R = C + D\n\n    if L < R:\n        return \"Left\"\n    elif L <= R:\n        return \"Balanced\"\n    else:\n        return \"Right\"\n\na, b, c, d = map(int, input().split())\nprint(weigh(a, b, c, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995640218257904,
            0.9958674907684326,
            0.9934423565864563,
            0.9932760000228882,
            0.9959652423858643,
            0.9925132393836975,
            0.9929264783859253,
            0.994816243648529,
            0.9961267709732056,
            0.9963527321815491,
            0.9959608316421509,
            0.9954581260681152,
            0.9904602766036987,
            0.9898468852043152,
            0.9957605004310608,
            0.9957341551780701,
            0.9950146079063416,
            0.995925784111023,
            0.9938932657241821,
            0.995909571647644
        ]
    },
    "4345": {
        "similarity": 0.9973630309104919,
        "body": "    n = len(a)\n    increasing = [0] * n\n    decreasing = [1] * n\n\n    for i in range(n):\n        if i > 0:\n            if a[i - 1] < a[i]:\n                increasing[i] = increasing[i-1]\n            elif a[i - 1] == a[i]:\n                increasing[i] = 2\n            else:\n                increasing[i] = 3\n\n            if a[i - 1] > a[i]:\n                decreasing[i] = decreasing[i-1]\n            elif a[i - 1] == a[i]:\n                decreasing[i] = 2\n            else:\n                decreasing[i] = 3\n\n    for i in range(n):\n        if increasing[i] >= 3 or decreasing[i] >= 3:\n            return \"NO\"\n\n    res = [0] * n\n    for i in range(n):\n        if increasing[i] != 2 and decreasing[i] == 2:\n            res[i] = 1\n\n    return [\"YES\", ' '.join(map(str, res))]\n\nn = int(input())\na = list(map(int, input().split()))\nprint(insertions(a)[0])\nif insertions(a)[0] == \"YES\":\n    print(\" \".join(map(str,insertions(a)[1])))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965763092041016,
            0.9966273903846741,
            0.9961241483688354,
            0.9964715838432312,
            0.9949770569801331,
            0.9971683025360107,
            0.9966974854469299,
            0.9960541129112244,
            0.9954651594161987,
            0.9971533417701721,
            0.9966127276420593,
            0.9973630309104919,
            0.9972403645515442,
            0.9969056844711304,
            0.9965792298316956,
            0.9970231652259827,
            0.9953931570053101,
            0.9964385032653809,
            0.9968783855438232,
            0.9968506693840027
        ]
    },
    "4075": {
        "similarity": 0.997748851776123,
        "body": "    n, m = map(int, input().split())\n    switches = {}\n    for i in range(m):\n        k_i, *s_ij = map(int, input().split())\n        for s in s_ij:\n            if s not in switches:\n                switches[s] = 0\n        switches[i+1] = len(s_ij)\n    p = list(map(int, input().split()))\n    result = 1 << n\n    for i in range(m):\n        count = [0] * (n + 1)\n        for s in switches.get(i+1, []):\n            count[s] += 1\n        even_count = sum(1 for c in count if c % 2 == 0)\n        odd_count = sum(count) - even_count\n        result *= int(even_count >= p[i] and odd_count < p[i])\n    return result\n\nprint(count_combinations())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975591897964478,
            0.9967890381813049,
            0.9970773458480835,
            0.9976840019226074,
            0.9962209463119507,
            0.9974734783172607,
            0.9971700310707092,
            0.997748851776123,
            0.9969354271888733,
            0.9971611499786377,
            0.9976174235343933,
            0.9974441528320312,
            0.9958677887916565,
            0.9962590932846069,
            0.997203528881073,
            0.9972640872001648,
            0.997597336769104,
            0.9974378347396851,
            0.9977326989173889,
            0.9966325163841248
        ]
    },
    "4408": {
        "similarity": 0.9967619180679321,
        "body": "import sys\n\n    n, k = map(int, input().split())\n    cards = list(map(int, input().split()))\n    favorites = list(map(int, input().split()))\n    joy_levels = list(map(int, input().split()))\n\n    counts = [0] * 100001\n    for card in cards:\n        counts[card] += 1\n\n    sorted_favorites = []\n    for favorite in set(favorites):\n        count = favorites.count(favorite)\n        sorted_favorites.append((favorite, count))\n\n    sorted_favorites.sort()\n\n    max_total_joy = [0] * (n + 1)\n\n    for i, favorite in enumerate(sorted_favorites):\n        counts[favorite[0]] -= favorite[1]\n        max_total_joy[0] += min(counts[favorite[0]], k) * joy_levels[k - favorite[1]]\n\n        if i > 0:\n            for j in range(1, n + 1):\n                max_total_joy[j] = max(max_total_joy[j], max_total_joy[j - 1])\n\n                count = min(counts[favorite[0]], k - j)\n                max_total_joy[j] = max(max_total_joy[j], max_total_joy[j - 1] + joy_levels[k - j] * count)\n\n    return max_total_joy[n]\n\nprint(max_joy_levels())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958394765853882,
            0.9962692260742188,
            0.9947776794433594,
            0.9954641461372375,
            0.9963804483413696,
            0.9964720010757446,
            0.9956663250923157,
            0.9958652853965759,
            0.996099591255188,
            0.9951076507568359,
            0.9960780143737793,
            0.996590256690979,
            0.9952159523963928,
            0.9955773949623108,
            0.9960256814956665,
            0.9945222735404968,
            0.9958275556564331,
            0.9960916638374329,
            0.9959716796875,
            0.9967619180679321
        ]
    },
    "4282": {
        "similarity": 0.996687114238739,
        "body": "import sys\n\n    pairs = {}\n    for i in range(1, n + 1):\n        a1, a2 = map(int, input().split())\n        pairs[a1] = (i, a2)\n        pairs[a2] = (i, a1)\n\n    adj = [[] for _ in range(n + 1)]\n    for kid, pair in pairs.items():\n        i, next_kid = pair\n        if next_kid == kid:\n            continue\n        if not adj[i]:\n            adj[i].append(next_kid)\n        else:\n            adj[next_kid].append(i)\n\n    visited = [False] * (n + 1)\n    for node in range(1, n + 1):\n        if not visited[node]:\n            path = []\n            dfs(node, path, adj, visited)\n            for p in path:\n                print(p, end=' ')\n\n    path.append(node)\n    visited[node] = True\n    for next_node in adj[node]:\n        if not visited[next_node]:\n            dfs(next_node, path, adj, visited)\n\nn = int(input())\nrestore_order(n, None)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996386706829071,
            0.9941125512123108,
            0.996201753616333,
            0.9955518841743469,
            0.9948208332061768,
            0.9966226816177368,
            0.9959858655929565,
            0.9948182702064514,
            0.9963455200195312,
            0.9961468577384949,
            0.9950204491615295,
            0.9962348937988281,
            0.9961820840835571,
            0.9932662844657898,
            0.9957162141799927,
            0.9960840344429016,
            0.9948059916496277,
            0.9964003562927246,
            0.9961258769035339,
            0.996687114238739
        ]
    },
    "4331": {
        "similarity": 0.9972200989723206,
        "body": "    digits = []\n    for d in str(n):\n        digits.append(d)\n    for digit in digits:\n        if digit == '7':\n            return 'Yes'\n    return 'No'\n\nn = int(input())\nprint(check_digit(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963384866714478,
            0.9937262535095215,
            0.9940769672393799,
            0.9931166768074036,
            0.9968795776367188,
            0.9957461953163147,
            0.9929074048995972,
            0.9932577013969421,
            0.9960294961929321,
            0.9963638186454773,
            0.9972200989723206,
            0.9966208934783936,
            0.9967836141586304,
            0.9966760873794556,
            0.9956461191177368,
            0.9968193769454956,
            0.9965816140174866,
            0.9954140186309814,
            0.996347963809967,
            0.9966474771499634
        ]
    },
    "4550": {
        "similarity": 0.9958499073982239,
        "body": "import sys\n\n    total_candies = a + b + c\n    if total_candies % 2 == 0:\n        return \"Yes\"\n    else:\n        return \"No\"\n\na, b, c = map(int, input().split())\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942647218704224,
            0.9940218925476074,
            0.9936834573745728,
            0.9954763650894165,
            0.9958499073982239,
            0.9955733418464661,
            0.9873636960983276,
            0.9927275776863098,
            0.9953392744064331,
            0.995023250579834,
            0.9952101707458496,
            0.9954619407653809,
            0.9943116903305054,
            0.9949674010276794,
            0.9946564435958862,
            0.9956759214401245,
            0.993961751461029,
            0.9941352009773254,
            0.9953643679618835,
            0.9947612285614014
        ]
    },
    "4271": {
        "similarity": 0.9948905110359192,
        "body": "    n = int(input())\n    a_values = list(map(int, input().split()))\n    b_values = list(map(int, input().split()))\n    c_values = list(map(int, input().split()))\n\n    satisfaction_points = 0\n    for i in range(n):\n        if i == (n - 1):\n            satisfaction_points += b_values[a_values[i] - 1]\n        else:\n            satisfaction_points += b_values[a_values[i] - 1] + c_values[i]\n\n    return satisfaction_points\n\nprint(calculate_satisfaction_points())",
        "result": "failed: testcase 0",
        "similarities": [
            0.99399334192276,
            0.9912874102592468,
            0.9942488670349121,
            0.9908906817436218,
            0.9938966631889343,
            0.9925419688224792,
            0.9921983480453491,
            0.9914778470993042,
            0.9877498149871826,
            0.9941220879554749,
            0.9929572939872742,
            0.9881963133811951,
            0.9905142784118652,
            0.993627667427063,
            0.9927751421928406,
            0.994160532951355,
            0.992539644241333,
            0.9912235736846924,
            0.9923943281173706,
            0.9948905110359192
        ]
    },
    "4848": {
        "similarity": 0.9987218976020813,
        "body": "import math\n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(2, n):\n    if is_squarefree(m * n):\n        print(m)\n        break",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975929260253906,
            0.9977519512176514,
            0.9987218976020813,
            0.9976589679718018,
            0.9982087016105652,
            0.9986525177955627,
            0.9972291588783264,
            0.9960378408432007,
            0.9983328580856323,
            0.9986899495124817,
            0.9983827471733093,
            0.996497392654419,
            0.998134195804596,
            0.9986758232116699,
            0.9982820153236389,
            0.9986428618431091,
            0.9982368350028992,
            0.9987066388130188,
            0.9979137778282166,
            0.9984709024429321
        ]
    },
    "4694": {
        "similarity": 0.9969731569290161,
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    min_dist = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = (a[j] - a[i]) * 2\n            for k in range(n):\n                if k != i and k != j:\n                    dist += abs(a[k] - a[i])\n                    dist += abs(a[k] - a[j])\n\n            min_dist = min(min_dist, dist)\n\n    return min_dist\n\nprint(min_distance())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961327314376831,
            0.9942758679389954,
            0.9967227578163147,
            0.9963330626487732,
            0.9960993528366089,
            0.9958667755126953,
            0.9934473633766174,
            0.9945599436759949,
            0.9963445067405701,
            0.9960955381393433,
            0.9947942495346069,
            0.9956845641136169,
            0.991521954536438,
            0.9960087537765503,
            0.9934867024421692,
            0.9960947632789612,
            0.9957548379898071,
            0.9969731569290161,
            0.9931872487068176,
            0.9954917430877686
        ]
    },
    "4213": {
        "similarity": 0.9974802732467651,
        "body": "import sys\n\n    min_val = abs(A[0])\n    max_val = 0\n    for num in A:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return max_val - min_val\n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(max_abs_diff(A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973568320274353,
            0.9974068999290466,
            0.9967876076698303,
            0.9974756836891174,
            0.9969570636749268,
            0.9964792132377625,
            0.9967756867408752,
            0.996240496635437,
            0.9965867400169373,
            0.995673656463623,
            0.9972752928733826,
            0.9960371255874634,
            0.9963434934616089,
            0.9947239756584167,
            0.9896563291549683,
            0.9958174824714661,
            0.9974802732467651,
            0.9972676634788513,
            0.9952247142791748,
            0.9973036050796509
        ]
    },
    "4471": {
        "similarity": 0.9961805939674377,
        "body": "    if max(heights) % 2 == 0:\n        return \"YES\"\n    for i in range(n):\n        heights[i] += 1\n        while max(heights) > 0:\n            for j in range(n):\n                heights[j] -= 1\n    return \"NO\" if max(heights) > 0 else \"YES\"\n\nn = int(input())\nfor _ in range(n):\n    m = int(input())\n    heights = list(map(int, input().split()))\n    print(can_clear_field(m, heights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949214458465576,
            0.9927545189857483,
            0.9948429465293884,
            0.9885977506637573,
            0.9842354655265808,
            0.9944239258766174,
            0.9940050840377808,
            0.9924455285072327,
            0.995426595211029,
            0.9945895671844482,
            0.9942042827606201,
            0.9960595369338989,
            0.9952624440193176,
            0.9953306317329407,
            0.9958478212356567,
            0.9945982098579407,
            0.9961805939674377,
            0.9956556558609009,
            0.9950168132781982,
            0.9953186511993408
        ]
    },
    "4802": {
        "similarity": 0.9956520795822144,
        "body": "import sys\n\n    hours, minutes = sorted(map(int, input().split()))\n    new_minutes = minutes - 45\n    if new_minutes < 0:\n        new_hours = hours - 1\n        new_minutes += 60\n        if new_hours < 0:\n            new_hours = 23\n    else:\n        new_hours = hours\n\n    print(f\"{new_hours} {new_minutes}\")\n\nget_new_time()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9810996055603027,
            0.992432177066803,
            0.9915345907211304,
            0.9914562106132507,
            0.9952872395515442,
            0.9955450296401978,
            0.9928467273712158,
            0.9945546388626099,
            0.9955395460128784,
            0.9937850832939148,
            0.9939996600151062,
            0.99498450756073,
            0.9956520795822144,
            0.9949643015861511,
            0.9953591227531433,
            0.9952524900436401,
            0.9945970773696899,
            0.9952766299247742,
            0.9926072955131531,
            0.9946185946464539
        ]
    },
    "4890": {
        "similarity": 0.995934247970581,
        "body": "import sys\n\n    n, m, s, d = map(int, input().split())\n    curr_bottles = list(map(int, input().split()))\n    \n    available_slots = [d - x for x in curr_bottles]\n    total_available = sum(available_slots)\n    \n    new_bottles_per_slot = []\n    \n    if n <= m * min(d, max(curr_bottles)):\n        return 'impossible'\n        \n    for i in range(s):\n        available_space = d - curr_bottles[i]\n        needed = min(n - (i * d), available_space)\n        \n        new_bottles_per_slot.append(needed)\n        n -= needed\n        curr_bottles[i] += needed\n        \n    if n > 0:\n        new_bottles_per_slot[0] += n\n        \n    return ' '.join(map(str, new_bottles_per_slot))\n\nprint(optimize_refill_scheme())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958632588386536,
            0.9951151013374329,
            0.9941039085388184,
            0.9941055178642273,
            0.9951855540275574,
            0.9931644797325134,
            0.9956740140914917,
            0.9941611289978027,
            0.9944614768028259,
            0.9959330558776855,
            0.9914703369140625,
            0.9952033162117004,
            0.9949236512184143,
            0.9946761727333069,
            0.9937905669212341,
            0.9943750500679016,
            0.9947730898857117,
            0.995934247970581,
            0.99344402551651,
            0.9928231835365295
        ]
    },
    "4286": {
        "similarity": 0.9976370930671692,
        "body": "import sys\nfrom collections import defaultdict\n\n    n, m = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    edges = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        edges.append([x, y, w])\n\n    adj = defaultdict(list)\n    for i in range(1, n+1):\n        adj[i].append(i)\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n        rootx = find(x)\n        rooty = find(y)\n        if rootx == rooty:\n            return\n        if rank[rootx] > rank[rooty]:\n            parent[rooty] = rootx\n        else:\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n        for j in adj[i]:\n            if find(j) != find(i):\n                union(i, j)\n                dfs(j)\n\n    connected_components = n\n    cost = sum(a)\n    edges.sort(key=lambda x: a[x[0]] + a[x[1]])\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            cost -= (a[u] + a[v]) - w\n            connected_components -= 1\n    if connected_components > 1:\n        dfs(1)\n        return sum(a) - cost\n\n    sys.stdout.write(str(cost))\n\nmin_coins_to_connect_graph()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976370930671692,
            0.9969495534896851,
            0.9959339499473572,
            0.9974822998046875,
            0.993678629398346,
            0.9965262413024902,
            0.9963959455490112,
            0.997044026851654,
            0.9968754649162292,
            0.9970611929893494,
            0.9968873858451843,
            0.9968276023864746,
            0.9969241619110107,
            0.9931445121765137,
            0.9966082572937012,
            0.9936843514442444,
            0.9965569376945496,
            0.9964816570281982,
            0.9976303577423096,
            0.9968841075897217
        ]
    },
    "4713": {
        "similarity": 0.996801495552063,
        "body": "import sys\n\n    N = int(input())\n    S = input()\n    x = 0\n    max_val = 0\n    for i in range(N):\n        if S[i] == 'I':\n            x += 1\n        else:\n            x -= 1\n        max_val = max(max_val, x)\n    return max_val\n\nprint(max_value_taken_by_x())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965595602989197,
            0.9959456920623779,
            0.9964684247970581,
            0.9964678883552551,
            0.9953246116638184,
            0.9963268637657166,
            0.9938796162605286,
            0.9920228719711304,
            0.9960886240005493,
            0.992012619972229,
            0.9964335560798645,
            0.9924929738044739,
            0.9962179064750671,
            0.996301531791687,
            0.9947583079338074,
            0.9900321960449219,
            0.9953801035881042,
            0.996801495552063,
            0.9957058429718018,
            0.9959527850151062
        ]
    },
    "4698": {
        "similarity": 0.9963294863700867,
        "body": "import sys\n\n    total_times = []\n    for i in range(1, m + 1):\n        time = 0\n        for j in range(1, n + 1):\n            if p_x[j - 1][0] == i:\n                time += min(t[j - 1], p_x[j - 1][1])\n            else:\n                time += t[j - 1]\n        total_times.append(time)\n    return total_times\n\nn = int(input())\nt = list(map(int, input().split()))\nm = int(input())\np_x = []\nfor _ in range(m):\n    p, x = map(int, input().split())\n    p_x.append((p, x))\n\ntotal_times = calculate_time(n, t, m, p_x)\nfor time in total_times:\n    print(time)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941011071205139,
            0.9962799549102783,
            0.9932824969291687,
            0.9962387084960938,
            0.9943090677261353,
            0.9954524636268616,
            0.9953039288520813,
            0.9935991168022156,
            0.9956339597702026,
            0.9928538799285889,
            0.9958693981170654,
            0.9906153678894043,
            0.994176983833313,
            0.9941011667251587,
            0.9951086640357971,
            0.9942886233329773,
            0.9963294863700867,
            0.9960373640060425,
            0.9955514669418335,
            0.994995653629303
        ]
    },
    "4841": {
        "similarity": 0.9977515339851379,
        "body": "import sys\n\n    count = 0\n    last_num = -1\n    for bite in bites:\n        if bite == \"mumble\":\n            continue\n        num = int(bite)\n        if num < last_num or num != count + 1:\n            return False\n        count += 1\n        last_num = num\n    return True\n\nn = int(input())\nbites = input().split()\nif check_counting(n, bites):\n    print(\"makes sense\")\nelse:\n    print(\"something is fishy\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971166253089905,
            0.9970054626464844,
            0.9944866895675659,
            0.9965775012969971,
            0.9960039854049683,
            0.9977515339851379,
            0.9965822100639343,
            0.9969919919967651,
            0.9966322183609009,
            0.9971325397491455,
            0.9972080588340759,
            0.996928870677948,
            0.9957879781723022,
            0.9947606325149536,
            0.9975446462631226,
            0.9953659772872925,
            0.9967749714851379,
            0.9970964193344116,
            0.9975804686546326,
            0.9959604144096375
        ]
    },
    "4865": {
        "similarity": 0.9965218901634216,
        "body": "import sys\n\n    test_cases = int(input())\n    for _ in range(test_cases):\n        direction, delta_minutes, hour, minute = input().split()\n        delta_minutes = int(delta_minutes)\n        hour = int(hour)\n        minute = int(minute)\n\n        if direction == 'F':\n            new_minute = (minute + delta_minutes) % 60\n            new_hour = (hour + (minute + delta_minutes) // 60) % 24\n        else:\n            new_minute = (minute - delta_minutes) % 60\n            new_hour = (hour - (minute - delta_minutes) // 60 + 24) % 24\n\n        print(f'{new_hour} {new_minute}')\n\ncalculate_new_time()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959909319877625,
            0.9955523610115051,
            0.9940696358680725,
            0.9901999235153198,
            0.9952298402786255,
            0.9939073324203491,
            0.9884507060050964,
            0.9954625368118286,
            0.9955903887748718,
            0.9937836527824402,
            0.9956016540527344,
            0.9932567477226257,
            0.9930786490440369,
            0.9954935312271118,
            0.9955525994300842,
            0.9965218901634216,
            0.9952054619789124,
            0.9954986572265625,
            0.9935535788536072,
            0.9961527585983276
        ]
    },
    "4957": {
        "similarity": 0.9975292086601257,
        "body": "import sys\n\n    land_cells = []\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                land_cells.append((i, j))\n    \n    visited = [[False for _ in range(m)] for _ in range(n)]\n    coffee_shops = [['' for _ in range(m)] for _ in range(n)]\n\n        if 0 <= i < n and 0 <= j < m:\n            if grid[i][j] == '.' and not visited[i][j]:\n                visited[i][j] = True\n                for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = i + x, j + y\n                    if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and not visited[nx][ny]:\n                        place_coffee_shop(nx, ny)\n                coffee_shops[i][j] = 'E'\n\n    for cell in land_cells:\n        place_coffee_shop(cell[0], cell[1])\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and not visited[i][j]:\n                place_coffee_shop(i, j)\n\n    return '\\n'.join(''.join(row) for row in coffee_shops)\n\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\nprint(cover_land(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950617551803589,
            0.9958794116973877,
            0.9956135153770447,
            0.9963276386260986,
            0.9957819581031799,
            0.9959715008735657,
            0.9955514669418335,
            0.9971721172332764,
            0.9972802996635437,
            0.9967579245567322,
            0.9967681765556335,
            0.9958283305168152,
            0.9970220327377319,
            0.9968025088310242,
            0.9937723278999329,
            0.9975292086601257,
            0.9955064058303833,
            0.9973704814910889,
            0.9973283410072327,
            0.9953179955482483
        ]
    },
    "4382": {
        "similarity": 0.9951503276824951,
        "body": "import sys\n\n    n = int(input())\n    total = 1\n    for digit in range(n + 1):\n        for _ in range(3):\n            total *= (n - digit + 1)\n    return total\n\nprint(count_passwords())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934706687927246,
            0.9933839440345764,
            0.9929919838905334,
            0.9924848675727844,
            0.9924445748329163,
            0.9929885864257812,
            0.9917548298835754,
            0.9923577904701233,
            0.9946321249008179,
            0.9946243762969971,
            0.9951503276824951,
            0.9940610527992249,
            0.9914928078651428,
            0.9817004799842834,
            0.9914491772651672,
            0.9944620728492737,
            0.9940378069877625,
            0.9939725995063782,
            0.9912354350090027,
            0.9916887879371643
        ]
    },
    "4456": {
        "similarity": 0.9966311454772949,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    char_count = defaultdict(int)\n    for i in range(1, n + 1):\n        char_count[p[i]] += 1\n        char_count[q[n - i]] += 1\n\n    min_count = min(char_count.values())\n    if min_count < k:\n        return \"NO\"\n\n    p_min_char = [None] * (n + 1)\n    q_max_char = [None] * (n + 1)\n\n    for i in range(1, n + 1):\n        p_min_char[i] = chr((ord(p[i]) - ord('a') + 1) % k + ord('a'))\n        q_max_char[n - i + 1] = chr((ord(q[n - i]) - ord('a') + 1) % k + ord('a'))\n\n    s = [''] * n\n    for i in range(1, n):\n        p_min_char[i] = min(p_min_char[i], p_min_char[i - 1])\n        q_max_char[i + 1] = max(q_max_char[i + 1], q_max_char[i])\n\n        if p_min_char[i] == q_max_char[i + 1]:\n            s[n - i - 1] = p_min_char[i]\n\n    return 'YES\\n' + ''.join(s[::-1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955944418907166,
            0.9959966540336609,
            0.9877932667732239,
            0.9954245686531067,
            0.995918869972229,
            0.9922630190849304,
            0.9961098432540894,
            0.9966311454772949,
            0.995375394821167,
            0.9964624047279358,
            0.9955235719680786,
            0.9957981109619141,
            0.9958816170692444,
            0.9963808655738831,
            0.9966017007827759,
            0.9965591430664062,
            0.9959150552749634,
            0.9950118064880371,
            0.9960570335388184,
            0.9956387877464294
        ]
    },
    "4594": {
        "similarity": 0.9966416954994202,
        "body": "import sys\n\n    n = int(input())\n    d = [0] + sorted([int(i) for i in sys.stdin.readlines()[1:]], reverse=True)\n    layers = 1\n    smallest_so_far = d[1]\n\n    for i in range(2, n+1):\n        if d[i] < smallest_so_far:\n            smallest_so_far = d[i]\n            layers += 1\n\n    return layers\n\nprint(max_kagami_mochi_layers())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954760670661926,
            0.9954731464385986,
            0.995741605758667,
            0.9956530332565308,
            0.9966416954994202,
            0.9953895211219788,
            0.9945560097694397,
            0.9960645437240601,
            0.9965686798095703,
            0.9956178069114685,
            0.9917308688163757,
            0.9965248107910156,
            0.9966264367103577,
            0.9962106347084045,
            0.9924107789993286,
            0.9950709939002991,
            0.9959142804145813,
            0.9962903261184692,
            0.9962823987007141,
            0.9955159425735474
        ]
    },
    "4560": {
        "similarity": 0.997156023979187,
        "body": "import sys\n\n    one_yen = n % 500\n    if one_yen > a or one_yen < 0:\n        return 'No'\n    \n    number_of_500_yen = (n - one_yen) // 500\n    for i in range(number_of_500_yen + 1):\n        if i * 500 <= n and (n - i * 500) <= a:\n            return 'Yes'\n\n    return 'No'\n\na = int(input())\nn = int(input())\n\nprint(can_pay_exactly(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952455759048462,
            0.9928233623504639,
            0.9959461092948914,
            0.9960956573486328,
            0.996526300907135,
            0.9965125918388367,
            0.9957797527313232,
            0.9969242811203003,
            0.9954549670219421,
            0.9969685077667236,
            0.9928905367851257,
            0.9967400431632996,
            0.9961145520210266,
            0.9968594908714294,
            0.9951990246772766,
            0.9970689415931702,
            0.9964503049850464,
            0.997156023979187,
            0.996988832950592,
            0.9951340556144714
        ]
    },
    "4320": {
        "similarity": 0.9962822794914246,
        "body": "import sys\n    n = int(input())\n    for x in range(1, n + 1):\n        k = 0\n        total = 0\n        while True:\n            if k == 0 or total > n:\n                break\n            total += x * (2 ** k)\n            k += 1\n        if total == n:\n            return x\n\nprint(my_function())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944855570793152,
            0.9962611794471741,
            0.991753339767456,
            0.994089663028717,
            0.9958288073539734,
            0.9958438873291016,
            0.994546115398407,
            0.9900565147399902,
            0.9959407448768616,
            0.9891649484634399,
            0.995975911617279,
            0.9961914420127869,
            0.9955728650093079,
            0.9958010315895081,
            0.9962297081947327,
            0.9954550862312317,
            0.9931523203849792,
            0.9962760806083679,
            0.9962822794914246,
            0.9949445128440857
        ]
    },
    "4500": {
        "similarity": 0.9965463280677795,
        "body": "    total_yen = A + B\n    for i in range(C + 1):\n        if total_yen >= i and (total_yen - i) <= C:\n            return \"Yes\"\n\n    return \"No\"\n\nA, B, C = map(int, input().split())\nprint(takahashi_can_buy(A, B, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99514240026474,
            0.9951478838920593,
            0.9929416179656982,
            0.9956592917442322,
            0.9955329895019531,
            0.9947383403778076,
            0.9965463280677795,
            0.9924013018608093,
            0.9949813485145569,
            0.995527982711792,
            0.9949067831039429,
            0.9959943890571594,
            0.9943790435791016,
            0.9926711916923523,
            0.9912310242652893,
            0.9944104552268982,
            0.994906485080719,
            0.9958789348602295,
            0.9961624145507812,
            0.9960170388221741
        ]
    },
    "4739": {
        "similarity": 0.9965440630912781,
        "body": "import sys\n\n    M, N = map(int, input().split())\n    times = list(map(int, input().split()))\n    distances = list(map(int, input().split()))\n\n    speeds = set()\n    for i in range(M):\n        for j in range(i + 1, M):\n            prev_time = times[i]\n            curr_time = times[j]\n            dist_diff = distances[j] - distances[i]\n            time_diff = (curr_time - prev_time) / 1800  # Convert from minutes to hours\n            speed = dist_diff / time_diff if time_diff != 0 else float('inf')\n            speeds.add(int(speed))\n\n    print(len(speeds))\n    sorted_speeds = sorted(list(speeds))\n    for i in range(1, len(sorted_speeds)):\n        if sorted_speeds[i] == sorted_speeds[i - 1]:\n            continue\n        sys.stdout.write(str(sorted_speeds[i]) + ' ')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947688579559326,
            0.9952376484870911,
            0.9963503479957581,
            0.9951993227005005,
            0.9947133660316467,
            0.9956884980201721,
            0.9954442381858826,
            0.9932255148887634,
            0.9957128167152405,
            0.9943519234657288,
            0.9962314963340759,
            0.9933955669403076,
            0.9952938556671143,
            0.9938932657241821,
            0.9963768720626831,
            0.9947353005409241,
            0.9953832030296326,
            0.9951252341270447,
            0.9940521121025085,
            0.9965440630912781
        ]
    },
    "4410": {
        "similarity": 0.9974375367164612,
        "body": "import sys\n\n    ones = 0\n    leftmost_zero = float('inf')\n    \n    for i in range(n):\n        if s[i] == '1':\n            ones += 1\n            leftmost_zero = min(leftmost_zero, i - k)\n        \n        if s[i] == '0' and i >= leftmost_zero + k:\n            max_ones += 1\n    \n    return max(0, ones - max_ones)\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    s = input()\n    print(max_occupied_tables(n, k, s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942293763160706,
            0.9973267316818237,
            0.9971427917480469,
            0.9974375367164612,
            0.9931663870811462,
            0.9971960186958313,
            0.9960818886756897,
            0.9971185326576233,
            0.9964860677719116,
            0.9962696433067322,
            0.9966250061988831,
            0.994978666305542,
            0.9955242872238159,
            0.9969708323478699,
            0.9966848492622375,
            0.997416079044342,
            0.9955855011940002,
            0.9961763620376587,
            0.995558500289917,
            0.9962527751922607
        ]
    },
    "2441": {
        "similarity": 0.9980944395065308,
        "body": "import sys\n\n    n = int(input())\n    costs = list(map(int, input().split()))\n    m = int(input())\n    roads = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    cost = [0] * (n + 1)\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        roads[u].append(v)\n\n        if node != n:\n            visited[node] = True\n        stack = [node]\n        while len(stack) > 0:\n            curr_node = stack[-1]\n            for neighbor in roads[curr_node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append(neighbor)\n            stack.pop()\n        return\n\n    ways = 1\n    min_cost = float('inf')\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n        curr_cost = costs[i - 1]\n        temp_costs = [0] * (n + 1)\n\n        for j in range(1, n + 1):\n            if visited[j]:\n                temp_costs[j] = min(temp_costs[j], curr_cost)\n                cost[j] += temp_costs[j]\n\n        max_temp = float('-inf')\n        for j in range(n - 1, 0, -1):\n            if visited[j] and cost[j] <= max_temp:\n                ways = (ways * 2) % 1000000007\n            max_temp = max(max_temp, cost[j])\n\n    for i in range(1, n + 1):\n        min_cost = min(min_cost, costs[i - 1] + cost[i])\n\n    return '{} {}'.format(min_cost, ways)\n\nprint(min_security_cost_and_ways())",
        "result": "failed: testcase 0",
        "similarities": [
            0.997290849685669,
            0.997604250907898,
            0.9945170879364014,
            0.9978191256523132,
            0.9972004294395447,
            0.9972809553146362,
            0.9976426959037781,
            0.9973654747009277,
            0.996968150138855,
            0.9980944395065308,
            0.9969003796577454,
            0.9977824687957764,
            0.9967960715293884,
            0.9975607991218567,
            0.9967184662818909,
            0.9974435567855835,
            0.9966254234313965,
            0.9971188902854919,
            0.9978504180908203,
            0.997580885887146
        ]
    },
    "276": {
        "similarity": 0.9965196847915649,
        "body": "import sys\n\n    n = int(input())\n    colors = []\n    absent_names = []\n\n    for i in range(n):\n        color = input()\n        colors.append(color)\n\n    all_colors = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']\n    for name, color in zip(['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind'], all_colors):\n        if color not in colors:\n            absent_names.append(name)\n\n    print(len(absent_names))\n    for name in absent_names:\n        print(name)\n\nget_absent_gems()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939224123954773,
            0.9946056008338928,
            0.9957911968231201,
            0.9955567121505737,
            0.9963740110397339,
            0.9962722659111023,
            0.9931455850601196,
            0.9937029480934143,
            0.9947461485862732,
            0.9953611493110657,
            0.9955160021781921,
            0.9948586225509644,
            0.9940537810325623,
            0.9945076704025269,
            0.9897757172584534,
            0.9947758913040161,
            0.9934913516044617,
            0.9952080249786377,
            0.9951362609863281,
            0.9965196847915649
        ]
    },
    "2635": {
        "similarity": 0.9967456459999084,
        "body": "import sys\n\n    if not matrix or not all(matrix[0]):\n        return []\n    rows = len(matrix)\n    cols = len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n\n    while True:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(right, left - 1, -1):\n            result.append(matrix[bottom][i])\n        bottom -= 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(bottom, top - 1, -1):\n            result.append(matrix[i][left])\n        left += 1\n\n    print(result)\n\nmatrix = [list(map(int, input().split())) for _ in range(int(input()))]\nspiral_order(matrix)",
        "result": "failed: testcase 0",
        "similarities": [
            0.995898425579071,
            0.9948015809059143,
            0.995999276638031,
            0.9955077171325684,
            0.9964653849601746,
            0.9962955117225647,
            0.9955374002456665,
            0.994411051273346,
            0.9952648878097534,
            0.9928213357925415,
            0.9955862164497375,
            0.9959311485290527,
            0.9930917620658875,
            0.9947240948677063,
            0.9967456459999084,
            0.9953609108924866,
            0.9923892617225647,
            0.9935595989227295,
            0.9942079782485962,
            0.9956918358802795
        ]
    },
    "281": {
        "similarity": 0.9962363243103027,
        "body": "import math\nimport sys\n\n    a_factorial = 1\n    for i in range(1, a + 1):\n        a_factorial *= i\n\n    temp = 1\n    for i in range(a, b + 1):\n        temp *= i\n    result = a_factorial * pow(temp, -1, 10)\n    return result % 10\n\na, b = map(int, input().split())\nprint(last_digit(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9888440370559692,
            0.9909444451332092,
            0.996118426322937,
            0.9942009449005127,
            0.9955194592475891,
            0.9951043725013733,
            0.994852602481842,
            0.9962096214294434,
            0.995603084564209,
            0.9961146116256714,
            0.9943030476570129,
            0.99602210521698,
            0.9956201314926147,
            0.9954757690429688,
            0.9959142804145813,
            0.9944632649421692,
            0.9947292804718018,
            0.9953593015670776,
            0.9948076009750366,
            0.9962363243103027
        ]
    },
    "2300": {
        "similarity": 0.9972679018974304,
        "body": "import sys\n\n    n, m = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    operations = []\n    for i in range(m):\n        op_type = int(input())\n        if op_type == 1:\n            x, v = map(int, input().split())\n            operations.append((op_type, x, v))\n        elif op_type == 2:\n            l, r = map(int, input().split())\n            operations.append((op_type, l, r))\n\n    return n, m, a, operations\n\n    for t, *params in operations:\n        if t == 1:\n            x, v = params\n            a[x] = v\n        elif t == 2:\n            l, r = params\n            f = [0] * (r - l + 2)\n            f[0] = f[1] = 1\n            for i in range(2, len(f)):\n                f[i] = f[i-1] - 1 + f[i-2]\n            ans = sum(a[l+x] * f[x+1] for x in range(r-l+1))\n        else:\n            l, r, d = params\n            for x in range(l, r+1):\n                a[x] += d\n\n    return [a[x] % 1000000000 for x in range(1, n+1)]\n\n    _, _, a, operations = process_input()\n    ans = perform_operations(len(a)-1, len(operations), a, operations)\n    print('\\n'.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951095581054688,
            0.9971587657928467,
            0.9972679018974304,
            0.9967818260192871,
            0.9964276552200317,
            0.9953130483627319,
            0.9967284202575684,
            0.9966159462928772,
            0.9968320727348328,
            0.9967896342277527,
            0.9970952868461609,
            0.9967036843299866,
            0.9924127459526062,
            0.997186541557312,
            0.9954382181167603,
            0.9958441853523254,
            0.9969996213912964,
            0.9970040917396545,
            0.9965543150901794,
            0.9970234632492065
        ]
    },
    "2104": {
        "similarity": 0.9964637756347656,
        "body": "import sys\n\n    l, r = map(int, input().split())\n    if (r - l + 1) % 2 == 0:\n        return \"NO\"\n\n    pairs = []\n    for i in range(l, r + 1, 2):\n        pairs.append((i, i + 1))\n    print(\"YES\")\n    total_pairs = (r - l + 1) // 2\n    for i in range(total_pairs):\n        if pairs[i][0] % 2 == 1:\n            j = i * 2\n        else:\n            j = i * 2 + 1\n        print(pairs[j])\n\nget_pairs()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961270093917847,
            0.9926868081092834,
            0.9942502379417419,
            0.9948676228523254,
            0.9951999187469482,
            0.9932155609130859,
            0.9957773089408875,
            0.9936878085136414,
            0.9959009885787964,
            0.9953674674034119,
            0.9958293437957764,
            0.9964637756347656,
            0.995789110660553,
            0.9928979277610779,
            0.9961198568344116,
            0.9939278364181519,
            0.9963358640670776,
            0.9960224032402039,
            0.996067225933075,
            0.9927635192871094
        ]
    },
    "1995": {
        "similarity": 0.9972654581069946,
        "body": "import sys\n\n    s = list(s)\n    substring = s[l-1:r]\n    shifted_substring = substring[-k:] + substring[:-k]\n    s[l-1:r] = shifted_substring\n    return ''.join(s)\n\ns = input()\nm = int(input())\nfor _ in range(m):\n    l, r, k = map(int, input().split())\n    s = cyclic_shift(s, l, r, k)\nprint(s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965782165527344,
            0.9962426424026489,
            0.994583249092102,
            0.9965720176696777,
            0.9966152906417847,
            0.9958227276802063,
            0.9961535930633545,
            0.9972654581069946,
            0.9957652688026428,
            0.9968593120574951,
            0.9965556263923645,
            0.9955325722694397,
            0.9964580535888672,
            0.9958990216255188,
            0.9927363991737366,
            0.9970071911811829,
            0.9956347942352295,
            0.9967275261878967,
            0.9959623217582703,
            0.9965701699256897
        ]
    },
    "2064": {
        "similarity": 0.9949037432670593,
        "body": "import sys\n\n    digits = []\n    for i in range(9, 0, -1):\n        if n >= i:\n            n -= i\n            digits.append(i)\n    num_str = ''\n    for digit in sorted(digits):\n        num_str += str(digit)\n    return num_str\n\nn = int(input())\nprint(max_integer(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9895204305648804,
            0.9947896599769592,
            0.9939519166946411,
            0.9949037432670593,
            0.9925128817558289,
            0.9939126372337341,
            0.9920132160186768,
            0.9947136640548706,
            0.9917721152305603,
            0.9943550825119019,
            0.9947750568389893,
            0.9916189312934875,
            0.9902577996253967,
            0.9933976531028748,
            0.9881618022918701,
            0.9937232136726379,
            0.9941385388374329,
            0.9940792918205261,
            0.9916720390319824,
            0.9770233035087585
        ]
    },
    "1715": {
        "similarity": 0.9955568909645081,
        "body": "import sys\n    distances = []\n    for i in range(Q):\n        min_distance = float('inf')\n        for j in range(A):\n            left = abs(shrines[j] - queries[i])\n            for k in range(B):\n                right = max(0, min(abs(shrines[j] - temples[k]), abs(queries[i] - temples[k])))\n                distance = left + right\n                if distance < min_distance:\n                    min_distance = distance\n        distances.append(min_distance)\n    return distances\n\nA, B, Q = map(int, input().split())\nshrines = list(map(int, input().split()))\ntemples = list(map(int, input().split()))\nqueries = list(map(int, input().split()))\n\ndistances = get_min_distance(A, B, Q, shrines, temples, queries)\nfor distance in distances:\n    print(distance)",
        "result": "failed: testcase 0",
        "similarities": [
            0.991899311542511,
            0.9943080544471741,
            0.9902086853981018,
            0.9943372011184692,
            0.9930261373519897,
            0.9955568909645081,
            0.99413001537323,
            0.9951220154762268,
            0.9940133690834045,
            0.9918460845947266,
            0.9935792684555054,
            0.9935798645019531,
            0.9938350319862366,
            0.9932183027267456,
            0.9918277263641357,
            0.9946098327636719,
            0.9938786029815674,
            0.9948749542236328,
            0.99249267578125,
            0.9933700561523438
        ]
    },
    "2074": {
        "similarity": 0.9966091513633728,
        "body": "    n, m = map(int, input().split())\n    costs = [list(map(int, input().split())) for _ in range(n)]\n\n    max_street = 0\n    max_cost = 0\n\n    for i in range(n):\n        street_max = 0\n        for j in range(m):\n            if costs[i][j] > street_max:\n                street_max = costs[i][j]\n        if street_max > max_cost:\n            max_cost = street_max\n            max_street = i + 1\n\n    min_avenue = float('inf')\n    for k in range(m):\n        avenue_min = min(costs[max_street - 1][k], min_avenue)\n        min_avenue = avenue_min\n\n    return min_avenue",
        "result": "failed: testcase 0",
        "similarities": [
            0.9918297529220581,
            0.9961734414100647,
            0.9955922365188599,
            0.9958088397979736,
            0.9956098198890686,
            0.9959504008293152,
            0.9953924417495728,
            0.9924958944320679,
            0.9966091513633728,
            0.9945265054702759,
            0.995517909526825,
            0.9949374794960022,
            0.9928505420684814,
            0.9950639605522156,
            0.989343523979187,
            0.9956209063529968,
            0.9959511160850525,
            0.9962030649185181,
            0.9958626627922058,
            0.9959710836410522
        ]
    },
    "2921": {
        "similarity": 0.9977138042449951,
        "body": "    drinks = []\n    for i in range(d):\n        name, strength, size, cost = input().split()\n        strength, price = float(strength), float(cost)\n        quantity = (100 * price) / strength\n        if size == '1/3':\n            quantity /= 3.0\n        elif size == '1/2':\n            quantity /= 2.0\n        drinks.append((name, int(quantity)))\n    drinks.sort(key=lambda x: x[1], reverse=True)\n\n    total_money = 0\n    purchased_drinks = {}\n    for name, quantity in drinks:\n        cost = (quantity * drinks[(drinks.index((name, quantity)))[0]][1]) / 100.0\n        if m >= cost * quantity and u >= quantity:\n            m -= cost * quantity\n            u -= quantity\n            purchased_drinks[name] = int(quantity)\n        else:\n            break\n\n    if u < 0 or m < 0:\n        print('IMPOSSIBLE')\n    else:\n        for name, quantity in sorted(purchased_drinks.items()):\n            print(f'{name} {quantity}')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955681562423706,
            0.9973588585853577,
            0.9975538849830627,
            0.9953437447547913,
            0.9973949790000916,
            0.9971323609352112,
            0.9966273307800293,
            0.9970462322235107,
            0.9976194500923157,
            0.9970282316207886,
            0.997239351272583,
            0.9976306557655334,
            0.996953547000885,
            0.9967339038848877,
            0.997020423412323,
            0.9977138042449951,
            0.9974511861801147,
            0.9955966472625732,
            0.9974498748779297,
            0.9971352815628052
        ]
    },
    "1642": {
        "similarity": 0.9957996010780334,
        "body": "    n = int(input())\n    p = []\n    for i in range(n):\n        x, y = map(float, input().split())\n        p.append((x, y))\n\n        val = (p3[1] - p1[1]) * (p2[0] - p1[0]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n        if abs(val) < 1e-8:\n            return \"collinear\"\n        return 1 if val > 0 else -1\n\n        for i in range(n):\n            o = orientation(p[i], p[(i + 1) % n], p[(i + 2) % n])\n            if o == \"collinear\":\n                return False\n            elif o < 0:\n                return False\n\n    low = -float('inf')\n    high = float('inf')\n\n    while high - low > 1e-8:\n        mid = (low + high) / 2.0\n        p_check = [tuple(x + mid * c for x, c in zip(p[i], (1, 1))) for i in range(n)]\n        if check_convexity(p_check, mid):\n            low = mid\n        else:\n            high = mid\n\n    return round(high, 6)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951319694519043,
            0.9947646260261536,
            0.9949632883071899,
            0.9949317574501038,
            0.9957996010780334,
            0.9920231699943542,
            0.9951422810554504,
            0.9953386187553406,
            0.9893134236335754,
            0.9933889508247375,
            0.9948332905769348,
            0.994454026222229,
            0.9930877685546875,
            0.9945096373558044,
            0.9925006031990051,
            0.992842435836792,
            0.9954066872596741,
            0.9941344261169434,
            0.9952901601791382,
            0.9951139688491821
        ]
    },
    "947": {
        "similarity": 0.9932726621627808,
        "body": "    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return n - (n + 1) // 2, (n + 1) // 2\n\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a, b = find_a_b(n)\n    print(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9922860860824585,
            0.9910207986831665,
            0.9922932982444763,
            0.991804838180542,
            0.9779024720191956,
            0.9926709532737732,
            0.9932726621627808,
            0.9915342926979065,
            0.9903867840766907,
            0.9911351799964905,
            0.9919728636741638,
            0.9805101156234741,
            0.9779024720191956,
            0.9899663329124451,
            0.9831225872039795,
            0.992120623588562,
            0.9902430176734924,
            0.9929570555686951,
            0.9906203746795654,
            0.9898421764373779
        ]
    },
    "743": {
        "similarity": 0.9961433410644531,
        "body": "import sys\n\n    n = int(input())\n    nums = [0] + sorted([int(x) for x in input().split()])\n    sum_val = 0\n    for i in range(2, n+1):\n        while nums[i] > nums[i-1]:\n            sum_val += nums[i-1]\n            nums[i] -= nums[i-1]\n    print(sum(nums))\n\nmin_sum()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9906454682350159,
            0.9948456287384033,
            0.9938418865203857,
            0.9961433410644531,
            0.9952336549758911,
            0.9944744110107422,
            0.9940898418426514,
            0.9935618042945862,
            0.9957612752914429,
            0.9944865703582764,
            0.9958082437515259,
            0.9946375489234924,
            0.9935410022735596,
            0.9911818504333496,
            0.9918345212936401,
            0.9953157305717468,
            0.9942094087600708,
            0.9908093810081482,
            0.9938083291053772,
            0.9933533072471619
        ]
    },
    "1397": {
        "similarity": 0.997507631778717,
        "body": "import sys\nfrom collections import deque\n\n    graph = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    queue = deque()\n\n    for a, b in no_road_pairs:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            queue.append(i)\n            while queue:\n                curr_node = queue.popleft()\n                for neighbor in graph[curr_node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n\n    roads_needed = []\n    for i in range(1, n + 1):\n        if len(graph[i]) < 2:\n            continue\n        elif len(graph[i]) == 2:\n            a, b = graph[i]\n            if not visited[a] or not visited[b]:\n                roads_needed.append((i, min(a, b)))\n\n    print(len(roads_needed))\n    for road in roads_needed:\n        print(*road)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947066307067871,
            0.996971845626831,
            0.9966824054718018,
            0.997507631778717,
            0.9969384074211121,
            0.9959858655929565,
            0.9971483945846558,
            0.9969186186790466,
            0.9972644448280334,
            0.9958218336105347,
            0.9960469007492065,
            0.996810793876648,
            0.9967136383056641,
            0.9971811175346375,
            0.9961534738540649,
            0.9965089559555054,
            0.9964272379875183,
            0.9965651631355286,
            0.9961482882499695,
            0.996006190776825
        ]
    },
    "1144": {
        "similarity": 0.9969751238822937,
        "body": "import sys\n    t = 'a' + 'b' * (m - 1)\n    replacements = [[0] * n for _ in range(m)]\n    max_count = 0\n    for i in range(n - m + 1):\n        match = True\n        for j in range(m):\n            if s[i + j] != t[j] and s[i + j] != '?':\n                match = False\n                break\n        if match:\n            count = 0\n            for k in range(1, m):\n                if replacements[k][i - 1] < count:\n                    count = replacements[k][i - 1]\n                replacements[k][i] = max(count + 1, replacements[k][i])\n            max_count = max(max_count, replacements[-1][i])\n        else:\n            for j in range(m):\n                if s[i + j] != '?':\n                    replacements[j][i] += 1\n    min_replacements = n - max_count * m\n    for i in range(n):\n        for j in range(1, m):\n            if s[i] == '?' and (s[i + j] == 'a' or i + j >= n - m + 1 or replacements[j][i] < replacements[j][i + 1]):\n                min_replacements -= 1\n    return min_replacements\n\nn = int(input())\ns = input()\nm = int(input())\nprint(calc_min_replacements(n, s, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957992434501648,
            0.9966049194335938,
            0.9956110119819641,
            0.9948586821556091,
            0.9960919618606567,
            0.9958361387252808,
            0.99566650390625,
            0.9916042685508728,
            0.9966173768043518,
            0.9948972463607788,
            0.9960786700248718,
            0.9967480897903442,
            0.9958420991897583,
            0.9961842894554138,
            0.9966346621513367,
            0.996525228023529,
            0.9969751238822937,
            0.996311604976654,
            0.996515154838562,
            0.996394693851471
        ]
    },
    "890": {
        "similarity": 0.9965286254882812,
        "body": "import sys\n    min_diff = max(c)\n    num_ways = 0\n    for i in range(1, n + 1):\n        curr_min_diff = max(c) - c[i - 1]\n        if curr_min_diff >= x:\n            for j in range(i, n + 1):\n                total_difficulty = sum(c[:j])\n                min_curr_diff = max(c[:j]) - c[i - 1]\n                if l <= total_difficulty <= r and min_curr_diff >= x:\n                    num_ways += 1\n    return num_ways\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\nprint(count_problemsets(n, l, r, x, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9917524456977844,
            0.9950997233390808,
            0.9957141876220703,
            0.9935111999511719,
            0.9952358603477478,
            0.9944292306900024,
            0.9960441589355469,
            0.9947507977485657,
            0.996240496635437,
            0.9949227571487427,
            0.9944121837615967,
            0.9947489500045776,
            0.9959156513214111,
            0.9957536458969116,
            0.9958428144454956,
            0.9928926229476929,
            0.9942716360092163,
            0.9948632121086121,
            0.9960395693778992,
            0.9965286254882812
        ]
    },
    "2410": {
        "similarity": 0.9973841309547424,
        "body": "    pref_sum = [0] * n\n    max_pref_sum = 0\n    for i in range(1, n):\n        pref_sum[i] = pref_sum[i - 1] + a[i]\n        if pref_sum[i] > max_pref_sum:\n            max_pref_sum = pref_sum[i]\n\n    prefix_greater_than_max = False\n    for i in range(n):\n        if pref_sum[i] > max_pref_sum:\n            prefix_greater_than_max = True\n            break\n\n    return 'YES' if prefix_greater_than_max else 'NO'\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(will_be_happy(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966332316398621,
            0.9963333010673523,
            0.9967491030693054,
            0.9952455163002014,
            0.9965049624443054,
            0.9957143068313599,
            0.9963377118110657,
            0.9967705607414246,
            0.997342050075531,
            0.9965685606002808,
            0.9943444132804871,
            0.9967319965362549,
            0.9971052408218384,
            0.9948417544364929,
            0.9973841309547424,
            0.9972752928733826,
            0.9935687184333801,
            0.9960771203041077,
            0.996189534664154,
            0.9971102476119995
        ]
    },
    "1004": {
        "similarity": 0.9969913959503174,
        "body": "    n = int(input())\n    arr = list(map(int, input().split()))\n\n    pos = set()\n    curr_day = []\n\n    for i in range(n):\n        if arr[i] > 0:\n            if -arr[i] in pos or len(curr_day) != 0 and abs(arr[i]) == curr_day[0]:\n                return [-1]\n            else:\n                pos.add(-arr[i])\n                curr_day.append(abs(arr[i]))\n        else:\n            if not pos or arr[i] + curr_day[-1] <= 0:\n                return [-1]\n\n            pos.remove(-arr[i])\n            for j in range(len(curr_day)):\n                if abs(arr[i]) == curr_day[j]:\n                    del curr_day[j]\n                    break\n\n    d = len(curr_day)\n    print(d)\n\n    ans = [0] * (d + 1)\n    start = 1\n    for i, day in enumerate(curr_day):\n        ans[i + 1] = day\n        if i < len(ans) - 1:\n            ans[i + 2] += day\n\n    print(*ans[1:])\n\npartition_days()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9924564361572266,
            0.9965540170669556,
            0.9961678385734558,
            0.9961298108100891,
            0.9965516924858093,
            0.9965123534202576,
            0.9958242177963257,
            0.9968031048774719,
            0.9969913959503174,
            0.9951428771018982,
            0.9964603781700134,
            0.9957950115203857,
            0.996566653251648,
            0.9963110685348511,
            0.9952402710914612,
            0.9965410828590393,
            0.9955922961235046,
            0.9953716993331909,
            0.9966015219688416,
            0.9966530203819275
        ]
    },
    "531": {
        "similarity": 0.9973082542419434,
        "body": "import sys\n\n    n = int(input())\n    x_values = list(map(int, input().split()))\n    min_value = min(x_values)\n    max_value = max(x_values)\n\n    count_map = {}\n    for value in x_values:\n        if value not in count_map:\n            count_map[value] = 1\n        else:\n            count_map[value] += 1\n\n    sorted_x_values = sorted([(count, value) for value, count in count_map.items()])\n    sorted_y_values = []\n\n    i = j = 0\n    while i < n and j < len(sorted_x_values):\n        if (max_value - min_value) <= 2:\n            count, value = sorted_x_values[j]\n            while i < n and x_values[i] == value:\n                sorted_y_values.append(value)\n                i += 1\n                count -= 1\n                if count == 0:\n                    j += 1\n\n    return len(sorted_y_values), ' '.join(map(str, sorted_y_values))\n\nprint(*minimize_equal_measurements())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973082542419434,
            0.9956002831459045,
            0.9938068389892578,
            0.9920461773872375,
            0.996200442314148,
            0.9945281147956848,
            0.9963952898979187,
            0.9963666200637817,
            0.9959690570831299,
            0.9966741800308228,
            0.9965401887893677,
            0.9969910383224487,
            0.9969052076339722,
            0.9964348673820496,
            0.9967717528343201,
            0.9972415566444397,
            0.9970993399620056,
            0.9955592155456543,
            0.9964545369148254,
            0.9959245324134827
        ]
    },
    "510": {
        "similarity": 0.9906407594680786,
        "body": "    a = int(a)\n    b = int(b)\n    c = int(c)\n    d = int(d)\n\n    max_val = max(abs(a - b), abs(a - c), abs(b - c))\n    if max_val < d:\n        distance_ab = (d - abs(a - b)) // 2\n        distance_ac = (d - abs(a - c)) // 2\n        distance_bc = (d - abs(b - c)) // 2\n\n        max_distance = max(distance_ab, distance_ac, distance_bc)\n        min_duration = max_val + max_distance * 3\n    else:\n        min_duration = max_val\n\n    return min_duration\n\n\nif __name__ == \"__main__\":\n    input_data = [int(x) for x in input().split()]\n    print(min_duration(*input_data))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9871099591255188,
            0.9858255982398987,
            0.985792875289917,
            0.9542390704154968,
            0.9894428253173828,
            0.9840784668922424,
            0.9885324239730835,
            0.9878345131874084,
            0.9871115684509277,
            0.9884530305862427,
            0.9906407594680786,
            0.9895200133323669,
            0.988054096698761,
            0.9835046529769897,
            0.9808260202407837,
            0.9823265075683594,
            0.990321934223175,
            0.9883792400360107,
            0.9892186522483826,
            0.9905511736869812
        ]
    },
    "2555": {
        "similarity": 0.9968088865280151,
        "body": "    max_val = 0\n    pref_max = [0] * n\n    suff_min = [0] * n\n    pref_max[0] = a[0]\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            pref_max[i] = max(pref_max[i - 1], a[i])\n        else:\n            pref_max[i] = pref_max[i - 1]\n\n    suff_min[n - 1] = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] <= a[i + 1]:\n            suff_min[i] = min(suff_min[i + 1], a[i])\n        else:\n            suff_min[i] = suff_min[i + 1]\n\n    max_val = pref_max[-1]\n    result = [max_val]\n    for i in range(q):\n        l, r = ops[i][0], ops[i][1]\n        if l < r:\n            new_pref_max = pref_max[:l - 1]\n            if a[l] >= a[r]:\n                new_pref_max.append(max(pref_max[r - 1], a[l]))\n            else:\n                new_pref_max.append(pref_max[r - 1])\n            pref_max = new_pref_max\n            for i in range(l, r):\n                if a[i] >= a[i - 1]:\n                    pref_max[i] = max(pref_max[i - 1], a[i])\n                else:\n                    pref_max[i] = pref_max[i - 1]\n\n            new_suff_min = suff_min[:r + 1]\n            if a[l] <= a[r]:\n                new_suff_min[-1] = min(suff_min[l - 1], a[r])\n            else:\n                new_suff_min[-1] = suff_min[l - 1]\n            for i in range(r, n - 1):\n                if a[i] <= a[i + 1]:\n                    new_suff_min[i + 1] = min(new_suff_min[i], a[i])\n                else:\n                    new_suff_min[i + 1] = new_suff_min[i]\n            suff_min = new_suff_min\n\n        elif l > r:\n            new_pref_max = pref_max[:r - 1]\n            if a[l] >= a[r]:\n                new_pref_max.append(pref_max[r - 1])\n            else:\n                new_pref_max.append(max(pref_max[r - 1], a[l]))\n            for i in range(r, l):\n                if a[i] >= a[i + 1]:\n                    new_pref_max[i] = max(new_pref_max[i + 1], a[i])\n                else:\n                    new_pref_max[i] = new_pref_max[i + 1]\n            pref_max = new_pref_max\n\n            new_suff_min = suff_min[:l + 1]\n            if a[l] <= a[r]:\n                new_suff_min[-1] = min(suff_min[l - 1], a[r])\n            else:\n                new_suff_min[-1] = suff_min[l - 1]\n\n            for i in range(l, n - 1):\n                if a[i] <= a[i + 1]:\n                    new_suff_min[i + 1] = min(new_suff_min[i], a[i])\n                else:\n                    new_suff_min[i + 1] = new_suff_min[i]\n            suff_min = new_suff_min\n\n        max_val = pref_max[r - 1] - suff_min[l]\n\n        result.append(max_val)\n\n    return result",
        "result": "failed: testcase 0",
        "similarities": [
            0.9917226433753967,
            0.9953030943870544,
            0.9955504536628723,
            0.996476411819458,
            0.9957866668701172,
            0.9951208233833313,
            0.9964551329612732,
            0.9959124326705933,
            0.9958406090736389,
            0.9956902861595154,
            0.992520809173584,
            0.9961267113685608,
            0.99639493227005,
            0.994735836982727,
            0.9968088865280151,
            0.9942512512207031,
            0.9959688782691956,
            0.9963494539260864,
            0.9952549338340759,
            0.9951603412628174
        ]
    },
    "324": {
        "similarity": 0.9971741437911987,
        "body": "    for i in range(2, int((a ** 0.5) + 1)):\n        if a % i == 0:\n            return True\n    return False\n\nn = int(input())\n\nfor a in range(n + 1, (n << 1) + 10):\n    if find_composite(a):\n        b = a - n\n        if b >= 2 and find_composite(b):\n            print(a, b)\n            break",
        "result": "failed: testcase 0",
        "similarities": [
            0.995664119720459,
            0.9960989952087402,
            0.9962012767791748,
            0.995103120803833,
            0.9957823753356934,
            0.9963902831077576,
            0.9965372681617737,
            0.991718590259552,
            0.9952527284622192,
            0.9963384866714478,
            0.9961155652999878,
            0.9959530234336853,
            0.9966480135917664,
            0.9961782693862915,
            0.9961546063423157,
            0.9960305094718933,
            0.9971741437911987,
            0.9948611855506897,
            0.9956299662590027,
            0.9968622922897339
        ]
    },
    "2912": {
        "similarity": 0.9959272146224976,
        "body": "    string_dict = {}\n    for i in range(n):\n        string_dict[i+1] = strings[i]\n    \n    for op in operations:\n        a, b = map(int, op.split())\n        \n        string_dict[a] += string_dict[b]\n        del string_dict[b]\n    \n    return list(string_dict.values())[0]\n\nn = int(input())\nstrings = [input() for _ in range(n)]\noperations = [input() for _ in range(n-1)]\n\nprint(get_last_string(n, strings, operations))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955040812492371,
            0.9929372072219849,
            0.9957809448242188,
            0.9916175007820129,
            0.9940038919448853,
            0.9948106408119202,
            0.9943514466285706,
            0.9953597187995911,
            0.9934410452842712,
            0.9918277263641357,
            0.9948728680610657,
            0.9944171905517578,
            0.9947608113288879,
            0.9949477314949036,
            0.9950323700904846,
            0.9944576621055603,
            0.9959272146224976,
            0.9916605949401855,
            0.9943640828132629,
            0.9926643371582031
        ]
    },
    "9": {
        "similarity": 0.9973019957542419,
        "body": "    d = int(input())\n    n, m = map(int, input().split())\n\n    sofas = []\n    for i in range(d):\n        x1, y1, x2, y2 = map(int, input().split())\n        if abs(x1 - x2) + abs(y1 - y2) == 1:\n            sofas.append((x1, y1, x2, y2))\n\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    for i in range(d):\n        found = True\n        left_count = 0\n        right_count = 0\n        top_count = 0\n        bottom_count = 0\n\n        for j in range(len(sofas)):\n            if sofas[j][0] == sofas[i][0]:\n                if abs(sofas[j][1] - sofas[i][1]) + abs(sofas[j][2] - sofas[i][2]) != 1:\n                    continue\n                if i < j and (sofas[j][0], sofas[j][1]) > (sofas[i][0], sofas[i][1]):\n                    right_count += 1\n                elif i < j and (sofas[j][0], sofas[j][1]) <= (sofas[i][0], sofas[i][1]):\n                    left_count += 1\n            if sofas[j][1] == sofas[i][1]:\n                if abs(sofas[j][0] - sofas[i][0]) + abs(sofas[j][2] - sofas[i][2]) != 1:\n                    continue\n                if i < j and (sofas[j][0], sofas[j][2]) > (sofas[i][0], sofas[i][2]):\n                    bottom_count += 1\n                elif i < j and (sofas[j][0], sofas[j][2]) <= (sofas[i][0], sofas[i][2]):\n                    top_count += 1\n\n        if left_count == cnt_l and right_count == cnt_r and top_count == cnt_t and bottom_count == cnt_b:\n            return str(i + 1)\n    return \"-1\"",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963563680648804,
            0.9973019957542419,
            0.996301531791687,
            0.9965177774429321,
            0.9966416954994202,
            0.9965097308158875,
            0.9960924386978149,
            0.9966326355934143,
            0.9966753721237183,
            0.9955829977989197,
            0.9967383146286011,
            0.9941554069519043,
            0.9964380860328674,
            0.9957695007324219,
            0.9965015053749084,
            0.9957605600357056,
            0.9968336224555969,
            0.9954700469970703,
            0.9962375164031982,
            0.9967463612556458
        ]
    },
    "249": {
        "similarity": 0.996345043182373,
        "body": "import sys\n\n    for i in range(len(a)):\n        found_x = False\n        found_y = False\n        for j in range(i+1, len(a)):\n            if a[j] - a[i] == x:\n                found_x = True\n            if a[j] - a[i] == y:\n                found_y = True\n            if found_x and found_y:\n                break\n        if not found_x or not found_y:\n            return False\n    return True\n\n    for i in range(1, l+1):\n        if not (x % i == 0 and y % i == 0) and i != 1:\n            return i\n    return -1\n\n    if check(a, l, x, y):\n        return 0, []\n    \n    next_position = find_next_position(l, x, y)\n    if next_position == -1:\n        return -1, []\n\n    new_a = a[:]\n    for i in range(1, len(new_a)):\n        if new_a[i] - new_a[0] >= next_position and (new_a[i] % next_position != 0 or new_a[0] % next_position != 0):\n            new_a.insert(i, new_a[i] + next_position)\n    return len(new_a) - n, new_a[n:]\n\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nresult = solve(n, l, a, x, y)\n\nif result[0] == -1:\n    print(-1)\nelse:\n    print(result[0])\n    for i in result[1]:\n        print(i, end=' ')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920251965522766,
            0.9952084422111511,
            0.9939256906509399,
            0.9937717914581299,
            0.9944318532943726,
            0.9951547384262085,
            0.9917687773704529,
            0.9947068095207214,
            0.9921587705612183,
            0.9948192238807678,
            0.9935827851295471,
            0.9918233156204224,
            0.9945077300071716,
            0.9948104023933411,
            0.996345043182373,
            0.9953805804252625,
            0.994063138961792,
            0.9958881735801697,
            0.9940719604492188,
            0.994796633720398
        ]
    },
    "2999": {
        "similarity": 0.9967573285102844,
        "body": "import sys\n\n    n, s = map(int, input().split())\n    participants = []\n    for i in range(n):\n        name, bet = input().split()\n        participants.append([name, int(bet)])\n\n    current_highest_bid = 0\n    bids = {}\n\n    for participant in sorted(participants, key=lambda x: x[1]):\n        name, bid = participant\n        if bid > current_highest_bid:\n            current_highest_bid = bid\n\n        bids[name] = bid\n\n    groups = []\n    for i in range(len(participants)):\n        participants[i][1] = (participants[i][1], 0)\n        for j in range(i):\n            if sum(p[1] for p in [participants[k] for k in range(j+1, i+1)]) == s:\n                groups.append([p[0] for p in participants[j:i+1]])\n\n    winning_participants = set()\n    for group in groups:\n        for participant in group:\n            if bids[participant] <= current_highest_bid * 2:\n                winning_participants.add(participant)\n\n    print(len(winning_participants))\n    for participant in sorted(list(winning_participants)):\n        print(participant)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958080649375916,
            0.9963895678520203,
            0.9951676726341248,
            0.9947282671928406,
            0.9961959719657898,
            0.9955852031707764,
            0.9947446584701538,
            0.9963940382003784,
            0.9958299398422241,
            0.9955902099609375,
            0.9964834451675415,
            0.9945429563522339,
            0.9967573285102844,
            0.9956368207931519,
            0.9957463145256042,
            0.9964828491210938,
            0.9961532950401306,
            0.9955853819847107,
            0.9964011311531067,
            0.9955595135688782
        ]
    },
    "2239": {
        "similarity": 0.9971513152122498,
        "body": "    faces = [2, 3, 4, 5, 6, 7]\n    for i in range(1, n + 1):\n        total = sum(faces[:i])\n        if total >= n:\n            return i\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    print(min_rolls(x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964485168457031,
            0.9954797029495239,
            0.9956040978431702,
            0.9912852048873901,
            0.9962852001190186,
            0.9960670471191406,
            0.9969000816345215,
            0.9964536428451538,
            0.9966490864753723,
            0.9960881471633911,
            0.9958795309066772,
            0.9896935820579529,
            0.9969199299812317,
            0.9954197406768799,
            0.996923565864563,
            0.9962400197982788,
            0.9964677691459656,
            0.9971513152122498,
            0.9958149790763855,
            0.9962982535362244
        ]
    },
    "2615": {
        "similarity": 0.9965705871582031,
        "body": "import math\nfrom collections import defaultdict\nprime_factors = defaultdict(int)\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            prime_factors[i] += 1\n            n //= i\n    if n > 1:\n        prime_factors[n] += 1\n    max_power = max(prime_factors.values())\n    count = 1\n    for power in prime_factors.values():\n        if power != max_power:\n            break\n        count *= (max_power - power + 1)\n    return count\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(count_elegant_numbers(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961028099060059,
            0.9964178204536438,
            0.9963545799255371,
            0.9939656853675842,
            0.9952601194381714,
            0.9951404929161072,
            0.9956803917884827,
            0.9956620931625366,
            0.9954235553741455,
            0.9940460920333862,
            0.9957248568534851,
            0.9957941174507141,
            0.9962706565856934,
            0.995619535446167,
            0.9957583546638489,
            0.9965705871582031,
            0.9960727691650391,
            0.9959293007850647,
            0.9957343935966492,
            0.9937198162078857
        ]
    },
    "2542": {
        "similarity": 0.9964805245399475,
        "body": "import sys\n\n    n = len(s)\n    left = [0] * n\n    right = [0] * n\n    for i in range(1, n):\n        if s[i] == s[0]:\n            left[i] += 1 + left[i - 1]\n    for i in range(n - 2, -1, -1):\n        if s[i] == s[n - 1]:\n            right[i] += 1 + right[i + 1]\n    erase = 0\n    for i in range(n):\n        erase = max(erase, left[i] + right[i + 1] - n)\n    return erase\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    print(min_erase(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951619505882263,
            0.9921340942382812,
            0.9959355592727661,
            0.9951794147491455,
            0.9916396141052246,
            0.9912740588188171,
            0.9917433857917786,
            0.9920598268508911,
            0.9960907697677612,
            0.9944692850112915,
            0.9960985779762268,
            0.995303213596344,
            0.9928889274597168,
            0.9964805245399475,
            0.9962484240531921,
            0.9963001608848572,
            0.9962174296379089,
            0.9954565763473511,
            0.9962379932403564,
            0.9954239726066589
        ]
    },
    "511": {
        "similarity": 0.9944575428962708,
        "body": "    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            return i\n\n    while y > 0:\n        x, y = y, gcd(y, x)\n    return x\n\nx, y = map(int, input().split())\nprint(f(x, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927201867103577,
            0.9879703521728516,
            0.988845705986023,
            0.993859052658081,
            0.9943717122077942,
            0.9943997263908386,
            0.9940634369850159,
            0.9933159351348877,
            0.9936232566833496,
            0.9932397603988647,
            0.9910878539085388,
            0.9816052317619324,
            0.9937044382095337,
            0.9928091168403625,
            0.9913163781166077,
            0.9937366843223572,
            0.9944575428962708,
            0.9924118518829346,
            0.9931640625,
            0.9923940896987915
        ]
    },
    "1409": {
        "similarity": 0.9961766600608826,
        "body": "import sys\n\n    sorted_participants = sorted(participants)\n    teams = 0\n    i = n - 1\n    while i >= 2:\n        if (sorted_participants[i] + sorted_participants[i-1] +\n            sorted_participants[i-2]) >= k:\n            teams += 1\n            for _ in range(3):\n                i -= 1\n    return teams\n\nn, k = map(int, input().split())\nparticipants = list(map(int, input().split()))\nprint(max_teams(n, k, participants))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959074258804321,
            0.9941218495368958,
            0.9929715394973755,
            0.9957343935966492,
            0.994559645652771,
            0.9910511374473572,
            0.9961004853248596,
            0.9926753640174866,
            0.9958299398422241,
            0.9943293333053589,
            0.9913864135742188,
            0.9946678876876831,
            0.992720365524292,
            0.9953513145446777,
            0.9961766600608826,
            0.991692304611206,
            0.9958314299583435,
            0.9928002953529358,
            0.995772123336792,
            0.9957681894302368
        ]
    },
    "2274": {
        "similarity": 0.9966307282447815,
        "body": "    has_path = [[False for _ in range(m)] for __ in range(n)]\n    changed_cells = 0\n\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            if directions[i][j] == 'C':\n                has_path[i][j] = True\n            elif not has_path[i][j]:\n                if (i + 1 < n and directions[i+1][j] == 'D') or \\\n                   (j + 1 < m and directions[i][j+1] == 'R'):\n                    changed_cells += 1\n                else:\n                    has_path[i][j] = True\n\n    return changed_cells\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    directions = []\n    for _ in range(n):\n        row = list(input())\n        directions.append(row)\n    print(min_changes(n, directions))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99526447057724,
            0.9956298470497131,
            0.994390606880188,
            0.9965110421180725,
            0.9960384368896484,
            0.9950211048126221,
            0.9955919981002808,
            0.9963278770446777,
            0.9958682656288147,
            0.9955699443817139,
            0.9891291260719299,
            0.9949145913124084,
            0.9963098168373108,
            0.9965692162513733,
            0.9966307282447815,
            0.9958110451698303,
            0.9947333335876465,
            0.9959944486618042,
            0.9964441061019897,
            0.994138240814209
        ]
    },
    "2420": {
        "similarity": 0.9955225586891174,
        "body": "    n, r = map(int, input().split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    points.sort(key=lambda p: (abs(p[0]) + abs(p[1])))\n    covered_points = 0\n    center_x, center_y = 0, 0\n    for point in points:\n        x, y = point\n        if abs(x - center_x) <= r and abs(y - center_y) <= r:\n            continue\n        if abs(x - center_x) + abs(y - center_y) <= r:\n            covered_points += 1\n            center_x, center_y = x, y\n    return covered_points\n\nprint(max_covered_points())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944717288017273,
            0.9914442300796509,
            0.991343080997467,
            0.9938490986824036,
            0.9908743500709534,
            0.9898481965065002,
            0.9902336001396179,
            0.9949924945831299,
            0.9897133708000183,
            0.9947990775108337,
            0.9955225586891174,
            0.9951583743095398,
            0.9924143552780151,
            0.9928977489471436,
            0.9900635480880737,
            0.9949456453323364,
            0.9946116209030151,
            0.9950741529464722,
            0.9923301339149475,
            0.9938898682594299
        ]
    },
    "1267": {
        "similarity": 0.9977365732192993,
        "body": "    n = int(input())\n    scores = sorted([int(x) for x in input().split()])\n    prev_min_score = None\n    ways = 1\n    score_count = {}\n\n    for i, s in enumerate(scores):\n        if s != 0 and (prev_min_score is None or s < prev_min_score):\n            score_count[s] = score_count.get(s, 0) + 1\n            prev_min_score = s\n\n    min_score = scores[-1]\n    ways *= score_count[min_score]\n\n    for i in range(n - 2, -1, -1):\n        if scores[i] == min_score:\n            break\n        ways *= score_count[scores[i]]\n\n    return ways\n\nprint(count_diploma_subsets())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966107606887817,
            0.9977365732192993,
            0.996360182762146,
            0.9961054921150208,
            0.9970030784606934,
            0.9966647624969482,
            0.9974439740180969,
            0.9971385598182678,
            0.997226893901825,
            0.9974438548088074,
            0.996634840965271,
            0.996787428855896,
            0.9951045513153076,
            0.9973684549331665,
            0.9970690011978149,
            0.9977306723594666,
            0.9972832202911377,
            0.9974014759063721,
            0.9973851442337036,
            0.9966992735862732
        ]
    },
    "2356": {
        "similarity": 0.9961094260215759,
        "body": "import sys\n\n    n = len(a)\n    for i in range(n):\n        for j in range(i+1, n):\n            if j - a[j] <= i - a[i]:\n                return False\n    return True\n\n    a.sort()\n    if is_good(a):\n        return a\n    else:\n        new_a = []\n        temp = 0\n        for i in range(len(a)):\n            new_a.append(temp + (a[i] * (len(a) - i)))\n            temp += 1\n        return new_a\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        print(*shuffle_array(a))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943130016326904,
            0.9961094260215759,
            0.9955815672874451,
            0.9947507977485657,
            0.9960246682167053,
            0.995064377784729,
            0.9955404996871948,
            0.9948234558105469,
            0.9956466555595398,
            0.993388831615448,
            0.9953996539115906,
            0.9953711628913879,
            0.9917881488800049,
            0.9959720969200134,
            0.9895095825195312,
            0.9914201498031616,
            0.9912153482437134,
            0.9950636625289917,
            0.9932727813720703,
            0.9916127920150757
        ]
    },
    "108": {
        "similarity": 0.9958930015563965,
        "body": "import sys\n\n    ans = []\n    i = 0\n    j = 0\n    while i < len(s) or j <= 'z':\n        if i == len(s):\n            ans.append(chr(j))\n            j += 1\n            continue\n        if s[i] == chr(j):\n            i += 1\n        elif s[i] >= chr(j):\n            ans.append(s[i])\n            i += 1\n        else:\n            ans.append(chr(j))\n            j += 1\n    return ''.join(ans) if all(c <= 'z' for c in ans) else '-1'\n\nprint(solve(input()))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9889172911643982,
            0.9953210949897766,
            0.9927707314491272,
            0.9893953204154968,
            0.9938864707946777,
            0.9952567219734192,
            0.9952487945556641,
            0.9927409291267395,
            0.9945050477981567,
            0.9947338104248047,
            0.9958930015563965,
            0.9941755533218384,
            0.9950231313705444,
            0.9958918690681458,
            0.992750883102417,
            0.993556559085846,
            0.9949412941932678,
            0.995867908000946,
            0.9950382709503174,
            0.9934595823287964
        ]
    },
    "1833": {
        "similarity": 0.996128261089325,
        "body": "import sys\n\nMOD = 10**9 + 7\n\n    n = int(input())\n    a = list(map(int, input().split()))\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        for j in range(1, i + 2):\n            if a[i] % j == 0:\n                dp[j] += dp[i]\n                dp[j] %= MOD\n        if a[i] >= i + 1:\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n\n    ans = 0\n    for i in range(1, n + 1):\n        ans += dp[i]\n        ans %= MOD\n\n    print(ans)\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947130084037781,
            0.9952712655067444,
            0.9921483397483826,
            0.995278537273407,
            0.9948616027832031,
            0.9960867166519165,
            0.9948745369911194,
            0.9903429746627808,
            0.996128261089325,
            0.9918065667152405,
            0.9958189725875854,
            0.9955328106880188,
            0.994642436504364,
            0.9953874349594116,
            0.9939910769462585,
            0.9922658801078796,
            0.9956742525100708,
            0.9924241900444031,
            0.9957149028778076,
            0.9951246380805969
        ]
    },
    "2324": {
        "similarity": 0.9964162707328796,
        "body": "import math\n\n    n = len(s)\n    counts = [0] * (n + 1)\n\n    for i in range(n - 1, -1, -1):\n        half_length = math.floor((n - i) / 2)\n        is_k_palindrome = True\n        left_half = s[:i + 1]\n        right_half = s[i + 1:]\n\n        if len(left_half) <= half_length or len(right_half) <= half_length:\n            is_k_palindrome = False\n\n        for k in range(1, n):\n            j = i - (k - 1)\n            if j >= 0 and left_half == right_half:\n                is_k_palindrome = counts[k] + 1 > 0\n                break\n\n        for k in range(n - 1, -1, -1):\n            counts[k + 1] += counts[k]\n            if is_k_palindrome:\n                counts[k] += 1\n\n    return ' '.join(map(str, counts[:n]))\n\ns = input()\nprint(palindromic_characteristics(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956126809120178,
            0.9933826327323914,
            0.9950717091560364,
            0.9960375428199768,
            0.9931451678276062,
            0.9934788942337036,
            0.9926115274429321,
            0.995021402835846,
            0.9950599670410156,
            0.9960336089134216,
            0.9960831999778748,
            0.9930291771888733,
            0.9896025657653809,
            0.9942129254341125,
            0.9964162707328796,
            0.9921409487724304,
            0.9939222931861877,
            0.9938585162162781,
            0.9922035932540894,
            0.9948477745056152
        ]
    },
    "2372": {
        "similarity": 0.998136043548584,
        "body": "import sys\n\n    h, w = map(int, input().split())\n    ch, cw = map(int, input().split())\n    dh, dw = map(int, input().split())\n\n    grid = [list(input()) for _ in range(h)]\n\n    visited = [[False] * (w + 1) for _ in range(h + 1)]\n    queue = []\n\n    queue.append((ch, cw, 0))\n    visited[ch][cw] = True\n\n    while queue:\n        x, y, dist = queue.pop(0)\n\n        if x == dh and y == dw:\n            return dist\n\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if (nx >= 1 and nx <= h and ny >= 1 and ny <= w and not visited[nx][ny] and grid[nx - 1][ny - 1] == '.'):\n                queue.append((nx, ny, dist))\n                visited[nx][ny] = True\n\n        for dx in range(-2, 3):\n            for dy in range(-2, 3):\n                if dx != 0 or dy != 0:\n                    nx, ny = x + dx, y + dy\n                    if (nx >= 1 and nx <= h and ny >= 1 and ny <= w and not visited[nx][ny] and grid[nx - 1][ny - 1] == '.'):\n                        queue.append((nx, ny, dist + 1))\n                        visited[nx][ny] = True\n\n    return -1\n\nprint(min_magic_moves())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981209635734558,
            0.99786776304245,
            0.9975202679634094,
            0.9973200559616089,
            0.9977928996086121,
            0.9969960451126099,
            0.997788667678833,
            0.9968329071998596,
            0.9960322380065918,
            0.9966932535171509,
            0.9973573088645935,
            0.9977876543998718,
            0.9979352355003357,
            0.997572124004364,
            0.9968468546867371,
            0.9971808195114136,
            0.997578501701355,
            0.9970324635505676,
            0.998136043548584,
            0.997344970703125
        ]
    },
    "1984": {
        "similarity": 0.998116672039032,
        "body": "    levels = [list(input().strip()) for _ in range(k)]\n    transmitted = 0\n\n    diff_levels = {}\n    for i in range(1, k + 1):\n        d = 0\n        for j in range(n):\n            for h in range(m):\n                if levels[i - 1][j] != '.' and levels[i - 1][j] != levels[0][j]:\n                    d += 1\n        diff_levels[i] = (d, i)\n\n    levels.sort(key=lambda x: len([y for y in x if y != '.']))\n\n    used = set()\n    ans = [None] * k\n\n    for i in range(1, k + 1):\n        transmitted += w * n * m\n        if diff_levels[i][0]:\n            transmitted += diff_levels[i][0]\n            prev_level = None\n            for h in range(i - 1, 0, -1):\n                if (diff_levels[h][0], diff_levels[h][1]) not in used:\n                    used.add((diff_levels[h][0], diff_levels[h][1]))\n                    transmitted += diff_levels[h][0] * w\n                    prev_level = h\n            ans[i - 1] = (i, diff_levels[prev_level][1])\n        else:\n            ans[i - 1] = (i, 0)\n\n    print(transmitted)\n    for pair in ans:\n        print(pair[0], pair[1])\n\nn, m, k, w = map(int, input().split())\nmin_transfer(n, m, k, w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977091550827026,
            0.997401773929596,
            0.9965041279792786,
            0.99603271484375,
            0.996848464012146,
            0.9974424242973328,
            0.997768223285675,
            0.9976624846458435,
            0.998116672039032,
            0.9979463219642639,
            0.9979355335235596,
            0.9972448945045471,
            0.9975475668907166,
            0.9973759055137634,
            0.9955074191093445,
            0.9972638487815857,
            0.9978646636009216,
            0.997727632522583,
            0.997350811958313,
            0.9977176189422607
        ]
    },
    "1253": {
        "similarity": 0.9970422387123108,
        "body": "import sys\n\n    pos_count = 0\n    neg_count = 0\n    total = 0\n\n    for i in range(1, n + 1):\n        if a[i - 1] >= 0:\n            pos_count += 1\n        else:\n            neg_count += 1\n        total += a[i - 1]\n\n    for i in range(1, k + 1):\n        if pos_count <= neg_count:\n            total -= 2 * a[pos_count]\n            pos_count += 1\n\n    return abs(total)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940446615219116,
            0.9953430891036987,
            0.9954662322998047,
            0.9967444539070129,
            0.995936930179596,
            0.9938918948173523,
            0.9966272115707397,
            0.9965871572494507,
            0.9896705150604248,
            0.996002197265625,
            0.996250569820404,
            0.9939700961112976,
            0.9964332580566406,
            0.996592104434967,
            0.9970307946205139,
            0.9969517588615417,
            0.9970422387123108,
            0.9953197836875916,
            0.9966583251953125,
            0.9961151480674744
        ]
    },
    "523": {
        "similarity": 0.9962905049324036,
        "body": "    strs = []\n    for i in range(n):\n        s = input()\n        if len(s) != m:\n            return 0\n        strs.append(s)\n    strs.sort(reverse=True)\n    palindrome = \"\"\n    for i in range(m):\n        left = \"\"\n        right = \"\"\n        for j in range(n):\n            if (i + n - j) % 2 == 1 and len(strs[j]) > i:\n                right += strs[j][i]\n            elif len(left) < len(right) or (len(left) == len(right) and left <= right):\n                left = strs[j][:i+1]\n            if len(left) + len(right) >= n * m // 2:\n                palindrome = left + right[::-1]\n                break\n    return len(palindrome), palindrome\n\nn, m = map(int, input().split())\nresult = find_longest_palindrome(n, m)\nprint(result[0])\nif result[0] > 0:\n    print(result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957064390182495,
            0.9955780506134033,
            0.9932877421379089,
            0.9962905049324036,
            0.9948156476020813,
            0.992348313331604,
            0.9936834573745728,
            0.9908315539360046,
            0.9945054650306702,
            0.9946522116661072,
            0.9864583611488342,
            0.9944409728050232,
            0.9922205209732056,
            0.9947156310081482,
            0.9944180846214294,
            0.9946867227554321,
            0.9955805540084839,
            0.9947419762611389,
            0.9951962828636169,
            0.9955396056175232
        ]
    },
    "2934": {
        "similarity": 0.9951428771018982,
        "body": "import sys\n\n    n = int(input())\n    m = int(input())\n\n    if n == 1:\n        return m % 1000000007\n    if n > m or (n % 2 != 0 and m % 2 == 0):\n        return 0\n\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(i, m + 1):\n            if i % 2 == 0:\n                dp[i][j] += dp[i - 1][j - 1]\n            if (i * 2 <= j and j % 2 == 0) or (j == n and i == n // 2):\n                dp[i][j] += dp[i][j - 2]\n\n    ans = sum(dp[n]) % 1000000007\n    return ans",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927641153335571,
            0.9925103783607483,
            0.9917423129081726,
            0.994118332862854,
            0.9935845136642456,
            0.9941213726997375,
            0.994860827922821,
            0.9920626282691956,
            0.9937535524368286,
            0.9915856122970581,
            0.9914348125457764,
            0.9927255511283875,
            0.9928141236305237,
            0.9913011789321899,
            0.9951067566871643,
            0.9947750568389893,
            0.9936619997024536,
            0.9914249777793884,
            0.9931363463401794,
            0.9951428771018982
        ]
    },
    "1745": {
        "similarity": 0.9975095987319946,
        "body": "import sys\n\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    border = [[0]*m for _ in range(n)]\n\n        return 0 <= x1 < n and 0 <= y1 < m and 0 <= x2 < n and 0 <= y2 < m\n\n        if border[x][y]:\n            return False\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if not is_valid(nx, ny) or grid[nx][ny] == '#':\n                continue\n            if abs(nx-x)+abs(ny-y) <= max(n-1, m-1):\n                return True\n        for i in range(2):\n            for j in range(4):\n                nx = x + dx[i]\n                ny = y + dy[j]\n                if not is_valid(nx, ny) or grid[nx][ny] == '#':\n                    continue\n                border[nx][ny] = 1\n                if dfs(nx, ny, turns+1):\n                    return True\n                border[nx][ny] = 0\n        return False\n\n    ways = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and (i == 0 or j == 0) and not (i == 0 and j == 0) and not (i == n-1 or j == m-1):\n                border[i][j] = 1\n                ways += int(dfs(i, j, 0))\n                border[i][j] = 0\n\n    print(ways)\n\ncount_ways()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975095987319946,
            0.9967418313026428,
            0.9964311718940735,
            0.9957038760185242,
            0.9972303509712219,
            0.9959348440170288,
            0.9964486956596375,
            0.9963361024856567,
            0.9962605834007263,
            0.996717631816864,
            0.9966039061546326,
            0.9971520304679871,
            0.9968541860580444,
            0.9973169565200806,
            0.9957488179206848,
            0.9959443807601929,
            0.997175931930542,
            0.9963800311088562,
            0.9957006573677063,
            0.9957562685012817
        ]
    },
    "1422": {
        "similarity": 0.9964621663093567,
        "body": "    n = len(weights)\n    if weights[::2].count('1') < int(m / 2) or weights[1::2].count('1') < int(m / 2):\n        return False\n\n    weight_left = 0\n    weight_right = 0\n    sequence = []\n    i = 0\n    while len(sequence) < m:\n        if i % 2 == 0:\n            for j in range(10, -1, -1):\n                if weights[i] == '1' and (j not in sequence or abs(i // 2 - sequence.index(j)) > 1):\n                    weight_left += j\n                    sequence.append(j)\n                    break\n        else:\n            for j in range(10, -1, -1):\n                if weights[i] == '1' and (j not in sequence or abs((i + 1) // 2 - sequence.index(j)) > 1):\n                    weight_right += j\n                    sequence.append(j)\n                    break\n\n        if weight_left <= weight_right:\n            return False\n    return True, sequence[:m]\n\nweights = input()\nm = int(input())\nresult, solution = can_put_weights(weights, m)\n\nprint('YES' if result else 'NO')\nif result:\n    print(*solution)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959455132484436,
            0.9941896200180054,
            0.9951860308647156,
            0.9950125813484192,
            0.9950000643730164,
            0.9963172078132629,
            0.9950207471847534,
            0.9956088066101074,
            0.9957532286643982,
            0.99554842710495,
            0.9946501851081848,
            0.9927610158920288,
            0.9955805540084839,
            0.9958238005638123,
            0.996029794216156,
            0.9916920065879822,
            0.9964621663093567,
            0.9953830242156982,
            0.9933227896690369,
            0.9956666231155396
        ]
    },
    "1763": {
        "similarity": 0.9971715807914734,
        "body": "import sys\n\n    n, a, r, m = map(int, input().split())\n    heights = list(map(int, input().split()))\n\n    max_height = max(heights)\n    total_bricks = sum(heights)\n\n    costs = []\n    for target in range(max_height, 0, -1):\n        cost = 0\n        moves = 0\n        for i, h in enumerate(heights):\n            if h < target:\n                extra = target - h\n                cost += a * extra + r * (extra - 1)\n                moves += extra\n            elif h > target:\n                diff = h - target\n                cost += m * diff\n        costs.append(cost)\n\n    min_cost = sys.maxsize\n    for i in range(n):\n        cost = total_bricks - (max_height - heights[i]) + costs[max_height - 1]\n        if i > 0:\n            cost -= (n - i) * m\n        min_cost = min(min_cost, cost)\n\n    print(min_cost)\n\nmin_cost()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950706958770752,
            0.9946297407150269,
            0.9961498975753784,
            0.9949794411659241,
            0.9944908022880554,
            0.9953623414039612,
            0.9962816834449768,
            0.9960915446281433,
            0.9951428771018982,
            0.9963993430137634,
            0.9939718842506409,
            0.9960646629333496,
            0.9969538450241089,
            0.9969727396965027,
            0.9967548251152039,
            0.9965338706970215,
            0.9971715807914734,
            0.9954543113708496,
            0.995802640914917,
            0.9970167875289917
        ]
    },
    "974": {
        "similarity": 0.9973543882369995,
        "body": "    added = [0] * (n + 1)\n    removed = [0] * (n + 1)\n    stack = []\n    reorders = 0\n    for _ in range(2 * n):\n        cmd, arg = input().split()\n        arg = int(arg)\n        if cmd == 'add':\n            added[arg] += 1\n            while added[arg] > 0 and not stack or stack[-1] < arg:\n                stack.pop()\n                reorders += 1\n            stack.append(arg)\n        else:\n            removed[arg] += 1\n    return reorders\n\nprint(daru_daru(int(input())))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961274862289429,
            0.9971727132797241,
            0.9936185479164124,
            0.9960052967071533,
            0.9949285387992859,
            0.9967840909957886,
            0.9966147541999817,
            0.9969398379325867,
            0.9969369769096375,
            0.9953358173370361,
            0.9973543882369995,
            0.9972894787788391,
            0.9964343905448914,
            0.997273325920105,
            0.9966294169425964,
            0.9972811341285706,
            0.9970248341560364,
            0.9960083365440369,
            0.9958471059799194,
            0.9956809878349304
        ]
    },
    "2343": {
        "similarity": 0.9936977028846741,
        "body": "    for i in range(20, -1, -1):\n        if 2**i <= n and 2**(n-i) <= k:\n            return f\"YES {n-i}\"\n    return \"NO\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(solve(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920855164527893,
            0.9923531413078308,
            0.9914411306381226,
            0.9903533458709717,
            0.9931512475013733,
            0.9923194050788879,
            0.9923054575920105,
            0.9924361705780029,
            0.9818353056907654,
            0.9576637148857117,
            0.9919478893280029,
            0.9910284280776978,
            0.9875203967094421,
            0.9897549152374268,
            0.9932255148887634,
            0.9930067658424377,
            0.9919449687004089,
            0.9936977028846741,
            0.9919910430908203,
            0.9901217222213745
        ]
    },
    "627": {
        "similarity": 0.9956104755401611,
        "body": "import sys\n\n    max_idx = -1\n    for i in range(1, n):\n        if s[i] < s[i-1]:\n            return ''.join(sorted(s[:i-1] + s[i:]))\n        elif max_idx == -1 or s[max_idx] < s[i]:\n            max_idx = i\n\n    min_str = ''.join(sorted(s))\n    if len(min_str) > 1:\n        return min_str\n    else:\n        return s[0]\n\nn = int(input())\ns = input()\nprint(min_string(n, s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955357313156128,
            0.9936398863792419,
            0.9924522042274475,
            0.9949302673339844,
            0.9923272728919983,
            0.9909418821334839,
            0.9929438233375549,
            0.9940779805183411,
            0.9928635954856873,
            0.993884265422821,
            0.9956104755401611,
            0.988125741481781,
            0.9897793531417847,
            0.9947282075881958,
            0.9888682961463928,
            0.9945610761642456,
            0.9947229027748108,
            0.9951403737068176,
            0.9940510988235474,
            0.9949720501899719
        ]
    },
    "1655": {
        "similarity": 0.9973104596138,
        "body": "import sys\n\n    alive = [True] * n\n    for i in range(n - 2, -1, -1):\n        for j in range(i - min(lengths[i], i + 1), i):\n            if alive[j]:\n                alive[i] = False\n                break\n    return sum(alive)\n\nn = int(input())\nlengths = list(map(int, input().split()))\nprint(count_alive(n, lengths))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971567392349243,
            0.9970306754112244,
            0.9967870116233826,
            0.9958799481391907,
            0.9968224763870239,
            0.9965732097625732,
            0.9963638186454773,
            0.9955211281776428,
            0.9973104596138,
            0.9959334135055542,
            0.9956886768341064,
            0.9932016134262085,
            0.9964813590049744,
            0.9949055910110474,
            0.9971181154251099,
            0.9962000846862793,
            0.9965148568153381,
            0.9970066547393799,
            0.9959474205970764,
            0.9958558678627014
        ]
    },
    "2124": {
        "similarity": 0.9972488284111023,
        "body": "    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        usernames = list(map(str, input().split()))\n        m = int(input())\n\n        senders = [None] * m\n        prev_sender = None\n        impossible = False\n\n        for i in range(m):\n            line = input()\n            sender, text = line.split(':')\n            sender = sender.strip()\n\n            if sender == '?' and prev_sender is not None:\n                sender_index = usernames.index(prev_sender)\n                next_sender_index = (sender_index + 1) % n\n                senders[i] = usernames[next_sender_index]\n                if usernames[next_sender_index].lower() in text.lower():\n                    impossible = True\n            else:\n                senders[i] = sender\n\n            prev_sender = sender\n\n        if impossible:\n            print('Impossible')\n        else:\n            for i in range(m):\n                print(f'{senders[i]}:{input()}')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968839287757874,
            0.9971389770507812,
            0.9962376952171326,
            0.9971601366996765,
            0.994870662689209,
            0.99615877866745,
            0.9953966736793518,
            0.9965162873268127,
            0.9972488284111023,
            0.9961384534835815,
            0.9933732748031616,
            0.9966989159584045,
            0.9961888194084167,
            0.9958813190460205,
            0.9957299828529358,
            0.996905505657196,
            0.9965659976005554,
            0.9961172342300415,
            0.9951892495155334,
            0.9951585531234741
        ]
    },
    "1093": {
        "similarity": 0.9968599081039429,
        "body": "    ascent = 0\n    descent = 0\n    for i in range(m-1):\n        max_height = 0\n        prev_max_height = 0\n        for j in range(n):\n            if table[j][i] == '*':\n                height = 0\n                k = j\n                while k < n and table[k][i+1] == '*':\n                    height += 1\n                    k += 1\n                max_height = max(max_height, height)\n                prev_max_height = max(prev_max_height, height - 1)\n        if max_height > prev_max_height:\n            ascent = max(ascent, max_height - prev_max_height)\n        else:\n            descent = max(descent, prev_max_height - max_height)\n    return f\"{ascent} {descent}\"\n\nn, m = map(int, input().split())\ntable = [list(input()) for _ in range(n)]\nprint(max_ascent_descent(n, m, table))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968599081039429,
            0.9963394999504089,
            0.9931263327598572,
            0.9963777661323547,
            0.9954580068588257,
            0.9948640465736389,
            0.9947782754898071,
            0.9946821331977844,
            0.9957748055458069,
            0.9967969655990601,
            0.9964385628700256,
            0.9946228861808777,
            0.996703028678894,
            0.9932603240013123,
            0.9966145753860474,
            0.9936727285385132,
            0.9963390827178955,
            0.9962059855461121,
            0.9966837167739868,
            0.9957889914512634
        ]
    },
    "899": {
        "similarity": 0.9974681735038757,
        "body": "import sys\nfrom itertools import combinations\n\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edges.append((a, b, c))\n\n    dists = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dists[i][i] = 0\n\n    for u, v, w in edges:\n        dists[u][v] = w\n        dists[v][u] = w\n\n    for k in range(1, n + 1):\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                if dists[i][k] + dists[k][j] < dists[i][j]:\n                    dists[i][j] = dists[i][k] + dists[k][j]\n\n    count = 0\n    for u, v in combinations(range(1, n + 1), 2):\n        if dists[u][v] == float('inf'):\n            continue\n        min_dist = dists[u][v]\n        flag = False\n        for a, b, w in edges:\n            if a == u and b == v or a == v and b == u:\n                if w != min_dist:\n                    count += 1\n                    break\n\n    print(count)\n\nfind_edges()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974411725997925,
            0.9965083599090576,
            0.9969385862350464,
            0.9968273043632507,
            0.9943729043006897,
            0.9974379539489746,
            0.9937185049057007,
            0.9966916441917419,
            0.9973512887954712,
            0.9963434338569641,
            0.9973947405815125,
            0.9970263242721558,
            0.9973124265670776,
            0.9974271059036255,
            0.9968225359916687,
            0.9966589212417603,
            0.9966713786125183,
            0.9974681735038757,
            0.9945734143257141,
            0.994816243648529
        ]
    },
    "551": {
        "similarity": 0.9968788623809814,
        "body": "import sys\n\n    y_values = sorted(points)\n\n    for i in range(n - 1):\n        if y_values[i] == y_values[i + 1]:\n            return \"Yes\"\n\n    count = 0\n    for i in range(2, n - 1, 2):\n        if y_values[i - 2] <= y_values[i + 2] and y_values[i - 1] >= y_values[i + 1]:\n            count += 1\n\n    return \"Yes\" if count == 0 or count == 2 else \"No\"\n\nn = int(input())\npoints = list(map(int, input().split()))\n\nprint(can_draw_lines(n, points))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960691332817078,
            0.9955227375030518,
            0.9948731660842896,
            0.9949537515640259,
            0.994035005569458,
            0.9954480528831482,
            0.9935663342475891,
            0.9965730309486389,
            0.9957144856452942,
            0.9961889386177063,
            0.9968788623809814,
            0.9961137175559998,
            0.9960511922836304,
            0.9960097074508667,
            0.9945521950721741,
            0.9965567588806152,
            0.9958622455596924,
            0.995755136013031,
            0.9912480711936951,
            0.9966679811477661
        ]
    },
    "1772": {
        "similarity": 0.9949051737785339,
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    o = e = 0\n    for num in sorted(a):\n        if num % 2:\n            o += 1\n        else:\n            e += 1\n    large_bouquets = min(o, (e + 1) // 2)\n    return large_bouquets",
        "result": "failed: testcase 0",
        "similarities": [
            0.9918488264083862,
            0.9939306378364563,
            0.9870244264602661,
            0.993574857711792,
            0.9949051737785339,
            0.9916532635688782,
            0.9941605925559998,
            0.9906985759735107,
            0.991434633731842,
            0.9904270172119141,
            0.9944459795951843,
            0.9839984774589539,
            0.9889075756072998,
            0.9931077361106873,
            0.9932287335395813,
            0.9927942156791687,
            0.9848827719688416,
            0.9947763681411743,
            0.9938061237335205,
            0.9946898221969604
        ]
    },
    "1339": {
        "similarity": 0.9969033002853394,
        "body": "import sys\n\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    max_right = 0\n    best_i = -1\n    for i in range(n):\n        if segments[i][1] > max_right:\n            max_right = segments[i][1]\n            best_i = i\n\n    min_left = float('inf')\n    for i in range(n):\n        l, r = segments[i]\n        if i != best_i and l <= max_right <= r:\n            min_left = min(min_left, l)\n\n    if min_left < max_right:\n        print(best_i + 1)\n    else:\n        print(-1)\n\nfind_covering_segment()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967077970504761,
            0.9939528107643127,
            0.9940679669380188,
            0.9962465167045593,
            0.9934789538383484,
            0.9959709048271179,
            0.9967504739761353,
            0.996243953704834,
            0.9933816194534302,
            0.9942415952682495,
            0.994448721408844,
            0.9945908784866333,
            0.9963503479957581,
            0.9963698387145996,
            0.9966979026794434,
            0.9934526085853577,
            0.9968523979187012,
            0.9949533343315125,
            0.9960900545120239,
            0.9969033002853394
        ]
    },
    "440": {
        "similarity": 0.9977689385414124,
        "body": "import sys\n    n = int(input())\n    s = input()\n    i = 0\n    while i < n:\n        vowel = 'aeiouy'\n        if s[i] in vowel and (i == 0 or s[i - 1] not in vowel):\n            j = i + 1\n            while j < n and s[j] not in vowel:\n                j += 1\n            if j != n:\n                del s[i]\n                n -= 1\n            else:\n                break\n        else:\n            i += 1\n    print(s)\nword_corrector()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9922809600830078,
            0.9966904520988464,
            0.9972365498542786,
            0.9968606233596802,
            0.9964531660079956,
            0.9955706596374512,
            0.9970053434371948,
            0.9972362518310547,
            0.9966117739677429,
            0.9971209168434143,
            0.9963262677192688,
            0.9969687461853027,
            0.9969269633293152,
            0.9963528513908386,
            0.9973650574684143,
            0.9971791505813599,
            0.9943627119064331,
            0.9969570636749268,
            0.9966432452201843,
            0.9977689385414124
        ]
    },
    "2801": {
        "similarity": 0.9962481260299683,
        "body": "import sys\nimport math\nfrom collections import defaultdict\n\n    satisfaction = [0] * n\n    for i in range(n):\n        satisfaction[i] = c[i]\n\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n\n    max_satisfaction = 0.0\n\n    visited = [False] * n\n\n    stack = [(0, satisfaction[0])]\n    while len(stack) > 0:\n        current_stall, curr_sat = stack.pop()\n        if not visited[current_stall]:\n            visited[current_stall] = True\n            max_satisfaction = max(max_satisfaction, curr_sat)\n\n            if curr_sat == 1.0:\n                for neighbor in graph[current_stall]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, satisfaction[neighbor] / (2 ** len(graph) - 1)))\n    return round(max_satisfaction, 6)\n\n\nn = int(input().split()[0])\nm = int(input().split()[0])\nc = list(map(float, input().split()))\nconnections = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    connections.append((u, v))\n\nresult = pizza_festival(n, m, c, connections)\nsys.stdout.write(str(result) + '\\n')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931270480155945,
            0.9915969371795654,
            0.9935349822044373,
            0.9945161938667297,
            0.9958129525184631,
            0.992506206035614,
            0.9899240732192993,
            0.9960561990737915,
            0.9947718381881714,
            0.9938907623291016,
            0.9962481260299683,
            0.9942880272865295,
            0.9924440979957581,
            0.994795024394989,
            0.9942846894264221,
            0.995965838432312,
            0.9938292503356934,
            0.9951635003089905,
            0.9958337545394897,
            0.9956258535385132
        ]
    },
    "2749": {
        "similarity": 0.9976539611816406,
        "body": "import sys\n\n    H, W = map(int, input().split())\n    N = int(input())\n    a = list(map(int, input().split()))\n\n    colors = [[] for _ in range(N)]\n    row_counts = [0] * (H + 1)\n\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            color_idx = (i - 1) * W + j\n            color_num = 0\n\n            while color_num < N and a[color_num] > row_counts[i]:\n                colors[color_num].append((i, j))\n                a[color_num] -= 1\n                row_counts[i] += 1\n                color_num += 1\n\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            color_idx = (i - 1) * W + j\n            color_num = 0\n\n            while color_num < N and a[color_num] > 0:\n                if colors[color_num]:\n                    x, y = colors[color_num].pop()\n                    print(color_num + 1, end=' ')\n                    a[color_num] -= 1\n                    row_counts[i] += 1\n                    if i == x and j == y:\n                        color_num += 1\n\n                else:\n                    for k in range(max(0, i - 3), min(H, i + 4)):\n                        for l in range(max(0, j - 3), min(W, j + 4)):\n                            if (k, l) != (i, j):\n                                color_num = N\n                                break\n\n                        else:\n                            continue\n                        break\n\n                    else:\n                        print(\"Error: No adjacent squares available\")\n                color_num += 1\n\n        print()\n\npaint_squares()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971209168434143,
            0.9962541460990906,
            0.9964693784713745,
            0.9969292879104614,
            0.9972136616706848,
            0.99457186460495,
            0.9967876076698303,
            0.9962475299835205,
            0.9976539611816406,
            0.9969687461853027,
            0.9971168041229248,
            0.9968651533126831,
            0.9974218606948853,
            0.9960843324661255,
            0.996829092502594,
            0.9972230792045593,
            0.9970981478691101,
            0.9968327283859253,
            0.9971687197685242,
            0.9947504997253418
        ]
    },
    "2319": {
        "similarity": 0.9972096681594849,
        "body": "    n = len(s)\n    if s == t: return 0\n    for i in range(n - 1):\n        if s[i:] + s[:i] <= t:\n            return (n - i) // (n // 2 + 1)\n    return -1\n\n    t = int(input())\n    while t > 0:\n        n = int(input())\n        s = input()\n        t = input()\n        print(min_operations(s, t))\n        t -= 1\n\nmain()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969468712806702,
            0.9971998333930969,
            0.993709146976471,
            0.9957022666931152,
            0.9959678649902344,
            0.9960771799087524,
            0.9961223602294922,
            0.9957183003425598,
            0.9950711131095886,
            0.9962903261184692,
            0.995525062084198,
            0.9965065717697144,
            0.9964982867240906,
            0.9957001209259033,
            0.9967155456542969,
            0.9972096681594849,
            0.9943827390670776,
            0.9952645897865295,
            0.9970430135726929,
            0.9968504905700684
        ]
    },
    "2121": {
        "similarity": 0.9972774982452393,
        "body": "    n, k = map(int, input().split())\n    time_cost = [0] + list(map(int, input().split()))\n    graph = [[] for _ in range(n + 1)]\n\n    for i in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    for i in range(2, n + 1):\n        graph[i].sort(key=lambda x: time_cost[x], reverse=True)\n\n    visited = [False] * (n + 1)\n    max_grade = 0\n\n        nonlocal max_grade\n        if len(graph[node]) == 1 and node != parent:\n            return time_cost[node]\n        visited[node] = True\n        min_time = time_cost[node]\n\n        for child in graph[node]:\n            if not visited[child]:\n                child_min_time = dfs(child, node)\n                min_time = max(min_time, child_min_time)\n\n        max_grade = max(max_grade, min_time)\n        return min_time\n\n    for i in range(1, n + 1):\n        max_grade = 0\n        for j in graph[i]:\n            visited[j] = False\n        dfs(i, -1)\n\n    print(max_grade)\n\n\nfind_max_grade()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969881772994995,
            0.9963736534118652,
            0.9960535764694214,
            0.9967892169952393,
            0.9946178793907166,
            0.9971047639846802,
            0.9956845045089722,
            0.9972072243690491,
            0.9972012042999268,
            0.9967358112335205,
            0.9965662956237793,
            0.9972774982452393,
            0.9965393543243408,
            0.9960214495658875,
            0.9957956075668335,
            0.9950109124183655,
            0.9972224831581116,
            0.9965050220489502,
            0.9946995973587036,
            0.9950633645057678
        ]
    },
    "2617": {
        "similarity": 0.9966455101966858,
        "body": "import sys\n\n    res = []\n    days = 0\n    while n > 2:\n        if n % 2 == 1:\n            n -= 1\n            for i in range(days, 0, -1):\n                res.append(1)\n        else:\n            num = 0\n            while (n >> num) & 1 == 0:\n                num += 1\n            n >>= num\n            n += 1\n            res.extend([2] * num)\n        days += 1\n    return days, res\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 2 == 1:\n        print(-1)\n        continue\n    d, a = solve(n)\n    print(d)\n    print(' '.join(map(str, a)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966455101966858,
            0.9949776530265808,
            0.9964274168014526,
            0.9950348734855652,
            0.9961810111999512,
            0.9962714314460754,
            0.995478093624115,
            0.9952800273895264,
            0.9963981509208679,
            0.99528968334198,
            0.9963496327400208,
            0.9951236248016357,
            0.995132327079773,
            0.994175374507904,
            0.9925938844680786,
            0.9946315288543701,
            0.9963099956512451,
            0.9941329956054688,
            0.9965649843215942,
            0.9956613183021545
        ]
    },
    "175": {
        "similarity": 0.9967519044876099,
        "body": "    while True:\n        if a == 0 or b == 0:\n            return str(a) + \" \" + str(b)\n        elif a >= 2 * b:\n            a -= 2 * b\n        else:\n            b -= 2 * a\n\nn, m = map(int, input().split())\nprint(process_sequence(n, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957954287528992,
            0.9939588308334351,
            0.996071994304657,
            0.9954426288604736,
            0.9928416013717651,
            0.9962203502655029,
            0.9954583048820496,
            0.9957954287528992,
            0.9961417317390442,
            0.9962226748466492,
            0.9949384927749634,
            0.9951346516609192,
            0.995035707950592,
            0.9942359924316406,
            0.9953759908676147,
            0.996597170829773,
            0.9960915446281433,
            0.9947458505630493,
            0.9960516095161438,
            0.9967519044876099
        ]
    },
    "995": {
        "similarity": 0.9966499209403992,
        "body": "import math\nfrom collections import defaultdict\n\n    n = len(A)\n    f = [[[] for _ in range(n)] for _ in range(n)]\n    g = [[0] * (n + 1) for _ in range(n)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            x = A[j]\n            c = math.ceil(math.sqrt(x))\n            p = defaultdict(int)\n            for k in f[i][j]:\n                if k != 0:\n                    p[k] += 1\n                q = c * c // k\n                if q != 0 and (q not in p or p[q]):\n                    g[j + 1][c] += 1\n\n            if x < 0:\n                f[i][j].append(0)\n            else:\n                for k in range(2, int(math.sqrt(x)) + 1):\n                    if x % k == 0:\n                        q = x // k\n                        c_new = math.ceil(math.sqrt(k))\n                        if (k != q or p[q]) and c_new <= n:\n                            f[i][j].append(c_new)\n            g[j + 1][1] += 1\n\n    return [g[n][i] for i in range(1, n + 1)]\n\nn = int(input())\nA = list(map(int, input().split()))\nprint(' '.join(str(x) for x in find_groups(A)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945355653762817,
            0.9959213733673096,
            0.9924508333206177,
            0.9961079955101013,
            0.9960771203041077,
            0.9954414367675781,
            0.9965465068817139,
            0.9951286315917969,
            0.9957385659217834,
            0.9963662028312683,
            0.9965507388114929,
            0.9960919618606567,
            0.9963105916976929,
            0.9928861260414124,
            0.9966499209403992,
            0.996540904045105,
            0.9910115599632263,
            0.9954203367233276,
            0.9959197044372559,
            0.9965146780014038
        ]
    },
    "582": {
        "similarity": 0.996342122554779,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n\n    sorted_categories = []\n    for i in range(n):\n        sorted_categories.append((a[i], t[i]))\n\n    sorted_categories.sort()\n\n    result = 0\n    prev_pub_count = 0\n\n    for pub_count, time in sorted_categories:\n        if pub_count != prev_pub_count:\n            result += (pub_count - prev_pub_count) * time\n            prev_pub_count = pub_count\n\n    return result\n\nprint(min_required_time())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961529970169067,
            0.9953597187995911,
            0.9949190020561218,
            0.9958419799804688,
            0.9960306286811829,
            0.9958478212356567,
            0.9959965944290161,
            0.9947385191917419,
            0.9928189516067505,
            0.996342122554779,
            0.9958864450454712,
            0.9956958293914795,
            0.9909798502922058,
            0.9912282824516296,
            0.9929572939872742,
            0.9952750205993652,
            0.9956287741661072,
            0.9951081871986389,
            0.9935835003852844,
            0.9905040264129639
        ]
    },
    "1402": {
        "similarity": 0.9967268109321594,
        "body": "import sys\n\n    n = int(input())\n    s1 = input()\n    s2 = input()\n\n    count_s1 = [0] * 10\n    count_s2 = [0] * 10\n    diff = [0] * (n + 1)\n    ways = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        if s1[i] != '?':\n            count_s1[int(s1[i])] += 1\n        if s2[i] != '?':\n            count_s2[int(s2[i])] += 1\n\n    for i in range(10):\n        diff[0] += (count_s2[i] - count_s1[i]) * (count_s1[i] <= count_s2[i])\n\n    for i in range(n):\n        if s1[i] == '?' or s2[i] == '?':\n            j = 0\n            while diff[j]:\n                ways[s1[i] != '?' and j < int(s1[i])] += diff[j]\n                j += 1\n\n            k = 9\n            while k >= 0:\n                if count_s1[k] > count_s2[k] or (count_s1[k] <= count_s2[k] and s1[i] == '?'):\n                    ways[s1[i] != '?' and int(s1[i]) == k] += diff[0]\n                    for l in range(k - 1, -1, -1):\n                        if count_s1[l] < count_s2[l] or (count_s2[l] <= count_s1[l] and s2[i] == '?'):\n                            ways[s2[i] != '?' and int(s2[i]) == k and s1[i] != '?' and int(s1[i]) == l] += diff[0]\n                elif count_s2[k] > count_s1[k] or (count_s1[k] <= count_s2[k] and s2[i] == '?'):\n                    ways[s2[i] != '?' and int(s2[i]) == k] += diff[0]\n\n                k -= 1\n\n            for j in range(10):\n                if s1[i] == '?' or (s1[i] == s2[i] and int(s1[i]) > j) or count_s1[j] <= count_s2[j]:\n                    diff[j + 1] += diff[j]\n                elif s2[i] == '?':\n                    diff[0] += diff[j]\n\n    result = sum(ways[n][i] * (n - i) for i in range(n + 1)) % 1000000007\n    print(result)\n\ncount_incomparable_ways()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955323934555054,
            0.9961403608322144,
            0.9957895874977112,
            0.9967268109321594,
            0.9957200884819031,
            0.9952161908149719,
            0.9958477020263672,
            0.9962030053138733,
            0.9944319725036621,
            0.9941831231117249,
            0.9955727458000183,
            0.9959327578544617,
            0.9948102235794067,
            0.9955357909202576,
            0.9964341521263123,
            0.9942450523376465,
            0.9958102703094482,
            0.9933053851127625,
            0.9955646991729736,
            0.996171236038208
        ]
    },
    "1141": {
        "similarity": 0.997288167476654,
        "body": "import sys\n\n    for _ in range(m):\n        l, r, c1, c2 = map(str, input().split())\n        l -= 1\n        r -= 1\n        for i in range(l, r + 1):\n            if s[i] == c1:\n                s = s[:i] + c2 + s[i + 1:]\n    print(s)\n\nn, m = map(int, input().split())\ns = input()\nsolve(n, m, s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942556619644165,
            0.9940911531448364,
            0.9972121715545654,
            0.9965745806694031,
            0.9955945611000061,
            0.99713534116745,
            0.9966717958450317,
            0.9971042275428772,
            0.9965214133262634,
            0.9969329833984375,
            0.9964640736579895,
            0.997288167476654,
            0.9957203269004822,
            0.9968453645706177,
            0.9953532218933105,
            0.9940848350524902,
            0.9969743490219116,
            0.996780276298523,
            0.9964471459388733,
            0.9970970153808594
        ]
    },
    "2836": {
        "similarity": 0.9965277314186096,
        "body": "    n = int(input())\n    boys_names = sorted(list(map(int, input().split())))\n    a, b = map(int, input().split())\n\n    max_distance = 0\n    best_name = 0\n\n    for x in range(a, b + 1):\n        if x % 2 != 0:\n            distance = float('inf')\n            for boy in boys_names:\n                dist = min(abs(x - boy), abs(boy - x))\n                distance = min(distance, dist)\n            if distance > max_distance:\n                max_distance = distance\n                best_name = x\n\n    return best_name",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956212639808655,
            0.9931058287620544,
            0.9950754046440125,
            0.996124267578125,
            0.9929865002632141,
            0.9922512769699097,
            0.9950402975082397,
            0.9960290789604187,
            0.9938631653785706,
            0.9965277314186096,
            0.9950260519981384,
            0.9953052997589111,
            0.9961624145507812,
            0.9959103465080261,
            0.9958192706108093,
            0.9924605488777161,
            0.9912922382354736,
            0.9957156777381897,
            0.9945811033248901,
            0.9949723482131958
        ]
    },
    "1109": {
        "similarity": 0.9960523247718811,
        "body": "import sys\n\n    one_count = 0\n    two_count = 0\n    for i in range(k):\n        if a[i] == 1:\n            one_count += 1\n        else:\n            two_count += 1\n    max_one = (k * one_count) // n\n    min_two = k - ((k * two_count) // n)\n    return max(max_one - one_count, min_two - two_count)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(min_changes(a, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960523247718811,
            0.9941390156745911,
            0.9915482401847839,
            0.9957094788551331,
            0.98808753490448,
            0.9959890246391296,
            0.9953937530517578,
            0.995771586894989,
            0.9919631481170654,
            0.9947311282157898,
            0.9899019002914429,
            0.9931679964065552,
            0.9957567453384399,
            0.9915497303009033,
            0.9946894645690918,
            0.9944314360618591,
            0.9958363771438599,
            0.9957684874534607,
            0.9939165711402893,
            0.9960158467292786
        ]
    },
    "2125": {
        "similarity": 0.995802640914917,
        "body": "import sys\n\n    grid = [list(input().strip()) for _ in range(n)]\n    flag_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            color_i_j = grid[i][j]\n\n            for k in range(i + 1, n):\n                for h in range(j, m):\n                    color_k_h = grid[k][h]\n                    count_flag = 0\n                    flag_height = h - j + 1\n\n                    if (color_i_j == color_k_h or \n                        color_i_j == color_grid[k][j] or \n                        color_grid[i][h] == color_k_h):\n                        continue\n\n                    for ii in range(i, k + 1):\n                        count_flag += 1 if grid[ii][j:j+flag_height].count(color_i_j) == flag_height else 0\n                        count_flag += 1 if grid[ii][h:h-flag_height+1].count(color_k_h) == flag_height else 0\n\n                    for hh in range(j, h + 1):\n                        count_flag += 1 if grid[i:i+flag_height].count(grid[k][hh]) == flag_height else 0\n                        count_flag += 1 if grid[k][j:h+1].count(color_i_j) == (h - j + 1) else 0\n\n                    if count_flag == flag_count:\n                        flag_count = count_flag + 1\n\n            for k in range(i + 1, n):\n                color_k_j = grid[k][j]\n\n                if color_i_j == color_k_j or color_k_j == color_grid[i][h]:\n                    continue\n\n                for h in range(j, m):\n                    color_k_h = grid[k][h]\n                    count_flag = 0\n                    flag_height = h - j + 1\n\n                    if (color_i_j == color_k_h or \n                        color_i_j == color_grid[k][j] or \n                        color_grid[i][h] == color_k_h):\n                        continue\n\n                    for ii in range(i, k + 1):\n                        count_flag += 1 if grid[ii][j:j+flag_height].count(color_i_j) == flag_height else 0\n                        count_flag += 1 if grid[ii][h:h-flag_height+1].count(color_k_h) == flag_height else 0\n\n                    for hh in range(j, h + 1):\n                        count_flag += 1 if grid[i:i+flag_height].count(grid[k][hh]) == flag_height else 0\n                        count_flag += 1 if grid[k][j:h+1].count(color_i_j) == (h - j + 1) else 0\n\n                    if count_flag == flag_count:\n                        flag_count = count_flag + 1\n\n        for k in range(i + 1, n):\n            color_k_j = grid[k][j]\n            color_k_h = grid[k][h]\n\n            if color_i_j == color_k_j or color_i_j == color_k_h or color_grid[i][h] == color_k_j:\n                continue\n\n            count_flag = 0\n            flag_height = h - j + 1\n\n            for ii in range(i, k + 1):\n                count_flag += 1 if grid[ii][j:j+flag_height].count(color_i_j) == flag_height else 0\n                count_flag += 1 if grid[ii][h:h-flag_height+1].count(color_k_h) == flag_height else 0\n\n            for hh in range(j, h + 1):\n                count_flag += 1 if grid[i:i+flag_height].count(grid[k][hh]) == flag_height else 0\n                count_flag += 1 if grid[k][j:h+1].count(color_i_j) == (h - j + 1) else 0\n\n            if count_flag < flag_count:\n                break\n\n        if count_flag > flag_count:\n            flag_count = count_flag + 1\n\n    return flag_count",
        "result": "failed: testcase 0",
        "similarities": [
            0.993233323097229,
            0.9953375458717346,
            0.9952297210693359,
            0.9945470094680786,
            0.9949079751968384,
            0.9951554536819458,
            0.9950184226036072,
            0.9918481707572937,
            0.9955337047576904,
            0.9928643107414246,
            0.9942179322242737,
            0.993334949016571,
            0.9945165514945984,
            0.99578857421875,
            0.995802640914917,
            0.9942106008529663,
            0.9934712648391724,
            0.9956568479537964,
            0.9956297874450684,
            0.9942677021026611
        ]
    },
    "1746": {
        "similarity": 0.9969586730003357,
        "body": "    child_count = [0] * n\n    for i in range(n - 1):\n        parent = p[i] - 1\n        child = i + 1\n        child_count[parent] += 1\n    leaf_children = []\n    for i in range(1, n):\n        if child_count[i] == 0:\n            leaf_children.append(i)\n    for i in range(n):\n        if child_count[i] != 0 and len([x for x in leaf_children if p[x - 1] == i]) < 3:\n            return \"No\"\n    return \"Yes\"\n\nn = int(input())\np = []\nfor _ in range(n - 1):\n    p.append(int(input()))\nprint(is_spruce(n, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955448508262634,
            0.9965418577194214,
            0.9955516457557678,
            0.9954152703285217,
            0.9966995120048523,
            0.9966046214103699,
            0.9964957237243652,
            0.9944895505905151,
            0.9961040019989014,
            0.9940813779830933,
            0.9952685832977295,
            0.995525062084198,
            0.9931545257568359,
            0.9966782331466675,
            0.9954370260238647,
            0.9911665916442871,
            0.9960061311721802,
            0.9969586730003357,
            0.9968292117118835,
            0.9964577555656433
        ]
    },
    "1294": {
        "similarity": 0.9957083463668823,
        "body": "    char_count = {}\n    for c in s:\n        if c not in char_count:\n            char_count[c] = 1\n        else:\n            char_count[c] += 1\n    working = []\n    for c in sorted(char_count.keys()):\n        if char_count[c] % 2 == 0 and char_count[c] > 0:\n            continue\n        working.append(c)\n    return ''.join(working)\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    print(working_buttons(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920507669448853,
            0.9935789704322815,
            0.9954540729522705,
            0.9903573393821716,
            0.9957083463668823,
            0.9954015612602234,
            0.9897710084915161,
            0.9918473958969116,
            0.9949503540992737,
            0.9946890473365784,
            0.9939994812011719,
            0.9944223165512085,
            0.9952578544616699,
            0.9919118285179138,
            0.9947386384010315,
            0.9934545755386353,
            0.9891223907470703,
            0.989804208278656,
            0.9954700469970703,
            0.9917861819267273
        ]
    },
    "1159": {
        "similarity": 0.9980989694595337,
        "body": "    for i in range(2, num):\n        if num % i == 0:\n            return False\n    return True\n\n    edges = []\n    total_edges = 1\n    while not is_prime(total_edges):\n        total_edges += 1\n    edge_count = 0\n    for i in range(2, n + 1):\n        if is_prime(i) and (i * (n - 1)) <= total_edges:\n            edges.append((i, 1))\n            edges.append((i, n))\n            edge_count += 1\n    if edge_count < n:\n        return None\n    else:\n        for i in range(2, n + 1):\n            if is_prime(edge_count) and (edge_count * (n - 1)) <= total_edges:\n                for j in range(1, n + 1):\n                    if j not in [x[0] for x in edges]:\n                        edges.append((i, j))\n                        edge_count += 1\n        return sorted(edges, key=lambda x: (x[0], x[1]))\n\nn = int(input())\nedges = get_edges(n)\nif edges is None:\n    print(-1)\nelse:\n    total_edges = sum(1 for x in edges if (x[0] == 1 or x[0] == n))\n    print(total_edges)\n    for edge in edges:\n        print(edge[0], edge[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979268312454224,
            0.9975820779800415,
            0.9978963136672974,
            0.9970648884773254,
            0.9980316162109375,
            0.9973878264427185,
            0.9976969361305237,
            0.997442364692688,
            0.9977979063987732,
            0.9972440004348755,
            0.9976150393486023,
            0.9980868101119995,
            0.9976007342338562,
            0.9976316690444946,
            0.9976816773414612,
            0.9976838827133179,
            0.9971524477005005,
            0.9980989694595337,
            0.9978908896446228,
            0.9971768260002136
        ]
    },
    "2025": {
        "similarity": 0.9960853457450867,
        "body": "    if n <= 3:\n        return -1\n    composite_sums = [0] * (n + 1)\n    for i in range(4, n + 1):\n        j = 2\n        while j * j <= i:\n            if i % j == 0:\n                composite_sums[i] += 1\n                k = i // j\n                if k >= 4 and k != j:\n                    composite_sums[i] += composite_sums[k]\n            j += 1\n    return composite_sums[n]\n\nq = int(input())\nfor _ in range(q):\n    n = int(input())\n    print(count_composite_summands(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936479330062866,
            0.9943734407424927,
            0.994209885597229,
            0.9957357048988342,
            0.9913423657417297,
            0.9955351948738098,
            0.9931644797325134,
            0.995602548122406,
            0.9930362701416016,
            0.9953805208206177,
            0.9946871399879456,
            0.9954795837402344,
            0.9931690692901611,
            0.9939376711845398,
            0.9951273202896118,
            0.9944148659706116,
            0.9960853457450867,
            0.9959072470664978,
            0.9949240684509277,
            0.9960275292396545
        ]
    },
    "1429": {
        "similarity": 0.9955476522445679,
        "body": "import sys\n\n    N = len(S)\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    seen = [0] * (N + 1)\n    count = 0\n    for i in range(N):\n        for j in range(i, N):\n            substring = S[i:j+1]\n            t = ''.join(sorted(substring))\n            complement = ''.join(complement_map[c] for c in t)\n            if t <= complement:\n                count += seen[j + 4 - len(t)]\n                seen[j + 1] += 1\n    return count\n\nN, S = input().split()\nprint(count_permutations(S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9917480945587158,
            0.9939752817153931,
            0.9948393106460571,
            0.9942153096199036,
            0.9933672547340393,
            0.9951679110527039,
            0.9942466616630554,
            0.9940136671066284,
            0.9905472993850708,
            0.9955476522445679,
            0.9920705556869507,
            0.993545413017273,
            0.9946088194847107,
            0.9951751232147217,
            0.9952101707458496,
            0.9937905073165894,
            0.9934083819389343,
            0.9946773052215576,
            0.9890154600143433,
            0.9947977662086487
        ]
    },
    "1950": {
        "similarity": 0.9939025044441223,
        "body": "    n = int(input())\n    nums = list(map(int, input().split()))\n    dp = [0] * (n + 1)\n    dp[0] = max(nums)\n\n    for i in range(1, n):\n        dp[i] = dp[i-1]\n        if nums[i] < dp[i]:\n            continue\n        k = min(i+2, n) - 1\n        for j in range(k, 0, -1):\n            dp[i] = min(dp[i], dp[i-j] + (nums[i] - dp[i-j]) // j * j)\n\n    return dp[-1]\n\nprint(min_penalty())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934447407722473,
            0.9918066263198853,
            0.99169921875,
            0.976629376411438,
            0.9916295409202576,
            0.9874665141105652,
            0.9924671053886414,
            0.9891049265861511,
            0.9910744428634644,
            0.9919614195823669,
            0.9859563112258911,
            0.9892042279243469,
            0.9936447143554688,
            0.9920551776885986,
            0.9899554252624512,
            0.9904977083206177,
            0.9900660514831543,
            0.9893832802772522,
            0.9928615093231201,
            0.9939025044441223
        ]
    },
    "631": {
        "similarity": 0.9979604482650757,
        "body": "    a.sort(reverse=True)\n    s = 0\n    for i in range(len(a)):\n        temp = s\n        for j in range(i, len(a)):\n            temp += a[j] / (j + 1)\n        if temp == m:\n            return 'YES'\n        s = temp\n    return 'NO'\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(can_reorder(a, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9911348223686218,
            0.9978352785110474,
            0.9949560761451721,
            0.9976415038108826,
            0.9966575503349304,
            0.9977093935012817,
            0.996519923210144,
            0.9970787763595581,
            0.9972975850105286,
            0.9952319264411926,
            0.9974368214607239,
            0.9975128173828125,
            0.9975292682647705,
            0.99785977602005,
            0.9979604482650757,
            0.9971590638160706,
            0.9977494478225708,
            0.9962179064750671,
            0.9972959160804749,
            0.9974834322929382
        ]
    },
    "2480": {
        "similarity": 0.9971792101860046,
        "body": "    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    res = 0\n    for i in range(n):\n        s = 0\n        for j in range(i, n):\n            s += a[j]\n            if s % k == j - i + 1:\n                res += 1\n    return res\n\nprint(count_subsequences())",
        "result": "failed: testcase 0",
        "similarities": [
            0.994694173336029,
            0.9957166910171509,
            0.9971792101860046,
            0.9954414367675781,
            0.9911418557167053,
            0.9957835674285889,
            0.9954295754432678,
            0.9951508045196533,
            0.9949826002120972,
            0.9951941967010498,
            0.9940550923347473,
            0.9948415160179138,
            0.9965997338294983,
            0.9969257712364197,
            0.9969924092292786,
            0.9953508973121643,
            0.9953141808509827,
            0.9964392781257629,
            0.9958352446556091,
            0.9967641234397888
        ]
    },
    "2363": {
        "similarity": 0.9980669617652893,
        "body": "import sys\n\n    n = int(input())\n    for _ in range(n):\n        a, b = sorted(map(int, input().split()))\n        operations = 0\n        while a != b:\n            operations += 1\n            if a > b:\n                a -= b\n            else:\n                b -= a\n        print(operations)\n\ncount_operations()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970940351486206,
            0.995523989200592,
            0.9973841309547424,
            0.9970990419387817,
            0.9980489611625671,
            0.9959162473678589,
            0.9979709982872009,
            0.9968724846839905,
            0.9977757334709167,
            0.9965248107910156,
            0.99795001745224,
            0.9977658987045288,
            0.9960072040557861,
            0.9970180988311768,
            0.9977306723594666,
            0.9966261982917786,
            0.9967823028564453,
            0.9968026876449585,
            0.9964099526405334,
            0.9980669617652893
        ]
    },
    "909": {
        "similarity": 0.9921286702156067,
        "body": "        return x + y, x * y, y * x / x\n\n    max_val = 0\n    for sign_ab in [True, False]:\n        if sign_ab:\n            a_bc, _, _ = calculate(b * c, a)\n        else:\n            bc_a, _, bc_over_a = calculate(a, b * c)\n\n        max_val = max(max_val, bc_a, a_bc, bc_over_a)\n\n    return max_val\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_value(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9893170595169067,
            0.9874429106712341,
            0.9920014142990112,
            0.9868960976600647,
            0.9921286702156067,
            0.9868175983428955,
            0.9908493757247925,
            0.9887012839317322,
            0.9801497459411621,
            0.9917887449264526,
            0.9914153218269348,
            0.9879202842712402,
            0.9879053831100464,
            0.9891242980957031,
            0.9918172955513,
            0.9892855286598206,
            0.9894071817398071,
            0.9849416613578796,
            0.9862568378448486,
            0.9913268089294434
        ]
    },
    "154": {
        "similarity": 0.9957767128944397,
        "body": "import sys\nfrom math import gcd\nMOD = 998244353\n\n    dp = [[0]*n for _ in range(20)]\n    dp[0][i] = 1\n    for i in range(1, 20):\n        for j in range(i*n, -1, -1):\n            if j == 0:\n                dp[i][j] += dp[i-1][j]\n            else:\n                k = (n + 1) // 2**(i+1)\n                l = n - k\n                m = min((l-1)//k+1, ((n-j-1-k)//(2**i)+1))\n                for h in range(max(j-m*l,0),min(j,l)):\n                    dp[i][j] += dp[i-1][h]\n    return sum(dp[19][i] for i in range(n)) % MOD\n\nn = int(input())\nprint(count_trees(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952907562255859,
            0.9919473528862,
            0.9933341145515442,
            0.9957414269447327,
            0.9957767128944397,
            0.9946708679199219,
            0.9921494722366333,
            0.9928490519523621,
            0.9930735230445862,
            0.9953230619430542,
            0.9942594766616821,
            0.9954496622085571,
            0.9917730093002319,
            0.9943078756332397,
            0.9947152733802795,
            0.9946843981742859,
            0.9947492480278015,
            0.9938822388648987,
            0.9942085146903992,
            0.9936994314193726
        ]
    },
    "39": {
        "similarity": 0.9981514811515808,
        "body": "    max_length = 0\n    for length in range(1, len(s) + 1):\n        for start in range(len(s) - length + 1):\n            substring = s[start:start + length]\n            is_palindrome = True\n            for i in range(length // 2):\n                if substring[i] != substring[length - 1 - i]:\n                    is_palindrome = False\n                    break\n            if not is_palindrome:\n                max_length = length\n    return max_length\n\ns = input()\nprint(longest_non_palindrome(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969506859779358,
            0.9974837899208069,
            0.9979019165039062,
            0.9974523186683655,
            0.9968069195747375,
            0.9976537823677063,
            0.9977391958236694,
            0.99640291929245,
            0.9977832436561584,
            0.9981091022491455,
            0.9965478777885437,
            0.9981514811515808,
            0.9975880980491638,
            0.9977085590362549,
            0.9965249300003052,
            0.9978316426277161,
            0.9935439229011536,
            0.9977065920829773,
            0.9974937438964844,
            0.9977625012397766
        ]
    },
    "1885": {
        "similarity": 0.9944629669189453,
        "body": "import math\n\n    n = int(input())\n    total_combinations = 0\n    for i in range(5, min(n, 8)):\n        combinations = math.comb(n, i)\n        for j in range(i, n + 1):\n            if j - i <= i:\n                combinations *= (j - i) * (i - 1)\n            else:\n                combinations *= i\n        total_combinations += combinations\n    return total_combinations",
        "result": "failed: testcase 0",
        "similarities": [
            0.9900215864181519,
            0.9933032989501953,
            0.9912358522415161,
            0.992204487323761,
            0.9917869567871094,
            0.9913243651390076,
            0.9917618632316589,
            0.9925556182861328,
            0.9911569356918335,
            0.9926674365997314,
            0.9944629669189453,
            0.9917731285095215,
            0.9829319715499878,
            0.9912521243095398,
            0.9914571046829224,
            0.9856093525886536,
            0.9919339418411255,
            0.993882417678833,
            0.9908087849617004,
            0.9906367063522339
        ]
    },
    "1180": {
        "similarity": 0.9977905750274658,
        "body": "    mod = 10**9 + 7\n    max_val = int(s)\n    ways = [[0] * (k+1) for _ in range(n)]\n    dp = [0] * (n + 1)\n\n    for i in range(1, n+1):\n        val = int(s[i-1])\n        for j in range(k, -1, -1):\n            if j == k:\n                ways[i][j] = max_val\n            elif i < n and s[i] != '0':\n                ways[i][j] += val + dp[i]\n            if i > 1 and s[i-1] != '0' and s[i-2] != '0':\n                ways[i][j] += ways[i-2][j+1]\n        dp[i] = ways[i][k] % mod\n\n    return (dp[n] + max_val) % mod\n\nn, k = map(int, input().split())\ns = input()\nprint(calc_exp(n, k, s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964398741722107,
            0.9961546063423157,
            0.997008204460144,
            0.9956497550010681,
            0.9974309206008911,
            0.9973651766777039,
            0.9932367205619812,
            0.9974136352539062,
            0.9967127442359924,
            0.9977905750274658,
            0.9968393445014954,
            0.9968301057815552,
            0.9966603517532349,
            0.9969366192817688,
            0.9967252016067505,
            0.9971175193786621,
            0.9955052137374878,
            0.997668445110321,
            0.997281551361084,
            0.997288167476654
        ]
    },
    "1856": {
        "similarity": 0.9967494606971741,
        "body": "import sys\n\n    n = int(input())\n    words = []\n    for _ in range(n):\n        word = input()\n        words.append(word)\n    words.sort()\n\n    unique_words = set(words)\n\n    password_equivalence_count = {}\n    for i in range(len(unique_words)):\n        curr_word = unique_words[i]\n        for j in range(i + 1, len(unique_words)):\n            if curr_word in password_equivalence_count:\n                continue\n            other_word = unique_words[j]\n\n            overlap_found = False\n            for k in range(min(len(curr_word), len(other_word))):\n                if curr_word[k] == other_word[k]:\n                    overlap_found = True\n                    break\n\n            if overlap_found and not (curr_word in password_equivalence_count or other_word in password_equivalence_count):\n                password_equivalence_count[curr_word] = 1\n                password_equivalence_count[other_word] = 1\n            elif curr_word in password_equivalence_count or other_word in password_equivalence_count:\n                password_equivalence_count[curr_word] = 1\n\n    ans = len(unique_words) - len(password_equivalence_count)\n    print(ans)\n\ncount_passwords()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965521097183228,
            0.9939867258071899,
            0.9963904023170471,
            0.996333658695221,
            0.996418833732605,
            0.9957125782966614,
            0.9949169158935547,
            0.9947057366371155,
            0.9963993430137634,
            0.9961099028587341,
            0.9950310587882996,
            0.9960554242134094,
            0.9960698485374451,
            0.9954699277877808,
            0.9959068298339844,
            0.9950358867645264,
            0.9950027465820312,
            0.9964954853057861,
            0.9961449503898621,
            0.9967494606971741
        ]
    },
    "522": {
        "similarity": 0.9960027933120728,
        "body": "    n, f1, f2, f3, c = map(int, input().split())\n    mod = 10**9 + 7\n    prev_4 = [f1, f2, f3, 1]\n    for i in range(4, int(n) + 1):\n        next_val = pow(c, 2 * (i - 6), mod)\n        for j in range(3, -1, -1):\n            prev_4[j] = (prev_4[j] * prev_4[j - 1]) % mod\n        prev_4[0] = (next_val * prev_4[0]) % mod\n    return prev_4[-1]\n\nprint(calc_fn())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933699369430542,
            0.9949462413787842,
            0.9915755391120911,
            0.9921556115150452,
            0.9935524463653564,
            0.9898676872253418,
            0.9904224872589111,
            0.9953869581222534,
            0.9949616193771362,
            0.9936645030975342,
            0.9960027933120728,
            0.9950756430625916,
            0.9947724938392639,
            0.9951984882354736,
            0.9951393008232117,
            0.9935317635536194,
            0.9934796690940857,
            0.9944020509719849,
            0.9933722615242004,
            0.9936115741729736
        ]
    },
    "1719": {
        "similarity": 0.9959422945976257,
        "body": "import sys\nmod = 1000000007\n\n    dp = [[0] * 6 for _ in range(N + 1)]\n    dp[0][0] = 1\n    for n in range(1, N + 1):\n        dp[n][0] += dp[n - 1][0]\n        dp[n][2] += dp[n - 1][1]\n        dp[n][3] += dp[n - 1][2]\n        if n > 1:\n            dp[n][4] = (dp[n - 1][0] + dp[n - 2][1]) % mod\n            dp[n][5] = (dp[n - 1][0] + dp[n - 2][3]) % mod\n        for k in range(6):\n            dp[n][(k * 4) % 6] += dp[n - 1][k]\n    return sum(dp[N]) % mod\n\nN = int(input())\nprint(count_strings(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934861063957214,
            0.9955488443374634,
            0.9929671287536621,
            0.9946522116661072,
            0.9924834370613098,
            0.9945992231369019,
            0.9952262043952942,
            0.993496835231781,
            0.9955705404281616,
            0.9948586225509644,
            0.9921485781669617,
            0.9945979714393616,
            0.9788281321525574,
            0.9950274229049683,
            0.994114100933075,
            0.9896937012672424,
            0.9952137470245361,
            0.9885808229446411,
            0.993910551071167,
            0.9959422945976257
        ]
    },
    "1842": {
        "similarity": 0.9968740344047546,
        "body": "import math\n\n    discriminant = b**2 - 4*a*c\n    if discriminant <= 0:\n        raise ValueError(\"Discriminant must be greater than zero\")\n    root_discriminant = math.sqrt(discriminant)\n    root1 = (-b + root_discriminant) / (2 * a)\n    root2 = (-b - root_discriminant) / (2 * a)\n    return max(root1, root2), min(root1, root2)\n\na, b, c = map(float, input().split())\nprint(get_roots(a, b, c)[0])\nprint(get_roots(a, b, c)[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962762594223022,
            0.9954534769058228,
            0.9942398071289062,
            0.9963923096656799,
            0.9965488910675049,
            0.9944870471954346,
            0.994673490524292,
            0.9963231682777405,
            0.9951471090316772,
            0.9963967204093933,
            0.9957982301712036,
            0.9965944886207581,
            0.994373619556427,
            0.9955287575721741,
            0.9964550733566284,
            0.9968740344047546,
            0.9922192096710205,
            0.9967117309570312,
            0.9963170289993286,
            0.9956598877906799
        ]
    },
    "806": {
        "similarity": 0.9968594908714294,
        "body": "import sys\nMOD = 10**9 + 7\n\n    n, l, r = map(int, input().split())\n    ans = [0] * (r - l + 1)\n    for i in range(l, r + 1):\n        ans[i - l] = 1\n    dp = [[0, 0, 0] for _ in range(n)]\n    for i in range(r - l + 1):\n        for j in range(3):\n            if ans[i] == 1:\n                if i + 1 <= r - l and (j == 0 or j == 2):\n                    dp[i][j ^ 1] = (dp[i][j ^ 1] + dp[i - 1][j]) % MOD\n                if i + 2 <= r - l and (j == 1):\n                    dp[i][j] = (dp[i][j] + dp[i - 2][0]) % MOD\n    return sum(dp[-1]) % MOD\n\nprint(num_ways())",
        "result": "failed: testcase 0",
        "similarities": [
            0.993981122970581,
            0.9944208264350891,
            0.9946422576904297,
            0.9957086443901062,
            0.9962154030799866,
            0.9968594908714294,
            0.9952006936073303,
            0.9967045187950134,
            0.9960628151893616,
            0.9954038858413696,
            0.9944930076599121,
            0.9950448274612427,
            0.9958666563034058,
            0.9949405193328857,
            0.9962071776390076,
            0.993885338306427,
            0.9961832761764526,
            0.9949540495872498,
            0.9948384165763855,
            0.9966184496879578
        ]
    },
    "365": {
        "similarity": 0.9968430399894714,
        "body": "import sys\n\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    \n    i = 0\n    while i < n - 1:\n        if a[i] <= a[i + 1]:\n            a[i] += a[i + 1]\n            del a[i + 1]\n            n -= 1\n        else:\n            i += 1\n            \n    total_length = sum(a)\n    \n    if total_length == x and len(set(a)) == 1:\n        return \"YES\"\n    elif total_length != x or len(set(a)) > 1:\n        return \"NO\"\n\nprint(check_crossword_encoding())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930132031440735,
            0.9958733320236206,
            0.9961047768592834,
            0.9968430399894714,
            0.9959245324134827,
            0.9927240014076233,
            0.9953392744064331,
            0.9951956868171692,
            0.9961782693862915,
            0.996486246585846,
            0.996787428855896,
            0.996357798576355,
            0.9966545104980469,
            0.9958319664001465,
            0.9966734647750854,
            0.9968377947807312,
            0.9952963590621948,
            0.9955804944038391,
            0.9920110106468201,
            0.9966902732849121
        ]
    },
    "1158": {
        "similarity": 0.9972196817398071,
        "body": "import sys\n\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    freq = {}\n    for i in range(n):\n        if a[i] not in freq:\n            freq[a[i]] = 1\n        else:\n            freq[a[i]] += 1\n\n    count = sum(val % k == 0 and val >= k for val in freq.values())\n\n    stolen_utensils = n - max(freq.values())\n    return min(stolen_utensils, count)\n\nprint(min_stolen_utensils())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951689839363098,
            0.9966339468955994,
            0.9963340759277344,
            0.9956502318382263,
            0.9971100687980652,
            0.9963939189910889,
            0.9946862459182739,
            0.9965758323669434,
            0.9967347979545593,
            0.9967575073242188,
            0.9971288442611694,
            0.9943950176239014,
            0.9967207908630371,
            0.9963575601577759,
            0.9958371520042419,
            0.9972196817398071,
            0.9960008263587952,
            0.9969090223312378,
            0.9969589710235596,
            0.9956433176994324
        ]
    },
    "33": {
        "similarity": 0.9967796206474304,
        "body": "import sys\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\n    cnt = 0\n    for k in range(R // a1 + 1):\n        d1 = (R - a1 * k) / a2\n        if d1 <= 0 or not d1.is_integer() or b2 + a2 * int(d1) < L:\n            continue\n\n        for l in range(int(d1) + 1, min(R // a2 + 1, int(d1) + 10)):\n            if b2 + a2 * l == a1 * k + b1:\n                cnt += 1\n    return cnt\n\nprint(count_x())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963955283164978,
            0.9953545331954956,
            0.9963763356208801,
            0.9954490661621094,
            0.9942860007286072,
            0.9953119158744812,
            0.995935320854187,
            0.9951440691947937,
            0.9961178302764893,
            0.9953881502151489,
            0.9961001873016357,
            0.9932472109794617,
            0.9950067400932312,
            0.9944037199020386,
            0.9967796206474304,
            0.9940120577812195,
            0.9951609373092651,
            0.9941728711128235,
            0.9960607290267944,
            0.9909995198249817
        ]
    },
    "2498": {
        "similarity": 0.9972535371780396,
        "body": "    N, M = [int(x) for x in input().split()]\n    a = [int(x) * 2 for x in input().split()]\n\n    max_val = int(1e9 + 10)\n    lcm = []\n    for i in range(N):\n        new_lcm = (lcm[i-1] if i > 0 else 1)\n        while True:\n            if (new_lcm * 2 <= a[i]):\n                new_lcm *= 2\n            elif (a[i] % new_lcm == 0):\n                lcm.append(new_lcm)\n                break\n            else:\n                new_lcm = new_lcm // 2 + a[i]\n        i += 1\n\n    count = 0\n    for num in range(1, M+1):\n        is_semi_common_multiple = True\n        for k in range(N):\n            if (num % lcm[k] != 0):\n                is_semi_common_multiple = False\n                break\n        if is_semi_common_multiple:\n            count += 1\n\n    return str(count)\n\nprint(count_semi_common_multiples())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946174621582031,
            0.9950653910636902,
            0.9972208738327026,
            0.9966105222702026,
            0.9968395233154297,
            0.9959486126899719,
            0.9970466494560242,
            0.9962124228477478,
            0.9969130158424377,
            0.9964730143547058,
            0.996026873588562,
            0.9967619180679321,
            0.9965794086456299,
            0.9970292448997498,
            0.9972535371780396,
            0.9965819120407104,
            0.9964715838432312,
            0.9965944886207581,
            0.9970114827156067,
            0.9941206574440002
        ]
    },
    "2309": {
        "similarity": 0.997432291507721,
        "body": "import sys\n\n    return c in 'aeiou'\n\n    count = 0\n    for c in s:\n        if is_vowel(c):\n            count += 1\n    return count\n\n    last_vowel_idx = -1\n    for i, c in enumerate(reversed(s)):\n        if is_vowel(c):\n            last_vowel_idx = len(s) - 1 - i\n            break\n    return s[last_vowel_idx] if last_vowel_idx != -1 else ''\n\n    vowels_count_map = {}\n    last_vowel_map = {}\n\n    for idx, word in enumerate(words):\n        count = count_vowels(word)\n        if count not in vowels_count_map:\n            vowels_count_map[count] = []\n        vowels_count_map[count].append((word, idx))\n\n        last_vowel = get_last_vowel(word)\n        if last_vowel not in last_vowel_map:\n            last_vowel_map[last_vowel] = set()\n        last_vowel_map[last_vowel].add((word, idx))\n\n    words_by_vowels = []\n    for count in sorted(vowels_count_map.keys()):\n        words_by_vowels.append(vowels_count_map[count])\n\n    result = []\n\n    for first_line_vowels_count in range(1, max(vowels_count_map.keys()) + 1):\n        for second_line_vowels_count in range(first_line_vowels_count, max(vowels_count_map.keys()) + 1):\n            if (first_line_vowels_count == second_line_vowels_count and\n                    len(words_by_vowels[first_line_vowels_count - 1]) >= 2 and\n                    len(words_by_vowels[second_line_vowels_count - 1]) >= 2):\n                first_word, first_idx = words_by_vowels[first_line_vowels_count - 1][0]\n                second_word, _ = words_by_vowels[first_line_vowels_count - 1][1]\n\n                third_word, third_idx = words_by_vowels[second_line_vowels_count - 1][0]\n                fourth_word, _ = words_by_vowels[second_line_vowels_count - 1][1]\n\n                first_last_vowel = get_last_vowel(first_word)\n                second_last_vowel = get_last_vowel(second_word)\n\n                if (first_last_vowel == get_last_vowel(third_word) and\n                        second_last_vowel == get_last_vowel(fourth_word)):\n                    result.append((first_word, third_word))\n                    result.append((second_word, fourth_word))\n\n    print(len(result))\n\n    for lyric in result:\n        print(lyric[0], end=' ')\n        print(lyric[1])\n\nn = int(input())\nwords = []\nfor _ in range(n):\n    words.append(input())\n\nsolve(words, [len(word) for word in words])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973823428153992,
            0.9963077902793884,
            0.9969205260276794,
            0.997432291507721,
            0.9964466094970703,
            0.9971775412559509,
            0.9973387718200684,
            0.9947431683540344,
            0.9969924092292786,
            0.9973044991493225,
            0.9972624778747559,
            0.9962965250015259,
            0.9960806965827942,
            0.9960640668869019,
            0.996666669845581,
            0.9967151284217834,
            0.9960676431655884,
            0.9965028166770935,
            0.9972359538078308,
            0.9958309531211853
        ]
    },
    "1326": {
        "similarity": 0.9975987672805786,
        "body": "import math\n\n    count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            if n // i == i:\n                count += 1\n            else:\n                count += 2\n    return count\n\nN = int(input())\ntotal_sum = 0\nfor k in range(1, N + 1):\n    total_sum += k * count_divisors(k)\n\nprint(total_sum)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967790246009827,
            0.9951302409172058,
            0.9969390034675598,
            0.991847574710846,
            0.9969658255577087,
            0.9972801208496094,
            0.9970757365226746,
            0.997592031955719,
            0.9966884255409241,
            0.9968491792678833,
            0.9975987672805786,
            0.9959695935249329,
            0.9966091513633728,
            0.9965422749519348,
            0.9958897829055786,
            0.9959855675697327,
            0.9974172711372375,
            0.9974802136421204,
            0.9961788058280945,
            0.9950891733169556
        ]
    },
    "2950": {
        "similarity": 0.9959188103675842,
        "body": "import sys\n\n    n = int(input())\n    heights = sorted(map(int, input().split()))\n\n    total_floors = sum(heights)\n    removed_floors = 0\n\n    i = 0\n    while i < n and removed_floors < total_floors:\n        xth_floors_removed = 0\n\n        for height in heights[i:]:\n            if height > i + 1:\n                removed_heights = (i + 1)\n                xth_floors_removed += removed_heights\n            else:\n                xth_floors_removed += height\n\n            if xth_floors_removed >= heights[i]:\n                total_floors -= heights[i]\n                removed_floors += heights[i]\n\n        i += 1\n\n    return n - (total_floors == 0)\n\nprint(calculate_min_charges())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9914847016334534,
            0.9955683350563049,
            0.9951655864715576,
            0.9952523112297058,
            0.9958591461181641,
            0.9946032166481018,
            0.9946909546852112,
            0.9940082430839539,
            0.9953332543373108,
            0.9931755065917969,
            0.9949437379837036,
            0.9959188103675842,
            0.995257556438446,
            0.9935793876647949,
            0.9935312867164612,
            0.9853905439376831,
            0.9911717176437378,
            0.9916867613792419,
            0.995683491230011,
            0.9939599633216858
        ]
    },
    "1983": {
        "similarity": 0.997257649898529,
        "body": "    lis = [a[0]]\n    for i in range(1, n):\n        if a[i] > lis[-1]:\n            lis.append(a[i])\n        else:\n            idx = 0\n            while idx < len(lis) and lis[idx] >= a[i]:\n                idx += 1\n            lis[idx] = a[i]\n    return len(lis)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(longest_increasing_subsequence(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933341145515442,
            0.9963830709457397,
            0.9964093565940857,
            0.9940277934074402,
            0.9967459440231323,
            0.9965930581092834,
            0.9948518872261047,
            0.9956440329551697,
            0.9921242594718933,
            0.997257649898529,
            0.996124804019928,
            0.9966652393341064,
            0.9969068169593811,
            0.9968591928482056,
            0.9962370991706848,
            0.9950000643730164,
            0.996425211429596,
            0.9964498281478882,
            0.9968782067298889,
            0.9970961213111877
        ]
    },
    "1767": {
        "similarity": 0.996046781539917,
        "body": "    n = len(a)\n    or_a = [[0]*n for _ in range(n)]\n    or_b = [[0]*n for _ in range(n)]\n\n    for l in range(n):\n        for r in range(l, n):\n            temp = 0\n            for i in range(l, r + 1):\n                temp |= a[i]\n            or_a[l][r] = temp\n\n            temp = 0\n            for i in range(l, r + 1):\n                temp |= b[i]\n            or_b[l][r] = temp\n\n    max_sum = 0\n    for l in range(n):\n        for r in range(l, n):\n            max_sum = max(max_sum, or_a[l][r] + or_b[l][r])\n\n    return max_sum\n\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nprint(max_f(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9913627505302429,
            0.9935451149940491,
            0.9942911863327026,
            0.9951428174972534,
            0.9944606423377991,
            0.9923210144042969,
            0.9917609691619873,
            0.9943024516105652,
            0.9913080930709839,
            0.9930084943771362,
            0.9946925640106201,
            0.9955376982688904,
            0.9927036166191101,
            0.996046781539917,
            0.9956483244895935,
            0.9950070977210999,
            0.9954802989959717,
            0.9927542805671692,
            0.9926652312278748,
            0.9929654002189636
        ]
    },
    "2382": {
        "similarity": 0.9963475465774536,
        "body": "import sys\n\n    count = [0] * (10**9 + 1)\n    for slime in slimes:\n        count[slime] += 1\n    healths = [0] * N\n    healths[0] = max(count) // 2\n\n    for n in range(1, N):\n        for i in range(n - 1, -1, -1):\n            if healths[i] == 0:\n                continue\n            count[healths[i]] -= 1\n            if count[healths[i]]:\n                healths[n] = healths[i]\n                break\n\n        for health in sorted(count, reverse=True):\n            if count[health]:\n                healths[n] = health\n                break\n\n    return 'Yes' if all(x == max(count) // 2 for x in healths) else 'No'\n\nN = int(input())\nslimes = list(map(int, input().split()))\nprint(check_healths(N, slimes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9904420971870422,
            0.9963475465774536,
            0.9956415295600891,
            0.9962071776390076,
            0.994531512260437,
            0.9942880868911743,
            0.9917156100273132,
            0.9947867393493652,
            0.9953997731208801,
            0.9958716034889221,
            0.9848255515098572,
            0.9937222003936768,
            0.9959696531295776,
            0.9960569143295288,
            0.9954648613929749,
            0.9958162903785706,
            0.9952846169471741,
            0.9953916668891907,
            0.9958012104034424,
            0.9944157004356384
        ]
    },
    "3907": {
        "similarity": 0.9966214895248413,
        "body": "import sys\n\n    q_w = []\n    for _ in range(m):\n        q, w = map(int, input().split())\n        q_w.append((q, w))\n\n    q_w.sort(key=lambda x: (x[0], -x[1]))\n    prices = [0] * 100001\n    counts = [0] * 100001\n\n    for q, w in q_w:\n        counts[q] += 1\n        if counts[q] == 1:\n            prices[q] = w\n\n    result = 0\n    i = 100000\n\n    while n > 0 and i > 0:\n        n -= counts[i]\n        j = i - 1\n        while j >= 0 and (i + 1 != j or prices[j] <= prices[i]):\n            if i == j:\n                result += min(n, counts[j]) * prices[j]\n            else:\n                result += min(min(n, counts[i]), counts[j]) * prices[i]\n            n -= min(min(n, counts[i]), counts[j])\n            j -= 1\n        i = j\n\n    for q in range(100001):\n        if n > 0 and counts[q] != 0:\n            result += min(n, counts[q]) * prices[q]\n\n    return result\n\nprint(max_money(int(input().split()[0]), int(input().split()[1])))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964248538017273,
            0.9952706694602966,
            0.995680570602417,
            0.9959760904312134,
            0.9947553277015686,
            0.9956533312797546,
            0.9942576885223389,
            0.9964700937271118,
            0.9966214895248413,
            0.9963344931602478,
            0.9941363334655762,
            0.9955779910087585,
            0.996164858341217,
            0.9954037070274353,
            0.9955516457557678,
            0.9915149211883545,
            0.995982825756073,
            0.9953115582466125,
            0.9961222410202026,
            0.9912548065185547
        ]
    },
    "3676": {
        "similarity": 0.9962379932403564,
        "body": "    if R == 1:\n        return C + 1\n    elif C == 1:\n        return R + 1\n    else:\n        result = 2 * (R - 1) + 2 * (C - 1)\n        for i in range(3, min(R, C)):\n            result += i * 4\n        if R >= 3 and C >= 3:\n            result -= 6\n        return result\n\nR, C = [int(x) for x in input().split()]\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9935820698738098,
            0.9903935790061951,
            0.9953029155731201,
            0.9889650940895081,
            0.9946568012237549,
            0.9940807819366455,
            0.9947658181190491,
            0.9929096102714539,
            0.9951796531677246,
            0.9956191182136536,
            0.9940900206565857,
            0.9842543601989746,
            0.9952649474143982,
            0.9942088723182678,
            0.9954643249511719,
            0.9962379932403564,
            0.9957960247993469,
            0.9950055480003357,
            0.9949946403503418,
            0.9951907992362976
        ]
    },
    "3293": {
        "similarity": 0.9948227405548096,
        "body": "import sys\n\n    profit = 0\n    for i in range(1, n + 1):\n        f, p, m, s = positions[i - 1]\n        if s > 0:\n            new_profit = max(m - p, 0)\n            if new_profit > profit:\n                profit = new_profit\n    return profit\n\nn = int(input())\npositions = []\nfor i in range(1, n + 1):\n    f, p, m, s = map(int, input().split())\n    positions.append((f, p, m, s))\n\nprint(max_net_gain(n, positions))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944777488708496,
            0.9947449564933777,
            0.9938169121742249,
            0.9901687502861023,
            0.9941329956054688,
            0.9932217001914978,
            0.9926350116729736,
            0.9939595460891724,
            0.9939767718315125,
            0.9925016164779663,
            0.9947989583015442,
            0.990872859954834,
            0.9941458702087402,
            0.9889538288116455,
            0.9928946495056152,
            0.9948227405548096,
            0.9851511716842651,
            0.9942064881324768,
            0.9757289886474609,
            0.9936116933822632
        ]
    },
    "3587": {
        "similarity": 0.9973330497741699,
        "body": "import sys\n\n    n = int(input())\n    taboo_strings = []\n    for _ in range(n):\n        taboo_strings.append(input())\n\n    max_length = 0\n    max_string = \"\"\n\n    for length in range(1, len(taboo_strings[0]) + 2):\n        strings = {}\n        for i in range(len(taboo_strings)):\n            string = taboo_strings[i]\n            for j in range(len(string) - length + 1):\n                substr = string[j:j+length]\n                if substr not in strings:\n                    strings[substr] = 1\n                else:\n                    del strings[substr]\n\n        longest_substring_length = max(length, max(strings.keys(), default='') or '0')\n        if longest_substring_length > max_length:\n            max_length = longest_substring_length\n            max_string = ''.join([bit * length for bit in set(longest_substring)])\n\n    return max_string if max_length != len(max_string) else -1\n\nprint(longest_clue())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953721761703491,
            0.9951136708259583,
            0.9969090223312378,
            0.9955186247825623,
            0.9931640625,
            0.9973330497741699,
            0.9968133568763733,
            0.9967454671859741,
            0.9957602620124817,
            0.9958459734916687,
            0.9947672486305237,
            0.9950506091117859,
            0.9963820576667786,
            0.9964561462402344,
            0.9965835213661194,
            0.9964181780815125,
            0.9968308210372925,
            0.9966819286346436,
            0.9953634142875671,
            0.995462954044342
        ]
    },
    "3530": {
        "similarity": 0.996887743473053,
        "body": "    n = int(input())\n    coasters = []\n    for _ in range(n):\n        a, b, t = map(int, input().split())\n        fun = lambda k: a - (k-1)**2 * b if t > 0 else float('-inf')\n        coaster = {'fun': fun, 't': t}\n        coasters.append(coaster)\n\n    q = int(input())\n    for _ in range(q):\n        t = int(input())\n        max_fun = 0\n        for i in range(n):\n            k = min(t // coasters[i]['t'], 1000000)\n            fun = coasters[i]['fun'](k)\n            if fun > 0:\n                max_fun += fun\n\n        print(max_fun)\n\ncalculate_max_fun()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958552122116089,
            0.9960761070251465,
            0.9955002665519714,
            0.9920690655708313,
            0.9960748553276062,
            0.9963939189910889,
            0.9961726665496826,
            0.9954000115394592,
            0.996887743473053,
            0.9942458271980286,
            0.9946142435073853,
            0.9962128400802612,
            0.9961469769477844,
            0.9912557005882263,
            0.9957963824272156,
            0.9949314594268799,
            0.9954429268836975,
            0.9952216148376465,
            0.9949525594711304,
            0.9958877563476562
        ]
    },
    "3900": {
        "similarity": 0.9959061145782471,
        "body": "import sys\n\n    agrees = [0] * n\n    xys = []\n    for i in range(1, n+1):\n        x, y = map(int, input().split())\n        xys.append((x, y))\n        agrees[x-1] += 1\n        agrees[y-1] += 1\n\n    total_agrees = sum(agrees)\n\n    if p > total_agrees:\n        return 0\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            x, y = xys[i]\n            if (x == j or y == j) and agrees[j] >= p:\n                pairs.add((min(x, y), max(x, y)))\n            elif (x == i or y == i) and agrees[i] >= p:\n                pairs.add((min(i, j), max(i, j)))\n\n    return len(pairs)\n\nn, p = map(int, input().split())\nprint(solve(n, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9914729595184326,
            0.9954167604446411,
            0.9944478869438171,
            0.9950460195541382,
            0.9952035546302795,
            0.9949886798858643,
            0.9952244162559509,
            0.9959061145782471,
            0.9954069256782532,
            0.9949521422386169,
            0.9929696917533875,
            0.9941227436065674,
            0.9952226281166077,
            0.9947330355644226,
            0.9956408143043518,
            0.9941707253456116,
            0.9925221800804138,
            0.9922375082969666,
            0.992223858833313,
            0.9946805238723755
        ]
    },
    "3996": {
        "similarity": 0.9959791898727417,
        "body": "import sys\nfrom math import gcd\n\nMOD = 10**9 + 7\n\n    k = int(input())\n    a = list(map(int, input().split()))\n\n    prod = 1\n    for num in a:\n        prod *= num\n\n    res = 0\n    denom = 1\n    prime_factors = {}\n    for i in range(2, int(prod ** (1 / 3)) + 1):\n        while prod % i == 0:\n            if i not in prime_factors:\n                prime_factors[i] = 1\n            else:\n                prime_factors[i] += 1\n            prod //= i\n\n    prod += 1\n    for p, e in prime_factors.items():\n        temp_res = pow(p, e - 1, MOD)\n        res = (res * temp_res) % MOD\n        denom = (denom * (p - 1)) % MOD\n\n    print(f\"{res} / {denom}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.988667368888855,
            0.991604745388031,
            0.9943379759788513,
            0.9933078289031982,
            0.9923120141029358,
            0.9915679097175598,
            0.9953719973564148,
            0.9943791627883911,
            0.9941872358322144,
            0.9953932762145996,
            0.9908102750778198,
            0.9938112497329712,
            0.9959791898727417,
            0.9939484000205994,
            0.9954427480697632,
            0.9950796365737915,
            0.9930028319358826,
            0.9919060468673706,
            0.9952642321586609,
            0.9932323098182678
        ]
    },
    "3276": {
        "similarity": 0.9968053102493286,
        "body": "import sys\n\n    colors = ['R', 'G', 'B']\n    for i in range(N - 2):\n        for j in range(M - 2):\n            block = [board[i + k][j:j + 3] for k in range(3)]\n            if ''.join(block).count('W') == 9:\n                continue\n            flag = True\n            for color in colors:\n                sub_block = [''.join(row[j + i] for row in block) for i in range(3)]\n                if ''.join(sub_block).count(color) == 9 and all(\n                    cell == color or cell == 'W' for row in block for cell in row\n                ):\n                    flag = False\n                    break\n            if flag:\n                return \"NO\"\n    return \"YES\"\n\nN, M = map(int, input().split())\nboard = [list(input()) for _ in range(N)]\nprint(can_reproduce(N, M, board))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966717958450317,
            0.9962253570556641,
            0.9942315816879272,
            0.9956566691398621,
            0.9917574524879456,
            0.9955095052719116,
            0.9951952695846558,
            0.9962537884712219,
            0.9956035614013672,
            0.9960664510726929,
            0.9965516924858093,
            0.9955111145973206,
            0.9950034618377686,
            0.9968053102493286,
            0.9959794878959656,
            0.9946871399879456,
            0.9959527850151062,
            0.9964398741722107,
            0.9964156150817871,
            0.9955946207046509
        ]
    },
    "3834": {
        "similarity": 0.9975696206092834,
        "body": "import sys\n\n        if i < 0 or i >= n or j < 0 or j >= m or table[i][j] != value:\n            return False\n        table[i][j] = -1\n        visited.add((i, j))\n        for x in range(max(0, i-1), min(n, i+2)):\n            for y in range(max(0, j-1), min(m, j+2)):\n                if (x, y) not in visited:\n                    dfs(x, y, value)\n        return True\n\n    rows = [[-1] * m for _ in range(n)]\n    columns = [[-1] * n for _ in range(m)]\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] != -1:\n                visited = set()\n                if dfs(i, j, table[i][j]):\n                    count += 1\n\n    rows_sum = [sum(row) for row in rows]\n    columns_sum = [sum(col) for col in columns]\n\n    for i in range(n):\n        for j in range(m):\n            if (rows[i] + columns[j]) % 2 == table[i][j] and -rows_sum[i] <= k and -columns_sum[j] <= k:\n                return 0\n\n    return -1 if count == n * m else min(-k, -max(rows_sum) // 2 + max(columns_sum) // 2)\n\nn, m, k = map(int, input().split())\ntable = []\nfor _ in range(n):\n    table.append(list(map(int, input().split())))\n\nprint(min_cells_to_change(n, m, k, table))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967930316925049,
            0.9969882965087891,
            0.9962098002433777,
            0.9970639944076538,
            0.9953159689903259,
            0.9970654845237732,
            0.9963294863700867,
            0.9967153668403625,
            0.9969173073768616,
            0.9973791241645813,
            0.9973521828651428,
            0.9964820742607117,
            0.9966133832931519,
            0.9964302778244019,
            0.9975696206092834,
            0.9952779412269592,
            0.9968147277832031,
            0.9956892132759094,
            0.9970349669456482,
            0.9971739053726196
        ]
    },
    "3012": {
        "similarity": 0.9963660836219788,
        "body": "    mod = 1000000007\n    dp = [[[0 for _ in range(2)] for _ in range(max(a21, a22))] for _ in range(3)]\n    m = max(a21 + a22, a11 + a12)\n    \n    dp[0][a21][0] = a11 * 1 % mod\n    dp[0][a22][1] = a12 * 1 % mod\n    \n    for i in range(m):\n        for j in range(2):\n            for k in range(max(a21, a22)):\n                if dp[0][k][j]:\n                    for l in range(k + 1, max(a21, a22) + 1):\n                        if k != l:\n                            if (j == 0 and i < 3) or (i >= 2 and j == 0 and i - 3 > 0):\n                                dp[1][l][0] = (dp[1][l][0] + dp[0][k][j]) % mod\n                            else:\n                                dp[2][l][1] = (dp[2][l][1] + dp[0][k][j]) % mod\n\n    for i in range(3):\n        for j in range(max(a21, a22)):\n            if dp[i][j][0]:\n                dp[i][j][0] %= mod\n            if dp[i][j][1]:\n                dp[i][j][1] %= mod\n    \n    ans = 0\n    for i in range(3):\n        for j in range(max(a21, a22)):\n            for k in range(i + 1):\n                ans += dp[k][j][i ^ k]\n            ans %= mod\n\n    print(ans)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931620359420776,
            0.9963660836219788,
            0.995876133441925,
            0.9949867129325867,
            0.9957240223884583,
            0.9950973391532898,
            0.9954378008842468,
            0.9954944252967834,
            0.9959954619407654,
            0.9944949746131897,
            0.9962780475616455,
            0.9937534332275391,
            0.9947464466094971,
            0.9905564188957214,
            0.99392169713974,
            0.9939495921134949,
            0.996346652507782,
            0.9950587749481201,
            0.995672345161438,
            0.9959034323692322
        ]
    },
    "3745": {
        "similarity": 0.9956390261650085,
        "body": "import sys\n\n    char_map = {'a': 0, 'b': 1, 'c': 2}\n    colors = [''] * n\n    for i in range(1, n + 1):\n        if colors[i - 1] == '':\n            for c in 'abc':\n                valid = True\n                for u, v in edges:\n                    if (colors[u - 1] == '' and char_map[c] not in [char_map[s] for s in 'abc' if s != c]) or \\\n                       (u != i and colors[u - 1] == c) or \\\n                       (v != i and colors[v - 1] == c):\n                        valid = False\n                        break\n                if valid:\n                    colors[i - 1] = c\n    for i in range(1, n + 1):\n        if colors[i - 1] == '':\n            return 'No'\n    return 'Yes\\n' + ''.join(colors)\n\nn, m = map(int, input().split())\nedges = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    edges.append((u, v))\nprint(graph_to_string(n, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936882853507996,
            0.9942755699157715,
            0.9917696118354797,
            0.9948816895484924,
            0.9950649738311768,
            0.9941878318786621,
            0.9944027662277222,
            0.995036780834198,
            0.9955030083656311,
            0.9936975240707397,
            0.9947022199630737,
            0.9930327534675598,
            0.9926148653030396,
            0.9948306679725647,
            0.9946903586387634,
            0.9815141558647156,
            0.9944909811019897,
            0.9956390261650085,
            0.9917994141578674,
            0.9950181841850281
        ]
    },
    "3028": {
        "similarity": 0.9974987506866455,
        "body": "import sys\n\n    board = [list(map(int, input().split())) for _ in range(n)]\n    moves = []\n    for i in range(p * n * m + 1):\n        count = sum(1 for row in board for x in row if x == p)\n        if count == n * m:\n            print(i)\n            output = [x for row in board for x in row]\n            sys.stdout.write(' '.join(map(str, output)) + '\\n')\n            return\n        target_count = 0\n        max_target = -1\n        for r in range(n):\n            for c in range(m):\n                if board[r][c] < p:\n                    target_count += 1\n                    max_target = max(max_target, board[r][c])\n        row, col = (r + c) % n, (p - r) % m\n        while board[row][col] == p and count != n * m:\n            moves.append((row, col))\n            for i in range(n):\n                if board[i][col] < p:\n                    target_count -= 1\n                    max_target = min(max_target, board[i][col])\n            for j in range(m):\n                if board[row][j] < p:\n                    target_count -= 1\n                    max_target = min(max_target, board[row][j])\n            for i in range(n):\n                board[i][col] = (board[i][col] + 1) % p\n            for j in range(m):\n                board[row][j] = (board[row][j] + 1) % p\n            count += target_count\n        if max_target == -1 or count < n * m:\n            print(-1)\n            return\n        moves.append((row, col))\n        for i in range(n):\n            board[i][col] = (board[i][col] + 1) % p\n        for j in range(m):\n            board[row][j] = (board[row][j] + 1) % p\n\n    output = [x for row in board for x in row]\n    sys.stdout.write(' '.join(map(str, output)) + '\\n')\n\nprimonimo(*map(int, input().split()))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99688321352005,
            0.9964471459388733,
            0.9972198009490967,
            0.9969425201416016,
            0.9969922304153442,
            0.9956516623497009,
            0.9955661296844482,
            0.9964982867240906,
            0.9968562722206116,
            0.9927505850791931,
            0.996451735496521,
            0.9964653849601746,
            0.9967993497848511,
            0.9969433546066284,
            0.9957301616668701,
            0.9961191415786743,
            0.9969956278800964,
            0.9974987506866455,
            0.9969436526298523,
            0.9967466592788696
        ]
    },
    "3196": {
        "similarity": 0.9977997541427612,
        "body": "import sys\n\n    n, m = map(int, input().split())\n    graph = {}\n    for _ in range(m):\n        a, b = map(int, input().split())\n        if a not in graph:\n            graph[a] = []\n        if b not in graph:\n            graph[b] = []\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    dp = [0] * (n + 1)\n    stack = [(1, 0)]\n\n    while len(stack) > 0:\n        u, path = stack.pop()\n        if not visited[u]:\n            visited[u] = True\n            for v in graph.get(u, []):\n                if path < len(graph[v]) - 1 or (path == len(graph[v]) - 1 and dp[v] != n):\n                    dp[u] += 1\n                    stack.append((v, path + 1))\n\n    if dp[2] >= pow(10, 9):\n        print('inf')\n    else:\n        print(dp[2] % (pow(10, 9) + 7))\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997320294380188,
            0.9967888593673706,
            0.9971399903297424,
            0.9972715973854065,
            0.9977997541427612,
            0.9973260760307312,
            0.9964308738708496,
            0.9968000650405884,
            0.996812641620636,
            0.9975387454032898,
            0.9976828694343567,
            0.9977614879608154,
            0.9968472719192505,
            0.9974158406257629,
            0.9977485537528992,
            0.9975345134735107,
            0.9975646138191223,
            0.9956229329109192,
            0.9956403970718384,
            0.9976013898849487
        ]
    },
    "3405": {
        "similarity": 0.997238039970398,
        "body": "import math\n\n    result = []\n    for i in range(10**7):\n        if len(str(i)) <= 8:\n            first_digit = int(str(i)[0])\n            multiplied = str(int(i) * x)\n            if multiplied.startswith('0') and int(multiplied[1:]) == first_digit * int(multiplied[:-1]):\n                result.append(i)\n    return sorted(result)\n\nx = float(input())\nif trick_numbers(x):\n    for num in trick_numbers(x):\n        print(num)\nelse:\n    print(\"No solution\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939111471176147,
            0.9948264956474304,
            0.997238039970398,
            0.9968904256820679,
            0.9955254793167114,
            0.9963595867156982,
            0.9968245625495911,
            0.9960901141166687,
            0.9957907795906067,
            0.9962942004203796,
            0.9968466758728027,
            0.995841383934021,
            0.9965465068817139,
            0.9952179789543152,
            0.9958953857421875,
            0.9957385659217834,
            0.9946323037147522,
            0.9969262480735779,
            0.9934052228927612,
            0.9955670237541199
        ]
    },
    "3126": {
        "similarity": 0.9972808361053467,
        "body": "    jumps = [0] * n\n    i = 1\n    for j in range(n):\n        while pos[j] >= tower:\n            tower += i\n            jumps[j] += i - 1\n            i += 1\n    return sum(jumps)\n\n    n, pos = map(int, input().split())\n    frogs_pos = list(map(int, input().split()))\n    t = int(input())\n\n    for _ in range(t):\n        line = input().split()\n        if line[0] == '+':\n            new_pos = int(line[1])\n            min_jumps = calculate_jumps(n + 1, frogs_pos + [new_pos], 0)\n            print(min_jumps - calculate_jumps(n, frogs_pos, 0))\n        elif line[0] == '-':\n            old_pos = int(line[1])\n            min_jumps = calculate_jumps(n - 1, frogs_pos[:old_pos] + frogs_pos[old_pos + 1:], 0)\n            print(min_jumps - calculate_jumps(n, frogs_pos, 0))\n        else:\n            tower = int(line[1])\n            min_jumps = calculate_jumps(n, frogs_pos, tower)\n            print(min_jumps)\n\nmain()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971757531166077,
            0.9967454671859741,
            0.9966119527816772,
            0.9968775510787964,
            0.9953353404998779,
            0.9972808361053467,
            0.994907557964325,
            0.9967032074928284,
            0.9967225790023804,
            0.9963730573654175,
            0.9964221119880676,
            0.9961694478988647,
            0.9969686269760132,
            0.9966615438461304,
            0.995603084564209,
            0.9951481223106384,
            0.9971851706504822,
            0.9950190186500549,
            0.9970101118087769,
            0.996701180934906
        ]
    },
    "3279": {
        "similarity": 0.9969050884246826,
        "body": "import sys\n\n    # Initialize solution grid with all zeros\n    vertical = [[0] * (n + 1) for _ in range(n)]\n    horizontal = [[0] * n for _ in range(n)]\n\n    # Mark borders based on group sizes in each row and column\n    for i in range(n):\n        count = 0\n        for j in range(1, rows[i].count(' ') + 2):\n            if j <= len(rows[i]):\n                size = int(rows[i][j - 1])\n                if count < size:\n                    count += 1\n                    vertical[i][count] = 1\n            else:\n                break\n\n        count = 0\n        for j in range(1, cols[i].count(' ') + 2):\n            if j <= len(cols[i]):\n                size = int(cols[i][j - 1])\n                if count < size:\n                    count += 1\n                    horizontal[count - 1][i] = 1\n            else:\n                break\n\n    # Separate groups of consecutive bars in each row and column\n    for i in range(n):\n        prev_bar = None\n        for j in range(1, n + 1):\n            if vertical[i][j]:\n                prev_bar = (prev_bar[0] + 1, j)\n            elif prev_bar is not None:\n                for k in range(prev_bar[0], j):\n                    vertical[i][k] = 1\n                prev_bar = None\n\n        prev_bar = None\n        for j in range(n):\n            if horizontal[j][i]:\n                prev_bar = (prev_bar[0] + 1, i)\n            elif prev_bar is not None:\n                for k in range(prev_bar[0], i):\n                    horizontal[k][i] = 1\n                prev_bar = None\n\n    # Ensure no two bars touch by removing overlapping bars\n    for i in range(n):\n        count = 0\n        prev_bar = False\n        for j in range(1, n + 1):\n            if vertical[i][j]:\n                if prev_bar:\n                    count += 1\n                else:\n                    prev_bar = True\n            elif prev_bar:\n                prev_bar = False\n\n    for i in range(n):\n        count = 0\n        prev_bar = False\n        for j in range(n):\n            if horizontal[j][i]:\n                if prev_bar:\n                    count += 1\n                else:\n                    prev_bar = True\n            elif prev_bar:\n                prev_bar = False\n\n    # Print solution grid\n    for row in vertical:\n        print(''.join(map(str, row)))\n    for row in horizontal:\n        print(''.join(map(str, row)))\n\nn = int(input())\nrows = [input().split() for _ in range(n)]\ncols = [[cell for cell in input().split()] for _ in range(n)]\nbar_code(n, rows, cols)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941004514694214,
            0.9962935447692871,
            0.9965202212333679,
            0.9963675141334534,
            0.9963578581809998,
            0.996242344379425,
            0.9958395957946777,
            0.9962682127952576,
            0.9964146018028259,
            0.996069073677063,
            0.9960875511169434,
            0.9962323904037476,
            0.9934374094009399,
            0.9956056475639343,
            0.9954442381858826,
            0.9938336610794067,
            0.9951001405715942,
            0.9958717823028564,
            0.9958500266075134,
            0.9969050884246826
        ]
    },
    "3599": {
        "similarity": 0.9966458678245544,
        "body": "import sys\n\n    time = 0\n    stage_time = [0] * n\n    for i in range(n):\n        for j in range(breaks[i]):\n            if len([x for x in stage_time if x == -1]) < 3:\n                stage_time[i] = time\n            else:\n                break\n            time += 1\n            while any(stage_time[k] == time for k in range(n)):\n                time += 1\n        if i > 0 and stage_time[i-1] != -1:\n            stage_time[i] = max(stage_time[i], stage_time[i-1] + breaks[i-1])\n    for i in range(n):\n        while stage_time[i] < breaks[i]:\n            stage_time[i] += 1\n    return ' '.join(map(str, stage_time))\n\nt, n = map(int, input().split())\nbreaks = list(map(int, input().split()))\nprint(schedule_breaks(t, n, breaks))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9919096231460571,
            0.9935640096664429,
            0.9958935976028442,
            0.9928528666496277,
            0.9966458678245544,
            0.9954715371131897,
            0.9948068261146545,
            0.9964630007743835,
            0.9961801171302795,
            0.9957572817802429,
            0.9952939748764038,
            0.9947100281715393,
            0.9901134967803955,
            0.992456316947937,
            0.9954617023468018,
            0.9917960166931152,
            0.9941621422767639,
            0.9946566224098206,
            0.9956823587417603,
            0.9961051940917969
        ]
    },
    "3687": {
        "similarity": 0.9975457787513733,
        "body": "import sys\n\n    n, q, s = map(int, input().split())\n    queue_sizes = [0] * q\n    sensors_to_queues = [None] * s\n    for i in range(s):\n        sensor_queue = int(input()) - 1\n        sensors_to_queues[i] = sensor_queue\n        queue_sizes[sensor_queue] += 1\n\n    data_sizes = [[] for _ in range(q)]\n    for line in range(n):\n        window_size, *data_transferred = map(int, input().split())\n        for i, data in enumerate(data_transferred[:-1]):\n            sensors_to_queues[i].append((data, line))\n        queue_sizes = [size + sum(d[0] for d in data_sizes[q]) for q, size in enumerate(queue_sizes)]\n\n    for i in range(s):\n        sensor_queue = sensors_to_queues[i]\n        if any(data[0] > queue_sizes[sensor_queue[k][1]] for k, (data, _) in enumerate(sensor_queue)):\n            return False\n\n    return True\n\nprint(\"possible\" if can_transfer_data() else \"impossible\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961307048797607,
            0.9963815808296204,
            0.9972056150436401,
            0.9955412149429321,
            0.9962454438209534,
            0.9973281025886536,
            0.9941462278366089,
            0.9974742531776428,
            0.9968936443328857,
            0.996169924736023,
            0.9969385862350464,
            0.9952706098556519,
            0.9968842267990112,
            0.9975457787513733,
            0.9957188963890076,
            0.9957067370414734,
            0.996551513671875,
            0.9970226287841797,
            0.9961928129196167,
            0.9967836141586304
        ]
    },
    "3864": {
        "similarity": 0.9947069883346558,
        "body": "import sys\nMOD = 998244353\n\n    if n <= 3:\n        return [0] * n\n\n    dp = [[0 for _ in range(n + 1)] for _ in range(2)]\n    dp[0][1] = 1\n    dp[0][2] = 2\n    dp[0][3] = 4\n\n    for i in range(4, n + 1):\n        for j in range(i - 2, i + 1):\n            if j >= 0:\n                dp[i % 2][j + 1] += (dp[(i - 1) % 2][j] * 2)\n                dp[i % 2][j + 1] %= MOD\n\n        for j in range(i - 3, i):\n            if j >= 0:\n                dp[i % 2][j + 1] += (dp[(i - 1) % 2][j] * 4)\n                dp[i % 2][j + 1] %= MOD\n\n    return [sum(x) // (1 << i) for i, x in enumerate(dp[n % 2])]\n\nn = int(input())\nprint(*calculate_stones(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.993220865726471,
            0.9916383624076843,
            0.9896970987319946,
            0.994083821773529,
            0.9866762757301331,
            0.9922385811805725,
            0.9943950176239014,
            0.990597665309906,
            0.9947069883346558,
            0.9723934531211853,
            0.9904245138168335,
            0.9937770366668701,
            0.9931106567382812,
            0.9943608641624451,
            0.9922751188278198,
            0.993710994720459,
            0.9943854808807373,
            0.9918684959411621,
            0.9927601218223572,
            0.992110013961792
        ]
    },
    "3504": {
        "similarity": 0.9966493844985962,
        "body": "import sys\n\n    n, s = map(int, input().split())\n    points = []\n    sensors = []\n\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    for _ in range(s):\n        x1, x2, y = map(int, input().split())\n        sensors.append((min(x1, x2), max(x1, x2), y))\n\n    sensors.sort()\n    points.sort()\n\n    hits = [[] for _ in range(len(points))]\n\n    for i, point in enumerate(points):\n        left_sensor = None\n        right_sensor = None\n\n        for j, sensor in enumerate(sensors):\n            if sensor[0] <= point[0] <= sensor[1]:\n                if not left_sensor or sensor[2] < sensors[j-1][2]:\n                    left_sensor = (j, sensor[2])\n                right_sensor = (j, sensor[2])\n\n        for j in range(left_sensor[0], right_sensor[0]+1):\n            hits[left_sensor[0]].append((right_sensor[1]-left_sensor[0], sensors[j][2]))\n\n    for i, hit in enumerate(hits):\n        hit.sort(reverse=True)\n        if len(hit) > 0:\n            print(hit[0][1])\n        else:\n            print(0)\n\nantimatter_rain()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964360594749451,
            0.9961251020431519,
            0.9948571920394897,
            0.9966493844985962,
            0.9961001873016357,
            0.9966216683387756,
            0.9948086142539978,
            0.9959592223167419,
            0.9961974620819092,
            0.9919674396514893,
            0.9955348968505859,
            0.9954661130905151,
            0.9943681359291077,
            0.9961538910865784,
            0.9963021874427795,
            0.9941580891609192,
            0.995970606803894,
            0.9944345355033875,
            0.9951978921890259,
            0.9927827715873718
        ]
    },
    "3451": {
        "similarity": 0.9967982769012451,
        "body": "import sys\n\n    op = 0\n    cur = 0\n    pre_op = 0\n    for i in range(n):\n        if s[i] == '(':\n            cur -= c[i]\n        else:\n            cur += c[i]\n        if cur < -op or (cur > 0 and op <= k):\n            return '?'\n        if s[i] != s[n-i-1]:\n            pre_op = min(op, k-cur)\n            if cur < 0:\n                cur -= c[i]\n            else:\n                cur += c[i]\n            op += 1\n    if abs(cur) <= pre_op:\n        return '?'\n    return -cur\n\nn, k = map(int, input().split())\ns = input()\nc = [int(input()) for _ in range(n)]\nprint(min_effort(n, k, s, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942036867141724,
            0.9963780641555786,
            0.9963932037353516,
            0.9962178468704224,
            0.995979905128479,
            0.9956466555595398,
            0.9946566224098206,
            0.9966368675231934,
            0.9949377179145813,
            0.9959802031517029,
            0.9962852001190186,
            0.9963430166244507,
            0.9967982769012451,
            0.9961650371551514,
            0.9903950095176697,
            0.9956126809120178,
            0.9951704740524292,
            0.9960771799087524,
            0.9960762858390808,
            0.9954801797866821
        ]
    },
    "3156": {
        "similarity": 0.9981715679168701,
        "body": "    n = int(input())\n    k = int(input())\n    store_items = [set() for _ in range(n)]\n    for i in range(k):\n        store, item = input().split()\n        store = int(store)\n        store_items[store].add(item)\n\n    m = int(input())\n    items_bought = []\n    for i in range(m):\n        items_bought.append(input())\n\n    stores_visited = [None] * n\n    current_store = 0\n\n    for item in items_bought:\n        found = False\n        for store in store_items[current_store]:\n            if store == item:\n                stores_visited[current_store] = True\n                found = True\n                break\n        if not found:\n            return \"impossible\"\n\n        for store, items in enumerate(store_items):\n            if (item not in items) and (stores_visited[store] is None):\n                current_store = store\n\n    visited_stores = sum(1 for s in stores_visited if s is True)\n    return \"unique\" if visited_stores == 1 else \"ambiguous\"\n\nprint(solve())",
        "result": "failed: testcase 0",
        "similarities": [
            0.997747540473938,
            0.996793270111084,
            0.9978649020195007,
            0.9965015053749084,
            0.9977497458457947,
            0.9969412088394165,
            0.9976553916931152,
            0.9972110390663147,
            0.9971517324447632,
            0.9977797269821167,
            0.9981482625007629,
            0.9978538155555725,
            0.997891366481781,
            0.9962953329086304,
            0.9965102672576904,
            0.9974431395530701,
            0.997580885887146,
            0.9965736865997314,
            0.9974459409713745,
            0.9981715679168701
        ]
    },
    "3697": {
        "similarity": 0.9970678091049194,
        "body": "import sys\n\n    n, k, m, a = map(int, input().split())\n    votes = list(map(int, input().split()))\n\n    candidates = [[] for _ in range(n + 1)]\n    for i, vote in enumerate(votes):\n        candidates[vote].append((vote, i))\n\n    seats_taken = set()\n    outcomes = [0] * n\n    for candidate in range(1, n + 1):\n        num_votes = len(candidates[candidate])\n        if num_votes > k:\n            outcomes[candidate - 1] = 1\n            continue\n\n        candidates.sort(key=lambda x: (-x[0], x[1]))\n        current_num_seats = 0\n        for c, time in candidates:\n            if c not in seats_taken and current_num_seats < k:\n                current_num_seats += 1\n                outcomes[c - 1] = 2\n                seats_taken.add(c)\n\n    return ' '.join(map(str, outcomes))\n\nprint(determine_outcomes())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969871044158936,
            0.996931791305542,
            0.9965388774871826,
            0.9938110709190369,
            0.9951990842819214,
            0.9968769550323486,
            0.9950979351997375,
            0.9964564442634583,
            0.9970678091049194,
            0.9961012005805969,
            0.9965642690658569,
            0.9960789084434509,
            0.9948107004165649,
            0.9953683614730835,
            0.9965589642524719,
            0.9965991973876953,
            0.9964360594749451,
            0.9964810609817505,
            0.9961574077606201,
            0.995707094669342
        ]
    },
    "3647": {
        "similarity": 0.9973753094673157,
        "body": "import sys\nfrom collections import deque, namedtuple\n\nCell = namedtuple('Cell', ['r', 'c'])\n\n    for r in range(len(maze)):\n        for c in range(len(maze[0])):\n            if maze[r][c] == '.' and r == 2 and c == 4:\n                return Cell(r, c)\n\n    nr, nc = r + dr, c + dc\n    if (nr < 0 or nr >= len(maze) or \n        nc < 0 or nc >= len(maze[0]) or \n        maze[nr][nc] == '#'):\n        return False\n    return True\n\n    queue = deque([(cell, 0)])\n    visited = set([cell])\n    \n    while queue:\n        current_cell, moves = queue.popleft()\n        \n        if maze[current_cell.r][current_cell.c] == 'M':\n            return moves\n        \n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            if can_move(current_cell.r, current_cell.c, dr, dc):\n                new_cell = Cell(current_cell.r + dr, current_cell.c + dc)\n                \n                if new_cell not in visited:\n                    queue.append((new_cell, moves + 1))\n                    visited.add(new_cell)\n\n    return -1\n\n    R, C = map(int, input().split())\n    \n    goal = find_goal(maze)\n    \n    for r in range(R):\n        row = []\n        \n        for c in range(C):\n            distance = get_distance(Cell(r, c))\n            if distance != -1:\n                row.append(distance)\n            else:\n                row.append(-1)\n                \n        print(' '.join(map(str, row)))\n\nmaze = [input().strip() for _ in range(int(input().split()[0]))]\n\nsolve(maze)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968026876449585,
            0.9965319633483887,
            0.9966633319854736,
            0.9973015189170837,
            0.9972413778305054,
            0.9972866773605347,
            0.9973753094673157,
            0.9972255229949951,
            0.9968069195747375,
            0.9973515272140503,
            0.9973700642585754,
            0.9973344206809998,
            0.9964632987976074,
            0.9961211681365967,
            0.9972570538520813,
            0.9963678121566772,
            0.9967902302742004,
            0.9961254596710205,
            0.9949129223823547,
            0.9963854551315308
        ]
    },
    "3699": {
        "similarity": 0.9975540041923523,
        "body": "import math\nimport sys\n\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    ax, ay, bx, by, tx, ty = map(int, input().split())\n    n = int(input())\n\n    bottles = []\n    for _ in range(n):\n        xi, yi = map(int, input().split())\n        bottles.append((xi, yi))\n\n    total_distance = 0\n\n    adil_path = [(ax, ay)]\n    bera_path = [(bx, by)]\n\n    for bottle in sorted(bottles, key=lambda x: (x[0] - tx) ** 2 + (x[1] - ty) ** 2):\n        distance_to_adil = calculate_distance(adil_path[-1][0], adil_path[-1][1], bottle[0], bottle[1])\n        distance_to_bera = calculate_distance(bera_path[-1][0], bera_path[-1][1], bottle[0], bottle[1])\n\n        if distance_to_adil <= distance_to_bera:\n            total_distance += 2 * distance_to_adil\n            adil_path.append(bottle)\n        else:\n            total_distance += 2 * distance_to_bera\n            bera_path.append(bottle)\n\n    distance_to_recycling_bin = calculate_distance(adil_path[-1][0], adil_path[-1][1], tx, ty) + \\\n                                calculate_distance(bera_path[-1][0], bera_path[-1][1], tx, ty)\n    total_distance += 2 * distance_to_recycling_bin\n\n    print(total_distance)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996839702129364,
            0.9965595602989197,
            0.9951959848403931,
            0.9968016743659973,
            0.9943791627883911,
            0.9965171813964844,
            0.9961676597595215,
            0.9958559274673462,
            0.9958783984184265,
            0.9975540041923523,
            0.9962690472602844,
            0.9964219331741333,
            0.9955503344535828,
            0.9958314299583435,
            0.9971816539764404,
            0.9960440397262573,
            0.9962987303733826,
            0.996909499168396,
            0.9971715807914734,
            0.996669590473175
        ]
    },
    "3145": {
        "similarity": 0.9972553253173828,
        "body": "import sys\n\n    x, a, b = map(int, input().split())\n    allowed_digits = set(input())\n\n        return ''.join(sorted(str(n))) <= ''.join(allowed_digits)\n\n    count = 0\n    for i in range(a, b+1):\n        if i % x == 0 and is_allowed(i):\n            count += 1\n\n    print(count)\n\ncount_multiples()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967091083526611,
            0.9964954853057861,
            0.9964662790298462,
            0.9972158074378967,
            0.9972246885299683,
            0.9967710375785828,
            0.99712735414505,
            0.9964605569839478,
            0.997220516204834,
            0.9967765808105469,
            0.9972553253173828,
            0.9954507946968079,
            0.9971998333930969,
            0.9964672923088074,
            0.9969297647476196,
            0.9969409108161926,
            0.9967327117919922,
            0.9966467022895813,
            0.9937599897384644,
            0.9969461560249329
        ]
    },
    "3795": {
        "similarity": 0.9940587282180786,
        "body": "    euro = [100200, 100, 50, 20, 10, 5]\n    dollar = [100, 50, 20, 10, 5, 2, 1]\n    \n    n_dollar = n // d\n    for i in range(len(dollar)):\n        while n_dollar >= dollar[i]:\n            n -= min(n_dollar * dollar[i], n) * d\n            n_dollar = n // d\n            \n    for i in range(6):\n        while e <= n:\n            n -= euro[i]\n            \n    return n\n\nn = int(input())\nd = int(input())\ne = int(input())\n\nprint(min_rubles(n, e, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.992387592792511,
            0.9817824363708496,
            0.9861077070236206,
            0.9896853566169739,
            0.9931036233901978,
            0.9928498864173889,
            0.9916185140609741,
            0.9888148903846741,
            0.9899926781654358,
            0.9907374978065491,
            0.9935901165008545,
            0.991832435131073,
            0.9895217418670654,
            0.9937444925308228,
            0.9934694170951843,
            0.9925209879875183,
            0.9909565448760986,
            0.9913068413734436,
            0.9882982969284058,
            0.9940587282180786
        ]
    },
    "3353": {
        "similarity": 0.9982811808586121,
        "body": "from collections import deque\nimport sys\n\n    P, R, L = map(int, input().split())\n    graph = [[] for _ in range(R + 2)]\n    visited = [False] * (R + 2)\n    time_needed = [[float('inf')] * (R + 2) for _ in range(P)]\n\n    for _ in range(L):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited[0] = True\n    q = deque([(0, 0)])\n    while q:\n        node, level = q.popleft()\n        time_needed[0][node] = level\n\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                q.append((neighbor, level + 1))\n\n    for p in range(1, P):\n        while True:\n            max_time = -1\n            max_node = None\n            for node in range(R + 2):\n                if time_needed[p][node] > max_time and not visited[node]:\n                    max_time = time_needed[p][node]\n                    max_node = node\n\n            if max_node is None:\n                break\n\n            visited[max_node] = True\n            q.append((max_node, max_time))\n\n            for neighbor in graph[max_node]:\n                if not visited[neighbor]:\n                    time_needed[p + 1][neighbor] = max(max_time, time_needed[p + 1][neighbor])\n\n    min_time = float('inf')\n    for node in range(R + 2):\n        if visited[node]:\n            min_time = min(min_time, time_needed[P - 1][node])\n\n    if min_time == float('inf'):\n        print(P)\n    else:\n        print(min_time)\n\nmin_cross_time()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982578754425049,
            0.9978417158126831,
            0.9977611899375916,
            0.9979053139686584,
            0.9972139596939087,
            0.9982811808586121,
            0.9971285462379456,
            0.9977660775184631,
            0.9982149004936218,
            0.9978296160697937,
            0.9967716932296753,
            0.9973257184028625,
            0.9975610375404358,
            0.9977518320083618,
            0.9980311393737793,
            0.9979876279830933,
            0.9980607628822327,
            0.9979023337364197,
            0.9980666637420654,
            0.9973070025444031
        ]
    },
    "3065": {
        "similarity": 0.9973156452178955,
        "body": "import sys\nimport math\n\n    if x == y:\n        return 1.0 / 2.0\n    return 1.0 - math.pow((y - 1) / (x - 1), 2)\n\nn = int(input())\nl = int(input())\nwalk = [int(i) for i in input().split()]\n\ngraph = []\nfor _ in range(n):\n    n_i = int(input())\n    neighbors = [int(i) for i in input().split()]\n    graph.append((n_i, neighbors))\n\nvisited = [False] * n\ncaptain_prob = [0.0] * n\n\nfor i in range(l):\n    visited[walk[i]] = True\n    captain_prob[walk[i]] = 1.0 / len(graph[walk[i]][1])\n\nfor start in range(n):\n    if not visited[start]:\n        for end in range(n):\n            if not visited[end]:\n                curr_prob = 1.0\n                count = 0\n                path = []\n                for node in walk:\n                    if node == start or node == end:\n                        count += 1\n                        path.append(node)\n                for i in range(len(path) - 1):\n                    x = graph[path[i]][0]\n                    y = graph[path[i + 1]][0]\n                    curr_prob *= prob(x, y)\n                captain_prob[end] += (count / l) * curr_prob\n\ncaptain_prob[end] -= 2.0 / l\nprint(math.floor(1000000 * max(captain_prob)) / 1000000)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972086548805237,
            0.9949644804000854,
            0.9971128106117249,
            0.9968628287315369,
            0.9966386556625366,
            0.995823323726654,
            0.996128499507904,
            0.9955865740776062,
            0.9955827593803406,
            0.9970147013664246,
            0.997241199016571,
            0.9939002990722656,
            0.9968070983886719,
            0.9967955350875854,
            0.997138261795044,
            0.9966151714324951,
            0.9973156452178955,
            0.9959144592285156,
            0.9963813424110413,
            0.9969903230667114
        ]
    },
    "3250": {
        "similarity": 0.9961336851119995,
        "body": "    for m in range(1, b + 1):\n        remainder = 0\n        sign = -1 if m % 2 == 0 else 1\n        for power in range(m * (b - 1), 0, -m):\n            remainder += sign * pow(b, power, d)\n            sign *= -1\n        if remainder % d != 0:\n            return False\n    return True\n\nb, d = map(int, input().split())\nif is_valid_divisibility_hack(b, d):\n    print('yes')\nelse:\n    print('no')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952128529548645,
            0.995566725730896,
            0.9957854747772217,
            0.9950836896896362,
            0.995580792427063,
            0.9940666556358337,
            0.9919670820236206,
            0.9919232130050659,
            0.9955160021781921,
            0.9961336851119995,
            0.9960331320762634,
            0.9917480945587158,
            0.9960265755653381,
            0.9904324412345886,
            0.995564341545105,
            0.9904451966285706,
            0.9947223663330078,
            0.9923529624938965,
            0.9954572319984436,
            0.9930554628372192
        ]
    },
    "3306": {
        "similarity": 0.9971602559089661,
        "body": "    n, m = map(int, input().split())\n    detectors = []\n    for _ in range(n):\n        pos, calls = map(int, input().split())\n        detectors.append((pos, calls))\n\n    phones = [0] * (m + 1)\n    for pos, calls in detectors:\n        phones[pos - 1] += calls\n        phones[m - pos] -= calls\n\n    total_calls = 0\n    for i in range(1, m):\n        phones[i] += phones[i - 1]\n        if i < m // 2 and (i <= pos or m - i >= pos) and phones[i]:\n            total_calls += phones[i]\n\n    return total_calls\n\nprint(min_phone_calls())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967689514160156,
            0.9964601397514343,
            0.9971602559089661,
            0.9964419007301331,
            0.9968270063400269,
            0.9947918653488159,
            0.9962846040725708,
            0.9939833283424377,
            0.9958127737045288,
            0.9967756867408752,
            0.9958638548851013,
            0.9950613975524902,
            0.9939708709716797,
            0.9953133463859558,
            0.9969411492347717,
            0.9966049194335938,
            0.9966699481010437,
            0.994240403175354,
            0.9967352151870728,
            0.9958727955818176
        ]
    },
    "3970": {
        "similarity": 0.9962961077690125,
        "body": "import sys\nfrom collections import defaultdict\n\n    n, k = map(int, input().split())\n    a = sorted(map(int, input().split()))\n\n    used = [False] * (2 * 10 ** 9 + 5)\n    count = 0\n    for i in range(n):\n        if not used[a[i]]:\n            used[a[i]] = True\n            count += 1\n            j = 0\n            while j < i and a[j] * k <= a[i]:\n                j += 1\n            while j < i and a[j] % (a[i] // k) == 0:\n                j += 1\n    print(count)\n\nlargest_k_multiple_free_subset()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944649934768677,
            0.993698239326477,
            0.993965744972229,
            0.9960305094718933,
            0.9924936890602112,
            0.9962961077690125,
            0.9938899874687195,
            0.9960834980010986,
            0.9948242902755737,
            0.9961095452308655,
            0.994755208492279,
            0.994563639163971,
            0.9954482913017273,
            0.9953017234802246,
            0.994648814201355,
            0.9947558045387268,
            0.9945554137229919,
            0.9960179924964905,
            0.9956148862838745,
            0.9954121112823486
        ]
    },
    "3655": {
        "similarity": 0.9977709054946899,
        "body": "import sys\n\n    width, height = map(int, sys.stdin.readline().split())\n    robot_image = [list(map(int, sys.stdin.readline().split())) for _ in range(height)]\n    floor_image = [list(map(int, sys.stdin.readline().split())) for _ in range(height)]\n\n    max_match_count = 0\n    candidate_locations = []\n\n    for x in range(width - len(robot_image[0]) + 1):\n        for y in range(height - len(robot_image) + 1):\n            match_count = 0\n\n            for i in range(len(robot_image)):\n                for j in range(len(robot_image[i])):\n                    if robot_image[i][j] == floor_image[y + i][x + j]:\n                        match_count += 1\n\n            if match_count > max_match_count:\n                max_match_count = match_count\n                candidate_locations.clear()\n                candidate_locations.append((x, y))\n            elif match_count == max_match_count:\n                candidate_locations.append((x, y))\n\n    for location in sorted(candidate_locations):\n        print(f\"{location[0]} {location[1]}\")\n\nfind_candidate_locations()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967706799507141,
            0.9968133568763733,
            0.9973791837692261,
            0.9976862668991089,
            0.9974462389945984,
            0.99755859375,
            0.993696391582489,
            0.9971793293952942,
            0.9963039755821228,
            0.9969538450241089,
            0.9974510073661804,
            0.9974303245544434,
            0.997495174407959,
            0.9973011016845703,
            0.9970825910568237,
            0.9977709054946899,
            0.9973333477973938,
            0.9976453185081482,
            0.996998131275177,
            0.996208906173706
        ]
    },
    "3589": {
        "similarity": 0.997045636177063,
        "body": "import sys\n\n    count = [0] * 10\n    for product_id in range(L, R + 1):\n        x = product_id\n        while True:\n            digits = []\n            while x != 0:\n                digits.append(x % 10)\n                x //= 10\n            if len(digits) == 1:\n                count[digits[0]] += 1\n                break\n            new_x = 1\n            for digit in digits:\n                new_x *= digit\n            x = new_x\n\n    return ' '.join(map(str, count))\n\nL, R = map(int, input().split())\nprint(digit_product_counter(L, R))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959427714347839,
            0.9953283071517944,
            0.9950641989707947,
            0.9963721036911011,
            0.9963362812995911,
            0.9965852499008179,
            0.9967853426933289,
            0.9968740344047546,
            0.995813250541687,
            0.9964123964309692,
            0.9966161847114563,
            0.9967688322067261,
            0.997045636177063,
            0.9901593923568726,
            0.9955392479896545,
            0.9953330159187317,
            0.9966112375259399,
            0.9967191815376282,
            0.9957835674285889,
            0.9968010783195496
        ]
    },
    "3257": {
        "similarity": 0.9962077140808105,
        "body": "import math\n\n    a, b, c = sorted(map(float, input().split()))\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    if 0 < area <= 100 and a <= b <= c:\n        return round(area, 8)\n    else:\n        return -1\n\nprint(calculate_carpet_area())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950522184371948,
            0.9930745959281921,
            0.9940241575241089,
            0.9942516684532166,
            0.9913516640663147,
            0.9934331774711609,
            0.9952360391616821,
            0.9948674440383911,
            0.995406985282898,
            0.9948087334632874,
            0.9958949685096741,
            0.9924709796905518,
            0.9942880272865295,
            0.9954453706741333,
            0.9930129051208496,
            0.9962077140808105,
            0.9895418882369995,
            0.9954977631568909,
            0.9935877919197083,
            0.9950021505355835
        ]
    },
    "3927": {
        "similarity": 0.9953234791755676,
        "body": "import sys\n\n    # Sort masses in ascending order\n    a.sort()\n    \n    max_k = 0\n    \n    for i in range(1, n + 1):\n        for j in range(i - 1, -1, -1):\n            if (i - j) * a[i] <= (n - i) * a[j]:\n                if j == 0:\n                    k = i\n                else:\n                    k = i + 1\n                max_k = max(max_k, k)\n    \n    return max_k\n\nn = int(input())\na = list(map(int, input().split()))\nprint(max_weights(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933000802993774,
            0.9927319884300232,
            0.9919383525848389,
            0.9901467561721802,
            0.9950999021530151,
            0.9926015138626099,
            0.9913225769996643,
            0.9931421875953674,
            0.9943068623542786,
            0.9924583435058594,
            0.9911422729492188,
            0.9943699240684509,
            0.9953234791755676,
            0.9932864308357239,
            0.9921258687973022,
            0.9940126538276672,
            0.9814919233322144,
            0.9950856566429138,
            0.9942257404327393,
            0.9915921092033386
        ]
    },
    "3319": {
        "similarity": 0.9973373413085938,
        "body": "    n, nx, ny, nz = [int(i) for i in input().split()]\n    planetoids = []\n    for _ in range(n):\n        mass, x, y, z, vx, vy, vz = [int(i) for i in input().split()]\n        planetoids.append([mass, x, y, z, vx, vy, vz])\n\n        return (planetoid[dim] + planetoid[5+dim]) % nx if dim == 0 else \\\n               (planetoid[dim] + planetoid[5+dim]) % ny if dim == 1 else \\\n               (planetoid[dim] + planetoid[5+dim]) % nz\n\n    collisions = True\n    while collisions:\n        collisions = False\n        new_planetoids = []\n        for i in range(n):\n            for j in range(i+1, n):\n                x, y, z = update_planet(planetoids[i], 0), update_planet(planetoids[j], 1), update_planet(planetoids[j], 2)\n                if (x, y, z) == (update_planet(planetoids[j], 0), update_planet(planetoids[i], 1), update_planet(planetoids[i], 2)):\n                    mass = planetoids[i][0] + planetoids[j][0]\n                    velocity_x = int((planetoids[i][4]+planetoids[j][4])/2)\n                    velocity_y = int((planetoids[i][5]+planetoids[j][5])/2)\n                    velocity_z = int((planetoids[i][6]+planetoids[j][6])/2)\n                    new_planetoids.append([mass, x, y, z, velocity_x, velocity_y, velocity_z])\n                    collisions = True\n                    planetoids.pop(j)\n                    planetoids.pop(i)\n                    n -= 2\n        if not collisions:\n            planetoids += new_planetoids\n\n    mass_order = sorted(range(n), key=lambda k: (planetoids[k][0], planetoids[k][1], planetoids[k][2], planetoids[k][3]))\n    print(n)\n\n    for i in mass_order:\n        mass, x, y, z, vx, vy, vz = planetoids[i]\n        print('P{:d}: {:d} {:d} {:d} {:d} {:d} {:d}'.format(i, mass, x, y, vx, vy, vz))\n\nmain()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962013959884644,
            0.9966951608657837,
            0.9971652626991272,
            0.9969081878662109,
            0.9965370893478394,
            0.9973373413085938,
            0.9963328838348389,
            0.9943354725837708,
            0.9969850182533264,
            0.9970607757568359,
            0.9962254762649536,
            0.9973166584968567,
            0.9964922666549683,
            0.9958727955818176,
            0.996789813041687,
            0.9950973391532898,
            0.9972396492958069,
            0.9969803690910339,
            0.9952526092529297,
            0.9972538352012634
        ]
    },
    "3009": {
        "similarity": 0.997085452079773,
        "body": "import sys\n\n    n = int(input())\n    lamps = []\n    for i in range(n):\n        x, y, e = map(int, input().split())\n        lamps.append((x, y, e))\n    \n    positive_energy = [lamp[2] > 0 for lamp in lamps]\n    negative_energy = [not p for p in positive_energy]\n\n        return ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n\n    lines = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if not (positive_energy[i] == positive_energy[j]):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                lines.append((distance(x1, y1, x2, y2), i, j))\n\n    lines.sort(reverse=True)\n    current_line_length = 0\n    for line in lines:\n        length, i, j = line\n        current_positive_energy = positive_energy[i] + (positive_energy[j] == True)\n        remaining_positive_lamps = sum(1 for k in range(n) if positive_energy[k])\n        if remaining_positive_lamps - current_positive_energy <= 0 and len(lines) >= n:\n            line_length = 0\n            i_prev = None\n            j_prev = None\n            for k, (length_k, i_k, j_k) in enumerate(lines):\n                x1, y1, e1 = lamps[i_k]\n                x2, y2, e2 = lamps[j_k]\n                if length_k < length:\n                    continue\n                line_length += distance(x1, y1, x2, y2)\n                current_positive_energy += positive_energy[j_k] - (positive_energy[i_k] == True)\n                if i_prev != None and j_prev != None:\n                    line_length += distance(x1, y1, lamps[i_prev][0], lamps[i_prev][1])\n                    line_length += distance(lamps[j_prev][0], lamps[j_prev][1], x2, y2)\n                i_prev = i_k\n                j_prev = j_k\n            if current_positive_energy <= remaining_positive_lamps:\n                return round(line_length, 6)\n\n    return \"IMPOSSIBLE\"\n\nprint(find_balancing_line())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959288239479065,
            0.9956519603729248,
            0.9966050982475281,
            0.9956280589103699,
            0.9967557191848755,
            0.9965485334396362,
            0.9967384338378906,
            0.9960389733314514,
            0.9916276335716248,
            0.997085452079773,
            0.9968771934509277,
            0.996748685836792,
            0.9936490654945374,
            0.9962658286094666,
            0.996666669845581,
            0.9962712526321411,
            0.996612548828125,
            0.9931594729423523,
            0.9963055849075317,
            0.9962497353553772
        ]
    },
    "3896": {
        "similarity": 0.9964913725852966,
        "body": "import sys\n\n    n = len(x)\n    MOD = 1000000007\n    ans = 0\n    for i in range(n):\n        ai = int(x[i])\n        j = (1 << n) - 2 * (i + 1) + 1\n        while j >= 0:\n            bi = int(x[j] != '0')\n            if ai < bi:\n                ans += ((1 << i) * (1 << (n - j - 1))) % MOD\n            j -= 2\n    return ans % MOD\n\nx = input().strip()\nprint(dance_complexity(x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959620237350464,
            0.995522677898407,
            0.9960764050483704,
            0.9872714877128601,
            0.9929325580596924,
            0.9951660633087158,
            0.9954443573951721,
            0.9964913725852966,
            0.994818925857544,
            0.996246337890625,
            0.9950894713401794,
            0.9956504702568054,
            0.9942183494567871,
            0.9925829172134399,
            0.9924348592758179,
            0.9893662333488464,
            0.9959774017333984,
            0.9956566691398621,
            0.9956068992614746,
            0.9952474236488342
        ]
    },
    "3509": {
        "similarity": 0.9969794750213623,
        "body": "import sys\n\n    time = [[float('inf')] * len(graph) for _ in range(len(graph))]\n    time[source][source] = 0\n    queue = [(source, 0)]\n\n    while queue:\n        node, dist = queue.pop(0)\n        for neighbor, road_time in graph[node]:\n            if time[neighbor][node] > dist + road_time:\n                time[neighbor][node] = dist + road_time\n                queue.append((neighbor, dist + road_time))\n\n    a, b = map(int, input().split())\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        u, v, t = map(int, input().split())\n        graph[u - 1].append((v - 1, t))\n\n    bfs(graph, n - 1)\n\n    max_time_to_janet_house = 0\n    for i in range(n):\n        if graph[i]:\n            max_time_to_janet_house = max(max_time_to_janet_house,\n                                          time[n - 1][i])\n\n    min_waiting_time = a\n    max_waiting_time = b\n\n    while min_waiting_time <= max_waiting_time:\n        waiting_time = (min_waiting_time + max_waiting_time) // 2\n        for i in range(n):\n            if graph[i]:\n                time_to_janet_house = max(time[n - 1][i], max_time_to_janet_house)\n                if waiting_time >= time_to_janet_house:\n                    min_waiting_time = waiting_time + 1\n                    break\n\n    return min_waiting_time - 1\n\nprint(worst_case_waiting_time())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965125918388367,
            0.9960168600082397,
            0.9959327578544617,
            0.9959545135498047,
            0.9967376589775085,
            0.9962704181671143,
            0.9963191151618958,
            0.9964213371276855,
            0.996367335319519,
            0.9904173016548157,
            0.9954286217689514,
            0.9958726763725281,
            0.9960620403289795,
            0.9951582551002502,
            0.9962853193283081,
            0.9960362315177917,
            0.9969794750213623,
            0.9967085123062134,
            0.9943064451217651,
            0.9959115386009216
        ]
    },
    "3547": {
        "similarity": 0.9955278038978577,
        "body": "import sys\n\n    n = int(input())\n    area = 0\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        new_area = (x2 - x1) * (y2 - y1)\n        current_area = 0\n        for i in range(_):\n            a1, b1, a2, b2 = map(float, input().split())\n            intersection_x = max(a1, x1)\n            intersection_y = max(b1, y1)\n            intersection_w = min(x2, a2) - intersection_x\n            if intersection_w > 0:\n                intersection_h = min(y2, b2) - intersection_y\n                if intersection_h < 0:\n                    continue\n                current_area -= intersection_w * intersection_h\n        area += new_area + current_area\n    return round(area, 2)\n\nprint(actual_land_area())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950476288795471,
            0.9851829409599304,
            0.9932259321212769,
            0.9951696991920471,
            0.9931038618087769,
            0.994450032711029,
            0.9948132038116455,
            0.9951673746109009,
            0.9933907389640808,
            0.9855534434318542,
            0.9925525188446045,
            0.9945480227470398,
            0.9950926899909973,
            0.9944648742675781,
            0.9954740405082703,
            0.9955278038978577,
            0.9946134686470032,
            0.9949870705604553,
            0.9863371849060059,
            0.9946604371070862
        ]
    },
    "3017": {
        "similarity": 0.9962314963340759,
        "body": "import sys\n\n    max_num = int('2' * (e + 1))\n    num_digits = e + 1\n    for pow in range(e + 1):\n        max_num //= 2\n        num_digits -= 1\n\n    dp = [0] * (max_num + 1)\n    for i in range(max_num + 1):\n        if i < num_digits:\n            new_dp = [0] * (max_num + 1)\n            for j in range(max_num + 1):\n                new_dp[j] += dp[j]\n                if int(str(j) + '2' * pow) <= max_num:\n                    new_dp[int(str(j) + '2' * pow)] += dp[j]\n            dp = new_dp\n        else:\n            dp[i] = n - i + 1\n\n    return sum(dp)\n\nn, e = map(int, input().split())\nprint(count_power_of_two(n, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948593974113464,
            0.9962314963340759,
            0.995400071144104,
            0.9923087954521179,
            0.9940225481987,
            0.9957219958305359,
            0.9906439781188965,
            0.9946576952934265,
            0.9953609108924866,
            0.9945188760757446,
            0.9952649474143982,
            0.9957008361816406,
            0.9906933307647705,
            0.9939873218536377,
            0.9944076538085938,
            0.9936643242835999,
            0.9946385622024536,
            0.99466472864151,
            0.9922351837158203,
            0.9960869550704956
        ]
    },
    "3076": {
        "similarity": 0.9966385364532471,
        "body": "import sys\n\n    jewels = []\n    for _ in range(n):\n        s, v = map(int, input().split())\n        jewels.append((s, v))\n\n    knapsacks = [0] * (k + 1)\n    sizes = sorted([j[0] for j in jewels])\n\n    for size in sizes:\n        for i in range(k, -1, -1):\n            if i + size <= k and knapsacks[i] < knapsacks[i + size]:\n                knapsacks[i + size] = knapsacks[i]\n        knapsacks[size] += max(0, [j[1] for j in jewels if j[0] == size][0])\n\n    return ' '.join(map(str, knapsacks[1:]))\n\nk, n = map(int, input().split())\nprint(max_jewel_value(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99643474817276,
            0.9957187175750732,
            0.9958482384681702,
            0.9944595694541931,
            0.995791494846344,
            0.9958755970001221,
            0.9966228008270264,
            0.9927217364311218,
            0.9938238263130188,
            0.9938580393791199,
            0.9950582385063171,
            0.9960036873817444,
            0.9946720004081726,
            0.9964816570281982,
            0.9903711080551147,
            0.9966385364532471,
            0.9953697919845581,
            0.990250825881958,
            0.9961176514625549,
            0.9901894927024841
        ]
    },
    "3923": {
        "similarity": 0.9963768720626831,
        "body": "    p = [0] * (n + 1)\n    a_count = 0\n    b_count = 0\n    i = n\n    while True:\n        if a_count == a or b_count == b:\n            break\n        if a_count < a and i % a != 0:\n            p[i] = i\n            a_count += 1\n        elif b_count < b and i % b != 0:\n            p[i] = i\n            b_count += 1\n        else:\n            p[i] = n - i + 1\n        i -= 1\n\n    for i in range(1, n):\n        if a == b and p[i] == p[n]:\n            print(-1)\n            return\n        if p[i] < p[i+1]:\n            temp = p[i]\n            p[i] = p[i + 1]\n            p[i + 1] = temp\n\n    for i in range(1, n + 1):\n        print(p[i], end=' ')\n\nimport sys\nn, a, b = map(int, input().split())\nsolve(n, a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947182536125183,
            0.9961227774620056,
            0.9958465099334717,
            0.9927574992179871,
            0.9929574728012085,
            0.9957292675971985,
            0.9948248863220215,
            0.9950408935546875,
            0.995316743850708,
            0.9951933026313782,
            0.9958170056343079,
            0.9939754009246826,
            0.9952974915504456,
            0.9963768720626831,
            0.9927186369895935,
            0.9925822019577026,
            0.9955540895462036,
            0.9953820109367371,
            0.9958281517028809,
            0.9955834746360779
        ]
    },
    "3332": {
        "similarity": 0.9971299767494202,
        "body": "import sys\n\n    streams = []\n    for _ in range(n):\n        s, d, p = map(int, input().split())\n        end = s + d\n        streams.append((s, end, p))\n\n    streams.sort()\n    stack = []\n    dp = [0] * (n + 1)\n    max_total_priority = 0\n\n    for i in range(n):\n        if not stack or streams[i][0] >= stack[-1]:\n            while len(stack) > 0 and streams[i][0] >= stack[-1]:\n                top = stack.pop()\n                dp[i] = max(dp[i], dp[top-1])\n            stack.append(i)\n            dp[i] += max_total_priority\n        else:\n            while i < n and streams[i][0] < stack[-1] and streams[i][1] > stack[-1]:\n                max_total_priority = max(max_total_priority, dp[stack.pop()])\n            stack.append(i)\n\n    return max(max(dp) for dp in dp)\n\nprint(max_streams(int(input())))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962207674980164,
            0.9949846863746643,
            0.9966665506362915,
            0.995035707950592,
            0.9934096336364746,
            0.9964857697486877,
            0.9963908791542053,
            0.9966664910316467,
            0.9971299767494202,
            0.9970428943634033,
            0.9964730143547058,
            0.9962915182113647,
            0.9951239228248596,
            0.9955495595932007,
            0.9964744448661804,
            0.9962549805641174,
            0.9954904317855835,
            0.9917851686477661,
            0.9956693053245544,
            0.9950110912322998
        ]
    },
    "3240": {
        "similarity": 0.9969049096107483,
        "body": "import sys\n\n    best_outcome = 0\n    max_ballots = 2 ** k - 1\n    for i in range(max_ballots + 1):\n        expected_outcomes = 0\n        for j in range(v - 1):\n            prob_voting = probabilities[j]\n            num_ballots = ballots[j]\n            outcome = (num_ballots >> j) & 1\n            if outcome == 0:\n                expected_outcomes += prob_voting * ((i >> j) & 1)\n        if expected_outcomes > best_outcome:\n            best_outcome = expected_outcomes\n    return int(best_outcome >= 0.5)\n\n    for i in range(2 ** (len(probabilities) - 1)):\n        k = bin(i).count('1')\n        if count_positions(k, len(probabilities), probabilities, ballots):\n            return i\n\nprobabilities = []\nballots = []\nfor _ in range(int(input()) - 1):\n    p, b = map(float, input().split())\n    probabilities.append(p)\n    ballots.append(b)\n\nprint(max_ballots(len(probabilities), probabilities, ballots))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961559772491455,
            0.9960994720458984,
            0.9952256083488464,
            0.994806706905365,
            0.9960224032402039,
            0.9969049096107483,
            0.9966813325881958,
            0.9955736398696899,
            0.9943687319755554,
            0.9958835244178772,
            0.9950900673866272,
            0.9957048296928406,
            0.996714174747467,
            0.9940621256828308,
            0.9951023459434509,
            0.9942213296890259,
            0.9950809478759766,
            0.9957879781723022,
            0.9961216449737549,
            0.9968571066856384
        ]
    },
    "3368": {
        "similarity": 0.9962335824966431,
        "body": "import sys\n\n    n, m = map(int, input().split())\n    enclosures = [input().split()[1:] for _ in range(n)]\n    animal_enclosures = {}\n    wrong_enclosures = set()\n\n    for i in range(n):\n        if len(enclosures[i]) > 0:\n            animal = enclosures[i][0]\n            if animal not in animal_enclosures:\n                animal_enclosures[animal] = [i]\n            elif i not in animal_enclosures[animal]:\n                wrong_enclosures.add(i)\n\n    for i in range(n):\n        for j, animal in enumerate(enclosures[i]):\n            if animal != enclosures[i][0] and animal not in animal_enclosures:\n                wrong_enclosures.add(i)\n                break\n\n    for i in wrong_enclosures:\n        current = list(enclosures[i])\n        for other_i in range(n):\n            if other_i == i:\n                continue\n            other = list(enclosures[other_i])\n            new_wrong_enclosures = set()\n            for animal in current:\n                found = False\n                for j, a in enumerate(other):\n                    if animal == a and j != 0:\n                        del other[j]\n                        break\n                else:\n                    new_wrong_enclosures.add(i)\n                    break\n\n            for animal in other:\n                found = False\n                for j, a in enumerate(current):\n                    if animal == a and j != 0:\n                        del current[j]\n                        break\n                else:\n                    new_wrong_enclosures.add(other_i)\n                    break\n        wrong_enclosures = new_wrong_enclosures | wrong_enclosures\n\n    return \"POSSIBLE\" if len(wrong_enclosures) > 0 else \"FALSE ALARM\"\n\nprint(solve())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961403608322144,
            0.9956227540969849,
            0.9960755705833435,
            0.9952535033226013,
            0.9934853315353394,
            0.990775465965271,
            0.9962335824966431,
            0.9954336285591125,
            0.9941065907478333,
            0.9960406422615051,
            0.9952153563499451,
            0.9942744374275208,
            0.9946108460426331,
            0.9936580657958984,
            0.9920260906219482,
            0.9900627136230469,
            0.9959618449211121,
            0.9960507750511169,
            0.9937097430229187,
            0.9958118796348572
        ]
    },
    "3538": {
        "similarity": 0.9964438080787659,
        "body": "import sys\n\n    max_depth = d + 1\n    n = len(frogs)\n    escape = [False] * n\n    weights = sorted([[f[2], f[0]] for f in frogs])\n\n        l = weights[i][1]\n        return l >= (depth - weights[i][0]) and not escape[i]\n\n    total_weight = 0\n    count = 0\n\n    for i in range(n):\n        if not escape[i]:\n            weight = weights[i][0]\n            max_height = weights[i][0] + d\n\n            for j in range(i, n):\n                if not escape[j] and can_escape(j, max_height) and total_weight + weight <= weights[j][0]:\n                    max_height = max(max_height, weights[j][0] + d)\n                    total_weight += weight\n                    escape[j] = True\n\n            count += 1\n\n    return count\n\n\nn, d = map(int, input().split())\nfrogs = []\nfor _ in range(n):\n    l, w, h = map(int, input().split())\n    frogs.append([l, w, h])\n\nprint(max_frogs(d, frogs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964438080787659,
            0.9961140155792236,
            0.9951754212379456,
            0.9960322976112366,
            0.9956540465354919,
            0.9934017062187195,
            0.9959970116615295,
            0.9960354566574097,
            0.9957570433616638,
            0.9951406121253967,
            0.9959760904312134,
            0.9958296418190002,
            0.9954015016555786,
            0.9950652122497559,
            0.9939607381820679,
            0.9951821565628052,
            0.995588481426239,
            0.9956473112106323,
            0.9964366555213928,
            0.9949798583984375
        ]
    },
    "3183": {
        "similarity": 0.9972870349884033,
        "body": "import sys\n\n    cost = [[0] * n for _ in range(n)]\n    flow = [0] * n\n    for u, v, c, w in graph:\n        cost[u][v] -= w\n        cost[v][u] += w\n\n    for i in range(n):\n        for j in range(n):\n            if cost[i][j] < 0:\n                cost[i][j] = float('inf')\n\n    parent = [-1] * n\n\n        queue = [s]\n        visited = [False] * n\n        visited[s] = True\n\n        while queue:\n            u = queue.pop(0)\n            for v in range(n):\n                if not visited[v] and cost[u][v] - flow[u] > 0:\n                    visited[v] = True\n                    parent[v] = u\n                    queue.append(v)\n\n        bfs()\n        while True:\n            min_residual = float('inf')\n            v = t\n            while v != s:\n                min_residual = min(min_residual, cost[parent[v]][v])\n                v = parent[v]\n            for v in range(n):\n                if cost[parent[v]][v] - flow[parent[v]] > 0 and v != t:\n                    u = parent[v]\n                    flow[u] += min_residual\n                    flow[v] -= min_residual\n                    cost[u][v] -= min_residual\n                    cost[v][u] += min_residual\n\n    ford_fulkerson()\n\n    return sum(flow[i] for i in range(n) if i != s and i != t), sum(cost[s][i] * flow[s] for i in range(n) if i != s)\n\ngraph = []\nfor _ in range(int(input().split()[1])):\n    graph.append(tuple(map(int, input().split())))\n\nn, m, s, t = map(int, input().split())\nflow, cost = max_flow(graph, n + 1, m, s, t)\nprint(flow, cost)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970584511756897,
            0.9967507123947144,
            0.9953545928001404,
            0.9967311024665833,
            0.9957789182662964,
            0.9960117340087891,
            0.9971210956573486,
            0.9972870349884033,
            0.995937168598175,
            0.9954541921615601,
            0.9957238435745239,
            0.9961234927177429,
            0.9967432618141174,
            0.9967296123504639,
            0.9971544146537781,
            0.9964285492897034,
            0.9967514872550964,
            0.9967023730278015,
            0.9963776469230652,
            0.996772050857544
        ]
    },
    "3916": {
        "similarity": 0.9966697692871094,
        "body": "import sys\nfrom math import *\n\n    i = 2\n    factors = []\n    while i * i <= x:\n        if x % i:\n            i += 1\n        else:\n            x //= i\n            factors.append(i)\n    if x > 1:\n        factors.append(x)\n    return factors\n\n    path_length = 0\n    for f in prime_factors(factorial(node)):\n        while node >= factorial(f):\n            path_length += 1\n            node //= f\n    return path_length * (node - 1)\n\nn = int(input())\nk = [int(x) for x in input().split()]\nmin_sum = 1000000\n\nfor p in range(1, factorial(5001)):\n    path_lengths = []\n    for k_i in k:\n        path_lengths.append(node_to_path(k_i))\n    sum_paths = sum(path_lengths)\n    if sum_paths < min_sum:\n        min_sum = sum_paths\n\nprint(min_sum)",
        "result": "failed: testcase 0",
        "similarities": [
            0.994411289691925,
            0.9951968789100647,
            0.9953547120094299,
            0.9957640767097473,
            0.9952313303947449,
            0.9952165484428406,
            0.9941557049751282,
            0.9956472516059875,
            0.995013415813446,
            0.9948737621307373,
            0.9962056875228882,
            0.9950944781303406,
            0.9949628114700317,
            0.9952436089515686,
            0.9916777610778809,
            0.9961521625518799,
            0.9966697692871094,
            0.993649423122406,
            0.9953356385231018,
            0.9953338503837585
        ]
    },
    "3195": {
        "similarity": 0.9976793527603149,
        "body": "import math\nfrom fractions import Fraction\n\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n\n    lights_color_change_times = []\n    for _ in range(n):\n        t, c = input().split()\n        t = int(t)\n        if c == 'green':\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r))\n        elif c == 'yellow':\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r) + T_g)\n        else:\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r) + T_g + T_y)\n\n    t_q, c_q = map(str.strip, input().split())\n\n    possible_T_values = []\n    for time in range(T_g + T_y + T_r):\n        count = sum(1 for i in lights_color_change_times if (i - time) % (T_g + T_y + T_r) == 0)\n        if count >= 3:\n            possible_T_values.append(time)\n\n    t_q_real_time = int(t_q) % (T_g + T_y + T_r)\n\n    result = Fraction(1, len(possible_T_values))\n    for T in possible_T_values:\n        diff = t_q_real_time - T\n        if diff >= 0 and diff <= T_g:\n            result += Fraction(diff / (T_g + T_y + T_r))\n\n    return str(float(result))\n\nprint(calculate_probability())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962102174758911,
            0.997668445110321,
            0.9968273639678955,
            0.9963651299476624,
            0.9972933530807495,
            0.9964690208435059,
            0.9968970417976379,
            0.9972459673881531,
            0.9976793527603149,
            0.9976010918617249,
            0.9964419007301331,
            0.9969523549079895,
            0.9967547059059143,
            0.997303307056427,
            0.9949589967727661,
            0.9962676167488098,
            0.9962708353996277,
            0.996074378490448,
            0.9976539611816406,
            0.9970101714134216
        ]
    },
    "3998": {
        "similarity": 0.9967359304428101,
        "body": "import sys\n\n    max_rating = sum(r) // n  # Calculate maximum possible rating\n\n    if max_rating == 0:\n        return [max_rating], [[1 for _ in range(n)]]\n\n    ratings = list(r)\n    matches = []\n    current_matches = []\n\n        nonlocal current_matches\n        current_matches.clear()\n        while len(current_matches) < n and max_rating > 0:\n            i, j = None, None\n            max_diff = -1\n\n            for p in range(len(ratings)):\n                if ratings[p] >= max_rating:\n                    continue\n                for q in range(p + 1, len(ratings)):\n                    diff = abs(q - p)\n                    if diff > max_diff and diff <= min(5, n):\n                        i, j, max_diff = p, q, diff\n\n            current_matches.append((i, j))\n            ratings[i] += 1\n            ratings[j] += 1\n            max_rating -= 2\n\n    update_current_matches()\n\n    while len(current_matches) < n and max_rating > 0:\n        new_current_matches = []\n        for i, j in current_matches:\n            for k in range(i + 1, j):\n                diff = abs(k - i)\n                if diff <= min(5, n):\n                    new_current_matches.append((i, k))\n                    ratings[i] += 1\n                    ratings[k] += 1\n                    max_rating -= 2\n\n        update_current_matches()\n        for m in current_matches:\n            new_current_matches.append(m)\n\n        current_matches = new_current_matches\n\n    for i in range(n):\n        if ratings[i] == max_rating:\n            matches.extend([i] * (len(current_matches) - n + 1))\n\n    return [max_rating], [[0 if k not in matches else '1' for k in range(n)] for _ in range(len(matches))]\n\nn = int(input())\nr = list(map(int, input().split()))\nresult, matrix = equal_ratings(n, r)\nprint(result[0])\nfor row in matrix:\n    print(''.join(row))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964272379875183,
            0.9948297142982483,
            0.9950818419456482,
            0.9960818886756897,
            0.9958139061927795,
            0.9944170713424683,
            0.9955944418907166,
            0.9944576621055603,
            0.9960416555404663,
            0.9967091083526611,
            0.9950539469718933,
            0.9964288473129272,
            0.9965395927429199,
            0.9954469799995422,
            0.9967359304428101,
            0.9900603294372559,
            0.9961336255073547,
            0.9958616495132446,
            0.9964471459388733,
            0.9962579607963562
        ]
    },
    "3150": {
        "similarity": 0.9967550039291382,
        "body": "import sys\n\n    N = int(input())\n    trenches = []\n    for i in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        trench = [(x1, y1), (x2, y2)]\n        if trench not in trenches:\n            trenches.append(trench)\n    \n    guards = set()\n    ways = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1 = trenches[i][0]\n            x2, y2 = trenches[j][0]\n            dx = abs(x2 - x1)\n            dy = abs(y2 - y1)\n            if dy == 0 and dx >= 1:\n                if not (x1 in [t[0] for t in trenches] or\n                        x1 in [t[1] for t in trenches]):\n                    guards.add((i, j))\n            elif dx > 0 and dy <= 0:\n                if not ((x2, y2) == (trenches[i][0]) or\n                        (x2, y2) == (trenches[j][0])):\n                    guards.add((i, j))\n    \n    for guard1 in guards:\n        x1, y1 = trenches[guard1[0]][0]\n        x2, y2 = trenches[guard1[1]][0]\n        if x1 <= x2 and x2 - x1 < 100000 and (x2, y2) not in [t[1] for t in trenches]:\n            ways += 2\n        elif x1 >= x2 and x1 - x2 < 100000:\n            ways += 2\n    \n    return str(ways)\n\nprint(count_ways())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962366819381714,
            0.9954933524131775,
            0.9951989054679871,
            0.9889590740203857,
            0.9935507774353027,
            0.9954026937484741,
            0.9960847496986389,
            0.9951256513595581,
            0.9950773119926453,
            0.9963759183883667,
            0.9967550039291382,
            0.9961087107658386,
            0.9964166283607483,
            0.9959122538566589,
            0.9955112934112549,
            0.9964216351509094,
            0.9920971393585205,
            0.9936286807060242,
            0.9961527585983276,
            0.9963412880897522
        ]
    },
    "3566": {
        "similarity": 0.9964174032211304,
        "body": "    for _ in range(q):\n        i, x = map(int, input().split())\n        huts[i] = x\n        left_queue_sum = 0\n        right_queue_sum = 0\n        best_position = -1\n        queue_differences = []\n        for j in range(n):\n            if j < i:\n                left_queue_sum += huts[j]\n                queue_differences.append(left_queue_sum - (right_queue_sum + huts[i] - huts[j]))\n            elif j > i:\n                right_queue_sum += huts[j]\n                queue_differences.append(right_queue_sum - (left_queue_sum + huts[i] - huts[j]))\n        min_difference = min(queue_differences)\n        best_positions = [j for j in range(n) if queue_differences[j] == min_difference]\n        print(min(best_positions))\n\nimport sys\nn, q = map(int, input().split())\nhuts = list(map(int, input().split()))\nfood_truck(n, q, huts)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9866417646408081,
            0.9956280589103699,
            0.9921174645423889,
            0.9959229230880737,
            0.9955522418022156,
            0.9943448901176453,
            0.9948959350585938,
            0.9964174032211304,
            0.9951529502868652,
            0.9929370880126953,
            0.9959818124771118,
            0.9950467944145203,
            0.9927179217338562,
            0.9955360293388367,
            0.9954090118408203,
            0.9947900176048279,
            0.9946134686470032,
            0.9958608746528625,
            0.9956801533699036,
            0.9954289197921753
        ]
    },
    "3401": {
        "similarity": 0.997023344039917,
        "body": "import sys\nimport heapq\n\n    dist = [float('inf')] * len(graph)\n    dist[start] = 0\n    pq = [(0, start)]\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]:\n            continue\n        for v, w in graph[u]:\n            nd = dist[u] + w\n            if nd < dist[v]:\n                dist[v] = nd\n                heapq.heappush(pq, (nd, v))\n    return dist\n\n    n, s, t, q = map(int, input().split())\n    hills = [[] for _ in range(n)]\n    springs = list(map(lambda x: int(x) - 1, input().split()))\n    towns = list(map(lambda x: int(x) - 1, input().split()))\n\n    for i in range(n):\n        h = list(map(int, input().split()))\n        hills[i].append((h[0], h[1], h[2]))\n\n    graph = [[] for _ in range(n)]\n    for i in range(s):\n        u = springs[i]\n        for v in range(n):\n            if hills[u][0] < hills[v][0]:\n                continue\n            dist = abs(hills[u][0] - hills[v][0]) + abs(hills[u][1] - hills[v][1])\n            if dist <= q:\n                graph[u].append((v, dist))\n        for v in range(n):\n            if hills[u][0] > hills[v][0]:\n                continue\n            dist = abs(hills[u][0] - hills[v][0]) + abs(hills[u][1] - hills[v][1])\n            if dist <= q:\n                graph[v].append((u, dist))\n\n    for i in range(t):\n        u = towns[i]\n        for v in springs:\n            if hills[u][2] > hills[v][2]:\n                continue\n            dist = abs(hills[u][0] - hills[v][0]) + abs(hills[u][1] - hills[v][1])\n            if dist <= q:\n                graph[v].append((u, dist))\n        for v in springs:\n            if hills[u][2] < hills[v][2]:\n                continue\n            dist = abs(hills[u][0] - hills[v][0]) + abs(hills[u][1] - hills[v][1])\n            if dist <= q:\n                graph[u].append((v, dist))\n\n    result = 0.0\n    for i in range(t):\n        u = towns[i]\n        path = find_path(graph, u)\n        best_spring = None\n        for v in springs:\n            if hills[v][2] > hills[u][2]:\n                continue\n            if path[v] < float('inf'):\n                dist = path[v] - 0.5 * abs(hills[v][0] - hills[u][0]) - 0.5 * abs(hills[v][1] - hills[u][1])\n                best_spring = v\n                result += dist\n        if not best_spring:\n            print(\"IMPOSSIBLE\")\n            return\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955651164054871,
            0.9967001080513,
            0.9936726093292236,
            0.9957588911056519,
            0.997023344039917,
            0.995583176612854,
            0.9961135387420654,
            0.9951833486557007,
            0.996010422706604,
            0.9932494759559631,
            0.9952388405799866,
            0.9966309070587158,
            0.9965556263923645,
            0.9966282248497009,
            0.9960532784461975,
            0.9947056174278259,
            0.9952290058135986,
            0.9913023114204407,
            0.9955881834030151,
            0.9967768788337708
        ]
    },
    "3660": {
        "similarity": 0.9972291588783264,
        "body": "import sys\n\n    msg = input()\n    n = int(input())\n    stickers = [[] for _ in range(n)]\n    prices = [0] * n\n    for i in range(n):\n        word, price = input().split()\n        stickers[i].append(word)\n        prices[i] = int(price)\n\n    dp = [[float('inf')] * (len(msg) + 1) for _ in range(len(msg) + 1)]\n    dp[0][0] = 0\n    for i in range(1, len(msg) + 1):\n        last_sticker = -1\n        for j in range(n):\n            for k in range(len(stickers[j])):\n                if i >= len(stickers[j][k]) and (not last_sticker or stickers[last_sticker][0][-1] != stickers[j][k][0]):\n                    cost = dp[i - len(stickers[j][k])][i - len(stickers[j][k])] + prices[j]\n                    for l in range(i - 1, i - len(stickers[j][k]), -1):\n                        if dp[l][i - len(stickers[j][k]) - 1] < cost:\n                            cost = dp[l][i - len(stickers[j][k]) - 1] + prices[j]\n                    for l in range(i - 2, i - len(stickers[j][k]), -1):\n                        if last_sticker >= 0 and stickers[last_sticker][0][-1] == stickers[j][k][0]:\n                            cost = min(cost, dp[l][i - len(stickers[j][k]) + 1] + prices[j])\n                    dp[i][j] = min(dp[i][j], cost)\n                if i >= len(stickers[j][k]) and last_sticker != j:\n                    dp[i][j] = min(dp[i][j], dp[i - len(stickers[j][k])][i])\n\n        last_sticker = j\n    if dp[len(msg)][len(msg)] == float('inf'):\n        print('IMPOSSIBLE')\n    else:\n        print(dp[len(msg)][len(msg)])\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931250214576721,
            0.995450496673584,
            0.9966996908187866,
            0.994913637638092,
            0.9966598153114319,
            0.9968669414520264,
            0.996662974357605,
            0.9963714480400085,
            0.9933669567108154,
            0.9964200854301453,
            0.9954123497009277,
            0.9967635273933411,
            0.9948703646659851,
            0.9965599775314331,
            0.9962500333786011,
            0.9958921074867249,
            0.9969554543495178,
            0.9972291588783264,
            0.9968519806861877,
            0.9960495829582214
        ]
    },
    "3721": {
        "similarity": 0.9967129230499268,
        "body": "    present = set()\n    for _ in range(q):\n        r, c = map(int, input().split())\n        present.add((r - 1, c - 1))\n\n        if (row, col) not in present:\n            return\n        marked[(row, col)] = True\n        for i in range(n):\n            if (i, col) in present and not marked.get((i, col), False):\n                mark_connected(i, col, marked, present)\n        for j in range(m):\n            if (row, j) in present and not marked.get((row, j), False):\n                mark_connected(row, j, marked, present)\n\n    count = n * m - len(present)\n    marked = {}\n    for r in range(n):\n        for c in range(m):\n            if (r, c) in present:\n                continue\n            mark_connected(r, c, marked, present)\n            count -= 1\n\n    return count\n\nn, m, q = map(int, input().split())\nprint(min_purchases(n, m, q))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952775835990906,
            0.9958130717277527,
            0.9963330030441284,
            0.9951366782188416,
            0.9957076907157898,
            0.9948918223381042,
            0.9966042041778564,
            0.9933792948722839,
            0.9964188933372498,
            0.9967129230499268,
            0.9961826205253601,
            0.9964376091957092,
            0.996634840965271,
            0.9964897036552429,
            0.996521532535553,
            0.9955708384513855,
            0.9933361411094666,
            0.9953679442405701,
            0.9961578249931335,
            0.9950700998306274
        ]
    },
    "3811": {
        "similarity": 0.99608314037323,
        "body": "import math\n\n    n = int(input())\n    min_num = float('inf')\n    factors = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        if a > 1:\n            factors.append(a)\n        if b > 1 and (a != b or b < min_num):\n            factors.append(b)\n        min_num = min(min_num, a, b)\n\n    for possible_wcd in range(2, int(math.sqrt(min_num)) + 3):\n        can_divide_all = True\n        for num in factors:\n            if num % possible_wcd != 0:\n                can_divide_all = False\n                break\n        if can_divide_all:\n            return possible_wcd\n\n    return -1\n\nprint(calculate_wcd())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957367777824402,
            0.9948564171791077,
            0.9946545958518982,
            0.9939068555831909,
            0.99608314037323,
            0.9950897097587585,
            0.9929410219192505,
            0.9931231141090393,
            0.9947648644447327,
            0.9952192902565002,
            0.9957981109619141,
            0.9948608875274658,
            0.9934677481651306,
            0.9948571920394897,
            0.9839547872543335,
            0.9939017295837402,
            0.9887108206748962,
            0.9946284294128418,
            0.9945581555366516,
            0.9925892353057861
        ]
    },
    "3528": {
        "similarity": 0.9963170289993286,
        "body": "    n = int(input())\n    nails = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        nails.append((x, y))\n    picked_nails = list(input())\n\n    total_area = 0.0\n    prev_x_max = -1\n    prev_y_max = -1\n\n    for pick in picked_nails:\n        area = 0.0\n        x_min = float('inf')\n        x_max = float('-inf')\n        y_min = float('inf')\n        y_max = float('-inf')\n\n        if pick == 'L':\n            for i, (x, _) in enumerate(nails):\n                if i != nails.index((nails[n - 1][0], nails[n - 1][1])):\n                    x_min = min(x_min, x)\n                    x_max = max(x_max, x)\n                    y_min = min(y_min, nails[i][1])\n                    y_max = max(y_max, nails[i][1])\n\n            area = (x_max - x_min) * (y_max - y_min)\n\n        elif pick == 'R':\n            for i, (_, y) in enumerate(nails):\n                if i != nails.index((nails[n - 1][0], nails[n - 1][1])):\n                    x_min = min(x_min, nails[i][0])\n                    x_max = max(x_max, nails[i][0])\n                    y_min = min(y_min, y)\n                    y_max = max(y_max, y)\n\n            area = (x_max - x_min) * (y_max - y_min)\n\n        elif pick == 'U':\n            for i, (_, y) in enumerate(nails):\n                if i != nails.index((nails[n - 1][0], nails[n - 1][1])):\n                    x_min = min(x_min, nails[i][0])\n                    x_max = max(x_max, nails[i][0])\n                    y_min = min(y_min, y)\n                    y_max = max(y_max, y)\n\n            area = (x_max - x_min) * (y_max - y_min)\n\n        elif pick == 'D':\n            for i, (x, _) in enumerate(nails):\n                if i != nails.index((nails[n - 1][0], nails[-1][1])):\n                    x_min = min(x_min, x)\n                    x_max = max(x_max, x)\n                    y_min = min(y_min, nails[i][1])\n                    y_max = max(y_max, nails[i][1])\n\n            area = (x_max - x_min) * (y_max - y_min)\n\n        prev_x_max = x_max\n        prev_y_max = y_max\n\n        total_area += area / 2.0\n        print(area / 2.0)\n\ncalculate_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944146871566772,
            0.9950090646743774,
            0.9951511025428772,
            0.9950976371765137,
            0.9962136149406433,
            0.9963170289993286,
            0.9917291402816772,
            0.995896577835083,
            0.9954763054847717,
            0.9908824563026428,
            0.9953221678733826,
            0.9919411540031433,
            0.9955347180366516,
            0.9861423373222351,
            0.9954961538314819,
            0.995025634765625,
            0.9959965944290161,
            0.9953670501708984,
            0.9948285818099976,
            0.9952214956283569
        ]
    },
    "3890": {
        "similarity": 0.9953697919845581,
        "body": "import sys\nMOD = 1000000007\n\n    if n == k or n == k + 1:\n        return n\n    res = 0\n    for i in range(k - 2, 0, -1):\n        res += pow(i, n - k, MOD)\n    for i in range(1, k - 1):\n        res -= pow(i, n - k, MOD)\n    res %= MOD\n    return res\n\nn, k = map(int, input().split())\nprint(solve(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950591921806335,
            0.9822032451629639,
            0.9918246865272522,
            0.9920162558555603,
            0.9885607361793518,
            0.9933392405509949,
            0.9934847950935364,
            0.9953565001487732,
            0.9886464476585388,
            0.9953488707542419,
            0.9942695498466492,
            0.994513988494873,
            0.9949174523353577,
            0.9916282296180725,
            0.9936916828155518,
            0.9941908121109009,
            0.9953697919845581,
            0.9953116178512573,
            0.9950509667396545,
            0.9947152733802795
        ]
    },
    "3534": {
        "similarity": 0.9964850544929504,
        "body": "import sys\n\n    max_cnt = 0\n    best_k = -1\n    for k in range(2*10**9 + 1):\n        cnt = [0] * n\n        prev_key = a[0]\n        cnt[0] += 1\n        max_cnt = max(max_cnt, cnt[0])\n        if max_cnt > n:\n            break\n        for i in range(1, n):\n            next_key = a[i]\n            diff = abs(next_key - prev_key)\n            if diff == 0:\n                cnt[i] += cnt[i-1]\n            elif (next_key < prev_key) and (diff <= k):\n                cnt[i] += 1\n            elif (next_key > prev_key) and (diff >= k):\n                cnt[i] = max(cnt[i], cnt[i-1] + 1)\n            else:\n                continue\n            if cnt[i] > max_cnt:\n                max_cnt = cnt[i]\n                best_k = k\n    return [str(max_cnt), str(best_k)]",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945049285888672,
            0.9953115582466125,
            0.9958505034446716,
            0.9944422841072083,
            0.9948954582214355,
            0.9952868223190308,
            0.9961051940917969,
            0.9964850544929504,
            0.9953942894935608,
            0.9961662292480469,
            0.9953263998031616,
            0.9953647255897522,
            0.9943996071815491,
            0.9920558929443359,
            0.9959688782691956,
            0.9957492351531982,
            0.9959521889686584,
            0.9953576922416687,
            0.9946114420890808,
            0.9950364828109741
        ]
    },
    "3371": {
        "similarity": 0.9970713257789612,
        "body": "import sys\n\n    n, c = map(int, input().split())\n    first_meet = {}\n    for i in range(c):\n        a, b, y = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        pair = (a, b)\n        first_meet[pair] = y\n\n    groups_before_y = [0]*(10**5+1)\n    groups_after_y = [0]*(10**5+1)\n\n    for i in range(2008, 1948, -1):\n        for a in range(1, n + 1):\n            for b in range(a + 1, n + 1):\n                if (a, b) not in first_meet or first_meet[(a, b)] >= i:\n                    groups_before_y[i] += 1\n\n    for pair, y in first_meet.items():\n        a, b = pair\n        groups_after_y[y] += 1\n\n    for year in range(2008, 1948, -1):\n        before = sum(groups_before_y[:year])\n        after = sum(groups_after_y[year:])\n        if before <= (2*n)//3 and after <= (2*n)//3:\n            return year\n\nprint(\"Impossible\" if solve() == None else solve())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947889447212219,
            0.9959414601325989,
            0.9970713257789612,
            0.995365560054779,
            0.9920023679733276,
            0.9965693950653076,
            0.9967413544654846,
            0.9955368041992188,
            0.9970016479492188,
            0.9964708089828491,
            0.9963812828063965,
            0.9957619905471802,
            0.9959560036659241,
            0.9966105222702026,
            0.9963310956954956,
            0.9954563975334167,
            0.991911768913269,
            0.9967369437217712,
            0.9958371520042419,
            0.9966862201690674
        ]
    },
    "3621": {
        "similarity": 0.9968984723091125,
        "body": "import sys\n\n    n = int(input())\n    M = [[int(c) for c in input().split()] for _ in range(n)]\n    mod = 10**9 + 7\n    ans = 0\n    for i in range(1, 2**n):\n        s = bin(i)[2:].zfill(n)\n        same_colors = True\n        msk = 0\n        max_same = 0\n        for j in range(n):\n            if s[j] == '1':\n                cur_max = 0\n                for k in range(j + 1, n):\n                    if s[k] == '1' and M[j][k] == M[j][j]:\n                        same_colors = False\n                    elif s[k] == '1' and M[j][k] != M[j][j]:\n                        cur_max += 1\n                max_same = max(max_same, cur_max)\n            msk |= (1 << j)\n        if not same_colors:\n            continue\n        ans += pow(2, max_same + 1, mod) * pow(2, n - max_same - 1, mod) % mod\n    print(ans % mod)\n\nmain()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968984723091125,
            0.9963039755821228,
            0.9957505464553833,
            0.9966434836387634,
            0.9958593249320984,
            0.9954988360404968,
            0.9963926076889038,
            0.9936872124671936,
            0.9961650371551514,
            0.9957492351531982,
            0.9965091347694397,
            0.9968873858451843,
            0.995588481426239,
            0.9954930543899536,
            0.996397852897644,
            0.9925469160079956,
            0.9967918395996094,
            0.9968590140342712,
            0.9923362731933594,
            0.9960355162620544
        ]
    },
    "3392": {
        "similarity": 0.9970042705535889,
        "body": "import sys\nfrom collections import deque\n\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n        return 0 <= i < N and 0 <= j < N\n\n    max_group_size = 0\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                group_size = 0\n                queue = deque([(i, j)])\n                visited[i][j] = True\n                heights_diff = [0]\n                while queue:\n                    x, y = queue.popleft()\n                    group_size += 1\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if is_valid(nx, ny) and not visited[nx][ny]:\n                            if heights[nx][ny] - speeds[nx][ny] <= heights_diff[-1]:\n                                queue.append((nx, ny))\n                                visited[nx][ny] = True\n                max_group_size = max(max_group_size, group_size)\n\n    return max_group_size\n\nN = int(input())\nheights = []\nspeeds = []\nfor _ in range(N):\n    line = list(map(int, input().split()))\n    heights.append(line)\nfor _ in range(N):\n    line = list(map(int, input().split()))\n    speeds.append(line)\nprint(max_connected_group(N, heights, speeds))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960955381393433,
            0.996606707572937,
            0.9966382384300232,
            0.9970042705535889,
            0.9949412941932678,
            0.9956993460655212,
            0.9962856769561768,
            0.9963436126708984,
            0.9964197874069214,
            0.9955207705497742,
            0.9963591694831848,
            0.9949672222137451,
            0.996436357498169,
            0.9962443113327026,
            0.9956079125404358,
            0.9961410164833069,
            0.9959568381309509,
            0.9966564178466797,
            0.9959403872489929,
            0.9947280883789062
        ]
    },
    "3095": {
        "similarity": 0.9973642230033875,
        "body": "import sys\n\n    R = len(matrix)\n    S = len(matrix[0])\n    max_elements = 0\n    for r in range(2, R + 1):\n        for s in range(2, S + 1):\n            is_cool = True\n            for i in range(R - r + 1):\n                for j in range(S - s + 1):\n                    submatrix_sum = sum(sum(matrix[i+k][j:j+s]) for k in range(r))\n                    if (i == 0 and j == 0) or (submatrix_sum > matrix[0][s] + matrix[r][0]):\n                        is_cool = False\n                        break\n                if not is_cool:\n                    break\n            if is_cool:\n                max_elements = max(max_elements, r * s)\n    return max_elements\n\nR, S = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(R)]\nprint(count_extremely_cool_submatrices(matrix))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966932535171509,
            0.9965838193893433,
            0.9962218403816223,
            0.9962660074234009,
            0.9957565665245056,
            0.9963114857673645,
            0.996306300163269,
            0.9952308535575867,
            0.9924432635307312,
            0.9965435862541199,
            0.9961140155792236,
            0.996812105178833,
            0.9967650175094604,
            0.993782639503479,
            0.996453046798706,
            0.9973642230033875,
            0.9968652129173279,
            0.9962248802185059,
            0.9970701336860657,
            0.9961381554603577
        ]
    },
    "3769": {
        "similarity": 0.9971795678138733,
        "body": "import sys\n\n    p, k = map(int, input().split())\n    mod = 10**9 + 7\n    if k == 0:\n        return 1 % mod\n    res = pow(k, p, mod)\n    for x in range(2, p):\n        if (x * k) % p not in [i * k % p for i in range(p)]:\n            res = (res * pow(x, mod - 2, mod)) % mod\n    return res\n\nprint(count_distinct_functions())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947738647460938,
            0.9962090253829956,
            0.9943712949752808,
            0.9960676431655884,
            0.9959636330604553,
            0.9960777759552002,
            0.9934960603713989,
            0.9970220327377319,
            0.9968651533126831,
            0.9965794086456299,
            0.9902824759483337,
            0.9962493777275085,
            0.9964686036109924,
            0.996551513671875,
            0.9969598650932312,
            0.9960317015647888,
            0.9966327548027039,
            0.9970767498016357,
            0.9932091236114502,
            0.9971795678138733
        ]
    },
    "3563": {
        "similarity": 0.9955424070358276,
        "body": "    n = int(input())\n    holes = list(map(int, input().split()))[:n * 2]\n\n    lines = 0\n    leftmost = float('inf')\n    stack = []\n\n    for i in range(0, len(holes) - 1, 2):\n        x, y = holes[i:i+2]\n        if x < leftmost:\n            while len(stack) >= 2 and (stack[-1][0] == x or stack[-2][0] == x):\n                last_x, _ = stack.pop()\n                _, prev_y = stack[-1] if stack else (-1, -1)\n                lines += abs(y - prev_y) != abs(y - _)\n            leftmost = x\n        stack.append((x, y))\n\n    while len(stack) >= 2:\n        last_x, _ = stack.pop()\n        _, prev_y = stack[-1] if stack else (-1, -1)\n        lines += abs(prev_y - _) != abs(prev_y - _)\n\n    return lines\n\nprint(min_lines())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9893349409103394,
            0.9949172139167786,
            0.9934560060501099,
            0.9955424070358276,
            0.9941177368164062,
            0.9943310618400574,
            0.9939765930175781,
            0.9893792867660522,
            0.99480801820755,
            0.9952217936515808,
            0.9944365620613098,
            0.994146466255188,
            0.9934331178665161,
            0.9953060150146484,
            0.9949974417686462,
            0.994110643863678,
            0.9937575459480286,
            0.9938859343528748,
            0.9947503805160522,
            0.9893760681152344
        ]
    },
    "3618": {
        "similarity": 0.9968289732933044,
        "body": "import sys\n\n    MOD = 998244353\n    max_val = 9 * (10 ** n) - 1\n    dp = [[0] * n for _ in range(max_val + 2)]\n    for i in range(10, max_val + 1):\n        dp[i][i % n] = 1\n\n    for i in range(10, max_val + 1):\n        for j in range(n - 1):\n            last_digit = (i // 10 ** j) * 9\n            if i < last_digit:\n                continue\n            dp[last_digit][(j + 2) % n] += dp[i][j]\n            current_digit = (last_digit // 10 ** (j + 1)) * 9 + 1\n            if current_digit == last_digit and j > 0:\n                continue\n            dp[current_digit][(j + 1) % n] += dp[i][j]\n\n    return sum(dp[10 ** i - 1][i % n] for i in range(n)) % MOD\n\nn = int(input())\nprint(get_best_friend_pairs(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967836141586304,
            0.9967358112335205,
            0.9963203072547913,
            0.9963967204093933,
            0.9931822419166565,
            0.9954702258110046,
            0.9938451647758484,
            0.9952502846717834,
            0.995941698551178,
            0.9956666231155396,
            0.9963259696960449,
            0.9965243935585022,
            0.9963864088058472,
            0.9929470419883728,
            0.996734619140625,
            0.996811032295227,
            0.9965619444847107,
            0.9964773058891296,
            0.9968289732933044,
            0.9958750009536743
        ]
    },
    "3830": {
        "similarity": 0.9963594675064087,
        "body": "    n = int(input())\n    s = input()\n\n    directions = []\n    for i in range(n):\n        if s[i] == '>':\n            directions.append((1, 0))\n        elif s[i] == '<':\n            directions.append((-1, 0))\n\n    can_enter = [False]*n\n    can_exit = [False]*n\n\n    direction = 0\n    for i in range(n):\n        if can_enter[i]:\n            continue\n        j = (i + n - direction) % n\n        if (direction == 0 or directions[j][0] != 0) and s[j] == '-':\n            can_exit[i] = True\n\n        k = (j + n - direction) % n\n        if can_enter[k]:\n            continue\n        if directions[j][0] != 0 and s[k] == '-':\n            can_enter[j] = True\n\n    return sum(1 for i in range(n) if can_exit[i])\n\nt = int(input())\nfor _ in range(t):\n    print(count_returnable_rooms())",
        "result": "failed: testcase 0",
        "similarities": [
            0.994900643825531,
            0.9957325458526611,
            0.9940645098686218,
            0.9930829405784607,
            0.993904709815979,
            0.994003176689148,
            0.9963405132293701,
            0.9963594675064087,
            0.9952537417411804,
            0.9927197694778442,
            0.9931493997573853,
            0.9955251812934875,
            0.9961801171302795,
            0.9961901307106018,
            0.9955261945724487,
            0.9936725497245789,
            0.9944403767585754,
            0.9956446290016174,
            0.9961957335472107,
            0.9922353029251099
        ]
    },
    "3912": {
        "similarity": 0.9963417053222656,
        "body": "import sys\nfrom collections import Counter\n\n    n = len(s)\n    counts = Counter(s)\n    odd_count = 0\n    for count in counts.values():\n        if count % 2 != 0:\n            odd_count += 1\n\n    if odd_count > 1:\n        return -1, []\n\n    length = (n + odd_count) // (odd_count + 2)\n    palindrome_length = length * 2\n\n    first_half = []\n    second_half = []\n    for char in s:\n        if len(first_half) < palindrome_length // 2:\n            first_half.append(char)\n        else:\n            second_half.append(char)\n\n    result = [''.join(first_half[i:i + palindrome_length // 2]) +\n              ''.join(second_half[i:i + palindrome_length // 2])[::-1] for i in range(palindrome_length)]\n\n    return len(result), result\n\nn = int(input())\ns = input()\nk, result = rearrange_string(s)\nprint(k)\nprint(' '.join(result))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945922493934631,
            0.9953250885009766,
            0.9957223534584045,
            0.9963183999061584,
            0.9932400584220886,
            0.9957954287528992,
            0.9950774312019348,
            0.9963417053222656,
            0.9956758618354797,
            0.987778902053833,
            0.9955403208732605,
            0.9945247173309326,
            0.9953258037567139,
            0.9954733848571777,
            0.99560546875,
            0.9928245544433594,
            0.9953646659851074,
            0.9949971437454224,
            0.99462890625,
            0.995276689529419
        ]
    },
    "3878": {
        "similarity": 0.9978614449501038,
        "body": "import sys\n\n    n = int(input())\n    m = int(input().split()[1])\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        edges[u].append(v)\n        edges[v].append(u)\n\n    visited = [0] * n\n    degrees = [len(edges[i]) - 1 for i in range(n)]\n    queue = []\n    max_degrees = [-1] * (n + 1)\n    selected_guests = []\n\n    for u in range(n):\n        if degrees[u] > max_degrees[degrees[u]]:\n            max_degrees[degrees[u]] = degrees[u]\n            queue.append((u, u))\n\n    step_count = 0\n    while queue:\n        selected_guests.extend([guest[1] + 1 for guest in queue])\n        for i in range(len(queue)):\n            u, guest_index = queue.pop(0)\n            visited[u] = 1\n\n            for v in edges[u]:\n                if not visited[v]:\n                    degrees[v] -= 1\n                    max_degrees[degrees[v]] = max(max_degrees[degrees[v]], degrees[v])\n\n                    if degrees[v] > 0:\n                        queue.append((v, guest_index))\n                    elif degrees[v] == 0:\n                        selected_guests.append(guest_index + 1)\n                        step_count += 1\n        step_count -= 1\n\n    print(step_count)\n    for i in range(len(selected_guests) - 1):\n        sys.stdout.write(str(selected_guests[i]) + ' ')\n    sys.stdout.write(str(selected_guests[-1]))\n\nmin_steps()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975930452346802,
            0.9971129894256592,
            0.9977850914001465,
            0.9975807666778564,
            0.9973042011260986,
            0.9978614449501038,
            0.997536301612854,
            0.9974774718284607,
            0.9977896809577942,
            0.9968814849853516,
            0.9968329071998596,
            0.9973288178443909,
            0.9974449872970581,
            0.997599184513092,
            0.9976212382316589,
            0.9977221488952637,
            0.9971401691436768,
            0.9959967732429504,
            0.9975730776786804,
            0.9977289438247681
        ]
    },
    "3010": {
        "similarity": 0.9966926574707031,
        "body": "    points = set()\n    for _ in range(n):\n        x0, y0, x1, y1 = map(int, input().split())\n        if x0 == x1 or y0 == y1:\n            continue\n        m0, c0 = (y0 - y1) / (x0 - x1), y0 - m0 * x0\n        for _ in range(n):\n            x2, y2, x3, y3 = map(int, input().split())\n            if x2 == x3 or y2 == y3:\n                continue\n            m1, c1 = (y2 - y3) / (x2 - x3), y2 - m1 * x2\n            if m0 == m1 and (c0 - c1) != 0:\n                p_x = -(c0 - c1) / (m0 - m1)\n                p_y = m0 * p_x + c0\n                points.add((p_x, p_y))\n    return len(points) if points else -1\n\nprint(intersecting_points(int(input())))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960311055183411,
            0.9940105080604553,
            0.9956051707267761,
            0.9957985281944275,
            0.9962411522865295,
            0.9966842532157898,
            0.9962077736854553,
            0.9963053464889526,
            0.9963847994804382,
            0.988513171672821,
            0.9949509501457214,
            0.995486319065094,
            0.9958903789520264,
            0.9963170289993286,
            0.9964267611503601,
            0.9958383440971375,
            0.9960296154022217,
            0.9963133931159973,
            0.9963775277137756,
            0.9966926574707031
        ]
    },
    "3068": {
        "similarity": 0.9965027570724487,
        "body": "    N = int(input())\n    if N == 0:\n        return 2600\n    suspects = set(chr(i) for i in range(65, 91))\n    circles = 0\n    investigations = [tuple(map(str, input().split())) for _ in range(N)]\n    for suspect1, suspect2, player, reply in investigations:\n        if int(reply) == 0:\n            suspects -= {suspect1, suspect2}\n        elif int(reply) == 1:\n            if player == '1':\n                suspects.discard(suspect1)\n                suspects.discard(suspect2)\n            else:\n                suspects -= {suspect1, suspect2} - suspects\n        else:\n            if player == '1':\n                suspects &= {suspect1, suspect2}\n            else:\n                suspects = {suspect1, suspect2} & suspects\n    for suspect1 in sorted(list(suspects)):\n        for suspect2 in sorted(list(suspects - {suspect1}))[:]:\n            for suspect3 in sorted(list(suspects - {suspect1, suspect2})):\n                admissible = True\n                for suspect4, suspect5, player, reply in investigations:\n                    count = int(reply)\n                    if count == 0 and {suspect4, suspect5} & {suspect1, suspect2, suspect3} != set():\n                        continue\n                    elif count == 1 and (player == '1' and suspect4 not in {suspect1, suspect2, suspect3}) or \\\n                         (player == '2' and suspect4 in {suspect1, suspect2, suspect3}):\n                        continue\n                    elif count == 2 and (player == '1' and {suspect4, suspect5} != {suspect1, suspect2, suspect3}) or \\\n                         (player == '2' and {suspect4, suspect5} == {suspect1, suspect2, suspect3}):\n                        continue\n                    admissible = False\n                if admissible:\n                    circles += 1\n    return circles\n\nprint(count_admissible_solutions())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950460195541382,
            0.9933375120162964,
            0.996042788028717,
            0.9952932596206665,
            0.9964068531990051,
            0.9951601624488831,
            0.9920017719268799,
            0.9958444237709045,
            0.9958720803260803,
            0.9945429563522339,
            0.9961028695106506,
            0.9946233630180359,
            0.9957546591758728,
            0.9959642291069031,
            0.9951997399330139,
            0.9949418902397156,
            0.9914795756340027,
            0.995009183883667,
            0.9965027570724487,
            0.9963383078575134
        ]
    },
    "3030": {
        "similarity": 0.9970324635505676,
        "body": "    n = int(input())\n    values = [0] * (n + 1)\n    parents = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        v, p = map(int, input().split())\n        values[i] = v\n        parents[i] = p\n\n    count = [0] * (n + 1)\n    max_count = 0\n\n    for node in range(n, 0, -1):\n        parent = parents[node]\n        if node == 1 or values[parent] <= values[node]:\n            continue\n\n        i = node\n        while True:\n            count[i] += 1\n            if i == 1:\n                break\n            i = parents[i]\n\n        max_count = max(max_count, sum(count[1:]))\n\n    return max_count + (count[1] > 0)\n\nprint(max_heap_nodes())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962576627731323,
            0.9967374205589294,
            0.9951952695846558,
            0.9962654113769531,
            0.997015118598938,
            0.9927510023117065,
            0.9965108633041382,
            0.9964197874069214,
            0.9969530701637268,
            0.9965949058532715,
            0.996016263961792,
            0.9954984784126282,
            0.9942476153373718,
            0.9952804446220398,
            0.9946237206459045,
            0.9964824318885803,
            0.9969781637191772,
            0.9964619874954224,
            0.996683657169342,
            0.9970324635505676
        ]
    },
    "3630": {
        "similarity": 0.9949436187744141,
        "body": "    n = len(s1)\n    cost = [[0] * 26 for _ in range(n)]\n    moves = 0\n\n    for i in range(n - 1, -1, -1):\n        shift = ord(s2[i]) - ord('a')\n        min_cost = float('inf')\n\n        for j in range(26):\n            cost_i_j = cost[i + 1][j] if i + 1 < n else 0\n\n            if 'z' not in s1[i:i + 1 + shift - j]:\n                min_cost = min(min_cost, cost_i_j + abs(shift - j))\n            if 'a' not in s1[i:i + 1 + shift - j]:\n                min_cost = min(min_cost, cost_i_j + abs(shift - (j + 26)))\n\n        moves += min_cost\n        for j in range(26):\n            cost[i][j] = min_cost if 'z' not in s1[i:i + 1 + shift - j] else float('inf')\n\n    return moves\n\ns1, s2 = input().split()\nprint(min_moves(s1, s2))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943900108337402,
            0.9937293529510498,
            0.9936954975128174,
            0.9797955751419067,
            0.9926950335502625,
            0.9934315085411072,
            0.994647204875946,
            0.9935876727104187,
            0.994434654712677,
            0.9949436187744141,
            0.9947216510772705,
            0.9939792156219482,
            0.9899623394012451,
            0.9940794706344604,
            0.9938017129898071,
            0.9928857684135437,
            0.9939761757850647,
            0.9934161305427551,
            0.9932563304901123,
            0.9928390383720398
        ]
    },
    "3133": {
        "similarity": 0.9962927103042603,
        "body": "    n, a, b = map(int, input().split())\n    graph = []\n    for i in range(n):\n        l, r, t = map(int, input().split())\n        graph.append([l, r, t])\n\n        if node == 0:\n            return [turn_count]\n        if node in visited or graph[node][2] != 1:\n            return []\n        visited.add(node)\n        left_result = dfs(graph[node][0], turn_count + 1, visited.copy())\n        right_result = dfs(graph[node][1], turn_count + 1, visited.copy())\n        return left_result if left_result else right_result\n\n    a_path = dfs(a - 1, 0, set())\n    b_path = dfs(b - 1, 0, set())\n\n    for i in range(min(len(a_path), len(b_path))):\n        if graph[a_path[i] - 1][2] == 1 and graph[b_path[i] - 1][2] != 1:\n            print(i + 1)\n            return\n        elif graph[a_path[i] - 1][2] != 1 and graph[b_path[i] - 1][2] == 1:\n            print(i + 1)\n            return\n\n    print(\"indistinguishable\")\n\ncalculate_min_turns()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930318593978882,
            0.9961234927177429,
            0.9962635040283203,
            0.9960774779319763,
            0.994565486907959,
            0.9953828454017639,
            0.9954257607460022,
            0.9962927103042603,
            0.9952725172042847,
            0.994803786277771,
            0.9940193891525269,
            0.9954379200935364,
            0.996071457862854,
            0.9940584897994995,
            0.9957458972930908,
            0.9957802295684814,
            0.9958321452140808,
            0.9914870262145996,
            0.9957355856895447,
            0.9942296743392944
        ]
    },
    "3480": {
        "similarity": 0.9978480935096741,
        "body": "import sys\n\n    lines = []\n    delays = []\n\n    for _ in range(L):\n        line1 = input().strip()\n        syllables = line1.split()\n\n        line2 = input().split()\n        time_units = list(map(int, line2))\n\n        start_time = 0\n        for i in range(len(syllables)):\n            lines.append((syllables[i], start_time))\n            delays.append(time_units[i])\n            start_time += time_units[i]\n\n    result = []\n    start_line = 0\n    for i in range(L):\n        line1 = ''\n        line2 = ''\n\n        delay_index = D // 16 * 4 + (D % 16) // 4\n\n        current_time = delays[delay_index]\n        index = delay_index\n        while current_time > start_line and index < len(delays):\n            syllable, time = lines[index]\n\n            if time <= current_time:\n                line1 += '_' * (current_time - time)\n                line2 += syllable + '_'\n\n                for j in range(index + 1, min(len(lines), index + 16)):\n                    syllable2, time2 = lines[j]\n                    if time2 > current_time:\n                        break\n                    diff = time2 - current_time\n                    line2 += '_' * (diff) + syllable2 + '_'\n            else:\n                line1 += syllable + '___'\n\n            start_line += delays[delay_index]\n            index += 1\n\n        result.append(line1)\n        if line2 != '':\n            result.append(line2[:-1])\n        else:\n            result.append('/')\n\n    for line in result:\n        print(line)\n\ndisplay_round(int(input().split()[0]), int(input().split()[1]))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974887371063232,
            0.9974247813224792,
            0.997035562992096,
            0.9964353442192078,
            0.9973036050796509,
            0.9974376559257507,
            0.9973238706588745,
            0.9978480935096741,
            0.9964423179626465,
            0.9975571036338806,
            0.9965858459472656,
            0.9969924092292786,
            0.9955722689628601,
            0.9973204731941223,
            0.9969334006309509,
            0.9970352053642273,
            0.9976968169212341,
            0.9970765709877014,
            0.9975253939628601,
            0.9937762022018433
        ]
    },
    "3389": {
        "similarity": 0.9955793023109436,
        "body": "from collections import defaultdict\nimport sys\n\n    n, k = map(int, input().split())\n    types = input()\n    groups = defaultdict(list)\n    for i in range(n):\n        groups[types[i]].append(i + 1)\n\n    clicks = 0\n    prev_group = None\n    for group_type, indices in groups.items():\n        if len(indices) <= 1:\n            continue\n\n        clicks += 1\n\n        if not prev_group or len(groups[prev_group]) == 1:\n            pass\n        elif max(indices) > max([i for i in groups[prev_group] if i < max(indices)]):\n            clicks += 1\n\n        prev_group = group_type\n\n    print(clicks)\n\nmin_clicks()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942365288734436,
            0.990871250629425,
            0.9953011870384216,
            0.9930241107940674,
            0.9949356913566589,
            0.9927608966827393,
            0.9886521100997925,
            0.9940491914749146,
            0.9934543967247009,
            0.9886609315872192,
            0.9929912090301514,
            0.9940111041069031,
            0.9935682415962219,
            0.9909854531288147,
            0.9950698018074036,
            0.9955793023109436,
            0.9939842224121094,
            0.9938669800758362,
            0.9934171438217163,
            0.9947141408920288
        ]
    },
    "3925": {
        "similarity": 0.9953852295875549,
        "body": "    max_len = 0\n    n = len(s)\n    for i in range(n):\n        black_count = white_count = 0\n        for j in range(i, n):\n            if s[j] == 'b':\n                black_count += 1\n            else:\n                white_count += 1\n            if (black_count > 0 and white_count <= black_count) or \\\n               (white_count > 0 and black_count <= white_count):\n                max_len = max(max_len, min(black_count, white_count) * 2)\n    return max_len\n\ns = input().strip()\nprint(longest_zebra(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943699240684509,
            0.994240403175354,
            0.9953852295875549,
            0.9952499270439148,
            0.9950636625289917,
            0.9944400787353516,
            0.9903853535652161,
            0.9876062273979187,
            0.9928275942802429,
            0.9939306378364563,
            0.9941847920417786,
            0.9926440715789795,
            0.993253231048584,
            0.9943703413009644,
            0.9896036386489868,
            0.9944350719451904,
            0.9952632784843445,
            0.9952161908149719,
            0.9920991659164429,
            0.9942185282707214
        ]
    },
    "3700": {
        "similarity": 0.9962140321731567,
        "body": "import sys\n\n    num_ways = 0\n    i = 1\n    while i <= n:\n        if 2 * i <= k and k - 2 * i < n:\n            j_max = (k - 2 * i) // 1\n            if j_max >= i:\n                num_ways += (j_max - i + 1)\n        i += 1\n    return num_ways\n\nn, k = map(int, input().split())\nprint(calculate_ways(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942666292190552,
            0.9912453889846802,
            0.9952763319015503,
            0.9919052124023438,
            0.9956754446029663,
            0.9952903389930725,
            0.9947130084037781,
            0.9949565529823303,
            0.9960046410560608,
            0.9951523542404175,
            0.9932718873023987,
            0.9944519400596619,
            0.995430588722229,
            0.9951949119567871,
            0.9962140321731567,
            0.988230288028717,
            0.9930174946784973,
            0.9926679730415344,
            0.9949309825897217,
            0.9956494569778442
        ]
    },
    "3944": {
        "similarity": 0.99567049741745,
        "body": "import sys\nmod = 10**9 + 7\n\n    N, M, K = map(int, input().split())\n    dp0 = [1]\n    for n in range(1, N+1):\n        dp0_new = []\n        for i in range(n+1):\n            if i == 0:\n                dp0_new.append((dp0[i] * (M + K)) % mod)\n            else:\n                dp0_new.append(((3 * (M + K) - 2 * i + 1) * dp0[i-1]) % mod)\n        dp0 = dp0_new\n    ans = sum(dp0) % mod\n    for n in range(N+1):\n        for m in range(M+1):\n            if n + m < N:\n                ans += (dp0[n] * (K - m)) % mod\n    return ans\n\nprint(card_game())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9923856854438782,
            0.9932839274406433,
            0.9946736693382263,
            0.995243489742279,
            0.9882681965827942,
            0.9954702258110046,
            0.9916014671325684,
            0.9946464896202087,
            0.9947354197502136,
            0.9936294555664062,
            0.9915083646774292,
            0.9952406883239746,
            0.9918472766876221,
            0.9946575164794922,
            0.9952860474586487,
            0.994789719581604,
            0.9944323301315308,
            0.99567049741745,
            0.9950932860374451,
            0.9948350787162781
        ]
    },
    "3821": {
        "similarity": 0.9964343905448914,
        "body": "    max_prob = 0\n    for i in range(1, n + 1):\n        prob = 0\n        for j in range(i):\n            prob += p[j] * (p[i] - p[j])\n        for k in range(i, n):\n            prob *= (1 - p[k])\n        max_prob = max(max_prob, prob)\n    return max_prob\n\nn = int(input())\np = [float(x) for x in input().split()]\nprint(max_prob(n, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964343905448914,
            0.9947003722190857,
            0.9960955381393433,
            0.9948348999023438,
            0.9954831004142761,
            0.9954521059989929,
            0.9948337078094482,
            0.9918050169944763,
            0.9944016337394714,
            0.9928285479545593,
            0.9918496012687683,
            0.9956603050231934,
            0.9911300539970398,
            0.9956450462341309,
            0.9942570924758911,
            0.9956958293914795,
            0.9959809184074402,
            0.9955716729164124,
            0.991420328617096,
            0.995350182056427
        ]
    },
    "3667": {
        "similarity": 0.9966059327125549,
        "body": "import sys\n\n    w, p = map(int, input().split())\n    wells = []\n    pipes = []\n    for i in range(w):\n        x, y = map(int, input().split())\n        wells.append((x, y))\n    for _ in range(p):\n        s, x, y = map(int, input().split())\n        pipes.append(((s-1, x, y), set()))\n    return w, p, wells, pipes\n\n    n = len(wells)\n    edges = []\n    for pipe in pipes:\n        i = 0\n        while i < n and (wells[i][0] == pipe[0][0] or wells[i][1] == pipe[0][2]):\n            if (pipe[0][0], wells[i][1]) == (pipe[0][2], pipe[0][3]):\n                if not pipe[1]:\n                    pipes[pipes.index(pipe)][1].add(i)\n            i += 1\n        for j in range(n):\n            if wells[j] != pipe[0]:\n                x = (wells[j][0] - pipe[0][2]) * (pipe[0][3] - pipe[0][1])\n                y = (pipe[0][2] - wells[j][1]) * (wells[j][0] - pipe[0][0])\n                if x < y:\n                    edges.append((j, i))\n    return edges\n\n    for j in edges[i]:\n        if not visited[j]:\n            visited[j] = True\n            dfs(j, visited, pipes)\n            if len(pipes[j]) > 1:\n                return False\n    return True\n\nw, p, wells, pipes = read_input()\nedges = add_edge(wells, pipes)\n\npossible = True\nvisited = [False]*len(edges)\nfor i in range(len(edges)):\n    if not visited[i]:\n        visited[i] = True\n        for pipe in pipes[edges[i][0]]:\n            if len(pipe) > 1:\n                possible = False\n        if dfs(i, visited, pipes):\n            continue\n        possible = False\n\nprint('possible' if possible else 'impossible')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965733885765076,
            0.9943935871124268,
            0.9964694976806641,
            0.9966059327125549,
            0.9959801435470581,
            0.9961752891540527,
            0.996486246585846,
            0.9964587688446045,
            0.9944786429405212,
            0.9964706301689148,
            0.9953454732894897,
            0.995926022529602,
            0.9935693144798279,
            0.991890549659729,
            0.9964340925216675,
            0.9964919686317444,
            0.9964705109596252,
            0.9960915446281433,
            0.995069682598114,
            0.9949238300323486
        ]
    },
    "3959": {
        "similarity": 0.9972445964813232,
        "body": "    import sys\n    MOD = 10**9 + 7\n\n    n, m = map(int, input().split())\n    gym_counts = []\n    for _ in range(n):\n        g = list(map(int, input().split()))\n        types = {}\n        for t in g[1:]:\n            if t not in types:\n                types[t] = 0\n            types[t] += 1\n        count = [types[t] for t in sorted(types.keys())]\n        gym_counts.append(count)\n\n    total_pokemon_count = sum(sum(g) for g in gym_counts)\n    pokemon_type_counts = {}\n    for g in gym_counts:\n        for i, count in enumerate(g):\n            if i not in pokemon_type_counts:\n                pokemon_type_counts[i] = 0\n            pokemon_type_counts[i] += count\n\n    factorials = [1]\n    for i in range(1, m+1):\n        factorials.append((factorials[-1] * i) % MOD)\n\n    denominator = 1\n    for v in pokemon_type_counts.values():\n        if v != total_pokemon_count:\n            return \"0\"\n        denominator *= factorials[v]\n\n    numerator = 1\n    for i in range(m):\n        numerator *= (factorials[pokemon_type_counts[i]] - 1)\n\n    result = (numerator * pow(denominator, MOD-2, MOD)) % MOD\n    print(result)\n\ncount_evolution_plans()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957482218742371,
            0.9970060586929321,
            0.9965550303459167,
            0.9971568584442139,
            0.9970871806144714,
            0.9962790608406067,
            0.9972445964813232,
            0.9963845014572144,
            0.9970321655273438,
            0.9959213137626648,
            0.9859894514083862,
            0.9970263242721558,
            0.9969356060028076,
            0.997242271900177,
            0.9966264367103577,
            0.9970375895500183,
            0.9969335794448853,
            0.9968701601028442,
            0.9965732097625732,
            0.9946175813674927
        ]
    },
    "3692": {
        "similarity": 0.9965764284133911,
        "body": "import sys\n\n    n = int(input())\n    circles = []\n    for i in range(n):\n        x, y, r = map(int, input().split())\n        circles.append((x, y, r))\n    circles.sort()\n\n    visited = [False] * n\n    regions = 0\n\n    for i in range(n):\n        x, y, r = circles[i]\n        if not visited[i]:\n            stack = [(x, y)]\n            while stack:\n                curr_x, curr_y = stack.pop()\n                for j in range(i + 1, n):\n                    next_x, next_y, next_r = circles[j]\n                    dx = abs(next_x - curr_x)\n                    dy = abs(next_y - curr_y)\n                    if dx * dx + dy * dy <= (r + next_r) * (r + next_r):\n                        stack.extend([(next_x, next_y)])\n                        visited[j] = True\n            regions += 1\n\n    return regions + 1\n\nprint(count_regions())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964445233345032,
            0.9944402575492859,
            0.9941534996032715,
            0.9958145618438721,
            0.9963302612304688,
            0.9964507222175598,
            0.9960877299308777,
            0.996134340763092,
            0.9962911009788513,
            0.9957235455513,
            0.9953517913818359,
            0.996242344379425,
            0.995802640914917,
            0.9965764284133911,
            0.9950934052467346,
            0.9947530031204224,
            0.9946466088294983,
            0.986383318901062,
            0.9961403608322144,
            0.9952701926231384
        ]
    },
    "3894": {
        "similarity": 0.9963312745094299,
        "body": "import sys\n    odd = 0\n    even = []\n    for i in range(n):\n        if a[i] % 2 == 1:\n            odd += 1\n        else:\n            even.append(a[i])\n    even.sort(reverse=True)\n    total_cows = sum(a)\n    moves = (total_cows + 1) // 2 - 1\n    for i in range(len(even)):\n        if even[i] >= k * 2 and moves > 0:\n            moves -= even[i] // 2\n            even[i] %= 2\n    if sum(even) % 2 == 1 or moves < len(even):\n        return \"Kevin\"\n    else:\n        return \"Nicky\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(get_winner(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947688579559326,
            0.9924900531768799,
            0.9920503497123718,
            0.9949477314949036,
            0.9936366677284241,
            0.9960263967514038,
            0.9939701557159424,
            0.9947969317436218,
            0.9932224750518799,
            0.9957655072212219,
            0.994205892086029,
            0.9916046857833862,
            0.9963312745094299,
            0.9935158491134644,
            0.9957690834999084,
            0.9939337372779846,
            0.9949295520782471,
            0.9949798583984375,
            0.9958705902099609,
            0.9934708476066589
        ]
    },
    "3856": {
        "similarity": 0.997374415397644,
        "body": "import sys\n\n    n = int(input())\n    areas = []\n    for _ in range(n):\n        w, h = map(int, input().split())\n        if w < h:\n            areas.append((w, h))\n        else:\n            areas.append((h, w))\n    areas.sort(key=lambda x: x[0])\n    n_half = n // 2\n    total_width = sum(areas[:n_half][i][0] for i in range(n_half))\n    total_height = max(areas[i][1] for i in range(n_half))\n\n    return total_width * total_height\n\nprint(min_photo_area())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964773058891296,
            0.9966090321540833,
            0.9968292117118835,
            0.9962727427482605,
            0.997374415397644,
            0.9949800372123718,
            0.995071291923523,
            0.9964311718940735,
            0.9938037395477295,
            0.9957982897758484,
            0.997089684009552,
            0.9956963062286377,
            0.9956450462341309,
            0.9963706135749817,
            0.9969866871833801,
            0.9946457743644714,
            0.9961963295936584,
            0.9965910911560059,
            0.9957717061042786,
            0.9970323443412781
        ]
    },
    "3282": {
        "similarity": 0.9964715838432312,
        "body": "    P = int(input())\n    possible_bills = []\n    digits = [str(i) for i in range(1, 10)]\n    for beverage_price in range(1, P + 1):\n        for main_dish_price in range(beverage_price + 1, P + 1):\n            total_price = beverage_price + main_dish_price\n            if total_price > P:\n                break\n            digit_set = set()\n            if set(str(beverage_price)) & set(str(main_dish_price)):\n                continue\n            if set(str(beverage_price)) | set(str(total_price)) == set(str(main_dish_price)):\n                continue\n            possible_bills.append((beverage_price, main_dish_price))\n    possible_bills.sort()\n    print(len(possible_bills))\n    for i in range(min(5000, len(possible_bills))):\n        print(*possible_bills[i], sep=' ')\n\ncount_free_desserts()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960342049598694,
            0.9940257668495178,
            0.9954758882522583,
            0.9924708008766174,
            0.9956313967704773,
            0.9946114420890808,
            0.9936575889587402,
            0.9953122735023499,
            0.9948897361755371,
            0.9964174032211304,
            0.9951873421669006,
            0.9959405660629272,
            0.9957178831100464,
            0.9919467568397522,
            0.9958524107933044,
            0.9942237734794617,
            0.9963470101356506,
            0.9964715838432312,
            0.9950267672538757,
            0.9917558431625366
        ]
    },
    "3596": {
        "similarity": 0.9968318939208984,
        "body": "    a, b, c = map(float, input().split())\n    t1, t2, t3, t4 = map(int, input().split())\n    n, k, r, s, l = map(int, input().split())\n\n        gamma_x = 0\n        for i in range(1000): # approximation for Gamma(z)\n            gamma_x += (x**i) / math.factorial(i+1)\n        erf_x = 2 / math.sqrt(math.pi) * sum(((-1)**j) * (x**(2*j+1)) / math.factorial(2*j+1) for j in range(100))\n        J_k_x = 0\n        for i in range(100):\n            J_k_x += (math.cos(k*i - x*math.sin(i))) / math.pi\n        return t1 * gamma_x + ((t2**-1) * math.log(erf_x))**(0.5) - (J_k_x ** t4)\n\n        result = 0\n        for i in range(r+1):\n            result += (((f(i / (r+n))) / math.factorial(i)) * x**i)\n        return result\n\n        p = P(0, s, r+s)\n        for _ in range(s + 1):\n            p = P(p, s, r+s)\n        return p.derivative().eval(n)\n\n    return str(((g(l) + l)**2 / (math.pi * math.e)) + (1/(l+1)))[:7]",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958450198173523,
            0.990472674369812,
            0.9951101541519165,
            0.995810866355896,
            0.9955283999443054,
            0.9968318939208984,
            0.9943141937255859,
            0.9954478740692139,
            0.996730387210846,
            0.9962056875228882,
            0.995267391204834,
            0.9947753548622131,
            0.9953428506851196,
            0.9951595664024353,
            0.9965883493423462,
            0.9903861880302429,
            0.9958541393280029,
            0.9957100749015808,
            0.9960699677467346,
            0.9948015809059143
        ]
    },
    "3540": {
        "similarity": 0.9948451519012451,
        "body": "from collections import deque\n\n    colors = ['R', 'G', 'B', 'Y']\n    queue = deque([(grid, 0)])\n    visited = set()\n\n    while queue:\n        state, moves = queue.popleft()\n        \n        if ''.join(state).split('R')[1].split('G')[0] == '':\n            return moves\n\n        key = tuple(state)\n\n        if key in visited:\n            continue\n        else:\n            visited.add(key)\n\n        for color in colors:\n            new_state = list(state)\n\n            # horizontal moves\n            for i, char in enumerate(new_state):\n                if char != color and (i == 0 or new_state[i - 1] == color) and (i == len(new_state) - 1 or new_state[i + 1] != color):\n                    new_state[i], new_state[(i + 1) % 4] = new_state[(i + 1) % 4], new_state[i]\n                    queue.append((tuple(new_state), moves + 1))\n                    new_state[(i + 1) % 4], new_state[i] = new_state[i], new_state[(i + 1) % 4]\n\n            # vertical moves\n            for i in range(4):\n                if new_state[i] != color and (new_state[i - 1] == color or new_state[i - 1] == '') and (new_state[i + 3] != color or new_state[i + 3] == ''):\n                    new_state[i], new_state[(i + 1) % 4] = new_state[(i + 1) % 4], new_state[i]\n                    queue.append((tuple(new_state), moves + 1))\n                    new_state[(i + 1) % 4], new_state[i] = new_state[i], new_state[(i + 1) % 4]\n\nif __name__ == \"__main__\":\n    grid = [input().strip() for _ in range(4)]\n    print(solve_puzzle(grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934738874435425,
            0.9948451519012451,
            0.9915948510169983,
            0.993682861328125,
            0.994822084903717,
            0.9930371642112732,
            0.9917385578155518,
            0.9909740090370178,
            0.9938126802444458,
            0.9946556091308594,
            0.990456759929657,
            0.990424633026123,
            0.9943357706069946,
            0.9943318963050842,
            0.9932644367218018,
            0.9946281313896179,
            0.9932429790496826,
            0.9902454018592834,
            0.9932389855384827,
            0.9940992593765259
        ]
    },
    "3354": {
        "similarity": 0.9963472485542297,
        "body": "import math\n\n    sandwich_area = math.pi * s ** 2\n    pickle_area = math.pi * r ** 2\n    max_covered = sandwich_area * (z / 100)\n    for i in range(n + 1):\n        area_covered = pickle_area * i\n        if area_covered <= max_covered:\n            new_sandwich_radius = s - r * i\n            new_pickle_area = math.pi * new_sandwich_radius ** 2\n            if new_pickle_area >= pickle_area:\n                return i\n    return 0\n\ns, r = map(float, input().split())\nn, z = map(int, input().split())\nprint(max_pickles(s, r, n, z))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9910989999771118,
            0.990908682346344,
            0.99554842710495,
            0.9956139922142029,
            0.994688868522644,
            0.9923449158668518,
            0.9954788088798523,
            0.9949594736099243,
            0.9954233765602112,
            0.9961807727813721,
            0.9953119158744812,
            0.9945746064186096,
            0.9956032633781433,
            0.9958199262619019,
            0.990149974822998,
            0.9955841898918152,
            0.9922382235527039,
            0.9963472485542297,
            0.9950941205024719,
            0.9956774711608887
        ]
    },
    "3217": {
        "similarity": 0.9942110180854797,
        "body": "    if n == 0:\n        return 0\n\n    min_size = float('inf')\n\n    for i in range(n):\n        x1, y1, z1 = cells[i]\n        for j in range(i + 1, n):\n            x2, y2, z2 = cells[j]\n\n            max_x = max(x1, x2)\n            max_y = max(y1, y2)\n            max_z = max(z1, z2)\n\n            min_size = min(min_size, (max_x - x1 + 1) * (max_y - y1 + 1) * (max_z - z1 + 1), \n                           (max_x - x2 + 1) * (max_y - y2 + 1) * (max_z - z2 + 1))\n\n    return min_size\n\nn = int(input())\ncells = []\n\nfor _ in range(n):\n    cells.append([int(i) for i in input().split()])\n\nprint(min_panels(n, cells))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942110180854797,
            0.9918804168701172,
            0.9890233278274536,
            0.9926182627677917,
            0.9917261004447937,
            0.9910332560539246,
            0.9850842356681824,
            0.9938504099845886,
            0.9899842143058777,
            0.9930421710014343,
            0.9859277606010437,
            0.9934205412864685,
            0.9933435320854187,
            0.9931548237800598,
            0.9939656853675842,
            0.990967333316803,
            0.9926376342773438,
            0.992240309715271,
            0.9938488006591797,
            0.9915995597839355
        ]
    },
    "3520": {
        "similarity": 0.9968717694282532,
        "body": "    n, p, c = map(int, input().split())\n    pills = []\n    for _ in range(p):\n        ti, xi, yi = map(int, input().split())\n        pills.append((ti, xi, yi))\n    pills.sort()\n    max_time = 0\n    dp = [0.0] * (n + 1)\n    for i in range(n + 1):\n        time = pills[0][0]\n        if i < len(pills) and pills[i][0] <= n:\n            time = min(time, pills[i][0])\n        j = i - 1\n        while j >= 0 and (time - pills[j][0]) * 1.0 / (pills[j + 1][2] - pills[j][2]) < (n - i) * 1.0 / (pills[j + 1][2] - pills[j][2]):\n            j -= 1\n        for k in range(j, -1, -1):\n            dp[i] = max(dp[i], time + (time - pills[k][0]) * 1.0 / (pills[k + 1][2] - pills[k][2]) * (pills[k + 1][2] - pills[k][2]))\n        if i < len(pills) and pills[i][0] <= n:\n            max_time = max(max_time, dp[i] + c)\n    print('%.6f' % max_time)\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946808218955994,
            0.9950947165489197,
            0.9955452680587769,
            0.9955929517745972,
            0.994307279586792,
            0.9958628416061401,
            0.9957051873207092,
            0.9946195483207703,
            0.9955115914344788,
            0.9962549805641174,
            0.9948891401290894,
            0.9959526062011719,
            0.9960218667984009,
            0.9950027465820312,
            0.9959748983383179,
            0.9949538707733154,
            0.9953742623329163,
            0.9968717694282532,
            0.9943426251411438,
            0.9951099753379822
        ]
    },
    "3475": {
        "similarity": 0.9976112842559814,
        "body": "import sys\n\n    t, n = map(int, input().split())\n    d_min = [0] * t\n    a_max = [0] * t\n    for i in range(t):\n        d_min[i], a_max[i] = map(int, input().split())\n    distances = []\n    headings = []\n    for _ in range(n-1):\n        di, hi = map(int, input().split())\n        distances.append(di)\n        headings.append(hi)\n\n    if len(distances) == 0:\n        return \"IMPOSSIBLE\"\n\n    switches = [False] * n\n    num_switches = 0\n\n    for i in range(1, n):\n        total_distance = sum(distances[:i])\n        heading_diff = abs(headings[i-1] - headings[0])\n\n        if total_distance < d_min[0]:\n            continue\n\n        if heading_diff > a_max[0]:\n            switches[i] = True\n            num_switches += 1\n            for j in range(t):\n                if d_min[j] <= total_distance and abs(headings[i-1] - headings[i]) <= (a_max[j]/1000):\n                    break\n\n        i_prev = i\n        while i < n:\n            total_distance += distances[i]\n            heading_diff = abs(headings[i] - headings[i_prev])\n\n            if total_distance >= d_min[0]:\n                if heading_diff > a_max[0]:\n                    switches[i+1] = True\n                    num_switches += 1\n                    for j in range(t):\n                        if d_min[j] <= total_distance and abs(headings[i] - headings[i_prev]) <= (a_max[j]/1000):\n                            break\n\n            i += 1\n\n    ans = sum(1 for s in switches if s)\n    return str(ans)\n\nprint(transportation_switching_scheme())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972837567329407,
            0.9959319233894348,
            0.9976112842559814,
            0.9971281290054321,
            0.9963883757591248,
            0.9965254068374634,
            0.9971684217453003,
            0.9958640933036804,
            0.9960477948188782,
            0.9972638487815857,
            0.9969661235809326,
            0.9967774152755737,
            0.9968461394309998,
            0.9971460103988647,
            0.9967866539955139,
            0.996945858001709,
            0.9959637522697449,
            0.9961013793945312,
            0.9974071383476257,
            0.9969183206558228
        ]
    },
    "3977": {
        "similarity": 0.9954884052276611,
        "body": "import sys\n\n    gov_set = set(govs)\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        if u not in gov_set or v not in gov_set:\n            continue\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    result = 0\n    for i in range(1, n + 1):\n        if i in gov_set:\n            continue\n        neighbor_count = 0\n        for j in adj_list[i]:\n            if j not in gov_set and j != i:\n                neighbor_count += 1\n        result += max(0, (len(govs) - 1 - neighbor_count))\n\n    return result\n\nn, m, k = map(int, input().split())\ngovs = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nresult = max_edges(n, m, k, govs, edges)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927653074264526,
            0.9923752546310425,
            0.9952567219734192,
            0.9939595460891724,
            0.9954884052276611,
            0.992706835269928,
            0.9947504997253418,
            0.9933316111564636,
            0.991255521774292,
            0.9931564331054688,
            0.9913548827171326,
            0.9945060610771179,
            0.9927636384963989,
            0.9889534711837769,
            0.991073727607727,
            0.9926171898841858,
            0.9880157113075256,
            0.9894515872001648,
            0.9944646954536438,
            0.9948471784591675
        ]
    },
    "3626": {
        "similarity": 0.9969716668128967,
        "body": "import sys\n\n    n = int(input())\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        rectangles.append((x1, y1, x2, y2))\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1_i, y1_i, x2_i, y2_i = rectangles[i]\n            x1_j, y1_j, x2_j, y2_j = rectangles[j]\n            \n            if (x1_j < x2_i) and (y1_j < y2_i) and (x1_i <= x2_j) and (y1_i <= y2_j):\n                return 1\n    \n    return 0\n\nprint(intersect_rectangles())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960212707519531,
            0.9940195679664612,
            0.9944998025894165,
            0.9945905804634094,
            0.9926241636276245,
            0.9961308836936951,
            0.9961541891098022,
            0.9965177774429321,
            0.9956616163253784,
            0.9966340661048889,
            0.9969716668128967,
            0.9952378869056702,
            0.9912179708480835,
            0.9951286315917969,
            0.995308518409729,
            0.996860682964325,
            0.9963142275810242,
            0.9968104362487793,
            0.9936774373054504,
            0.994277834892273
        ]
    },
    "3584": {
        "similarity": 0.997124433517456,
        "body": "import sys\n\n    onion_coords = [[int(o.split()[0]), int(o.split()[1])] for o in onions]\n    post_coords = [[int(p.split()[0]), int(p.split()[1])] for p in fence]\n\n    hull_points = []\n        return (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\n        n = len(points)\n        leftmost = 0\n        for i in range(1, n):\n            if points[i][0] < points[leftmost][0]:\n                leftmost = i\n\n        p = leftmost\n        q = 0\n        while True:\n            hull_points.append(points[p])\n            q = (p + 1) % n\n            for i in range(n):\n                if orientation(points[p], points[i], points[q]) < 0:\n                    q = i\n            p = q\n            if p == leftmost:\n                break\n\n    convex_hull(post_coords)\n    hull_points.append(hull_points[0])\n    max_onions = 0\n    for k in range(1, K + 1):\n        on_count = 0\n        for point in hull_points:\n            if (orientation(point, hull_points[k], hull_points[0]) <= 0 and \n                orientation(point, hull_points[k - 1], hull_points[0]) <= 0):\n                on_count += 1\n        max_onions = max(max_onions, on_count)\n    return max_onions\n\n    N, M, K = [int(i) for i in input().split()]\n    onions = []\n    fence = []\n    for _ in range(N):\n        onions.append(input())\n    for _ in range(M):\n        fence.append(input())\n\n    print(greedy_onions(N, M, K, onions, fence))\n\nif __name__ == '__main__':\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961339831352234,
            0.9955149292945862,
            0.9946366548538208,
            0.9955167174339294,
            0.9966605305671692,
            0.9959115386009216,
            0.997124433517456,
            0.9953151345252991,
            0.9969667196273804,
            0.9963993430137634,
            0.9959481954574585,
            0.9960387349128723,
            0.9963061809539795,
            0.9961764812469482,
            0.9958375692367554,
            0.9961760640144348,
            0.9962602257728577,
            0.996421217918396,
            0.9951391816139221,
            0.9959489703178406
        ]
    },
    "3950": {
        "similarity": 0.9981159567832947,
        "body": "import sys\n\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    pos = [0] * (n + 1)\n    start = [q+1] * (q + 1)\n\n    for i in range(n):\n        if a[i] > 0:\n            pos[a[i]] = i\n            start[a[i]] = min(start[a[i]], i + 1)\n\n    for i in range(1, q + 1):\n        if pos[i] != 0 and (pos[i] < start[i] or start[i] > n):\n            print('NO')\n            return\n\n    last = [q+1] * (n + 1)\n    b = a[:]\n    for i in range(1, q + 1):\n        if pos[i] != 0:\n            for j in range(start[i], pos[i]+1):\n                b[j-1] = i\n                last[j-1] = max(last[j-1], i)\n\n    for i in range(n):\n        if b[i] == 0:\n            l = q + 1\n            r = -1\n\n            for j in range(1, q+1):\n                if last[j] >= i:\n                    if l == q + 1 or last[l] < last[j]:\n                        l = j\n\n            for j in range(q, l-1, -1):\n                if pos[j] > i and start[j] <= i:\n                    r = j\n                    break\n\n            if l != q + 1:\n                b[i] = l\n                for k in range(l, r+1):\n                    last[k] = max(last[k], i)\n            else:\n                print('NO')\n                return\n\n    print('YES')\n    print(*b)\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970158338546753,
            0.9977176189422607,
            0.9980481863021851,
            0.997768223285675,
            0.9968902468681335,
            0.9975876212120056,
            0.9969154000282288,
            0.9976516366004944,
            0.9981159567832947,
            0.9978844523429871,
            0.9978470206260681,
            0.9973413348197937,
            0.9978297352790833,
            0.9967038035392761,
            0.9975066781044006,
            0.9979810118675232,
            0.9979293346405029,
            0.9965563416481018,
            0.9974144697189331,
            0.9974479675292969
        ]
    },
    "3075": {
        "similarity": 0.9973983764648438,
        "body": "import sys\n\n    distances = []\n    costs = []\n\n    for _ in range(n):\n        d, c = map(int, input().split())\n        distances.append(d)\n        costs.append(c)\n\n    dp = [0] * n\n    best_gas_station = 0\n\n    for i in range(1, n):\n        min_cost_to_reach_i = float('inf')\n        for j in range(best_gas_station + 1, i + 1):\n            cost_to_travel_j_to_i = (distances[i] - distances[j]) * costs[j]\n            if dp[j-1] < g:\n                cost_to_refuel_at_j = min_cost_to_reach_j + cost_to_travel_j_to_i\n                min_cost_to_reach_i = min(min_cost_to_reach_i, cost_to_refuel_at_j)\n\n        if min_cost_to_reach_i == float('inf'):\n            return \"cancel road trip\"\n        dp[i] = min_cost_to_reach_i\n        best_gas_station = i\n\n    if dp[-1] > g:\n        return \"cancel road trip\"\n\n    return dp[-1]\n\nn, g = map(int, input().split())\nprint(min_cost_to_travel(n, g))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969819784164429,
            0.9926640391349792,
            0.9964594841003418,
            0.9960740804672241,
            0.9946997761726379,
            0.9964107871055603,
            0.9966699481010437,
            0.9946943521499634,
            0.9954999685287476,
            0.9967396259307861,
            0.9960963726043701,
            0.9973983764648438,
            0.9968772530555725,
            0.9960360527038574,
            0.9966901540756226,
            0.9953804016113281,
            0.9972745180130005,
            0.9952571392059326,
            0.9944229125976562,
            0.9964166879653931
        ]
    },
    "3711": {
        "similarity": 0.9961854815483093,
        "body": "import sys\n\n    if n == 1 or m == 1:\n        return -1\n    if k <= min(n, m) + 1:\n        smallest_side = min(n, m)\n        biggest_piece = smallest_side * (smallest_side + 1) // 2\n        for i in range(k):\n            biggest_piece -= n * (m - (k - i))\n        return max(biggest_piece, 0)\n    else:\n        return -1\n\nn, m, k = map(int, input().split())\nprint(max_min_area(n, m, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948388934135437,
            0.9937688708305359,
            0.9925133585929871,
            0.995877742767334,
            0.9958701133728027,
            0.9950197339057922,
            0.9935254454612732,
            0.995374858379364,
            0.9913930296897888,
            0.9926846027374268,
            0.9933696389198303,
            0.9943605661392212,
            0.9949242472648621,
            0.9955102801322937,
            0.9953780174255371,
            0.991743803024292,
            0.9961854815483093,
            0.99528968334198,
            0.9917853474617004,
            0.9939589500427246
        ]
    }
}