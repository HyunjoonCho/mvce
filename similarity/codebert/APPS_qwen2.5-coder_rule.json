{
    "4693": {
        "similarity": 0.9977654218673706,
        "body": "a, b = map(int, input().split())\nif a + b >= 10:\n    print(\"error\")\nelse:\n    print(a + b)",
        "result": "passed",
        "similarities": [
            0.9966845512390137,
            0.9966556429862976,
            0.9973870515823364,
            0.9973870515823364,
            0.9950223565101624,
            0.9961848855018616,
            0.9973870515823364,
            0.9904960989952087,
            0.9973870515823364,
            0.9977654218673706,
            0.9961684346199036,
            0.9973870515823364,
            0.9977654218673706,
            0.9973870515823364,
            0.99737948179245,
            0.9966556429862976,
            0.9973870515823364,
            0.9977654218673706,
            0.9973870515823364,
            0.9977654218673706
        ]
    },
    "4077": {
        "similarity": 0.997135579586029,
        "body": "import bisect\n\n    count = 0\n    for l in range(n):\n        prefix_sum = [0]\n        sorted_prefix = []\n        for r in range(l, n):\n            num = a[r]\n            if num <= m:\n                bisect.insort(sorted_prefix, num)\n                prefix_sum.append(prefix_sum[-1] + 1)\n            if len(sorted_prefix) % 2 == 1:\n                median_index = len(sorted_prefix) // 2\n                if sorted_prefix[median_index] == m:\n                    count += (prefix_sum[r+1] - prefix_sum[l])\n    return count\n\n# Read input from stdin\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_median_pairs(n, m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950655698776245,
            0.9958420991897583,
            0.9968435168266296,
            0.9953259825706482,
            0.9956838488578796,
            0.9946278929710388,
            0.9963828921318054,
            0.9956365823745728,
            0.9958987832069397,
            0.9951855540275574,
            0.9963158369064331,
            0.9949551820755005,
            0.997135579586029,
            0.9961028099060059,
            0.9965859651565552,
            0.9971147775650024,
            0.994046688079834,
            0.9954513907432556,
            0.996917724609375,
            0.9964811205863953
        ]
    },
    "4006": {
        "similarity": 0.9979850649833679,
        "body": "    reachable = set()\n    stack = [n]\n    \n    while stack:\n        current = stack.pop()\n        if current not in reachable:\n            reachable.add(current)\n            next_value = current + 1\n            while next_value % 10 == 0:\n                next_value //= 10\n            stack.append(next_value)\n    \n    return len(reachable)\n\n# Read input from stdin\nn = int(input().strip())\n\n# Print the result\nprint(count_reachable_numbers(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975936412811279,
            0.9978674054145813,
            0.9974389672279358,
            0.9978775382041931,
            0.9974115490913391,
            0.9975449442863464,
            0.9979850649833679,
            0.9966697692871094,
            0.9969924092292786,
            0.997949481010437,
            0.9969586730003357,
            0.9968315958976746,
            0.9968785643577576,
            0.9971064329147339,
            0.9972566366195679,
            0.997220516204834,
            0.9976973533630371,
            0.9973474144935608,
            0.997681200504303,
            0.9976581931114197
        ]
    },
    "4556": {
        "similarity": 0.99444180727005,
        "body": "    s = input().strip()\n    x = s[0]\n    print(f\"A{x}\")\n\nabbreviate_contest_name()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9905094504356384,
            0.9938153028488159,
            0.9924631714820862,
            0.9921543598175049,
            0.989201009273529,
            0.9791955351829529,
            0.9935895800590515,
            0.9896469116210938,
            0.991298258304596,
            0.9921949505805969,
            0.9888799786567688,
            0.9906684756278992,
            0.9904798269271851,
            0.9941297769546509,
            0.99444180727005,
            0.9937487244606018,
            0.9932909607887268,
            0.9911551475524902,
            0.9934491515159607,
            0.9940717816352844
        ]
    },
    "4571": {
        "similarity": 0.9973363280296326,
        "body": "import sys\n\n    total_time = 0\n    probability = 1 / 2\n    for i in range(1, M + 1):\n        total_time += (i * 1900) * probability\n        probability /= 2\n    total_time += N - M * 100\n    return int(total_time)\n\n# Read input from stdin\nN, M = map(int, input().split())\n\n# Calculate and print the expected execution time\nprint(expected_execution_time(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995995283126831,
            0.996272623538971,
            0.996091365814209,
            0.9950159788131714,
            0.9969964623451233,
            0.9970040917396545,
            0.9958650469779968,
            0.9973363280296326,
            0.9953109622001648,
            0.9961397051811218,
            0.9958707094192505,
            0.9952051043510437,
            0.9964741468429565,
            0.9964322447776794,
            0.9968087077140808,
            0.9971776604652405,
            0.993493914604187,
            0.9956462383270264,
            0.995813250541687,
            0.9947054982185364
        ]
    },
    "4019": {
        "similarity": 0.9978612661361694,
        "body": "import sys\n\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        if v > u:\n            v, u = u, v\n        edges.append((v, u))\n    \n    visited = [False] * (n + 1)\n    degree = [0] * (n + 1)\n    \n        visited[v] = True\n        for u in range(1, n + 1):\n            if not visited[u]:\n                if (v, u) in edges or (u, v) in edges:\n                    degree[v] += 1\n                    dfs(u)\n    \n    dfs(1)\n    \n    if degree[1] == D:\n        for (v, u) in edges:\n            print(v, u)\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    n, m, D = map(int, input().split())\n    find_spanning_tree(n, m, D)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974061250686646,
            0.9977803826332092,
            0.9967472553253174,
            0.9968990683555603,
            0.9977267384529114,
            0.9969944357872009,
            0.9972972869873047,
            0.9975883364677429,
            0.9972542524337769,
            0.9971633553504944,
            0.9978612661361694,
            0.9976373314857483,
            0.9966408610343933,
            0.9973323345184326,
            0.9973706603050232,
            0.9968462586402893,
            0.9967576861381531,
            0.996881902217865,
            0.9963810443878174,
            0.9946877360343933
        ]
    },
    "4265": {
        "similarity": 0.9979196786880493,
        "body": "import sys\n\n    operations = 0\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            operations += 1\n    return operations\n\n# Read input from stdin\ns = input().strip()\nt = input().strip()\n\n# Calculate and print the result\nresult = min_operations_to_transform(s, t)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973385334014893,
            0.9977144002914429,
            0.9971830248832703,
            0.99689120054245,
            0.9977772235870361,
            0.997780442237854,
            0.99689120054245,
            0.9971026182174683,
            0.9971027374267578,
            0.996364176273346,
            0.9971027374267578,
            0.99689120054245,
            0.9971492290496826,
            0.9976581931114197,
            0.9977772235870361,
            0.9979196786880493,
            0.9973223805427551,
            0.997780442237854,
            0.9973385334014893,
            0.9973223805427551
        ]
    },
    "4657": {
        "similarity": 0.9984325766563416,
        "body": "    odd_count = sum(1 for x in a if x % 2 != 0)\n    if odd_count < k or odd_count % 2 != 0:\n        return \"NO\"\n    \n    result = []\n    current_sum = 0\n    current_index = 0\n    \n    for i in range(n):\n        current_sum += a[i]\n        if current_sum % 2 != 0 and (i == n - 1 or a[i + 1] % 2 == 0):\n            result.append(i + 1)\n            current_sum = 0\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_split_into_odd_sum_subsegments(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980846047401428,
            0.9979187846183777,
            0.9971678853034973,
            0.9984325766563416,
            0.9953328371047974,
            0.997780978679657,
            0.9976222515106201,
            0.9976618885993958,
            0.9983893036842346,
            0.9962832927703857,
            0.9981944561004639,
            0.9983851909637451,
            0.9984096884727478,
            0.9978005290031433,
            0.9982876181602478,
            0.9979735016822815,
            0.9970312714576721,
            0.9979952573776245,
            0.9979444742202759,
            0.9971049427986145
        ]
    },
    "4599": {
        "similarity": 0.9963469505310059,
        "body": "    alice_score = 0\n    bob_score = 0\n    for i in range(N):\n        if i % 2 == 0:\n            alice_score += a[i]\n        else:\n            bob_score += a[i]\n    return alice_score - bob_score\n\n# Read input from stdin\nN = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(game_score(N, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947239756584167,
            0.9952283501625061,
            0.9940962791442871,
            0.9952157735824585,
            0.9961782693862915,
            0.9963469505310059,
            0.9931330680847168,
            0.993796706199646,
            0.9960107207298279,
            0.9956983327865601,
            0.9950999021530151,
            0.9943134784698486,
            0.9957035779953003,
            0.9942155480384827,
            0.9951415061950684,
            0.9945970773696899,
            0.9963365793228149,
            0.9957480430603027,
            0.9955753684043884,
            0.9956942200660706
        ]
    },
    "4774": {
        "similarity": 0.9974177479743958,
        "body": "import sys\n\noperators = ['+', '-', '*', '/']\n\n    results = []\n    for op1 in operators:\n        for op2 in operators:\n            if op2 == '/' and (c == 0 or d == 0):\n                continue\n            expr = f\"{a} {op1} {b} = {c} {op2} {d}\"\n            if eval(f\"{a}{op1}{b} == {c}{op2}{d}\"):\n                results.append(expr)\n    return sorted(results)\n\n    input_line = input().strip()\n    a, b, c, d = map(int, input_line.split())\n    results = check_equation(a, b, c, d)\n    if not results:\n        print(\"problems ahead\")\n    else:\n        for result in results:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974177479743958,
            0.9969224333763123,
            0.9963415265083313,
            0.9889407753944397,
            0.9969149231910706,
            0.9961907267570496,
            0.9949929118156433,
            0.9969900250434875,
            0.9965827465057373,
            0.9958769083023071,
            0.9960650205612183,
            0.9956242442131042,
            0.996722400188446,
            0.9966235756874084,
            0.9960935711860657,
            0.9967491626739502,
            0.9954464435577393,
            0.9973008036613464,
            0.9959813356399536,
            0.9964724183082581
        ]
    },
    "4851": {
        "similarity": 0.9978110790252686,
        "body": "    digit_sum = sum(int(digit) for digit in str(num))\n    return num % digit_sum == 0\n\n    while not is_harshad_number(n):\n        n += 1\n    return n\n\nn = int(input())\nprint(smallest_harshad(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978110790252686,
            0.9974898099899292,
            0.9971976280212402,
            0.9975301027297974,
            0.9962748289108276,
            0.9968572854995728,
            0.995869517326355,
            0.997282862663269,
            0.9970248341560364,
            0.9971976280212402,
            0.9958714246749878,
            0.9969996213912964,
            0.9971976280212402,
            0.9970715045928955,
            0.9967938661575317,
            0.995106041431427,
            0.9968559145927429,
            0.9958714246749878,
            0.9970494508743286,
            0.9969727396965027
        ]
    },
    "4655": {
        "similarity": 0.994944155216217,
        "body": "    piles = [a, b, c]\n    piles.sort()\n    if piles[0] + piles[2] <= 2 * piles[1]:\n        return piles[1]\n    else:\n        return (piles[0] + piles[1] + piles[2]) // 2\n\nq = int(input())\nresults = []\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    results.append(max_candies(a, b, c))\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9880655407905579,
            0.9878523945808411,
            0.9941079020500183,
            0.9933825135231018,
            0.9923897981643677,
            0.9934443235397339,
            0.9945756196975708,
            0.9947455525398254,
            0.9947734475135803,
            0.9906925559043884,
            0.9903263449668884,
            0.9939461946487427,
            0.994944155216217,
            0.9944066405296326,
            0.9899244904518127,
            0.9944857358932495,
            0.9940308332443237,
            0.9901751279830933,
            0.9945395588874817,
            0.9812433123588562
        ]
    },
    "4132": {
        "similarity": 0.9969256520271301,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    while len(a) > 1:\n        a.sort()\n        x, y = a[0], a[1]\n        a.pop(0)\n        a.pop(0)\n        a.append(x + y - x)\n    \n    print(a[0])\n\nmin_final_health()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943538308143616,
            0.9956579804420471,
            0.9969256520271301,
            0.995326817035675,
            0.9943334460258484,
            0.9949948191642761,
            0.9966078400611877,
            0.9947373270988464,
            0.9954994916915894,
            0.9967039227485657,
            0.9965288043022156,
            0.9966979026794434,
            0.9949985146522522,
            0.9950709342956543,
            0.9931618571281433,
            0.9947858452796936,
            0.9945312142372131,
            0.9950904846191406,
            0.9926795959472656,
            0.9956938028335571
        ]
    },
    "4085": {
        "similarity": 0.9969496726989746,
        "body": "import math\nimport sys\nfrom typing import List\n\n    divisors.sort()\n    n = len(divisors)\n    \n    for i in range(n):\n        if i == 0 or divisors[i] != 2 * divisors[i - 1]:\n            continue\n        \n        candidate_x = divisors[i]\n        valid = True\n        for d in divisors:\n            if candidate_x % d != 0 and d != candidate_x // 2:\n                valid = False\n                break\n        \n        if valid:\n            return candidate_x\n    \n    return -1\n\n    t = int(input().strip())\n    results = []\n    \n    for _ in range(t):\n        n = int(input().strip())\n        divisors = list(map(int, input().strip().split()))\n        result = find_min_x(divisors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966667890548706,
            0.9954583048820496,
            0.9963334798812866,
            0.995691180229187,
            0.9936220049858093,
            0.9955163598060608,
            0.9941024780273438,
            0.9931911826133728,
            0.9969496726989746,
            0.9966709613800049,
            0.9937577843666077,
            0.9961000084877014,
            0.996208906173706,
            0.9964049458503723,
            0.993903398513794,
            0.9947936534881592,
            0.9967808127403259,
            0.9961698651313782,
            0.9968281984329224,
            0.9963539838790894
        ]
    },
    "4399": {
        "similarity": 0.9971004128456116,
        "body": "    a_stations = [i+1 for i, c in enumerate(s) if c == 'A']\n    b_stations = [i+1 for i, c in enumerate(s) if c == 'B']\n    \n    for a_station in a_stations:\n        for b_station in b_stations:\n            if a_station < b_station:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\n# Read input from stdin\ns = input()\ncheck_bus_service(s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959134459495544,
            0.9956647157669067,
            0.9971004128456116,
            0.9943912029266357,
            0.9969530701637268,
            0.9967784881591797,
            0.9961186647415161,
            0.9959186911582947,
            0.9962724447250366,
            0.9961504936218262,
            0.9947777986526489,
            0.9967541098594666,
            0.9966979622840881,
            0.9936105012893677,
            0.9921826720237732,
            0.9957705140113831,
            0.9946553111076355,
            0.9970794320106506,
            0.9897220134735107,
            0.9957211017608643
        ]
    },
    "4999": {
        "similarity": 0.9981629252433777,
        "body": "    operations = 0\n    while a < b:\n        if b % 2 == 1:\n            b += 1\n        else:\n            b //= 2\n        operations += 1\n    return operations + (b - a)\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    print(min_operations(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961031675338745,
            0.9979280233383179,
            0.9976137280464172,
            0.9976065754890442,
            0.9979331493377686,
            0.9979450702667236,
            0.997893214225769,
            0.996820867061615,
            0.9981629252433777,
            0.9980665445327759,
            0.9976439476013184,
            0.9978145956993103,
            0.9978360533714294,
            0.9977355003356934,
            0.9923850893974304,
            0.9979539513587952,
            0.9975873827934265,
            0.9962643384933472,
            0.9979926943778992,
            0.9961164593696594
        ]
    },
    "4727": {
        "similarity": 0.9973966479301453,
        "body": "    for row in grid:\n        non_zeros = [x for x in row if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        row[:] = merged + [0] * (4 - len(merged))\n\n    for col in range(4):\n        non_zeros = [grid[row][col] for row in range(4) if grid[row][col] != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        for row in range(4):\n            grid[row][col] = merged.pop(0) if merged else 0\n\n    for row in grid:\n        non_zeros = [x for x in reversed(row) if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        row[:] = list(reversed(merged + [0] * (4 - len(merged))))\n\n    for col in range(4):\n        non_zeros = [grid[row][col] for row in reversed(range(4)) if grid[row][col] != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        for row in range(4):\n            grid[row][col] = merged.pop() if merged else 0\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    grid = [list(map(int, data[4*i:4*(i+1)])) for i in range(4)]\n    direction = int(data[16])\n    \n    if direction == 0:\n        move_left(grid)\n    elif direction == 1:\n        move_up(grid)\n    elif direction == 2:\n        move_right(grid)\n    elif direction == 3:\n        move_down(grid)\n    \n    for row in grid:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959262013435364,
            0.9973966479301453,
            0.9969968199729919,
            0.9968554973602295,
            0.9930892586708069,
            0.9962407350540161,
            0.9964768290519714,
            0.9971889853477478,
            0.9962738752365112,
            0.9965262413024902,
            0.9968286752700806,
            0.9967432618141174,
            0.9953930377960205,
            0.9968147277832031,
            0.9971197843551636,
            0.9968230724334717,
            0.997386634349823,
            0.9963155388832092,
            0.9950069785118103,
            0.997012197971344
        ]
    },
    "4906": {
        "similarity": 0.9971359968185425,
        "body": "import sys\n\n    encoded = []\n    count = 1\n    for i in range(1, len(input_str)):\n        if input_str[i] == input_str[i - 1]:\n            count += 1\n        else:\n            encoded.append(f\"{input_str[i-1]}{count}\")\n            count = 1\n    encoded.append(f\"{input_str[-1]}{count}\")\n    return ''.join(encoded)\n\n    decoded = []\n    i = 0\n    while i < len(input_str):\n        char = input_str[i]\n        i += 1\n        count = int(input_str[i])\n        decoded.append(char * count)\n        i += 1\n    return ''.join(decoded)\n\n    mode, message = input().split(' ', 1)\n    if mode == 'E':\n        print(run_length_encode(message))\n    elif mode == 'D':\n        print(run_length_decode(message))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959138631820679,
            0.9965887665748596,
            0.99571692943573,
            0.9966768026351929,
            0.9962877035140991,
            0.9965431094169617,
            0.9966588616371155,
            0.9900336265563965,
            0.9950696229934692,
            0.9951924681663513,
            0.9971359968185425,
            0.9968643188476562,
            0.9898341298103333,
            0.996006429195404,
            0.9967913627624512,
            0.9962781667709351,
            0.9962231516838074,
            0.9956211447715759,
            0.9967840313911438,
            0.9970937371253967
        ]
    },
    "4011": {
        "similarity": 0.9979677796363831,
        "body": "    max_val = int(a)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment = a[i:j]\n            new_segment = ''.join(str(f[int(digit)]) for digit in segment)\n            new_num = int(a[:i] + new_segment + a[j:])\n            if new_num > max_val:\n                max_val = new_num\n    return max_val\n\nn = int(input())\na = input()\nf = list(map(int, input().split()))\nprint(max_number(n, a, f))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979677796363831,
            0.997898519039154,
            0.9966172575950623,
            0.9961515069007874,
            0.9975412487983704,
            0.9974656701087952,
            0.997553288936615,
            0.9975057244300842,
            0.9961529970169067,
            0.996543288230896,
            0.9976949095726013,
            0.9960355162620544,
            0.9976091980934143,
            0.9970468282699585,
            0.9963266253471375,
            0.9974492788314819,
            0.9963650107383728,
            0.9976761341094971,
            0.9973798990249634,
            0.9973475933074951
        ]
    },
    "4099": {
        "similarity": 0.9979113340377808,
        "body": "import sys\n\n    total_required = M * N\n    current_total = sum(A)\n    needed_on_last = total_required - current_total\n    \n    if needed_on_last < 0 or needed_on_last > K:\n        return -1\n    else:\n        return needed_on_last\n\n# Read input from stdin\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_points_needed(N, K, M, A)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963189959526062,
            0.9943674802780151,
            0.9976333975791931,
            0.9955011010169983,
            0.996988832950592,
            0.9975025653839111,
            0.9969439506530762,
            0.9973951578140259,
            0.9942724108695984,
            0.9973635673522949,
            0.9960589408874512,
            0.9970647692680359,
            0.99625164270401,
            0.9977563619613647,
            0.9958064556121826,
            0.9970993399620056,
            0.9928892254829407,
            0.9965302348136902,
            0.9972923994064331,
            0.9979113340377808
        ]
    },
    "4465": {
        "similarity": 0.9970212578773499,
        "body": "    a, b = map(int, input().split())\n    area = (a - 1) * (b - 1)\n    print(area)\n\ncalculate_yard_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951605796813965,
            0.9951605796813965,
            0.9954189658164978,
            0.9948579668998718,
            0.9970212578773499,
            0.9957094788551331,
            0.9969819784164429,
            0.9956066012382507,
            0.9959161877632141,
            0.9964908957481384,
            0.9952884316444397,
            0.9962798953056335,
            0.9962798953056335,
            0.9957366585731506,
            0.9959161877632141,
            0.9964053630828857,
            0.9969323873519897,
            0.9935200214385986,
            0.9962210655212402,
            0.9948099851608276
        ]
    },
    "4315": {
        "similarity": 0.9976809620857239,
        "body": "import math\n\n    radius = int(input())\n    circumference = 2 * math.pi * radius\n    print(f\"{circumference:.15f}\")\n\ncalculate_circumference()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966914653778076,
            0.9976772665977478,
            0.9953001141548157,
            0.9967356324195862,
            0.995000958442688,
            0.9883262515068054,
            0.9948894381523132,
            0.997525691986084,
            0.997663676738739,
            0.9960929751396179,
            0.9968743920326233,
            0.9976772665977478,
            0.9976740479469299,
            0.9976809620857239,
            0.9966990947723389,
            0.9939448833465576,
            0.9926360249519348,
            0.997525691986084,
            0.9976058602333069,
            0.9966914653778076
        ]
    },
    "4633": {
        "similarity": 0.9973914623260498,
        "body": "import sys\n\n    moves = 0\n    while sum(int(digit) for digit in str(n)) > s:\n        n += 1\n        moves += 1\n    return moves\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, s = map(int, input().split())\n    results.append(min_moves(n, s))\n    \nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959666728973389,
            0.9942342638969421,
            0.9972432851791382,
            0.9966334104537964,
            0.9966334104537964,
            0.9964856505393982,
            0.9949584007263184,
            0.9973914623260498,
            0.9962209463119507,
            0.9933837056159973,
            0.9964646697044373,
            0.994137704372406,
            0.9964646697044373,
            0.9972991943359375,
            0.9966621398925781,
            0.9964451193809509,
            0.9972752928733826,
            0.9892746806144714,
            0.9968501925468445,
            0.9940595030784607
        ]
    },
    "4734": {
        "similarity": 0.9980893731117249,
        "body": "    if y.endswith('ex'):\n        return y + p\n    elif y[-1] in 'aeiou':\n        return y[:-1] + 'ex' + p\n    else:\n        return y + 'ex' + p\n\n# Read input from stdin\ny, p = input().split()\n\n# Print the result\nprint(extend_apaxian_name(y, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980700612068176,
            0.9978058338165283,
            0.9975482821464539,
            0.9980893731117249,
            0.9980893731117249,
            0.9959660768508911,
            0.9980893731117249,
            0.9980893731117249,
            0.9953429698944092,
            0.9980893731117249,
            0.995908260345459,
            0.9980700612068176,
            0.9974592328071594,
            0.9973251819610596,
            0.9974084496498108,
            0.9954155683517456,
            0.9964742064476013,
            0.9963308572769165,
            0.9929741621017456,
            0.9974793195724487
        ]
    },
    "4229": {
        "similarity": 0.9985435009002686,
        "body": "    total = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            continue\n        elif i % 3 == 0 or i % 5 == 0:\n            continue\n        else:\n            total += i\n    print(total)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    fizz_buzz_sum(n)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980322122573853,
            0.9964731931686401,
            0.9974055290222168,
            0.9983791708946228,
            0.9982563853263855,
            0.9981203675270081,
            0.9982907176017761,
            0.9979621767997742,
            0.9984413981437683,
            0.9984332919120789,
            0.9978094696998596,
            0.9978094696998596,
            0.9977090954780579,
            0.9981051087379456,
            0.9976179003715515,
            0.9981473684310913,
            0.9980345368385315,
            0.9985435009002686,
            0.9947883486747742,
            0.9978727102279663
        ]
    },
    "4321": {
        "similarity": 0.9992201924324036,
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result\nprint(tanya_decrease(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981049299240112,
            0.9991475343704224,
            0.9991533160209656,
            0.9986076354980469,
            0.9992201924324036,
            0.9992201924324036,
            0.9988670349121094,
            0.9991534352302551,
            0.9988133311271667,
            0.9988332986831665,
            0.9992201924324036,
            0.9979991912841797,
            0.9991475343704224,
            0.9959092736244202,
            0.9979555010795593,
            0.9992201924324036,
            0.9978492259979248,
            0.9992201924324036,
            0.9991475343704224,
            0.9992201924324036
        ]
    },
    "4503": {
        "similarity": 0.9976634979248047,
        "body": "import sys\n\n    moves = sorted(A)\n    for i in range(N):\n        if H <= 0:\n            return \"Yes\"\n        H -= moves[i]\n    return \"No\"\n\nif __name__ == \"__main__\":\n    input_data = input().split()\n    H = int(input_data[0])\n    N = int(input_data[1])\n    A = list(map(int, input_data[2:]))\n    print(can_raccoon_win(H, N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972294569015503,
            0.9943592548370361,
            0.9974547028541565,
            0.9970225095748901,
            0.9964310526847839,
            0.9960817098617554,
            0.9970058798789978,
            0.9962652325630188,
            0.995744526386261,
            0.99547278881073,
            0.9968235492706299,
            0.9976634979248047,
            0.9958704710006714,
            0.9951795339584351,
            0.9970362782478333,
            0.9972787499427795,
            0.9965639710426331,
            0.9969757795333862,
            0.9974762797355652,
            0.9971568584442139
        ]
    },
    "4855": {
        "similarity": 0.9961658120155334,
        "body": "import math\n\n    current_citations = articles * (target_impact - 1)\n    bribes_needed = max(0, math.ceil(current_citations) - articles)\n    return bribes_needed\n\n# Read input from stdin\nA, I = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_bribes(A, I))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950282573699951,
            0.9929658770561218,
            0.9928681254386902,
            0.9952813982963562,
            0.9943578839302063,
            0.9952621459960938,
            0.9919031858444214,
            0.9955721497535706,
            0.9922764301300049,
            0.9948403239250183,
            0.9935449361801147,
            0.9948605895042419,
            0.9932534098625183,
            0.9961658120155334,
            0.9925577044487,
            0.9938041567802429,
            0.9958552122116089,
            0.9923129677772522,
            0.995664119720459,
            0.9940623044967651
        ]
    },
    "4704": {
        "similarity": 0.9983910322189331,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    total_sum = sum(a)\n    prefix_sum = 0\n    min_diff = float('inf')\n    \n    for i in range(n - 1):\n        prefix_sum += a[i]\n        suffix_sum = total_sum - prefix_sum\n        diff = abs(prefix_sum - suffix_sum)\n        if diff < min_diff:\n            min_diff = diff\n    \n    print(min_diff)\n\nmin_card_difference()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983389973640442,
            0.9980229735374451,
            0.9983775615692139,
            0.9953721761703491,
            0.9951103925704956,
            0.9981396198272705,
            0.9980979561805725,
            0.9979740977287292,
            0.9982763528823853,
            0.9981693625450134,
            0.9983910322189331,
            0.9961182475090027,
            0.9981655478477478,
            0.9983389973640442,
            0.9973980784416199,
            0.9981592893600464,
            0.9975212812423706,
            0.9981759786605835,
            0.9981211423873901,
            0.9967542886734009
        ]
    },
    "4829": {
        "similarity": 0.9983700513839722,
        "body": "    if left == 0 and right == 0:\n        return \"Not a moose\"\n    elif left == right:\n        points = left + right\n        return f\"Even {points}\"\n    else:\n        max_tines = max(left, right)\n        if max_tines * 2 - min(left, right) <= 4:\n            points = max_tines * 2\n            return f\"Odd {points}\"\n        else:\n            return \"Not a moose\"\n\n# Read input from stdin\nleft, right = map(int, input().split())\n\n# Print the result\nprint(moose_points(left, right))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981294274330139,
            0.9978200793266296,
            0.9973608255386353,
            0.9981476664543152,
            0.9978891611099243,
            0.9981840252876282,
            0.9974194765090942,
            0.9982917308807373,
            0.9977188110351562,
            0.9976381063461304,
            0.9983700513839722,
            0.9982452392578125,
            0.9976341128349304,
            0.998195469379425,
            0.9983019828796387,
            0.9968829154968262,
            0.9977934956550598,
            0.9978151917457581,
            0.9975306987762451,
            0.9965924620628357
        ]
    },
    "4730": {
        "similarity": 0.9978709816932678,
        "body": "import sys\n\n    length = int(input())\n    program = input().strip()\n    \n    delimiter_stack = []\n    matching_delimiter = {')': '(', ']': '[', '}': '{'}\n    \n    for index, char in enumerate(program):\n        if char in \"([{\":\n            delimiter_stack.append((char, index))\n        elif char in \")]}\":\n            if not delimiter_stack or delimiter_stack[-1][0] != matching_delimiter[char]:\n                print(char, index)\n                return\n            delimiter_stack.pop()\n    \n    if delimiter_stack:\n        last_opening = delimiter_stack[-1]\n        print(last_opening[0], last_opening[1])\n    else:\n        print(\"ok so far\")\n\nvalidate_delimiters()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972683787345886,
            0.9976941347122192,
            0.9963940978050232,
            0.9976943135261536,
            0.9975218772888184,
            0.9954279065132141,
            0.9973877668380737,
            0.9978709816932678,
            0.9977539777755737,
            0.9944050312042236,
            0.9962339997291565,
            0.9945710897445679,
            0.9963828921318054,
            0.99724280834198,
            0.9976100921630859,
            0.9971324801445007,
            0.9974086284637451,
            0.9978493452072144,
            0.9971894025802612,
            0.9974818825721741
        ]
    },
    "4729": {
        "similarity": 0.9980216026306152,
        "body": "    password_chars = list(password)\n    msg_index = 0\n    \n    for char in message:\n        if msg_index >= len(password_chars):\n            break\n        if char == password_chars[msg_index]:\n            msg_index += 1\n            \n    return \"PASS\" if msg_index == len(password_chars) else \"FAIL\"\n\n# Read input from stdin\npassword, message = input().strip().split()\n\n# Print the result\nprint(check_valid_message(password, message))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974306225776672,
            0.9968775510787964,
            0.9980216026306152,
            0.9966862201690674,
            0.9974897503852844,
            0.9976925253868103,
            0.9973445534706116,
            0.9958815574645996,
            0.9977232217788696,
            0.9966623187065125,
            0.9977726340293884,
            0.9941526651382446,
            0.9975226521492004,
            0.9970051646232605,
            0.9953645467758179,
            0.9971967935562134,
            0.9953123331069946,
            0.9970101118087769,
            0.997241199016571,
            0.9976840615272522
        ]
    },
    "4582": {
        "similarity": 0.9958751201629639,
        "body": "import sys\n\n    if a == 'H':\n        if b == 'H':\n            return 'H'\n        else:\n            return 'D'\n    else:\n        if b == 'H':\n            return 'D'\n        else:\n            return 'H'\n\n# Read input\na, b = input().split()\n\n# Determine and print the result\nprint(determine_top_co_deer_honesty(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958751201629639,
            0.9929668307304382,
            0.9947248101234436,
            0.9935835003852844,
            0.9932265877723694,
            0.9947363138198853,
            0.9905012249946594,
            0.9947115182876587,
            0.9926591515541077,
            0.9945936799049377,
            0.9939878582954407,
            0.9915281534194946,
            0.9896845817565918,
            0.9927822947502136,
            0.9905012249946594,
            0.9922842979431152,
            0.9940868020057678,
            0.9941402077674866,
            0.992576003074646,
            0.9948140978813171
        ]
    },
    "4910": {
        "similarity": 0.9965318441390991,
        "body": "import collections\n\n    n = int(input())\n    categories = collections.Counter()\n    \n    for _ in range(n):\n        category = input().strip()\n        categories[category] += 1\n    \n    max_count = max(categories.values())\n    best_categories = [category for category, count in categories.items() if count == max_count]\n    \n    print('\\n'.join(sorted(best_categories)))\n\nbest_costume()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996425211429596,
            0.9953649640083313,
            0.9948674440383911,
            0.9954451322555542,
            0.9950035810470581,
            0.994547426700592,
            0.9965318441390991,
            0.9948686361312866,
            0.9961323142051697,
            0.9963927268981934,
            0.9949723482131958,
            0.9959664940834045,
            0.9962059855461121,
            0.9961380362510681,
            0.9911960959434509,
            0.9927482604980469,
            0.994384765625,
            0.9945329427719116,
            0.9925726056098938,
            0.9954707622528076
        ]
    },
    "4323": {
        "similarity": 0.9965739846229553,
        "body": "import sys\n\n    a = [s[0] for s in songs]\n    b = [s[1] for s in songs]\n    \n    dp = [False] * (m + 1)\n    dp[0] = True\n    \n    for i in range(n):\n        new_dp = dp.copy()\n        for size in range(m, b[i] - 1, -1):\n            if dp[size - b[i]]:\n                new_dp[size] = True\n        dp = new_dp\n    \n    for i in range(m + 1):\n        if dp[i]:\n            return n - (i == m)\n    \n    return -1\n\n# Read input from stdin\nn, m = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(min_songs_to_compress(n, m, songs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955075979232788,
            0.9961292743682861,
            0.9952996969223022,
            0.9913336038589478,
            0.9955142140388489,
            0.9961054921150208,
            0.9959347248077393,
            0.9911631345748901,
            0.9965739846229553,
            0.9962853789329529,
            0.9963183403015137,
            0.996351957321167,
            0.9938496351242065,
            0.9949079155921936,
            0.9931046366691589,
            0.9965339303016663,
            0.9930884838104248,
            0.9946367144584656,
            0.9923167824745178,
            0.9956309795379639
        ]
    },
    "4626": {
        "similarity": 0.9946900606155396,
        "body": "    results = []\n    for _ in range(q):\n        a, b, c = map(int, input().split())\n        positions = sorted([a, b, c])\n        a_prime, b_prime, c_prime = positions[0], positions[1], positions[2]\n        results.append(abs(a_prime - b_prime) + abs(b_prime - c_prime))\n    for result in results:\n        print(result)\n\nmin_pairwise_distance(int(input()))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941468834877014,
            0.9919798970222473,
            0.9932146668434143,
            0.986842930316925,
            0.9929350018501282,
            0.9936793446540833,
            0.9940974712371826,
            0.9943795800209045,
            0.9927892088890076,
            0.9938973784446716,
            0.9946900606155396,
            0.9930914044380188,
            0.9900708794593811,
            0.9933496713638306,
            0.9923717975616455,
            0.9910162091255188,
            0.9941551089286804,
            0.993945300579071,
            0.9931585192680359,
            0.9824748635292053
        ]
    },
    "4400": {
        "similarity": 0.9980087280273438,
        "body": "    max_rainy = 0\n    current_rainy = 0\n\n    for day in s:\n        if day == 'R':\n            current_rainy += 1\n            max_rainy = max(max_rainy, current_rainy)\n        else:\n            current_rainy = 0\n\n    return max_rainy\n\n# Read input from stdin\ns = input().strip()\n\n# Print the result\nprint(max_consecutive_rainy_days(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973641633987427,
            0.9962422251701355,
            0.9979142546653748,
            0.9967036843299866,
            0.9978283643722534,
            0.9972261190414429,
            0.9960585236549377,
            0.9976094961166382,
            0.9980087280273438,
            0.9970992207527161,
            0.9966903328895569,
            0.9974881410598755,
            0.9978283643722534,
            0.9961292743682861,
            0.9979702830314636,
            0.9962721467018127,
            0.9960585236549377,
            0.9970619082450867,
            0.9976726174354553,
            0.9978036284446716
        ]
    },
    "4794": {
        "similarity": 0.9958521127700806,
        "body": "import sys\n\n    r, c = map(int, input().split())\n    grid = [list(input().strip()) for _ in range(r)]\n    \n        return 0 <= x < r and 0 <= y < c and grid[x][y] != '#'\n    \n    counts = [0] * 5\n    \n    for i in range(r - 1):\n        for j in range(c - 1):\n            if not (is_valid(i, j) and is_valid(i + 1, j) and is_valid(i, j + 1) and is_valid(i + 1, j + 1)):\n                continue\n            if grid[i][j] == 'X' or grid[i + 1][j] == 'X' or grid[i][j + 1] == 'X' or grid[i + 1][j + 1] == 'X':\n                count = (grid[i][j] == 'X') + (grid[i + 1][j] == 'X') + (grid[i][j + 1] == 'X') + (grid[i + 1][j + 1] == 'X')\n                counts[count] += 1\n    \n    for count in counts:\n        print(count)\n\nif __name__ == \"__main__\":\n    count_parking_spaces()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939441680908203,
            0.9942057728767395,
            0.9944164752960205,
            0.9954860210418701,
            0.9915603995323181,
            0.9952925443649292,
            0.9927986860275269,
            0.9947025179862976,
            0.9894390106201172,
            0.9932916760444641,
            0.9925187826156616,
            0.9930293560028076,
            0.9946602582931519,
            0.9953583478927612,
            0.9958521127700806,
            0.9952634572982788,
            0.9944757223129272,
            0.9938514232635498,
            0.9905800223350525,
            0.9958158135414124
        ]
    },
    "4096": {
        "similarity": 0.9980103373527527,
        "body": "import sys\n\n    a.sort()\n    days = 0\n    pages_written = 0\n    i = 0\n    \n    while pages_written < m:\n        if i >= n:\n            return -1\n        day_pages = 0\n        for k in range(i, n):\n            caffeine = a[k]\n            day_pages += max(0, caffeine - (k - i))\n            if pages_written + day_pages >= m:\n                days += 1\n                pages_written += day_pages\n                i = k + 1\n                break\n    return days\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\na = list(map(int, data[2:]))\n\nprint(min_days_to_complete_coursework(n, m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972423911094666,
            0.9973155856132507,
            0.9967601299285889,
            0.9975144267082214,
            0.9974205493927002,
            0.9978923797607422,
            0.9969885945320129,
            0.9971693158149719,
            0.9973381757736206,
            0.9956104755401611,
            0.9944572448730469,
            0.9980103373527527,
            0.9964929819107056,
            0.9957515597343445,
            0.9967240691184998,
            0.9963811635971069,
            0.9977842569351196,
            0.9979032278060913,
            0.9979991912841797,
            0.9978750944137573
        ]
    },
    "4530": {
        "similarity": 0.9980161786079407,
        "body": "import sys\n\n    skill_count = {}\n    for skill in skills:\n        if skill in skill_count:\n            skill_count[skill] += 1\n        else:\n            skill_count[skill] = 1\n    \n    unique_skills = list(skill_count.keys())\n    team_sizes = []\n    \n    for skill in unique_skills:\n        if skill_count[skill] >= n // 2:\n            for other_skill in unique_skills:\n                if other_skill != skill and skill_count[other_skill] >= n // 2 - 1:\n                    team_sizes.append(min(skill_count[skill], skill_count[other_skill]))\n    \n    return max(team_sizes) if team_sizes else 0\n\n    t = int(input().strip())\n    results = []\n    \n    for _ in range(t):\n        n = int(input().strip())\n        skills = list(map(int, input().strip().split()))\n        results.append(max_team_size(n, skills))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974021911621094,
            0.9978244304656982,
            0.997763991355896,
            0.9975678324699402,
            0.9969654083251953,
            0.9974536895751953,
            0.9974993467330933,
            0.9975836873054504,
            0.9966450929641724,
            0.9973060488700867,
            0.9962989687919617,
            0.9979742169380188,
            0.9965109825134277,
            0.9974614381790161,
            0.9956580996513367,
            0.997930645942688,
            0.995396077632904,
            0.9977565407752991,
            0.9976847767829895,
            0.9980161786079407
        ]
    },
    "4724": {
        "similarity": 0.9960370659828186,
        "body": "    performance = (current_rating + 2 * desired_rating) / 3\n    return int(performance)\n\n# Read input from stdin\nR = int(input())\nG = int(input())\n\n# Calculate and print the required performance\nprint(calculate_performance(R, G))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951682090759277,
            0.9935352802276611,
            0.9875248670578003,
            0.9924653768539429,
            0.9960333108901978,
            0.9915100932121277,
            0.9931825399398804,
            0.995600163936615,
            0.994940996170044,
            0.9960370659828186,
            0.9880213737487793,
            0.9954188466072083,
            0.9932924509048462,
            0.9942838549613953,
            0.9944207072257996,
            0.9955834150314331,
            0.9948861002922058,
            0.9953954815864563,
            0.9931951761245728,
            0.9951154589653015
        ]
    },
    "4276": {
        "similarity": 0.9971036314964294,
        "body": "import sys\n\n    min_cost = float('inf')\n    \n    for cost, time in routes:\n        if time <= t:\n            min_cost = min(min_cost, cost)\n    \n    return min_cost if min_cost != float('inf') else 'TLE'\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    data_list = input_data.split()\n    \n    n = int(data_list[0])\n    t = int(data_list[1])\n    routes = [(int(data_list[2 + 2 * i]), int(data_list[3 + 2 * i])) for i in range(n)]\n    \n    result = find_min_cost_route(n, t, routes)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966283440589905,
            0.9950354695320129,
            0.9966439008712769,
            0.9966239929199219,
            0.9958959221839905,
            0.9949792623519897,
            0.9971036314964294,
            0.9924637675285339,
            0.9956092834472656,
            0.9970862865447998,
            0.9966769218444824,
            0.9965718984603882,
            0.9965525269508362,
            0.9964420795440674,
            0.9961708784103394,
            0.9970793724060059,
            0.9965412616729736,
            0.9941796064376831,
            0.9967803955078125,
            0.9970445036888123
        ]
    },
    "4708": {
        "similarity": 0.9982186555862427,
        "body": "import sys\n\n    n = int(input())\n    k = int(input())\n    x = int(input())\n    y = int(input())\n\n    total_cost = 0\n    for i in range(n):\n        if i < k:\n            total_cost += x\n        else:\n            total_cost += y\n\n    print(total_cost)\n\ncalculate_accommodation_fee()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979687929153442,
            0.9982186555862427,
            0.9974901080131531,
            0.9957950115203857,
            0.9980199933052063,
            0.9978828430175781,
            0.997372567653656,
            0.9973471760749817,
            0.9982186555862427,
            0.9982186555862427,
            0.9979823231697083,
            0.9940583109855652,
            0.9976509809494019,
            0.9979823231697083,
            0.9931392669677734,
            0.9982186555862427,
            0.9978828430175781,
            0.997173011302948,
            0.9956331849098206,
            0.9973520040512085
        ]
    },
    "4396": {
        "similarity": 0.9984292387962341,
        "body": "import sys\n\n    n = int(input())\n    total_yen = 0.0\n    \n    for _ in range(n):\n        x, u = input().split()\n        x = float(x)\n        \n        if u == \"JPY\":\n            total_yen += x\n        elif u == \"BTC\":\n            total_yen += x * 380000.0\n    \n    print(total_yen)\n\ncalculate_total_value()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981723427772522,
            0.9942501783370972,
            0.996587872505188,
            0.9981488585472107,
            0.998274564743042,
            0.9975088238716125,
            0.9938625693321228,
            0.9983235597610474,
            0.9984292387962341,
            0.9975473284721375,
            0.9980617165565491,
            0.9958969950675964,
            0.9983484148979187,
            0.9983127117156982,
            0.9979460835456848,
            0.9979230761528015,
            0.9982010722160339,
            0.9982665181159973,
            0.9979302287101746,
            0.9971668720245361
        ]
    },
    "4155": {
        "similarity": 0.9974859952926636,
        "body": "import sys\n\n    n = int(input())\n    h = list(map(int, input().split()))\n    \n    operations = 0\n    \n    for i in range(n):\n        if h[i] > 0:\n            operations += 1\n            l = max(1, i - h[i] + 1)\n            r = min(n, i + h[i])\n            for j in range(l - 1, r):\n                h[j] -= 1\n    \n    print(operations)\n\nmin_watering_operations()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966500997543335,
            0.9968568682670593,
            0.9973416924476624,
            0.9969004392623901,
            0.9971315264701843,
            0.9972891807556152,
            0.9962721467018127,
            0.9969973564147949,
            0.9974859952926636,
            0.9965503215789795,
            0.9955406188964844,
            0.9966383576393127,
            0.9964752197265625,
            0.9957731366157532,
            0.9969144463539124,
            0.9958829283714294,
            0.9973281025886536,
            0.9974639415740967,
            0.9967406392097473,
            0.9969506859779358
        ]
    },
    "4557": {
        "similarity": 0.9977924823760986,
        "body": "    if x >= a <= x + b:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from standard input\na, b, x = map(int, input().split())\n\n# Print the result\nprint(check_possible_cats(a, b, x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972612261772156,
            0.9928989410400391,
            0.9977883100509644,
            0.9976686239242554,
            0.9977839589118958,
            0.9966993927955627,
            0.9964553713798523,
            0.9977332949638367,
            0.997600257396698,
            0.997639000415802,
            0.9974017143249512,
            0.9973708987236023,
            0.9965316653251648,
            0.9943110942840576,
            0.9943285584449768,
            0.9968206286430359,
            0.9974297881126404,
            0.9977924823760986,
            0.9917761087417603,
            0.9975839257240295
        ]
    },
    "4930": {
        "similarity": 0.9978045225143433,
        "body": "    decoded_word = \"\"\n    vowels = \"aeiou\"\n    i = 0\n    while i < len(coded_sentence):\n        if coded_sentence[i] in vowels:\n            decoded_word += coded_sentence[i-1:i+3]\n            i += 4\n        else:\n            decoded_word += coded_sentence[i]\n            i += 1\n    return decoded_word\n\n# Read input from stdin\ncoded_sentence = input().strip()\n\n# Decode and print the sentence\ndecoded_sentence = decode_sentence(coded_sentence)\nprint(decoded_sentence)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977620840072632,
            0.997681200504303,
            0.9973558187484741,
            0.9962406158447266,
            0.9963471293449402,
            0.9972047209739685,
            0.997512936592102,
            0.9961816072463989,
            0.9976059794425964,
            0.9963977336883545,
            0.9967218041419983,
            0.9976033568382263,
            0.9972018003463745,
            0.9978045225143433,
            0.9973272085189819,
            0.9977213144302368,
            0.9966567158699036,
            0.9968093037605286,
            0.9974411725997925,
            0.9965877532958984
        ]
    },
    "4715": {
        "similarity": 0.9974077939987183,
        "body": "    colors = {a, b, c}\n    return len(colors)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print output\nprint(count_different_colors(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960786700248718,
            0.9962360858917236,
            0.9939109683036804,
            0.995527446269989,
            0.9969083666801453,
            0.9973405599594116,
            0.9965396523475647,
            0.9971718192100525,
            0.9972218871116638,
            0.9961402416229248,
            0.9974077939987183,
            0.996091365814209,
            0.9926182627677917,
            0.9967790246009827,
            0.9965396523475647,
            0.9970508217811584,
            0.9972218871116638,
            0.9969921112060547,
            0.9911962747573853,
            0.9969083666801453
        ]
    },
    "4008": {
        "similarity": 0.9981378316879272,
        "body": "import sys\n\n    if len(set(a)) < k:\n        return \"NO\"\n    \n    colors = {}\n    for i in range(k):\n        colors[i + 1] = []\n    \n    for num in set(a):\n        for i, color in enumerate(colors):\n            if len(colors[color]) < k and num not in colors[color]:\n                colors[color].append(num)\n                break\n    \n    coloring = [0] * n\n    for i in range(n):\n        coloring[i] = next(color for color, nums in colors.items() if a[i] in nums)\n    \n    return \"YES\\n\" + ' '.join(map(str, coloring))\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    a = list(map(int, data[2:]))\n    \n    result = color_array(n, k, a)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978153705596924,
            0.9980701804161072,
            0.9974652528762817,
            0.9974899291992188,
            0.9975971579551697,
            0.9979708790779114,
            0.9974920153617859,
            0.9938860535621643,
            0.9962202310562134,
            0.9977563619613647,
            0.9973128437995911,
            0.9965177774429321,
            0.997494637966156,
            0.9979132413864136,
            0.9975237846374512,
            0.9981378316879272,
            0.9975489377975464,
            0.9976746439933777,
            0.9969632029533386,
            0.9969385862350464
        ]
    },
    "4257": {
        "similarity": 0.996913492679596,
        "body": "import sys\n\na, b = map(int, input().split())\nprint(a * b)",
        "result": "passed",
        "similarities": [
            0.9969097971916199,
            0.994171142578125,
            0.996913492679596,
            0.9956297874450684,
            0.9936407208442688,
            0.9969097971916199,
            0.9952089190483093,
            0.9936407208442688,
            0.9963218569755554,
            0.9969099164009094,
            0.9952089190483093,
            0.9953758120536804,
            0.9969099164009094,
            0.996913492679596,
            0.9884358644485474,
            0.996913492679596,
            0.9950414896011353,
            0.9969097971916199,
            0.9927143454551697,
            0.996913492679596
        ]
    },
    "4584": {
        "similarity": 0.998722493648529,
        "body": "import sys\n\n    subordinates = [0] * (N + 1)\n    for i in range(2, N + 1):\n        subordinates[bosses[i - 1]] += 1\n    return subordinates[1:]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    bosses = list(map(int, input().split()))\n    result = count_subordinates(N, bosses)\n    for r in result:\n        print(r)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981187582015991,
            0.9981263875961304,
            0.9976831078529358,
            0.9981814026832581,
            0.998722493648529,
            0.9977226257324219,
            0.998013973236084,
            0.998131513595581,
            0.9970921874046326,
            0.9985237121582031,
            0.9985924959182739,
            0.9967723488807678,
            0.9985910058021545,
            0.9976831078529358,
            0.9973580241203308,
            0.997841477394104,
            0.9985910058021545,
            0.9984415769577026,
            0.9980162382125854,
            0.9978567361831665
        ]
    },
    "4195": {
        "similarity": 0.9978765249252319,
        "body": "import sys\n\n    count = 0\n    num = 1\n    while True:\n        if D == 0 and num % 100 != 0:\n            count += 1\n        elif D == 1 and num % 100 == 0:\n            count += 1\n        elif D == 2 and num % 100 == 0 and (num // 100) % 100 == 0:\n            count += 1\n        if count == N:\n            return num\n        num += 1\n\nif __name__ == \"__main__\":\n    D, N = map(int, input().split())\n    print(find_ringo_number(D, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961529970169067,
            0.9965914487838745,
            0.9951722025871277,
            0.9978765249252319,
            0.997727632522583,
            0.9975471496582031,
            0.9956733584403992,
            0.9977024793624878,
            0.9940786957740784,
            0.9964282512664795,
            0.9973179697990417,
            0.9975699186325073,
            0.9977259635925293,
            0.997482419013977,
            0.9973128437995911,
            0.9977004528045654,
            0.9974008202552795,
            0.995029866695404,
            0.9978587627410889,
            0.9976690411567688
        ]
    },
    "4176": {
        "similarity": 0.9934061765670776,
        "body": "import sys\n\n    min_pieces = A * B\n    for i in range(1, min_pieces + 1):\n        if i % A == 0 and i % B == 0:\n            return i\n\nif __name__ == \"__main__\":\n    line = input().strip()\n    A, B = map(int, line.split())\n    print(min_snacks(A, B))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933222532272339,
            0.9929297566413879,
            0.9910979270935059,
            0.9924809336662292,
            0.9899641275405884,
            0.9913570880889893,
            0.9878715872764587,
            0.9891906380653381,
            0.992258608341217,
            0.9901390075683594,
            0.9913249611854553,
            0.9932143688201904,
            0.9926038384437561,
            0.9929164052009583,
            0.9707309603691101,
            0.9907389283180237,
            0.9932268261909485,
            0.9897482991218567,
            0.9886338114738464,
            0.9934061765670776
        ]
    },
    "4166": {
        "similarity": 0.9980679750442505,
        "body": "import sys\n\n    digits = [0] * N\n    for s, c in constraints:\n        digits[s-1] = c\n    \n    for i in range(10**(N-1), 10**N):\n        num_digits = list(map(int, str(i)))\n        if all(num_digits[j-1] == constraints[j-1][1] for j in range(M)):\n            return i\n    return -1\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    constraints = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n    \n    result = find_smallest_integer(N, M, constraints)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980679750442505,
            0.9967913627624512,
            0.9972510933876038,
            0.9976820945739746,
            0.9973706603050232,
            0.9973645806312561,
            0.997443437576294,
            0.9945361614227295,
            0.9975649118423462,
            0.9973244071006775,
            0.9975981712341309,
            0.9966707825660706,
            0.9951927065849304,
            0.9970096945762634,
            0.9970446228981018,
            0.9974827170372009,
            0.997461199760437,
            0.99577796459198,
            0.9972934722900391,
            0.9958205819129944
        ]
    },
    "4827": {
        "similarity": 0.9963861107826233,
        "body": "import sys\n\n    ones = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    hundreds = [\"\", \"onehundred\", \"twohundred\", \"threehundred\", \"fourhundred\", \"fivehundred\", \"sixhundred\", \"sevenhundred\", \"eighthundred\", \"ninehundred\"]\n\n    if num < 10:\n        return ones[num]\n    elif 10 <= num < 20:\n        return teens[num - 10]\n    elif 20 <= num < 100:\n        tens_digit = num // 10\n        ones_digit = num % 10\n        if ones_digit == 0:\n            return tens[tens_digit]\n        else:\n            return tens[tens_digit] + ones[ones_digit]\n    elif 100 <= num < 1000:\n        hundreds_digit = num // 100\n        remainder = num % 100\n        if remainder == 0:\n            return hundreds[hundreds_digit]\n        else:\n            return hundreds[hundreds_digit] + number_to_words(remainder)\n\n    n = int(input())\n    words = [input().strip() for _ in range(n)]\n    index_of_dollar = words.index('$')\n    \n    # Calculate the total number of letters excluding the dollar sign\n    letter_count = sum(len(word) for word in words if word != '$')\n    \n    # Convert the letter count to words\n    result_words = words[:index_of_dollar] + [number_to_words(letter_count)] + words[index_of_dollar+1:]\n    \n    print(' '.join(result_words))\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953191876411438,
            0.994604229927063,
            0.9946261048316956,
            0.9938377737998962,
            0.9903402924537659,
            0.9963861107826233,
            0.9960614442825317,
            0.9928433299064636,
            0.9953557252883911,
            0.9914273023605347,
            0.9931855797767639,
            0.9945622682571411,
            0.9957668781280518,
            0.9949684143066406,
            0.9959481954574585,
            0.9950246214866638,
            0.9940442442893982,
            0.9954289793968201,
            0.9952402710914612,
            0.9943343997001648
        ]
    },
    "4871": {
        "similarity": 0.9979202151298523,
        "body": "import sys\n\n    n = len(scores)\n    current_score = sum(s * (4/5)**i for i, s in enumerate(scores)) / 5\n    \n    total_average_new_score = 0\n    for i in range(n):\n        new_scores = scores[:i] + scores[i+1:]\n        new_score = sum(s * (4/5)**j for j, s in enumerate(new_scores)) / 5\n        total_average_new_score += new_score\n    \n    average_new_score = total_average_new_score / n\n    \n    return current_score, average_new_score\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    scores = list(map(int, data[1:]))\n    \n    result = calculate_group_score(scores)\n    print(f\"{result[0]}\")\n    print(f\"{result[1]:.6f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.996052622795105,
            0.997758150100708,
            0.9975797533988953,
            0.9954766631126404,
            0.9972774982452393,
            0.995431125164032,
            0.9962660074234009,
            0.9967930316925049,
            0.9978474974632263,
            0.9978596568107605,
            0.9965654015541077,
            0.9979202151298523,
            0.997383713722229,
            0.9969008564949036,
            0.9976056814193726,
            0.9974727630615234,
            0.9974687695503235,
            0.9969428181648254,
            0.9975995421409607,
            0.9959608316421509
        ]
    },
    "4148": {
        "similarity": 0.9981247782707214,
        "body": "import sys\n\n    shifted = \"\"\n    for char in S:\n        if 'A' <= char <= 'Z':\n            shifted += chr((ord(char) - ord('A') + N) % 26 + ord('A'))\n        else:\n            shifted += char\n    print(shifted)\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = input().strip()\n    shift_string(N, S)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920074939727783,
            0.9981247782707214,
            0.9977174401283264,
            0.996933102607727,
            0.9980834126472473,
            0.9969369173049927,
            0.9979766011238098,
            0.9974959492683411,
            0.9977772235870361,
            0.9964169859886169,
            0.997434139251709,
            0.9970994591712952,
            0.9977201223373413,
            0.9976977109909058,
            0.9975298047065735,
            0.9976966381072998,
            0.9977663159370422,
            0.9969423413276672,
            0.9969378113746643,
            0.9966663718223572
        ]
    },
    "4316": {
        "similarity": 0.997977614402771,
        "body": "    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    distinct_chars = set(char_count.values())\n    return len(distinct_chars) == 2 and 2 in distinct_chars\n\ns = input().strip()\nprint(\"Yes\" if check_string(s) else \"No\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.997977614402771,
            0.9978430867195129,
            0.9978169798851013,
            0.9971619844436646,
            0.9972054362297058,
            0.9961449503898621,
            0.9959718585014343,
            0.9968820810317993,
            0.997810959815979,
            0.9950512647628784,
            0.9978457093238831,
            0.9977045655250549,
            0.9978059530258179,
            0.9970998167991638,
            0.9965892434120178,
            0.9979579448699951,
            0.9977715015411377,
            0.9974761009216309,
            0.996799647808075,
            0.9958673119544983
        ]
    },
    "4397": {
        "similarity": 0.9962000846862793,
        "body": "    j = N - i + 1\n    print(j)\n\n# Read input from stdin\nN, i = map(int, input().split())\n\nfind_position(N, i)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955794811248779,
            0.9918498992919922,
            0.993553876876831,
            0.9954591989517212,
            0.9959333539009094,
            0.9962000846862793,
            0.995566725730896,
            0.9918802976608276,
            0.9955629110336304,
            0.9959779381752014,
            0.9945356249809265,
            0.9952287077903748,
            0.9918802976608276,
            0.9947044849395752,
            0.9918802976608276,
            0.9942052960395813,
            0.9918498992919922,
            0.9918802976608276,
            0.9940956830978394,
            0.9913203716278076
        ]
    },
    "4180": {
        "similarity": 0.993791401386261,
        "body": "    num_bills = N // 1000\n    change = N % 1000\n    return change\n\nN = int(input())\nprint(calculate_change(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9908357262611389,
            0.9931585192680359,
            0.9921602010726929,
            0.9846047163009644,
            0.9917347431182861,
            0.99181067943573,
            0.9916051626205444,
            0.9914010763168335,
            0.9863834381103516,
            0.9887391924858093,
            0.9920114278793335,
            0.993791401386261,
            0.9882744550704956,
            0.9843397736549377,
            0.9926099181175232,
            0.9820042848587036,
            0.9919857382774353,
            0.9826292991638184,
            0.9921786785125732,
            0.9923051595687866
        ]
    },
    "4907": {
        "similarity": 0.9979407787322998,
        "body": "    if n % 2 == 0:\n        return \"Bob\", 1\n    else:\n        return \"Alice\", 1\n\nn = int(input())\nwinner, move = determine_winner_and_move(n)\nprint(winner)\nif winner == \"Alice\":\n    print(move)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976555705070496,
            0.9977723956108093,
            0.9979407787322998,
            0.9979086518287659,
            0.9978790283203125,
            0.9949873089790344,
            0.9943349957466125,
            0.9978583455085754,
            0.9961819052696228,
            0.9952422976493835,
            0.9979407787322998,
            0.9979407787322998,
            0.9974610209465027,
            0.9977471232414246,
            0.9973302483558655,
            0.9942120909690857,
            0.9896929860115051,
            0.9978790283203125,
            0.9956308603286743,
            0.9979056119918823
        ]
    },
    "4839": {
        "similarity": 0.9965574145317078,
        "body": "import sys\n\n    canisters.sort()\n    balloons = list(range(1, n + 1))\n    balloons.sort(reverse=True)\n    \n    for i in range(n):\n        if canisters[i] < balloons[i]:\n            return \"impossible\"\n    \n    total_helium = sum(canisters)\n    total_capacity = sum(balloons)\n    min_fraction = max(canister / balloon for canister, balloon in zip(canisters, balloons))\n    \n    return round(min_fraction, 6)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    canisters = list(map(int, input().split()))\n    print(max_fraction(n, canisters))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9850987195968628,
            0.9952037334442139,
            0.9964625835418701,
            0.9903182983398438,
            0.9920961260795593,
            0.9959875345230103,
            0.9947586059570312,
            0.9957297444343567,
            0.995459794998169,
            0.9961475729942322,
            0.9955246448516846,
            0.9965574145317078,
            0.995663583278656,
            0.9959639310836792,
            0.9932913780212402,
            0.995341956615448,
            0.9948353171348572,
            0.9942333698272705,
            0.9936110973358154,
            0.9954966306686401
        ]
    },
    "4665": {
        "similarity": 0.9988027811050415,
        "body": "from collections import namedtuple\n\n    n = int(input())\n    columns = input().split()\n    Student = namedtuple('Student', columns)\n    \n    total_marks = 0\n    for _ in range(n):\n        student_data = input().split()\n        student = Student(*student_data)\n        total_marks += float(student.MARKS)\n    \n    average_marks = total_marks / n\n    print(f\"{average_marks:.2f}\")\n\ncalculate_average_marks()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975919127464294,
            0.9988027811050415,
            0.9987872242927551,
            0.9986909627914429,
            0.9985060691833496,
            0.9984293580055237,
            0.9987617135047913,
            0.9987872242927551,
            0.9987872242927551,
            0.9987009763717651,
            0.997602641582489,
            0.9987872242927551,
            0.998776912689209,
            0.9981388449668884,
            0.9987000226974487,
            0.9971519112586975,
            0.9971347451210022,
            0.9987952709197998,
            0.9987879395484924,
            0.9918347597122192
        ]
    },
    "4785": {
        "similarity": 0.9974931478500366,
        "body": "    word = input()\n    for i in range(len(word) - 1):\n        if word[i] == 's' and word[i + 1] == 's':\n            print(\"hiss\")\n            return\n    print(\"no hiss\")\n\ncheck_for_consecutive_s()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973600506782532,
            0.9973660707473755,
            0.997343897819519,
            0.997343897819519,
            0.9971295595169067,
            0.9967131614685059,
            0.9974931478500366,
            0.9970695972442627,
            0.997343897819519,
            0.997343897819519,
            0.9959623217582703,
            0.9954757690429688,
            0.997320294380188,
            0.9967603087425232,
            0.997343897819519,
            0.9971552491188049,
            0.9971295595169067,
            0.9918884634971619,
            0.9961095452308655,
            0.997343897819519
        ]
    },
    "4272": {
        "similarity": 0.9968704581260681,
        "body": "import sys\n\n    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n - 2):\n        if s[i:i+3] == \"ABC\":\n            count += 1\n    print(count)\n\ncount_abc()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961192607879639,
            0.9949952960014343,
            0.993990957736969,
            0.9962068200111389,
            0.9961192607879639,
            0.9944428205490112,
            0.9940077066421509,
            0.9962850213050842,
            0.9962068200111389,
            0.9966517090797424,
            0.9962068200111389,
            0.9945329427719116,
            0.9966866374015808,
            0.9962068200111389,
            0.9954919219017029,
            0.9961192607879639,
            0.9964194297790527,
            0.9961192607879639,
            0.9968704581260681,
            0.9963427186012268
        ]
    },
    "4092": {
        "similarity": 0.9980581402778625,
        "body": "import sys\n\n    insertions = 0\n    current_sum = 0\n    seen_sums = set()\n    \n    for i in range(n):\n        current_sum += array[i]\n        if current_sum in seen_sums:\n            insertions += 1\n            seen_sums.clear()\n        seen_sums.add(current_sum)\n    \n    return insertions\n\n# Read input from stdin\nn = int(input())\narray = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_insertions_to_avoid_zero_sum_subsegments(n, array)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980581402778625,
            0.9971415996551514,
            0.99676114320755,
            0.9973130822181702,
            0.997107982635498,
            0.9971626996994019,
            0.9979981184005737,
            0.9977083802223206,
            0.9943721294403076,
            0.997755765914917,
            0.9976712465286255,
            0.9970526695251465,
            0.9970779418945312,
            0.9975062012672424,
            0.99718177318573,
            0.9980109333992004,
            0.9963060021400452,
            0.9967507123947144,
            0.9978200197219849,
            0.9976491332054138
        ]
    },
    "4023": {
        "similarity": 0.9973888397216797,
        "body": "    max_height = max(a)\n    total_bricks_needed = 0\n    \n    for height in a:\n        if height < max_height:\n            total_bricks_needed += (max_height - height) // 2\n    \n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956609010696411,
            0.9972414970397949,
            0.9973888397216797,
            0.9927999377250671,
            0.9959062337875366,
            0.9953755140304565,
            0.9968180656433105,
            0.9909437298774719,
            0.9973176717758179,
            0.9932234883308411,
            0.9956609010696411,
            0.9971204996109009,
            0.9952968955039978,
            0.996254563331604,
            0.9947311282157898,
            0.9955039024353027,
            0.9939011931419373,
            0.9960313439369202,
            0.9960939288139343,
            0.9964160919189453
        ]
    },
    "4160": {
        "similarity": 0.9975066184997559,
        "body": "import sys\n\n    initial_deposit = 100\n    interest_rate = 1 / 100\n    years = 0\n    balance = initial_deposit\n    \n    while balance < x:\n        balance += int(balance * interest_rate)\n        years += 1\n    \n    return years\n\nif __name__ == \"__main__\":\n    x = int(input())\n    print(years_to_reach_balance(x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9880889058113098,
            0.9970221519470215,
            0.9970000386238098,
            0.9971110820770264,
            0.9971455931663513,
            0.9961779713630676,
            0.9926091432571411,
            0.9967085123062134,
            0.9969717264175415,
            0.9951491355895996,
            0.9975066184997559,
            0.996052622795105,
            0.9968971610069275,
            0.9959270358085632,
            0.9971438050270081,
            0.997063398361206,
            0.996600329875946,
            0.9963567852973938,
            0.9948493838310242,
            0.9969532489776611
        ]
    },
    "4815": {
        "similarity": 0.9979699850082397,
        "body": "import sys\n\n    n, p, m = map(int, input().split())\n    players = {}\n    for _ in range(n):\n        name = input()\n        players[name] = 0\n    \n    scores = []\n    for _ in range(m):\n        line = input().split()\n        name = line[0]\n        points = int(line[1])\n        if name in players:\n            players[name] += points\n            if players[name] >= p:\n                scores.append(name)\n    \n    if scores:\n        for winner in scores:\n            print(f\"{winner} wins!\")\n    else:\n        print(\"No winner!\")\n\nfind_winners()",
        "result": "failed: testcase 0",
        "similarities": [
            0.99567049741745,
            0.9975813031196594,
            0.9973524808883667,
            0.9972120523452759,
            0.9976904988288879,
            0.9973210692405701,
            0.9978029131889343,
            0.9963740110397339,
            0.9979699850082397,
            0.9966188073158264,
            0.9956255555152893,
            0.9928537607192993,
            0.9978781342506409,
            0.9974652528762817,
            0.9974052309989929,
            0.9965294599533081,
            0.9970813393592834,
            0.9977717399597168,
            0.9960967898368835,
            0.9971401691436768
        ]
    },
    "4514": {
        "similarity": 0.9974262118339539,
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    order.append(u)\n    for v in graph[u]:\n        if v != parent:\n            dfs(v, u)\n\n    global graph, order\n    graph = defaultdict(list)\n    order = []\n    \n    for i in range(2, n + 1):\n        graph[p[i - 1]].append(i)\n    \n    result = [-1] * q\n    \n    for idx, (u, k) in enumerate(queries, start=1):\n        if k > len(graph[u]):\n            continue\n        order.clear()\n        dfs(u, -1)\n        result[idx - 1] = order[k - 1]\n    \n    return result\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\np = list(map(int, data[2:2 + n - 1]))\nqueries = [(int(data[2 + n - 1 + i * 2]), int(data[3 + n - 1 + i * 2])) for i in range(q)]\n\n# Process queries\nresult = process_queries(n, q, p, queries)\n\n# Print result\nfor res in result:\n    print(res)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9935649037361145,
            0.9974262118339539,
            0.9969728589057922,
            0.9969913959503174,
            0.9973182678222656,
            0.9968534708023071,
            0.9973646402359009,
            0.9969966411590576,
            0.9924812316894531,
            0.9974166750907898,
            0.9969266653060913,
            0.9956701993942261,
            0.9964897036552429,
            0.9972944855690002,
            0.9971069693565369,
            0.9967617392539978,
            0.9964559674263,
            0.996052622795105,
            0.9960731863975525,
            0.996902346611023
        ]
    },
    "4585": {
        "similarity": 0.9961532950401306,
        "body": "import math\n\n    time = 0\n    while True:\n        if X <= time * (time + 1) // 2:\n            break\n        time += 1\n    return time\n\nif __name__ == \"__main__\":\n    X = int(input().strip())\n    print(min_time_to_reach_nest(X))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959065318107605,
            0.9961532950401306,
            0.9931540489196777,
            0.9932150840759277,
            0.9941328167915344,
            0.9919614195823669,
            0.9959751963615417,
            0.9959743022918701,
            0.9954317808151245,
            0.9957488179206848,
            0.9949974417686462,
            0.9953962564468384,
            0.9940643310546875,
            0.9932478666305542,
            0.9854220151901245,
            0.9947326183319092,
            0.9936485290527344,
            0.9947925209999084,
            0.995633602142334,
            0.995738685131073
        ]
    },
    "4781": {
        "similarity": 0.9976190328598022,
        "body": "    players = list(range(1, 9))\n    current_index = K - 1\n    \n    for time, answer in questions:\n        if answer == 'P':\n            continue\n        \n        current_index = (current_index + 1) % len(players)\n    \n    return players[current_index] if players[current_index] != 0 else 8\n\n# Read input\nK = int(input())\nN = int(input())\nquestions = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Find and print the result\nresult = find_player_with_box(K, N, questions)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968584775924683,
            0.9968451261520386,
            0.9953616261482239,
            0.9972371459007263,
            0.9972548484802246,
            0.9972906708717346,
            0.9962068200111389,
            0.9971413016319275,
            0.9971267580986023,
            0.997146725654602,
            0.9949514269828796,
            0.997253954410553,
            0.9960692524909973,
            0.9944241046905518,
            0.9970718026161194,
            0.9970508217811584,
            0.9953093528747559,
            0.9967419505119324,
            0.9976190328598022,
            0.9966079592704773
        ]
    },
    "4551": {
        "similarity": 0.9971467852592468,
        "body": "    a, b, c, d = map(int, input().split())\n    left = a + b\n    right = c + d\n    if left > right:\n        print(\"Left\")\n    elif left < right:\n        print(\"Right\")\n    else:\n        print(\"Balanced\")\n\nbalance_scale()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947983622550964,
            0.9952456951141357,
            0.9971467852592468,
            0.9967232942581177,
            0.9947854280471802,
            0.9971452355384827,
            0.9970107078552246,
            0.995303213596344,
            0.9954242706298828,
            0.9958243370056152,
            0.996791660785675,
            0.9970797300338745,
            0.9970107078552246,
            0.9967616200447083,
            0.9970798492431641,
            0.9954911470413208,
            0.9955639243125916,
            0.9935867786407471,
            0.9949290752410889,
            0.996442973613739
        ]
    },
    "4345": {
        "similarity": 0.9972472190856934,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    if n == 1:\n        print(\"YES\")\n        print(0)\n        return\n    \n    increasing, decreasing = [], []\n    for i in range(n):\n        if not increasing or a[i] > increasing[-1]:\n            increasing.append(a[i])\n        else:\n            decreasing.append(a[i])\n    \n    if len(increasing) == 1 and len(decreasing) == n - 1:\n        print(\"YES\")\n        res = [0] * n\n        for i in range(n):\n            if a[i] not in increasing:\n                res[i] = 1\n        print(' '.join(map(str, res)))\n    else:\n        print(\"NO\")\n\nfind_sequences()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9919497966766357,
            0.9966793060302734,
            0.9965204000473022,
            0.9972472190856934,
            0.9950500130653381,
            0.9967702627182007,
            0.9971624612808228,
            0.9965993762016296,
            0.9970880746841431,
            0.9967501759529114,
            0.9967561364173889,
            0.9961985349655151,
            0.9960934519767761,
            0.9958420991897583,
            0.99722820520401,
            0.9965137839317322,
            0.9972047209739685,
            0.9954657554626465,
            0.9966964721679688,
            0.9962907433509827
        ]
    },
    "4075": {
        "similarity": 0.9963979125022888,
        "body": "import itertools\n\n    count = 0\n    for switch_states in itertools.product([0, 1], repeat=n):\n        if all((sum(switch_states[j-1] for j in i) % 2 == q) for i, q in zip(k, p)):\n            count += 1\n    return count\n\n# Read input from stdin\nn, m = map(int, input().split())\nk = []\ns = []\nfor _ in range(m):\n    k_i, *switches = map(int, input().split())\n    k.append(k_i)\n    s.append(switches)\np = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(lighted_bulbs(n, m, k, s, p))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963656067848206,
            0.9956222176551819,
            0.9913848042488098,
            0.9951943159103394,
            0.9948381185531616,
            0.9961373209953308,
            0.9963963031768799,
            0.9958305358886719,
            0.9962643980979919,
            0.9954766035079956,
            0.996073305606842,
            0.9943464398384094,
            0.9937226176261902,
            0.9940458536148071,
            0.9962158203125,
            0.995489239692688,
            0.9950649738311768,
            0.9929576516151428,
            0.9957855939865112,
            0.9963979125022888
        ]
    },
    "4408": {
        "similarity": 0.9973200559616089,
        "body": "import sys\nfrom collections import Counter\n\n    total_joy = 0\n    card_counts = Counter(cards)\n    \n    for i in range(n):\n        favorite_count = sum(1 for card in card_counts if card == favorites[i])\n        for t in range(k, -1, -1):\n            if favorite_count >= t:\n                total_joy += joy_levels[t]\n                break\n    \n    return total_joy\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\nfavorites = list(map(int, input().split()))\njoy_levels = list(map(int, input().split()))\n\n# Calculate and print result\nresult = max_joy_levels(n, k, cards, favorites, joy_levels)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956763386726379,
            0.9970817565917969,
            0.9943313598632812,
            0.9932699799537659,
            0.9963098168373108,
            0.9969476461410522,
            0.9961750507354736,
            0.9955278635025024,
            0.9962140917778015,
            0.9953259825706482,
            0.9967219829559326,
            0.9965039491653442,
            0.9973200559616089,
            0.9948907494544983,
            0.9953410625457764,
            0.9958454966545105,
            0.9943214058876038,
            0.9946205615997314,
            0.9967769980430603,
            0.996314525604248
        ]
    },
    "4282": {
        "similarity": 0.9972949624061584,
        "body": "from collections import defaultdict, deque\n\n    adjacency_list = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        x1, x2 = remembered_kids[i - 1]\n        adjacency_list[x1].append(x2)\n        in_degree[x2] += 1\n    \n    queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0])\n    \n    result = []\n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        \n        for neighbor in adjacency_list[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nn = int(input())\nremembered_kids = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(*reconstruct_dance_order(n, remembered_kids))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971348643302917,
            0.9964776635169983,
            0.9968931078910828,
            0.9961823225021362,
            0.9926010966300964,
            0.9967372417449951,
            0.9971321821212769,
            0.9963619112968445,
            0.995519757270813,
            0.9963740110397339,
            0.9970672130584717,
            0.9968510866165161,
            0.9966094493865967,
            0.9962794780731201,
            0.9964467287063599,
            0.9935405254364014,
            0.9972949624061584,
            0.9959668517112732,
            0.9952287077903748,
            0.9962798953056335
        ]
    },
    "4331": {
        "similarity": 0.996907114982605,
        "body": "n = int(input())\nfor digit in str(n):\n    if digit == '7':\n        print(\"Yes\")\n        break\nelse:\n    print(\"No\")",
        "result": "passed",
        "similarities": [
            0.9968265891075134,
            0.9909045696258545,
            0.9964982867240906,
            0.9967030882835388,
            0.9919778108596802,
            0.9962173104286194,
            0.9967052340507507,
            0.9967030882835388,
            0.9906112551689148,
            0.9950941205024719,
            0.9947816729545593,
            0.9944034218788147,
            0.9949327111244202,
            0.996907114982605,
            0.9966267347335815,
            0.9964982867240906,
            0.9967030882835388,
            0.9968233704566956,
            0.9959150552749634,
            0.9964982867240906
        ]
    },
    "4550": {
        "similarity": 0.9984733462333679,
        "body": "    total_candies = a + b + c\n    if total_candies % 2 != 0:\n        return \"No\"\n    target = total_candies // 2\n    for i in range(target + 1):\n        for j in range(target - i + 1):\n            k = target - i - j\n            if a >= i and b >= j and c >= k:\n                return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968222379684448,
            0.9967174530029297,
            0.9976952075958252,
            0.9971042275428772,
            0.998136043548584,
            0.9980008006095886,
            0.9977923035621643,
            0.9975278973579407,
            0.9976335763931274,
            0.9972389936447144,
            0.9950043559074402,
            0.9978229403495789,
            0.9970104098320007,
            0.9969907999038696,
            0.9984733462333679,
            0.9984560608863831,
            0.9981635212898254,
            0.9983790516853333,
            0.997898280620575,
            0.9981887340545654
        ]
    },
    "4271": {
        "similarity": 0.9970026612281799,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    \n    total_satisfaction = 0\n    \n    for i in range(n):\n        total_satisfaction += b[a[i] - 1]\n        if i < n - 1:\n            total_satisfaction += c[a[i] - 1][a[i + 1] - 1]\n    \n    print(total_satisfaction)\n\ncalculate_satisfaction()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968003034591675,
            0.996840238571167,
            0.9948140382766724,
            0.9933488965034485,
            0.9932243824005127,
            0.9968940615653992,
            0.996769368648529,
            0.9970026612281799,
            0.9968523979187012,
            0.9945270419120789,
            0.9963186383247375,
            0.9951390624046326,
            0.9968810081481934,
            0.9944736957550049,
            0.9890252351760864,
            0.9961943626403809,
            0.9929671287536621,
            0.9968699216842651,
            0.9966826438903809,
            0.996783435344696
        ]
    },
    "4848": {
        "similarity": 0.9973704814910889,
        "body": "import math\n\n    for m in range(2, n):\n        if all(m % i != 0 for i in range(2, int(math.sqrt(m)) + 1)):\n            product = m * n\n            if all(product % (i * i) != 0 for i in range(2, int(math.sqrt(product)) + 1)):\n                return m\n\n# Read input from stdin\nn = int(input())\n\n# Find and print the result\nprint(find_notes_per_beat(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931917786598206,
            0.9934925436973572,
            0.9967586994171143,
            0.9966915845870972,
            0.9967036843299866,
            0.9967925548553467,
            0.9958911538124084,
            0.9973543882369995,
            0.9961162209510803,
            0.9971379637718201,
            0.9948605298995972,
            0.9969590902328491,
            0.9970602989196777,
            0.9968110918998718,
            0.9937808513641357,
            0.9965927004814148,
            0.9961260557174683,
            0.9968557953834534,
            0.9948357343673706,
            0.9973704814910889
        ]
    },
    "4694": {
        "similarity": 0.9957007169723511,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Sort the array to make it easier to find the minimum distance\n    a.sort()\n    \n    # The minimum distance is the difference between the maximum and minimum values\n    min_distance = a[-1] - a[0]\n    \n    print(min_distance)\n\nmin_distance_to_travel()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9935034513473511,
            0.9937676787376404,
            0.9936021566390991,
            0.9941175580024719,
            0.993480384349823,
            0.9916362762451172,
            0.9923480153083801,
            0.9940446615219116,
            0.9952974915504456,
            0.9932693839073181,
            0.993759274482727,
            0.9939372539520264,
            0.9956070780754089,
            0.9924862384796143,
            0.9947031736373901,
            0.9957007169723511,
            0.9945427775382996,
            0.993995189666748,
            0.994089663028717,
            0.9926586151123047
        ]
    },
    "4213": {
        "similarity": 0.9988427758216858,
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    min_val = a[0]\n    max_diff = 0\n    \n    for i in range(1, n):\n        diff = abs(a[i] - min_val)\n        if diff > max_diff:\n            max_diff = diff\n        if a[i] < min_val:\n            min_val = a[i]\n    \n    print(max_diff)\n\nmax_absolute_difference()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978429079055786,
            0.9987872242927551,
            0.9986146688461304,
            0.998093843460083,
            0.9975076913833618,
            0.9986957907676697,
            0.9980317950248718,
            0.998559832572937,
            0.9986726641654968,
            0.9987177848815918,
            0.9980438947677612,
            0.9985867738723755,
            0.9984301328659058,
            0.9987177848815918,
            0.9988341927528381,
            0.9983857870101929,
            0.9977399706840515,
            0.9983857870101929,
            0.9988427758216858,
            0.9979111552238464
        ]
    },
    "4471": {
        "similarity": 0.9971612691879272,
        "body": "    while any(a):\n        for i in range(n):\n            if a[i] > 0:\n                a[i] += 2\n                break\n        else:\n            return False\n        for _ in range(101):  # Assuming a maximum of 100 steps\n            a = [x - 1 if x > 0 else x for x in a]\n    return True\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if can_clear_field(n, a):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947183728218079,
            0.9959486722946167,
            0.9930363893508911,
            0.9968950152397156,
            0.994602620601654,
            0.9926543235778809,
            0.9966587424278259,
            0.9964821338653564,
            0.9945020079612732,
            0.9966075420379639,
            0.9963248372077942,
            0.9964926838874817,
            0.9956085085868835,
            0.9957419037818909,
            0.9970584511756897,
            0.9957837462425232,
            0.9957791566848755,
            0.9971612691879272,
            0.9963347911834717,
            0.996621310710907
        ]
    },
    "4802": {
        "similarity": 0.9960873126983643,
        "body": "import sys\n\n    new_M = M - 45\n    if new_M < 0:\n        new_H = H - 1\n        if new_H < 0:\n            new_H += 24\n        new_M += 60\n    else:\n        new_H = H\n    print(f\"{new_H} {new_M}\")\n\n# Read input from stdin\nH, M = map(int, input().split())\n\n# Adjust the alarm time and print the result\nadjust_alarm(H, M)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955307841300964,
            0.9941357970237732,
            0.994635820388794,
            0.9939789175987244,
            0.9946287274360657,
            0.994221568107605,
            0.995391845703125,
            0.9942319989204407,
            0.9884250164031982,
            0.9937774538993835,
            0.9955549836158752,
            0.9959125518798828,
            0.9942253828048706,
            0.9907201528549194,
            0.9943193197250366,
            0.9947365522384644,
            0.9908425211906433,
            0.9960873126983643,
            0.9932740926742554,
            0.995212733745575
        ]
    },
    "4890": {
        "similarity": 0.9965645670890808,
        "body": "import sys\nfrom typing import List\n\n    total_cold = sum(c)\n    \n    if total_cold < m:\n        return \"impossible\"\n    \n    result = [0] * s\n    remaining_students = m\n    \n    for i in range(s):\n        if remaining_students > 0 and c[i] < d:\n            add_bottles = min(remaining_students, d - c[i])\n            result[i] = add_bottles\n            total_cold += add_bottles\n            remaining_students -= add_bottles\n    \n    return ' '.join(map(str, result))\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read()\n    data = input_data.split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = int(data[2])\n    d = int(data[3])\n    c = list(map(int, data[4:]))\n    \n    print(refill_fridge(n, m, s, d, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965645670890808,
            0.9950034618377686,
            0.9956249594688416,
            0.9955913424491882,
            0.9936297535896301,
            0.9958999156951904,
            0.9948276877403259,
            0.9958691000938416,
            0.9949626922607422,
            0.9959929585456848,
            0.9940778017044067,
            0.9957960247993469,
            0.9938387870788574,
            0.9952582120895386,
            0.9956943988800049,
            0.9953486919403076,
            0.9959728121757507,
            0.9894033670425415,
            0.9962413311004639,
            0.9947282671928406
        ]
    },
    "4286": {
        "similarity": 0.9977695941925049,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    edges = defaultdict(dict)\n    \n    for x, y, w in offers:\n        edges[x][y] = min(edges[x].get(y, float('inf')), w)\n        edges[y][x] = min(edges[y].get(x, float('inf')), w)\n    \n    min_cost_edges = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) not in edges and (j, i) not in edges:\n                min_cost_edges.append((a[i-1] + a[j-1], i, j))\n    \n    min_cost_edges.sort()\n    \n    parent = list(range(n+1))\n    rank = [0] * (n+1)\n    \n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n        rootX = find(x)\n        rootY = find(y)\n        \n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    for cost, x, y in min_cost_edges:\n        if find(x) != find(y):\n            union(x, y)\n    \n    components = set()\n    for i in range(1, n+1):\n        components.add(find(i))\n    \n    return sum(cost for cost, _, _ in min_cost_edges if len(components) <= 1)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    offers = []\n    \n    index = 2 + n\n    for _ in range(m):\n        x = int(data[index]) - 1\n        y = int(data[index+1]) - 1\n        w = int(data[index+2])\n        offers.append((x, y, w))\n        index += 3\n    \n    print(min_cost_to_connect_graph(n, m, a, offers))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968365430831909,
            0.9977695941925049,
            0.9972692728042603,
            0.9973122477531433,
            0.9973704814910889,
            0.9969907999038696,
            0.9972450733184814,
            0.9974682331085205,
            0.9971596598625183,
            0.9966008067131042,
            0.9975704550743103,
            0.9975088238716125,
            0.9968448281288147,
            0.9965097308158875,
            0.9945235252380371,
            0.9970267415046692,
            0.997689425945282,
            0.9974704384803772,
            0.9975144267082214,
            0.9970682263374329
        ]
    },
    "4713": {
        "similarity": 0.9980561137199402,
        "body": "    n = int(input())\n    s = input()\n    \n    x = 0\n    max_val = 0\n    \n    for char in s:\n        if char == 'I':\n            x += 1\n        elif char == 'D':\n            x -= 1\n        if x > max_val:\n            max_val = x\n            \n    print(max_val)\n\nmax_value_taken_by_x()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976411461830139,
            0.9968565106391907,
            0.9972288012504578,
            0.9972435832023621,
            0.9975916147232056,
            0.9980561137199402,
            0.9962999224662781,
            0.9976052045822144,
            0.9973955750465393,
            0.99712735414505,
            0.9975262880325317,
            0.9963204264640808,
            0.9972144961357117,
            0.9979170560836792,
            0.9979931712150574,
            0.9972501993179321,
            0.9978288412094116,
            0.9977858662605286,
            0.9978693127632141,
            0.9977912902832031
        ]
    },
    "4698": {
        "similarity": 0.9972812533378601,
        "body": "import sys\n\n    n = int(input())\n    t = list(map(int, input().split()))\n    m = int(input())\n    drinks = []\n    for _ in range(m):\n        p, x = map(int, input().split())\n        drinks.append((p - 1, x))\n\n    results = []\n    for p, x in drinks:\n        total_time = sum(t[:p]) + sum(t[p:]) + (x * t[p])\n        results.append(total_time)\n\n    for result in results:\n        print(result)\n\ncalculate_times()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996479868888855,
            0.9963032603263855,
            0.9951249361038208,
            0.9951679706573486,
            0.9972812533378601,
            0.9972692728042603,
            0.9963250756263733,
            0.9966888427734375,
            0.9932535886764526,
            0.996543288230896,
            0.9960682392120361,
            0.9964348673820496,
            0.9947034120559692,
            0.9961929321289062,
            0.9959716796875,
            0.9961754679679871,
            0.9962090253829956,
            0.9970669150352478,
            0.9971861839294434,
            0.9969339966773987
        ]
    },
    "4841": {
        "similarity": 0.9977255463600159,
        "body": "    n = int(input())\n    bites = input().split()\n    \n    expected = 1\n    for bite in bites:\n        if bite == \"mumble\":\n            continue\n        if int(bite) != expected:\n            print(\"something is fishy\")\n            return\n        expected += 1\n    \n    print(\"makes sense\")\n\ncheck_counting()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945741295814514,
            0.9974967837333679,
            0.9969062805175781,
            0.9966095685958862,
            0.9960070252418518,
            0.997485339641571,
            0.9967412352561951,
            0.9971307516098022,
            0.9966575503349304,
            0.9951024651527405,
            0.9973915815353394,
            0.9975500702857971,
            0.9972401857376099,
            0.997528076171875,
            0.9969916343688965,
            0.9970090985298157,
            0.9968574047088623,
            0.9972184896469116,
            0.9977255463600159,
            0.9961051940917969
        ]
    },
    "4865": {
        "similarity": 0.9970520734786987,
        "body": "import sys\n\n    results = []\n    for _ in range(test_cases):\n        direction, minutes_change, current_hour, current_minute = input().split()\n        minutes_change = int(minutes_change)\n        \n        if direction == 'F':\n            new_minutes = (current_minute + minutes_change) % 60\n            new_hours = (current_hour + (current_minute + minutes_change) // 60) % 24\n        else:\n            new_minutes = (current_minute - minutes_change) % 60\n            new_hours = (current_hour - (current_minute - minutes_change) // 60) % 24\n        \n        results.append(f\"{new_hours} {new_minutes}\")\n    \n    for result in results:\n        print(result)\n\n# Read the number of test cases\ntest_cases = int(input())\ncalculate_new_time(test_cases)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9927886128425598,
            0.9965175986289978,
            0.9956867694854736,
            0.9970520734786987,
            0.9943920969963074,
            0.994982898235321,
            0.9950709939002991,
            0.996405839920044,
            0.9970514178276062,
            0.9948437213897705,
            0.9967799186706543,
            0.9953446984291077,
            0.9962451457977295,
            0.9948284029960632,
            0.9960993528366089,
            0.9965721964836121,
            0.9965577721595764,
            0.9959572553634644,
            0.9928487539291382,
            0.9964374899864197
        ]
    },
    "4957": {
        "similarity": 0.9962595105171204,
        "body": "import sys\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                valid = True\n                for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + x, j + y\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        valid = False\n                        break\n                if valid:\n                    grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n    return grid\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, m = int(data[0]), int(data[1])\n    grid = data[2:]\n    \n    result = place_coffee_shops(n, m, grid)\n    \n    for row in result:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947143197059631,
            0.993996262550354,
            0.9953125715255737,
            0.9961317181587219,
            0.9951560497283936,
            0.9956129789352417,
            0.9956773519515991,
            0.9960502982139587,
            0.9934752583503723,
            0.99560546875,
            0.9958592653274536,
            0.9936670064926147,
            0.9952796101570129,
            0.9962595105171204,
            0.9955757856369019,
            0.9961140155792236,
            0.9951930642127991,
            0.9919791221618652,
            0.9955356121063232,
            0.9959520101547241
        ]
    },
    "4382": {
        "similarity": 0.9943835735321045,
        "body": "import sys\n\n    n = int(input().strip())\n    num_passwords = n ** 3\n    print(num_passwords)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9833738207817078,
            0.9833738207817078,
            0.9939940571784973,
            0.9924032092094421,
            0.9887203574180603,
            0.9912737607955933,
            0.9939759969711304,
            0.9922553896903992,
            0.9941739439964294,
            0.9940072894096375,
            0.9871748089790344,
            0.9940738677978516,
            0.9898260235786438,
            0.9927793741226196,
            0.9943835735321045,
            0.9883384704589844,
            0.992165207862854,
            0.9925443530082703,
            0.9914768934249878,
            0.9940738677978516
        ]
    },
    "4456": {
        "similarity": 0.9969926476478577,
        "body": "import sys\n\n    if n < k:\n        return \"NO\"\n    \n    # Create a list of distinct characters to use in the string\n    distinct_chars = sorted(set('abcdefghijklmnopqrstuvwxyz')[:k])\n    \n    # Initialize the result string with spaces\n    s = [' '] * n\n    \n    # Fill the string according to the permutations p and q\n    for i in range(n):\n        if i == 0 or p[i] > p[i-1]:\n            s[p[i]-1] = distinct_chars.pop(0)\n        else:\n            s[q[i]-1] = distinct_chars.pop(0)\n    \n    # Join the list into a string and return\n    result = ''.join(s)\n    if all(result[p[i]-1] <= result[p[i+1]-1] for i in range(n-1)) and all(result[q[i]-1] <= result[q[i+1]-1] for i in range(n-1)):\n        return f\"YES\\n{result}\"\n    else:\n        return \"NO\"\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# Get the result and print it\nprint(restore_string(n, k, p, q))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963966012001038,
            0.9962450265884399,
            0.9965254068374634,
            0.9967510104179382,
            0.9962969422340393,
            0.9966630339622498,
            0.9967842102050781,
            0.9958276152610779,
            0.9963107109069824,
            0.9960281848907471,
            0.9963399171829224,
            0.9960885643959045,
            0.9964684247970581,
            0.996545672416687,
            0.9967647194862366,
            0.9969926476478577,
            0.9934163689613342,
            0.9959819316864014,
            0.9956470131874084,
            0.9833614826202393
        ]
    },
    "4594": {
        "similarity": 0.9978804588317871,
        "body": "    d.sort(reverse=True)\n    max_layers = 1\n    current_diameter = d[0]\n    \n    for i in range(1, N):\n        if d[i] < current_diameter:\n            max_layers += 1\n            current_diameter = d[i]\n    \n    return max_layers\n\n# Read input from stdin\nN = int(input())\nd = [int(input()) for _ in range(N)]\n\n# Print the result\nprint(max_kagami_mochi_layers(N, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977284669876099,
            0.9978804588317871,
            0.9977205395698547,
            0.9966819286346436,
            0.9975953698158264,
            0.9968104958534241,
            0.9978267550468445,
            0.9975348114967346,
            0.9978188872337341,
            0.9960400462150574,
            0.9965046644210815,
            0.9959913492202759,
            0.9976164102554321,
            0.9955134391784668,
            0.9973070025444031,
            0.9975813627243042,
            0.9962474703788757,
            0.9973264932632446,
            0.9971835613250732,
            0.9970418810844421
        ]
    },
    "4560": {
        "similarity": 0.9984606504440308,
        "body": "    for i in range(0, N // 500 + 1):\n        if (N - i * 500) % 1 == 0 and (N - i * 500) <= A:\n            return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = int(input())\n    print(can_pay_exactly(N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9984092712402344,
            0.9980735778808594,
            0.9984091520309448,
            0.9980944395065308,
            0.998160719871521,
            0.9980838298797607,
            0.9983455538749695,
            0.9982355833053589,
            0.9983455538749695,
            0.998335063457489,
            0.996836245059967,
            0.9974322319030762,
            0.9983078837394714,
            0.9969831705093384,
            0.9982113242149353,
            0.9982035756111145,
            0.9984606504440308,
            0.9974437355995178,
            0.9983447194099426,
            0.9981761574745178
        ]
    },
    "4320": {
        "similarity": 0.9966675639152527,
        "body": "    for x in range(1, n + 1):\n        sum wrappers = 0\n        k = 1\n        while sum wrappers <= n:\n            sum wrappers += x * (2 ** (k - 1))\n            if sum wrappers == n:\n                return x\n            k += 1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(find_candy_x(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955459237098694,
            0.99547278881073,
            0.991998553276062,
            0.9948965311050415,
            0.9918841123580933,
            0.99566251039505,
            0.9958594441413879,
            0.9956757426261902,
            0.9954938292503357,
            0.9959205985069275,
            0.9933943748474121,
            0.9939403533935547,
            0.9951884746551514,
            0.9966675639152527,
            0.9957699179649353,
            0.9960363507270813,
            0.9958594441413879,
            0.9961230754852295,
            0.9959429502487183,
            0.9966175556182861
        ]
    },
    "4500": {
        "similarity": 0.9967900514602661,
        "body": "import sys\n\n    total = a + b\n    if total >= c:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    input_line = input().strip()\n    A, B, C = map(int, input_line.split())\n    print(can_buy_toy(A, B, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99639493227005,
            0.995555579662323,
            0.9961188435554504,
            0.9967900514602661,
            0.9963690042495728,
            0.9956725239753723,
            0.9962417483329773,
            0.9908666014671326,
            0.99639493227005,
            0.9961919188499451,
            0.9963650107383728,
            0.9962417483329773,
            0.9962756633758545,
            0.9943335652351379,
            0.9959182739257812,
            0.9965897798538208,
            0.9963791370391846,
            0.9960851073265076,
            0.9956757426261902,
            0.9963959455490112
        ]
    },
    "4739": {
        "similarity": 0.9976537823677063,
        "body": "import sys\n\n    speeds = set()\n    distances = []\n    \n    for i in range(1, M):\n        time_diff = T[i] - T[0]\n        dist_diff = X[T.index(T[i])] - X[T.index(T[0])]\n        speed = dist_diff / time_diff\n        if speed not in speeds:\n            speeds.add(speed)\n            distances.append(dist_diff)\n    \n    distances.sort()\n    \n    print(len(speeds))\n    print(\" \".join(map(str, distances)))\n\n# Read input from stdin\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ncalculate_speeds_and_distances(M, N, T, X)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971495270729065,
            0.9973689913749695,
            0.9969173073768616,
            0.9975515604019165,
            0.997430682182312,
            0.9973616600036621,
            0.9970183968544006,
            0.9970458149909973,
            0.9970219135284424,
            0.9947084188461304,
            0.9967079162597656,
            0.9973477125167847,
            0.9936307668685913,
            0.9971016645431519,
            0.9961495995521545,
            0.9957078695297241,
            0.9968577027320862,
            0.9974300861358643,
            0.9943540692329407,
            0.9976537823677063
        ]
    },
    "4410": {
        "similarity": 0.9972972869873047,
        "body": "import sys\n\n    i = 0\n    count = 0\n    while i < n:\n        if s[i] == '1':\n            i += k + 1\n        else:\n            count += 1\n            i += 1\n    return count\n\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        results.append(max_occupied_tables(n, k, s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970465302467346,
            0.9959281086921692,
            0.9967190623283386,
            0.9962241649627686,
            0.9968597888946533,
            0.9947638511657715,
            0.9925910830497742,
            0.9965509176254272,
            0.9962042570114136,
            0.9949368834495544,
            0.9928404092788696,
            0.9961987733840942,
            0.995555579662323,
            0.996344804763794,
            0.9954757690429688,
            0.9957649111747742,
            0.9967441558837891,
            0.9972972869873047,
            0.9962878227233887,
            0.99651038646698
        ]
    },
    "2441": {
        "similarity": 0.9980954527854919,
        "body": "import sys\n\n    MOD = 10**9 + 7\n    \n    # Initialize adjacency list for the graph\n    adj_list = [[] for _ in range(n)]\n    for u, v in roads:\n        adj_list[u-1].append(v-1)\n    \n    # Initialize DP arrays\n    dp_cost = [float('inf')] * n\n    dp_count = [0] * n\n    \n        if not adj_list[node]:\n            dp_cost[node] = costs[node]\n            dp_count[node] = 1\n            return dp_cost[node], dp_count[node]\n        \n        total_cost = costs[node]\n        total_ways = 1\n        \n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                cost, ways = dfs(neighbor, node)\n                dp_cost[node] += min(cost, dp_cost[node])\n                dp_count[node] = (dp_count[node] + ways) % MOD\n                \n        return dp_cost[node], dp_count[node]\n    \n    dfs(0, -1)\n    \n    return dp_cost[0], dp_count[0]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    costs = list(map(int, input().split()))\n    m = int(input())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    min_cost, min_ways = min_security_cost_and_ways(n, costs, roads)\n    print(min_cost, min_ways)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980493187904358,
            0.9979425668716431,
            0.997524082660675,
            0.9970737099647522,
            0.996849775314331,
            0.9977445006370544,
            0.9974676370620728,
            0.9956135153770447,
            0.9972801208496094,
            0.9977214336395264,
            0.9971978068351746,
            0.9970213174819946,
            0.9980954527854919,
            0.9979487061500549,
            0.9978796243667603,
            0.9969450235366821,
            0.9963350892066956,
            0.9980398416519165,
            0.9975534677505493,
            0.9970723986625671
        ]
    },
    "276": {
        "similarity": 0.9943548440933228,
        "body": "import sys\n\n    gems = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']\n    seen_colors = set()\n    \n    n = int(input())\n    for _ in range(n):\n        seen_color = input().strip()\n        if seen_color in gems:\n            seen_colors.add(seen_color)\n    \n    absent_gems = [gem for gem in gems if gem not in seen_colors]\n    \n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem.capitalize())\n\nfind_absent_gems()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931681752204895,
            0.991227388381958,
            0.9939579367637634,
            0.9902657866477966,
            0.9938523173332214,
            0.9912452697753906,
            0.9892377257347107,
            0.9896945953369141,
            0.9916221499443054,
            0.9908248782157898,
            0.9942250847816467,
            0.9925681948661804,
            0.9919044971466064,
            0.9905701875686646,
            0.9935409426689148,
            0.9943548440933228,
            0.9888026714324951,
            0.9935081005096436,
            0.993263840675354,
            0.9862324595451355
        ]
    },
    "2635": {
        "similarity": 0.9970661997795105,
        "body": "    m, n = len(matrix), len(matrix[0])\n    result = []\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    print(result)\n\n# Read input from stdin\nmatrix = [list(map(int, input().split())) for _ in range(int(input()))]\nspiral_order(matrix)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933867454528809,
            0.9952111840248108,
            0.9967401623725891,
            0.9955173134803772,
            0.9970661997795105,
            0.9964063763618469,
            0.9956023693084717,
            0.9965226054191589,
            0.9950557351112366,
            0.9957185983657837,
            0.9955995678901672,
            0.9966386556625366,
            0.9932205080986023,
            0.9937617778778076,
            0.99605792760849,
            0.9963173270225525,
            0.9968669414520264,
            0.9965534210205078,
            0.9957613945007324,
            0.9963148236274719
        ]
    },
    "281": {
        "similarity": 0.9979279041290283,
        "body": "import math\n\n    if a == b:\n        return 1\n    elif a == 0:\n        return 2\n    else:\n        last_digit = 1\n        for i in range(a + 1, b + 1):\n            last_digit = (last_digit * (i % 10)) % 10\n        return last_digit\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(last_digit_of_factorial_division(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997210681438446,
            0.9961069822311401,
            0.9970474243164062,
            0.9977902770042419,
            0.9958924055099487,
            0.9972192049026489,
            0.9972404837608337,
            0.9960118532180786,
            0.9979279041290283,
            0.9974602460861206,
            0.9971253275871277,
            0.9970002770423889,
            0.9954344034194946,
            0.9963834881782532,
            0.9978697896003723,
            0.996648907661438,
            0.9977400898933411,
            0.9963952302932739,
            0.9977778196334839,
            0.9973876476287842
        ]
    },
    "2300": {
        "similarity": 0.9980615377426147,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    operations = []\n    index = 2 + n\n    for _ in range(m):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index+1]) - 1\n            v = int(data[index+2])\n            operations.append((t, x, v))\n        elif t == 2:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            operations.append((t, l, r))\n        else:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            d = int(data[index+3])\n            operations.append((t, l, r, d))\n        index += (3 if t == 1 else 4)\n    \n        if i < 2:\n            return 1\n        f_values = [0] * (n + 1)\n        f_values[0], f_values[1] = 1, 1\n        for j in range(2, i + 1):\n            f_values[j] = (f_values[j - 1] - 1 + f_values[j - 2]) % 1000000000\n        return f_values[i]\n    \n    result = []\n    current_sum = sum(f(i) * a[i] for i in range(n))\n    for op in operations:\n        if op[0] == 1:\n            x, v = op[1], op[2]\n            current_sum -= f(x) * a[x]\n            a[x] = v\n            current_sum += f(x) * a[x]\n        elif op[0] == 2:\n            l, r = op[1], op[2]\n            new_sum = current_sum - sum(f(i) * a[i] for i in range(l, r))\n            current_sum = new_sum + sum(f(i) * (a[i] + 0) for i in range(l, r))\n        else:\n            l, r, d = op[1], op[2], op[3]\n            current_sum += d * (r - l)\n    \n    for value in result:\n        print(value)\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953725934028625,
            0.9980615377426147,
            0.9975658059120178,
            0.997564435005188,
            0.9978652596473694,
            0.9967979788780212,
            0.9959793090820312,
            0.9974265098571777,
            0.9980494976043701,
            0.9979020357131958,
            0.9975511431694031,
            0.9973458051681519,
            0.9977881908416748,
            0.9978839755058289,
            0.9972673058509827,
            0.9976204633712769,
            0.9956197142601013,
            0.9979140758514404,
            0.9979959726333618,
            0.9963734149932861
        ]
    },
    "2104": {
        "similarity": 0.9976645112037659,
        "body": "from math import gcd\n\n    if (r - l) % 2 != 1 or (r - l + 1) > 3 * 10**5:\n        return \"NO\"\n    \n    pairs = []\n    for i in range(l, r + 1):\n        found_pair = False\n        for j in range(i + 1, r + 1):\n            if gcd(i, j) == 1:\n                pairs.append((i, j))\n                found_pair = True\n                break\n        if not found_pair:\n            return \"NO\"\n    \n    return \"YES\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in pairs)\n\nl, r = map(int, input().split())\nresult = find_pairs(l, r)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975426197052002,
            0.9954152703285217,
            0.9976645112037659,
            0.9967241883277893,
            0.9971775412559509,
            0.9961927533149719,
            0.9976523518562317,
            0.9949584603309631,
            0.9964877963066101,
            0.9965057373046875,
            0.9973439574241638,
            0.9966717958450317,
            0.9972339272499084,
            0.9975019693374634,
            0.9959359765052795,
            0.9969013929367065,
            0.9960100054740906,
            0.9965549111366272,
            0.9969002604484558,
            0.9972425103187561
        ]
    },
    "1995": {
        "similarity": 0.9974271059036255,
        "body": "    for l, r, k in queries:\n        substring = s[l-1:r]\n        k = k % len(substring)  # Handle large k values\n        rotated_substring = substring[-k:] + substring[:-k]\n        s = s[:l-1] + rotated_substring + s[r:]\n    return s\n\n# Read input\ns = input().strip()\nm = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Process queries and print result\nresult = process_queries(s, queries)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972255229949951,
            0.9956861734390259,
            0.9973936676979065,
            0.9962373971939087,
            0.9970273375511169,
            0.9947594404220581,
            0.9972150921821594,
            0.9958858489990234,
            0.9972349405288696,
            0.9972233176231384,
            0.9964615702629089,
            0.9966070055961609,
            0.9969786405563354,
            0.997220516204834,
            0.9965625405311584,
            0.9922676086425781,
            0.9953134655952454,
            0.9962815642356873,
            0.9974271059036255,
            0.9968933463096619
        ]
    },
    "2064": {
        "similarity": 0.9972347617149353,
        "body": "    digits = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n    result = []\n    \n    for i in range(9, -1, -1):\n        while n >= digits[i]:\n            result.append(i)\n            n -= digits[i]\n    \n    return ''.join(map(str, result))\n\n# Read input from stdin\nn = int(input())\n# Print the result\nprint(max_integer(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969841837882996,
            0.9970757365226746,
            0.9972347617149353,
            0.9955201745033264,
            0.9965892434120178,
            0.9962325692176819,
            0.9958040118217468,
            0.993314266204834,
            0.9972030520439148,
            0.9943245649337769,
            0.9971901774406433,
            0.9958682060241699,
            0.9962312579154968,
            0.9955748319625854,
            0.997056245803833,
            0.9968143105506897,
            0.9908541440963745,
            0.9962166547775269,
            0.9970738291740417,
            0.9969460368156433
        ]
    },
    "1715": {
        "similarity": 0.9958741068840027,
        "body": "import sys\n\n    results = []\n    for x in queries:\n        min_distance = float('inf')\n        for s in shrines:\n            if s < x:\n                dist_to_shrine = x - s\n                for t in temples:\n                    if t > x:\n                        dist_to_temple = t - x\n                        min_distance = min(min_distance, dist_to_shrine + dist_to_temple)\n                        break\n        results.append(min_distance)\n    return results\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    A = int(data[0])\n    B = int(data[1])\n    Q = int(data[2])\n    \n    shrines = [int(data[3 + i]) for i in range(A)]\n    temples = [int(data[3 + A + i]) for i in range(B)]\n    queries = [int(data[3 + A + B + i]) for i in range(Q)]\n    \n    results = solve(A, B, Q, shrines, temples, queries)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953155517578125,
            0.9945133924484253,
            0.9948519468307495,
            0.9942426085472107,
            0.9958741068840027,
            0.9951673150062561,
            0.9918561577796936,
            0.9953325986862183,
            0.9891000390052795,
            0.9953565001487732,
            0.9947433471679688,
            0.9908851981163025,
            0.9926442503929138,
            0.995345950126648,
            0.9948712587356567,
            0.9946786165237427,
            0.9956148862838745,
            0.9954685568809509,
            0.9917906522750854,
            0.9952273964881897
        ]
    },
    "2074": {
        "similarity": 0.9952813386917114,
        "body": "import sys\n\n    min_costs = [min(row) for row in costs]\n    return max(min_costs)\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    costs = []\n    for _ in range(n):\n        costs.append(list(map(int, input().split())))\n    print(find_dinner_cost(n, m, costs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952813386917114,
            0.9944365620613098,
            0.995276689529419,
            0.9902279376983643,
            0.9943743348121643,
            0.9914349317550659,
            0.995153546333313,
            0.9923617839813232,
            0.9910268187522888,
            0.9943366050720215,
            0.9942895770072937,
            0.9945319294929504,
            0.9935091733932495,
            0.99213045835495,
            0.993376612663269,
            0.9942895770072937,
            0.9952049255371094,
            0.993376612663269,
            0.9912645220756531,
            0.9926880598068237
        ]
    },
    "2921": {
        "similarity": 0.9975913166999817,
        "body": "    drinks = []\n    for _ in range(d):\n        name, strength, size, cost = input().split()\n        strength = int(strength)\n        price = float(cost)\n        unit_cost = (price * 100) / strength\n        if size == '1/1':\n            size_val = 1.0\n        elif size == '1/2':\n            size_val = 0.5\n        else:\n            size_val = 1.0 / 3\n        drinks.append((name, unit_cost * size_val))\n\n    dp = [[False] * (u + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(m + 1):\n        for j in range(u + 1):\n            if dp[i][j]:\n                for name, cost in drinks:\n                    new_cost = i - cost\n                    new_units = j - cost // unit_cost\n                    if new_cost >= 0 and new_units >= 0:\n                        dp[new_cost][new_units] = True\n\n    if not dp[m][u]:\n        print(\"IMPOSSIBLE\")\n        return\n\n    result = []\n    for i in range(m, -1, -1):\n        for j in range(u, -1, -1):\n            if dp[i][j] and (i == 0 or not dp[i-1][j]):\n                for name, cost in drinks:\n                    new_cost = i - cost\n                    new_units = j - cost // unit_cost\n                    if new_cost == 0 and new_units == 0:\n                        result.append((name, int(i // cost)))\n    for name, count in result:\n        print(name, count)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967882037162781,
            0.995967447757721,
            0.9972843527793884,
            0.9929634928703308,
            0.9971254467964172,
            0.9972602725028992,
            0.996285080909729,
            0.9973070025444031,
            0.9971829652786255,
            0.9968921542167664,
            0.9967575073242188,
            0.9963738322257996,
            0.9955487847328186,
            0.9955448508262634,
            0.9967313408851624,
            0.9975913166999817,
            0.9972981810569763,
            0.9961708784103394,
            0.997105062007904,
            0.9965565204620361
        ]
    },
    "1642": {
        "similarity": 0.9978131055831909,
        "body": "import sys\n\n    n = int(input())\n    vertices = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    min_dist = float('inf')\n    \n    for i in range(n):\n        x1, y1 = vertices[i]\n        for j in range(i + 1, n):\n            x2, y2 = vertices[j]\n            dist = ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n            min_dist = min(min_dist, dist / 2)\n    \n    print(min_dist)\n\nmax_distance()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978131055831909,
            0.9973530173301697,
            0.9976856708526611,
            0.9976244568824768,
            0.9972693920135498,
            0.9969614148139954,
            0.9955165386199951,
            0.9970870614051819,
            0.9974668622016907,
            0.9972805380821228,
            0.9976272583007812,
            0.9975276589393616,
            0.9968915581703186,
            0.9973126649856567,
            0.9976159930229187,
            0.9966633319854736,
            0.9976979494094849,
            0.9968332052230835,
            0.9974877238273621,
            0.9947770833969116
        ]
    },
    "947": {
        "similarity": 0.9969568848609924,
        "body": "import sys\n\n    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return n - 1, 1\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a, b = min_lcm_pair(n)\n        print(a, b)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995488703250885,
            0.9922263622283936,
            0.996254563331604,
            0.9963300824165344,
            0.9956380128860474,
            0.9957742094993591,
            0.9963361024856567,
            0.9943216443061829,
            0.9963366985321045,
            0.996029794216156,
            0.9954166412353516,
            0.9959396719932556,
            0.9952515363693237,
            0.9956212639808655,
            0.9969568848609924,
            0.9967139363288879,
            0.995719313621521,
            0.9968753457069397,
            0.9947289228439331,
            0.9949720501899719
        ]
    },
    "743": {
        "similarity": 0.9974084496498108,
        "body": "    for i in range(n):\n        for j in range(i + 1, n):\n            if numbers[i] > numbers[j]:\n                numbers[i] -= numbers[j]\n    return sum(numbers)\n\n# Read input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Print result\nprint(min_sum(n, numbers))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971248507499695,
            0.996679425239563,
            0.9971436262130737,
            0.996905505657196,
            0.9949196577072144,
            0.9958246350288391,
            0.9968134164810181,
            0.993495762348175,
            0.9973716735839844,
            0.9963697195053101,
            0.997252345085144,
            0.9967535734176636,
            0.9974084496498108,
            0.9967535734176636,
            0.9930787682533264,
            0.9964715838432312,
            0.9967597126960754,
            0.9961848855018616,
            0.996657133102417,
            0.9953776001930237
        ]
    },
    "1397": {
        "similarity": 0.9959499835968018,
        "body": "import sys\n\n    roads = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if (i, j) not in forbidden_pairs and (j, i) not in forbidden_pairs:\n                roads.append((i, j))\n    return roads\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    forbidden_pairs = set()\n    index = 2\n    for _ in range(m):\n        a = int(data[index])\n        b = int(data[index+1])\n        forbidden_pairs.add((a, b))\n        forbidden_pairs.add((b, a))\n        index += 2\n    \n    roads = construct_roads(n, m, forbidden_pairs)\n    \n    print(len(roads))\n    for road in roads:\n        print(road[0], road[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.994208574295044,
            0.9949362874031067,
            0.992366373538971,
            0.9955131411552429,
            0.9954277873039246,
            0.9946622252464294,
            0.9954906105995178,
            0.9931703209877014,
            0.9955514669418335,
            0.9943183064460754,
            0.9959499835968018,
            0.9952316284179688,
            0.9952388405799866,
            0.994566798210144,
            0.9954480528831482,
            0.9950652122497559,
            0.9939814209938049,
            0.9946535229682922,
            0.9931203126907349,
            0.9942355751991272
        ]
    },
    "1144": {
        "similarity": 0.9969407916069031,
        "body": "    replacements = 0\n    t_pattern = 'ab' * (m // 2) + ('a' if m % 2 == 1 else '')\n    \n    for i in range(n - m + 1):\n        t_occurrence = s[i:i+m]\n        for j in range(m):\n            if t_occurrence[j] != '?' and t_occurrence[j] != t_pattern[j]:\n                replacements += 1\n                \n    return replacements\n\n# Read input\nn = int(input().strip())\ns = input().strip()\nm = int(input().strip())\n\n# Output the result\nprint(min_replacements_to_max_beauty(n, s, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949222207069397,
            0.9955266714096069,
            0.9961268901824951,
            0.9949653148651123,
            0.9957321882247925,
            0.9955225586891174,
            0.9962228536605835,
            0.9961463809013367,
            0.9936348795890808,
            0.9956538677215576,
            0.9969407916069031,
            0.9959545135498047,
            0.9930802583694458,
            0.9964330792427063,
            0.9920831322669983,
            0.9955543875694275,
            0.9962965250015259,
            0.9946504831314087,
            0.99506014585495,
            0.9969049692153931
        ]
    },
    "890": {
        "similarity": 0.9981716871261597,
        "body": "import sys\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(difficulties[i] - difficulties[j])\n            if diff >= x:\n                total_difficulty = difficulties[i] + difficulties[j]\n                if l <= total_difficulty <= r:\n                    count += 1\n    return count\n\n# Read input from stdin\nn, l, r, x = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Print the result\nprint(count_problemsets(n, l, r, x, difficulties))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977019429206848,
            0.9972596764564514,
            0.9978065490722656,
            0.9976156949996948,
            0.9979715943336487,
            0.9973772764205933,
            0.9976624250411987,
            0.9958504438400269,
            0.9978464841842651,
            0.9981716871261597,
            0.9977372884750366,
            0.9978750348091125,
            0.9970889091491699,
            0.9973239898681641,
            0.9979394674301147,
            0.9969984292984009,
            0.9967405200004578,
            0.9978758096694946,
            0.9973659515380859,
            0.99761563539505
        ]
    },
    "2410": {
        "similarity": 0.9972082376480103,
        "body": "import sys\n\n    n = len(tastiness)\n    yasser_total = sum(tastiness)\n    prefix_sums = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sums[i] = prefix_sums[i - 1] + tastiness[i - 1]\n    \n    max_adel_total = float('-inf')\n    for l in range(1, n):\n        for r in range(l, n):\n            adel_total = prefix_sums[r + 1] - prefix_sums[l]\n            if adel_total > max_adel_total:\n                max_adel_total = adel_total\n    \n    return yasser_total > max_adel_total\n\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n = int(input())\n        tastiness = list(map(int, input().split()))\n        results.append(\"YES\" if is_yasser_happy(tastiness) else \"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970217347145081,
            0.9956014752388,
            0.9970305562019348,
            0.9972082376480103,
            0.9961262941360474,
            0.9956368207931519,
            0.9953129291534424,
            0.9934433698654175,
            0.9957611560821533,
            0.9961722493171692,
            0.9956272840499878,
            0.9966527819633484,
            0.9945036172866821,
            0.9957677125930786,
            0.9963043928146362,
            0.9963807463645935,
            0.9968727827072144,
            0.9947063326835632,
            0.9961915612220764,
            0.996423602104187
        ]
    },
    "1004": {
        "similarity": 0.9975317120552063,
        "body": "import sys\n\n    balance = 0\n    days = []\n    day_length = 0\n    \n    for event in events:\n        if event > 0:\n            balance += 1\n        else:\n            balance -= 1\n        \n        day_length += 1\n        \n        if balance == 0:\n            days.append(day_length)\n            day_length = 0\n    \n    if balance != 0:\n        return -1\n    \n    print(len(days))\n    print(' '.join(map(str, days)))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    events = list(map(int, input().split()))\n    partition_events(n, events)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975317120552063,
            0.9957610964775085,
            0.9959694743156433,
            0.9967632293701172,
            0.9969598650932312,
            0.9972851276397705,
            0.9964039325714111,
            0.9960566163063049,
            0.9950520396232605,
            0.9969664216041565,
            0.9964476227760315,
            0.9960283041000366,
            0.995880663394928,
            0.9967014789581299,
            0.9964062571525574,
            0.9966852068901062,
            0.9952266216278076,
            0.9971012473106384,
            0.9962950348854065,
            0.9973769783973694
        ]
    },
    "531": {
        "similarity": 0.9971709251403809,
        "body": "import sys\n\n    x_min = min(x)\n    x_max = max(x)\n    avg = sum(x) // n\n    \n    y = []\n    equal_count = 0\n    \n    for i in range(n):\n        if x[i] == avg:\n            equal_count += 1\n        else:\n            y.append(avg)\n    \n    while len(y) < n:\n        y.append(avg)\n    \n    return equal_count, y\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    x = list(map(int, input().strip().split()))\n    \n    equal_count, y = min_equal_measurements(n, x)\n    \n    print(equal_count)\n    print(\" \".join(map(str, y)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971709251403809,
            0.9945275187492371,
            0.9949387311935425,
            0.9938985109329224,
            0.9956250786781311,
            0.9964024424552917,
            0.9960249066352844,
            0.9959725141525269,
            0.9963911175727844,
            0.99672931432724,
            0.9959923624992371,
            0.996906578540802,
            0.9967896342277527,
            0.9923933148384094,
            0.9971528649330139,
            0.9958415031433105,
            0.9958181977272034,
            0.9969456195831299,
            0.9927335381507874,
            0.9967870116233826
        ]
    },
    "510": {
        "similarity": 0.9948371052742004,
        "body": "import sys\n\n    a, b, c = sorted([a, b, c])\n    max_distance = max(b - a, c - b)\n    return (max_distance - 1) // d + 1 if max_distance > d else 0\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    a, b, c, d = map(int, input_data.split())\n    result = min_performance_duration(a, b, c, d)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933915734291077,
            0.9948371052742004,
            0.9929582476615906,
            0.9892371296882629,
            0.9940026998519897,
            0.9908555746078491,
            0.9908615946769714,
            0.9929837584495544,
            0.9945128560066223,
            0.99041348695755,
            0.994276762008667,
            0.9909000396728516,
            0.9943662881851196,
            0.9928556680679321,
            0.9903600811958313,
            0.9946445822715759,
            0.9919018149375916,
            0.9943093657493591,
            0.9925089478492737,
            0.9945228099822998
        ]
    },
    "2555": {
        "similarity": 0.9978147745132446,
        "body": "import sys\n\n        sorted_arr = sorted(arr)\n        return sum(sorted_arr[i] if i % 2 == 0 else -sorted_arr[i] for i in range(len(sorted_arr)))\n\n    initial_strength = calculate_max_strength(a[:])\n    strengths = [initial_strength]\n\n    for l, r in operations:\n        l -= 1\n        r -= 1\n        a[l], a[r] = a[r], a[l]\n        new_strength = calculate_max_strength(a[:])\n        strengths.append(new_strength)\n\n    return strengths\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        q = int(data[index + 1])\n        index += 2\n        \n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        operations = []\n        for _ in range(q):\n            l = int(data[index])\n            r = int(data[index + 1])\n            index += 2\n            operations.append((l, r))\n        \n        results.extend(max_army_strength(n, q, a, operations))\n    \n    print(*results)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976564049720764,
            0.9973050355911255,
            0.9965196847915649,
            0.9974702596664429,
            0.997410237789154,
            0.9975274801254272,
            0.9976932406425476,
            0.9971611499786377,
            0.9976579546928406,
            0.9970905780792236,
            0.9971753358840942,
            0.9969568848609924,
            0.9973015189170837,
            0.9957658052444458,
            0.9971344470977783,
            0.9978147745132446,
            0.9977588653564453,
            0.9972487092018127,
            0.9970961213111877,
            0.9972139000892639
        ]
    },
    "324": {
        "similarity": 0.9981223940849304,
        "body": "import sys\n\n    a = n + 2\n    while True:\n        if not is_prime(a):\n            b = a - n\n            if b >= 2 and not is_prime(b):\n                return (a, b)\n        a += 1\n\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ninput_n = int(input().strip())\na, b = find_composite_pair(input_n)\nprint(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.991346538066864,
            0.9959613680839539,
            0.9977016448974609,
            0.9976951479911804,
            0.9979376792907715,
            0.9978709816932678,
            0.9976636171340942,
            0.9979077577590942,
            0.9969834685325623,
            0.9976166486740112,
            0.9981223940849304,
            0.9980232119560242,
            0.9976395964622498,
            0.9977037310600281,
            0.9977195262908936,
            0.9970642924308777,
            0.9977850914001465,
            0.9980273246765137,
            0.9979211688041687,
            0.9965412020683289
        ]
    },
    "2912": {
        "similarity": 0.9964188933372498,
        "body": "import sys\n\n# Fast I/O\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nstrings = data[1:N+1]\noperations = [(int(data[N+i*2]) - 1, int(data[N+i*2+1]) - 1) for i in range(N-1)]\n\n# Process operations\nfor a, b in operations:\n    strings[a] += strings[b]\n    strings[b] = ''\n\n# Output the last remaining string\nprint(strings[-1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958328604698181,
            0.9933907389640808,
            0.9958328604698181,
            0.9942802786827087,
            0.9954888224601746,
            0.9957960844039917,
            0.9958456754684448,
            0.9958894848823547,
            0.9962260723114014,
            0.9958494305610657,
            0.9889134168624878,
            0.9952322244644165,
            0.9959210157394409,
            0.9963328838348389,
            0.9963177442550659,
            0.9943715929985046,
            0.9956656098365784,
            0.9950286746025085,
            0.9964188933372498,
            0.9898754954338074
        ]
    },
    "9": {
        "similarity": 0.9960818886756897,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    d = int(data[0])\n    n, m = map(int, data[1:3])\n    sofas = []\n    for i in range(d):\n        x1, y1, x2, y2 = map(int, data[6*i+3:6*(i+1)])\n        sofas.append(((x1, y1), (x2, y2)))\n    \n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, data[-4:])\n    \n    for i in range(d):\n        left, right, top, bottom = 0, 0, 0, 0\n        x1, y1 = sofas[i][0]\n        x2, y2 = sofas[i][1]\n        for j in range(d):\n            if i == j:\n                continue\n            x3, y3 = sofas[j][0]\n            x4, y4 = sofas[j][1]\n            if (x1 == x3 and abs(y1 - y3) == 1) or (y1 == y3 and abs(x1 - x3) == 1):\n                if y3 < y1 <= y2:\n                    top += 1\n                elif y3 > y2 >= y1:\n                    bottom += 1\n            elif (x2 == x4 and abs(y2 - y4) == 1) or (y2 == y4 and abs(x2 - x4) == 1):\n                if y4 < y2 <= y1:\n                    top += 1\n                elif y4 > y1 >= y2:\n                    bottom += 1\n        \n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            print(i + 1)\n            return\n    \n    print(-1)\n\nfind_sofa()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960818886756897,
            0.9940933585166931,
            0.9946277141571045,
            0.9944173097610474,
            0.9960397481918335,
            0.9946194887161255,
            0.9957697987556458,
            0.9928507804870605,
            0.9940823316574097,
            0.9924899935722351,
            0.9959907531738281,
            0.9944022297859192,
            0.9937738180160522,
            0.9944324493408203,
            0.9952159523963928,
            0.9958992004394531,
            0.9927968382835388,
            0.9950459003448486,
            0.9959763884544373,
            0.9958558678627014
        ]
    },
    "249": {
        "similarity": 0.9970199465751648,
        "body": "import sys\n\n    required = {x, y}\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = marks[j] - marks[i]\n            if diff not in required:\n                required.add(diff)\n    \n    current_coverage = set(marks)\n    additional_marks = []\n    \n    for dist in sorted(required):\n        if dist not in current_coverage:\n            additional_marks.append(dist)\n            current_coverage.add(dist)\n    \n    return len(additional_marks), additional_marks\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nl = int(data[1])\nx = int(data[2])\ny = int(data[3])\nmarks = list(map(int, data[4:]))\n\n# Calculate the minimum number of additional marks needed\nadditional_marks_count, marks_to_add = min_additional_marks(n, l, x, y, marks)\n\n# Print output\nprint(additional_marks_count)\nprint(\" \".join(map(str, marks_to_add)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99628084897995,
            0.9940126538276672,
            0.996680498123169,
            0.9968100190162659,
            0.9935377836227417,
            0.9950723052024841,
            0.9954088926315308,
            0.9950810670852661,
            0.9949901103973389,
            0.9955922365188599,
            0.9940603971481323,
            0.996506929397583,
            0.9963654279708862,
            0.9957211017608643,
            0.9922916293144226,
            0.9960507750511169,
            0.9970199465751648,
            0.9958074688911438,
            0.9956960082054138,
            0.996224045753479
        ]
    },
    "2999": {
        "similarity": 0.9973659515380859,
        "body": "from itertools import combinations\n\n    bets = [b for t, b in participants]\n    winning_participants = []\n\n    # Check all possible combinations of participants\n    for r in range(1, len(bets) + 1):\n        for combo in combinations(bets, r):\n            if sum(combo) == s:\n                winning_combination = [t for t, b in participants if b in combo]\n                winning_participants.extend(winning_combination)\n                break\n        else:\n            continue\n        break\n\n    winning_participants = list(set(winning_participants))\n    return len(winning_participants), winning_participants\n\n# Read input from stdin\nn, s = map(int, input().split())\nparticipants = [input().split() for _ in range(n)]\n\n# Find the number of winners and their names\nk, winners = find_lottery_winners(n, s, participants)\n\n# Output the result\nprint(k)\nfor winner in winners:\n    print(winner)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961796998977661,
            0.9961148500442505,
            0.9942581057548523,
            0.9972315430641174,
            0.9963386058807373,
            0.995217502117157,
            0.9969856142997742,
            0.9959542155265808,
            0.9973659515380859,
            0.9956110715866089,
            0.9968635439872742,
            0.9958898425102234,
            0.9967507123947144,
            0.9957385659217834,
            0.996135413646698,
            0.9961301684379578,
            0.9966505169868469,
            0.9970793724060059,
            0.996984601020813,
            0.9945505857467651
        ]
    },
    "2239": {
        "similarity": 0.9958435893058777,
        "body": "    for rolls in range(1, x + 1):\n        if sum(range(2, 8)) * rolls >= x:\n            return rolls\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    x = int(input())\n    results.append(min_rolls(x))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9907428622245789,
            0.9914556741714478,
            0.9939810037612915,
            0.9911760091781616,
            0.9955983757972717,
            0.9928468465805054,
            0.993770182132721,
            0.9912133812904358,
            0.9937069416046143,
            0.9929630756378174,
            0.9958435893058777,
            0.9945849180221558,
            0.9941627979278564,
            0.9951346516609192,
            0.9927825927734375,
            0.9916845560073853,
            0.9940610527992249,
            0.9953660368919373,
            0.9932884573936462,
            0.994378924369812
        ]
    },
    "2615": {
        "similarity": 0.9971613883972168,
        "body": "import math\n\n    sieve = [0] * (n + 1)\n    for i in range(2, n + 1):\n        if sieve[i] == 0:\n            j = i\n            while j <= n:\n                sieve[j] += 1\n                j *= i\n    prime_factors_count = [0] * (n + 1)\n    for i in range(2, n + 1):\n        prime_factors_count[i] += sieve[i]\n    \n        while b:\n            a, b = b, a % b\n        return a\n    \n    elegant_count = 0\n    for i in range(2, n + 1):\n        if all(gcd(i, prime_factors_count[j]) == 1 for j in range(i, n + 1, i)):\n            elegant_count += 1\n    return elegant_count\n\nT = int(input())\nresults = []\nfor _ in range(T):\n    n = int(input())\n    results.append(count_elegant_numbers(n))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9901363253593445,
            0.9967775940895081,
            0.9971613883972168,
            0.9928094148635864,
            0.9948266744613647,
            0.9967824220657349,
            0.9962385296821594,
            0.9952753782272339,
            0.9958650469779968,
            0.9965025186538696,
            0.9955601096153259,
            0.9918265342712402,
            0.9962473511695862,
            0.9963539838790894,
            0.9970157146453857,
            0.995802640914917,
            0.9970555901527405,
            0.9956111907958984,
            0.9943783283233643,
            0.9965224266052246
        ]
    },
    "2542": {
        "similarity": 0.9983090162277222,
        "body": "    n = len(s)\n    for i in range(n):\n        if s[:i] == s[i+1:]:\n            return n - 2 * i - 1\n    return n\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input()\n    results.append(min_erasure_to_good_string(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977492094039917,
            0.9972056150436401,
            0.9982911348342896,
            0.9982615113258362,
            0.9981266856193542,
            0.9977495074272156,
            0.9975795745849609,
            0.9982377290725708,
            0.9981319904327393,
            0.9947546720504761,
            0.9961941242218018,
            0.9977230429649353,
            0.9976900815963745,
            0.9958789348602295,
            0.9977132678031921,
            0.9983090162277222,
            0.9980664849281311,
            0.9980470538139343,
            0.9980625510215759,
            0.9982829689979553
        ]
    },
    "511": {
        "similarity": 0.9983835816383362,
        "body": "import math\n\n    if b == 0:\n        return 0\n    else:\n        return 1 + f(a, b - math.gcd(a, b))\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(f(x, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982584714889526,
            0.9981979727745056,
            0.9977313876152039,
            0.9974800944328308,
            0.9977313876152039,
            0.9974900484085083,
            0.9977819323539734,
            0.9983835816383362,
            0.9980031251907349,
            0.9983367919921875,
            0.9976497292518616,
            0.9980031251907349,
            0.9973168969154358,
            0.9921505451202393,
            0.9982584714889526,
            0.9983570575714111,
            0.9980254173278809,
            0.9974650144577026,
            0.997281551361084,
            0.9982354044914246
        ]
    },
    "1409": {
        "similarity": 0.9972120523452759,
        "body": "import sys\n\n    count = [0] * 6\n    for i in range(n):\n        count[y[i]] += 1\n    \n    teams = 0\n    for i in range(5, -1, -1):\n        if i - k >= 0 and count[i] >= k:\n            teams += count[i] // k\n            count[i] %= k\n    \n    return min(teams, n // 3)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    k = int(data[1])\n    y = list(map(int, data[2:]))\n    \n    print(max_teams(n, k, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966338276863098,
            0.9955512881278992,
            0.9966151714324951,
            0.9964420199394226,
            0.9971134662628174,
            0.9969959259033203,
            0.9971357583999634,
            0.9972120523452759,
            0.9956817626953125,
            0.9967340230941772,
            0.9970214366912842,
            0.9958591461181641,
            0.9959555268287659,
            0.9957917928695679,
            0.9969309568405151,
            0.9952259063720703,
            0.9967516660690308,
            0.9967489838600159,
            0.9971439838409424,
            0.9967884421348572
        ]
    },
    "2274": {
        "similarity": 0.997461199760437,
        "body": "import sys\n\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            if directions[i][j] == 'R' and (i != n-1 or j != m-2):\n                changes += 1\n            elif directions[i][j] == 'D' and (i != n-2 or j != m-1):\n                changes += 1\n    return changes\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index:index+2])\n        index += 2\n        directions = [data[index:index+m] for _ in range(n)]\n        index += m\n        \n        result = min_changes_to_functional(n, m, directions)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949268698692322,
            0.99689120054245,
            0.9972763061523438,
            0.9948058128356934,
            0.9967452883720398,
            0.9966012835502625,
            0.9970225095748901,
            0.995479166507721,
            0.9964767098426819,
            0.9955947399139404,
            0.9963873028755188,
            0.9951814413070679,
            0.9973352551460266,
            0.9964637756347656,
            0.997461199760437,
            0.9961624145507812,
            0.9965850710868835,
            0.9971584677696228,
            0.9971799254417419,
            0.9968864917755127
        ]
    },
    "2420": {
        "similarity": 0.9979920983314514,
        "body": "import sys\n\n    max_covered = 0\n    \n    for i in range(n):\n        covered_count = 0\n        for j in range(n):\n            if abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) <= r:\n                covered_count += 1\n        max_covered = max(max_covered, covered_count)\n    \n    return max_covered\n\n# Read input from stdin\nn, r = map(int, input().split())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(max_points_in_l1_ball(n, r, points))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966834187507629,
            0.9957612752914429,
            0.9969554543495178,
            0.9971963763237,
            0.9973554015159607,
            0.9962429404258728,
            0.9975009560585022,
            0.9975529909133911,
            0.9975107908248901,
            0.9966157674789429,
            0.9965896606445312,
            0.9976521730422974,
            0.9976378083229065,
            0.9979254007339478,
            0.9949826002120972,
            0.9974879026412964,
            0.9977831840515137,
            0.995877742767334,
            0.9966632723808289,
            0.9979920983314514
        ]
    },
    "1267": {
        "similarity": 0.9966543316841125,
        "body": "import sys\n\n    ways = 0\n    for i in range(1 << n):\n        selected = [j for j in range(n) if i & (1 << j)]\n        if not selected:\n            continue\n        min_score = min(scores[j] for j in selected)\n        if all(scores[j] >= min_score or scores[j] == 0 for j in range(n)):\n            ways += 1\n    return ways\n\nn = int(input())\nscores = list(map(int, input().split()))\nprint(count_ways(n, scores))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957975149154663,
            0.9960094094276428,
            0.9961719512939453,
            0.9957748055458069,
            0.9961565732955933,
            0.9961265921592712,
            0.9934616088867188,
            0.9949910044670105,
            0.9958490133285522,
            0.9946821331977844,
            0.9966543316841125,
            0.9940863251686096,
            0.9945813417434692,
            0.9951661825180054,
            0.993918776512146,
            0.9952046275138855,
            0.995725154876709,
            0.9919407367706299,
            0.9936630129814148,
            0.9956808686256409
        ]
    },
    "2356": {
        "similarity": 0.9973267316818237,
        "body": "import sys\n\n    n = len(a)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j - a[j] == i - a[i]:\n                return False\n    return True\n\n    while not is_good_array(a):\n        import random\n        random.shuffle(a)\n    return a\n\ninput = sys.stdin.read\ndata = input().split()\nindex = 0\n\nfor _ in range(int(data[index])):\n    index += 1\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    good_a = shuffle_to_good_array(a)\n    \n    print(n)\n    print(*good_a)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967662692070007,
            0.9963983297348022,
            0.9967892169952393,
            0.996728777885437,
            0.9956973195075989,
            0.9960054159164429,
            0.9964894652366638,
            0.9957705140113831,
            0.9973267316818237,
            0.9938318133354187,
            0.9968229532241821,
            0.9967325925827026,
            0.9946098327636719,
            0.9953786730766296,
            0.9970472455024719,
            0.9972682595252991,
            0.9945794939994812,
            0.9956390857696533,
            0.9924662709236145,
            0.9963973164558411
        ]
    },
    "108": {
        "similarity": 0.9968518614768982,
        "body": "import sys\n\n    target = \"abcdefghijklmnopqrstuvwxyz\"\n    s_len, t_len = len(s), len(target)\n    \n    i, j = 0, 0\n    result = []\n    \n    while i < s_len:\n        if s[i] == target[j]:\n            result.append(s[i])\n            j += 1\n        i += 1\n        \n        if j == t_len:\n            return ''.join(result)\n    \n    return \"-1\"\n\n# Read input from stdin\ns = input().strip()\n\n# Output the result\nprint(alphabet_subsequence(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965312480926514,
            0.9949708580970764,
            0.995745837688446,
            0.9959888458251953,
            0.9907158613204956,
            0.9957630634307861,
            0.9963603019714355,
            0.996372401714325,
            0.987967848777771,
            0.9924193024635315,
            0.9950762391090393,
            0.9968004822731018,
            0.9946238994598389,
            0.9955534934997559,
            0.995286226272583,
            0.9961066246032715,
            0.9956961274147034,
            0.9955400228500366,
            0.9968518614768982,
            0.9948805570602417
        ]
    },
    "1833": {
        "similarity": 0.9976573586463928,
        "body": "import sys\n\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in a:\n        for i in range(n, 0, -1):\n            dp[i] = (dp[i] + dp[i-1]) % mod\n    \n    result = sum(dp) - 1\n    return result % mod\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    print(count_good_subsequences(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963441491127014,
            0.9970811605453491,
            0.9976573586463928,
            0.9944167733192444,
            0.9968215823173523,
            0.9969474673271179,
            0.9968540668487549,
            0.9975984692573547,
            0.9964049458503723,
            0.9976298809051514,
            0.9971935749053955,
            0.9975705742835999,
            0.9963331818580627,
            0.9969678521156311,
            0.9955062866210938,
            0.9950143098831177,
            0.9954430460929871,
            0.9966806173324585,
            0.996551513671875,
            0.9973877668380737
        ]
    },
    "2324": {
        "similarity": 0.9979651570320129,
        "body": "    n = len(s)\n    dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if length == 1:\n                dp[start][end][0] = dp[start][end][1] = 1\n            elif s[start] == s[end]:\n                dp[start][end][0] = 2 * dp[start + 1][end - 1][0] + (length >= 3)\n                dp[start][end][1] = dp[start][end - 1][1] + dp[start + 1][end][1]\n            else:\n                dp[start][end][0] = max(dp[start + 1][end][0], dp[start][end - 1][0])\n                dp[start][end][1] = dp[start][end - 1][1] + dp[start + 1][end][1]\n    \n    result = []\n    for k in range(n):\n        count = 0\n        for start in range(n):\n            if dp[start][start + k][1] > 0:\n                count += dp[start][start + k][1]\n        result.append(count)\n    \n    print(\" \".join(map(str, result)))\n\n# Read input from stdin\ns = input().strip()\npalindromic_characteristics(s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955731630325317,
            0.9971166849136353,
            0.9973088502883911,
            0.9975816607475281,
            0.9976627826690674,
            0.9978570342063904,
            0.9975801110267639,
            0.9979651570320129,
            0.9970918893814087,
            0.9973447918891907,
            0.9974182844161987,
            0.9950834512710571,
            0.99773770570755,
            0.9965275526046753,
            0.9978891015052795,
            0.9977928996086121,
            0.9943417906761169,
            0.9977977275848389,
            0.9976740479469299,
            0.9969652891159058
        ]
    },
    "2372": {
        "similarity": 0.9981180429458618,
        "body": "import sys\n\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    queue = [(C_h, C_w, 0)]\n    visited = set()\n    while queue:\n        x, y, magic_used = queue.pop(0)\n        if (x, y) == (D_h, D_w):\n            return magic_used\n        for dx, dy in moves:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= H and 1 <= ny <= W and S[nx-1][ny-1] == '.' and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, magic_used))\n        if magic_used < 2:\n            for i in range(max(1, x-2), min(H+1, x+3)):\n                for j in range(max(1, y-2), min(W+1, y+3)):\n                    if S[i-1][j-1] == '.' and (i, j) not in visited:\n                        visited.add((i, j))\n                        queue.append((i, j, magic_used + 1))\n    return -1\n\nH, W = map(int, input().split())\nC_h, C_w = map(int, input().split())\nD_h, D_w = map(int, input().split())\nS = [input() for _ in range(H)]\n\nprint(min_magic_uses(H, W, C_h, C_w, D_h, D_w, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997803270816803,
            0.997717022895813,
            0.9967257976531982,
            0.9976659417152405,
            0.9939667582511902,
            0.9977729320526123,
            0.9977240562438965,
            0.9975889325141907,
            0.9980595111846924,
            0.996924638748169,
            0.9976216554641724,
            0.9980404376983643,
            0.9979733824729919,
            0.9978210926055908,
            0.9976483583450317,
            0.996860921382904,
            0.9978753924369812,
            0.9978591799736023,
            0.9981180429458618,
            0.9969158172607422
        ]
    },
    "1984": {
        "similarity": 0.9975919127464294,
        "body": "import sys\n\n    levels = []\n    for _ in range(k):\n        level = [input().strip() for _ in range(n)]\n        levels.append(level)\n\n        return sum(1 for i in range(n) for j in range(m) if a[i][j] != b[i][j])\n\n        if level in memo:\n            return memo[level]\n        min_cost = float('inf')\n        best_transfer = None\n        for prev_level in transferred:\n            diff = calculate_diff(levels[prev_level - 1], levels[level])\n            cost = diff * w\n            if cost < min_cost:\n                min_cost = cost\n                best_transfer = prev_level\n        if min_cost >= n * m:\n            min_cost = n * m\n            best_transfer = None\n        memo[level] = (min_cost, best_transfer)\n        return memo[level]\n\n    transferred = []\n    memo = {}\n    total_traffic = 0\n\n    for i in range(k):\n        cost, transfer = dfs(i + 1, transferred, memo)\n        total_traffic += cost\n        transferred.append(i + 1)\n\n    print(total_traffic)\n    for t in transferred:\n        if t == 1:\n            print(f\"{t} 0\")\n        else:\n            print(f\"{t} {transferred.index(t) + 2}\")\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    w = int(data[index + 3])\n    index += 4\n\n    min_traffic(n, m, k, w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972112774848938,
            0.997342586517334,
            0.994734525680542,
            0.9975919127464294,
            0.996059000492096,
            0.996491014957428,
            0.9962099194526672,
            0.996775209903717,
            0.9949119091033936,
            0.997433602809906,
            0.9969905018806458,
            0.9969474673271179,
            0.9972832202911377,
            0.9970582723617554,
            0.9973540306091309,
            0.9952059388160706,
            0.996337890625,
            0.9967716932296753,
            0.9965993165969849,
            0.9969050884246826
        ]
    },
    "1253": {
        "similarity": 0.9965232014656067,
        "body": "import sys\n\n    negative_count = sum(1 for x in a if x < 0)\n    positive_count = n - negative_count\n    \n    if k <= negative_count:\n        return sum(abs(x) for x in a[:k]) + sum(x for x in a[k:])\n    elif k <= negative_count + positive_count:\n        k -= negative_count\n        if k % 2 == 0:\n            return sum(a)\n        else:\n            return sum(a) - 2 * min(abs(x) for x in a)\n    else:\n        return -sum(a)\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957515597343445,
            0.9955846071243286,
            0.9957324862480164,
            0.9958863854408264,
            0.9962442517280579,
            0.9960602521896362,
            0.9949623942375183,
            0.9900788068771362,
            0.9906928539276123,
            0.995742678642273,
            0.9955188632011414,
            0.9943783283233643,
            0.9950870871543884,
            0.9960116147994995,
            0.9965232014656067,
            0.9930611848831177,
            0.9882563352584839,
            0.994645357131958,
            0.9951717257499695,
            0.9946025013923645
        ]
    },
    "523": {
        "similarity": 0.9969990253448486,
        "body": "import sys\n\n    max_length = 0\n    best_palindrome = \"\"\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            combined = strings[i] + strings[j]\n            if combined == combined[::-1]:\n                if len(combined) > max_length:\n                    max_length = len(combined)\n                    best_palindrome = combined\n            reverse_combined = strings[j] + strings[i]\n            if reverse_combined == reverse_combined[::-1]:\n                if len(reverse_combined) > max_length:\n                    max_length = len(reverse_combined)\n                    best_palindrome = reverse_combined\n    \n    return max_length, best_palindrome\n\n# Read input\nn, m = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\n\n# Find the longest palindrome\nlength, palindrome = find_longest_palindrome(n, m, strings)\n\n# Print the result\nprint(length)\nif palindrome:\n    print(palindrome)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969990253448486,
            0.9956802725791931,
            0.9925877451896667,
            0.9962786436080933,
            0.9967900514602661,
            0.9954663515090942,
            0.9943221211433411,
            0.9964696168899536,
            0.9964467287063599,
            0.9964935183525085,
            0.9961568117141724,
            0.9951603412628174,
            0.995021641254425,
            0.9965199828147888,
            0.995548665523529,
            0.9924631714820862,
            0.9960522055625916,
            0.996364176273346,
            0.995462954044342,
            0.9957731366157532
        ]
    },
    "2934": {
        "similarity": 0.9977063536643982,
        "body": "    MOD = 10**9\n    dp = [[0] * (M + 2) for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    for i in range(N + 1):\n        for j in range(M + 1):\n            if i >= 1:\n                dp[i][j] += dp[i - 1][j]\n            if j >= 2:\n                dp[i][j] += dp[i][j - 2]\n    \n    return dp[N][M] % MOD\n\nN = int(input().strip())\nM = int(input().strip())\nprint(tiling(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996751070022583,
            0.9961612224578857,
            0.9962513446807861,
            0.9966762065887451,
            0.9977063536643982,
            0.997443437576294,
            0.9946969747543335,
            0.996809720993042,
            0.9962234497070312,
            0.996785044670105,
            0.9972955584526062,
            0.9969935417175293,
            0.9965832233428955,
            0.996307373046875,
            0.9971839785575867,
            0.9955954551696777,
            0.9975373148918152,
            0.9947749972343445,
            0.996762752532959,
            0.9958817362785339
        ]
    },
    "1745": {
        "similarity": 0.9976766705513,
        "body": "        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n        if not (is_valid(x, y) and turns <= 2):\n            return 0\n        if (x, y, direction, turns) in visited:\n            return 0\n        visited.add((x, y, direction, turns))\n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            if direction == 0 and (y != 0 and y != m - 1):\n                return 1\n            if direction == 1 and (x != 0 and x != n - 1):\n                return 1\n        result = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if direction == 2 or abs(dx) != abs(direction):\n                result += dfs(nx, ny, dx * dy, turns + 1)\n        return result\n\n    visited = set()\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                for direction in [-1, 0, 1]:\n                    for turns in [0, 1]:\n                        if (i, j, direction, turns) not in visited:\n                            count += dfs(i, j, direction, turns)\n    return count\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Calculate and print the result\nprint(count_pipes(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968317151069641,
            0.9972593188285828,
            0.9964838624000549,
            0.9975276589393616,
            0.9971337914466858,
            0.997493326663971,
            0.9969278573989868,
            0.9967840313911438,
            0.9971070885658264,
            0.9969668984413147,
            0.9966260194778442,
            0.9933555126190186,
            0.9973624348640442,
            0.9963517785072327,
            0.9974604249000549,
            0.9975234866142273,
            0.9968151450157166,
            0.9946467876434326,
            0.9973660707473755,
            0.9976766705513
        ]
    },
    "1422": {
        "similarity": 0.9968974590301514,
        "body": "    left_sum = 0\n    right_sum = 0\n    used_weights = set()\n    \n    for i in range(m):\n        weight = None\n        for w in range(1, 11):\n            if weights[w-1] == '1' and w not in used_weights:\n                if (i % 2 == 0 and left_sum < right_sum + w) or (i % 2 == 1 and left_sum > right_sum + w):\n                    weight = w\n                    break\n        if weight is None:\n            return \"NO\"\n        if i % 2 == 0:\n            left_sum += weight\n        else:\n            right_sum += weight\n        used_weights.add(weight)\n    \n    if left_sum != right_sum:\n        return \"YES\\n\" + ' '.join(map(str, sorted(used_weights)))\n    else:\n        return \"NO\"\n\n# Example usage\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nweights = data[0]\nm = int(data[1])\nprint(can_put_weights(weights, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967612028121948,
            0.9905185699462891,
            0.996573805809021,
            0.9921092987060547,
            0.9962681531906128,
            0.9946786761283875,
            0.9911777973175049,
            0.9955295920372009,
            0.993208646774292,
            0.9932955503463745,
            0.996528148651123,
            0.9951683878898621,
            0.9968974590301514,
            0.9965111613273621,
            0.9954121112823486,
            0.996575117111206,
            0.9941850304603577,
            0.9954471588134766,
            0.9959641695022583,
            0.9961733818054199
        ]
    },
    "1763": {
        "similarity": 0.9965754151344299,
        "body": "import sys\n\n    total_bricks = sum(heights)\n    target_height = total_bricks // n\n    if total_bricks % n != 0:\n        return -1\n    \n    cost = 0\n    above_target = []\n    below_target = []\n    \n    for height in heights:\n        diff = height - target_height\n        if diff > 0:\n            above_target.extend([diff] * diff)\n        elif diff < 0:\n            below_target.append(-diff)\n    \n    below_target.sort()\n    \n    for diff in above_target:\n        if below_target and below_target[-1] <= m:\n            cost += min(diff, below_target.pop()) * r\n        else:\n            cost += diff * a\n    \n    return cost\n\n# Read input from stdin\nn, a, r, m = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Print the result\nprint(min_cost_to_restore_wall(n, a, r, m, heights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953945875167847,
            0.9948270916938782,
            0.9962698221206665,
            0.9955875873565674,
            0.993894100189209,
            0.9959505796432495,
            0.9940915703773499,
            0.99200040102005,
            0.9955440163612366,
            0.9926339387893677,
            0.9964492321014404,
            0.992195725440979,
            0.9919497966766357,
            0.9962473511695862,
            0.9965754151344299,
            0.9963269829750061,
            0.9927394390106201,
            0.9933177828788757,
            0.996333658695221,
            0.993640124797821
        ]
    },
    "974": {
        "similarity": 0.9974734783172607,
        "body": "from collections import deque\n\n    add_q = deque()\n    remove_q = deque()\n    reorder_count = 0\n    current_box = 1\n    \n    for command in commands:\n        if command.startswith(\"add\"):\n            _, box_num = command.split()\n            add_q.append(int(box_num))\n        elif command == \"remove\":\n            while add_q and add_q[0] != current_box:\n                add_q.popleft()\n                reorder_count += 1\n            if add_q:\n                add_q.popleft()\n                current_box += 1\n    \n    return reorder_count\n\nn = int(input())\ncommands = [input().strip() for _ in range(2 * n)]\nprint(min_reorders(n, commands))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972363710403442,
            0.9956645965576172,
            0.9920166730880737,
            0.9970574975013733,
            0.9973760843276978,
            0.9965800046920776,
            0.9974734783172607,
            0.9960170388221741,
            0.9970735311508179,
            0.9970709085464478,
            0.9957271218299866,
            0.9961572885513306,
            0.9974610209465027,
            0.9961344003677368,
            0.9967994689941406,
            0.9950800538063049,
            0.9973070025444031,
            0.9963968992233276,
            0.9971791505813599,
            0.9968705773353577
        ]
    },
    "2343": {
        "similarity": 0.9970886707305908,
        "body": "import sys\n\n    results = []\n    \n    for i in range(t):\n        n = n_values[i]\n        k = k_values[i]\n        \n        if k < 3 * (2 ** n - 1) or k > (2 ** (n + 1)) - 1:\n            results.append(\"NO\")\n        else:\n            path_length = k - 3 * (2 ** n - 1) + 1\n            log_side_length = path_length.bit_length() - 1\n            results.append(f\"YES {log_side_length}\")\n    \n    return results\n\n    input_lines = sys.stdin.read().splitlines()\n    t = int(input_lines[0])\n    n_values = list(map(int, input_lines[1::2]))\n    k_values = list(map(int, input_lines[2::2]))\n    \n    results = can_perform_operations(t, n_values, k_values)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957502484321594,
            0.9970099925994873,
            0.9965278506278992,
            0.9964778423309326,
            0.9964779615402222,
            0.995651125907898,
            0.995019793510437,
            0.9968418478965759,
            0.9955835938453674,
            0.9962310791015625,
            0.9934991598129272,
            0.99676913022995,
            0.9929242730140686,
            0.9964115619659424,
            0.9970886707305908,
            0.996316134929657,
            0.9963186979293823,
            0.9970670342445374,
            0.9961820840835571,
            0.9954382181167603
        ]
    },
    "627": {
        "similarity": 0.9976493716239929,
        "body": "    n = len(s)\n    for i in range(n-1):\n        if s[i] > s[i+1]:\n            return s[:i] + s[i+1:]\n    return s[:-1]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input().strip()\n    print(min_string(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974271059036255,
            0.9970336556434631,
            0.9966937899589539,
            0.9974493980407715,
            0.9877516031265259,
            0.9967436790466309,
            0.9967940449714661,
            0.9976493716239929,
            0.9971785545349121,
            0.9970592856407166,
            0.997612714767456,
            0.997437059879303,
            0.9975705742835999,
            0.9974578022956848,
            0.9970094561576843,
            0.9974384307861328,
            0.9945170879364014,
            0.996792733669281,
            0.9975477457046509,
            0.9962144494056702
        ]
    },
    "1655": {
        "similarity": 0.9983645081520081,
        "body": "    alive = [True] * n\n    for i in range(n):\n        if lengths[i] > 0:\n            for j in range(max(0, i - lengths[i]), i):\n                alive[j] = False\n    return sum(alive)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    lengths = list(map(int, input().split()))\n    print(number_of_alive_people(n, lengths))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980069398880005,
            0.9982548952102661,
            0.9966769814491272,
            0.9964084625244141,
            0.99798583984375,
            0.9981337189674377,
            0.9964674115180969,
            0.9963685870170593,
            0.9980657696723938,
            0.9979631304740906,
            0.9980728030204773,
            0.9982265830039978,
            0.9978480339050293,
            0.9977319836616516,
            0.9983466267585754,
            0.9979400634765625,
            0.9982446432113647,
            0.9982936382293701,
            0.9983645081520081,
            0.9974156618118286
        ]
    },
    "2124": {
        "similarity": 0.997287929058075,
        "body": "import sys\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        users = input().split()\n        m = int(input())\n        messages = [input() for _ in range(m)]\n        \n        possible_solutions = []\n        used_users = set()\n        \n            if index == m:\n                possible_solutions.append(current_solution.copy())\n                return\n            parts = messages[index].split(':')\n            if len(parts) != 2:\n                continue\n            user, text = parts[0], parts[1]\n            if user != '?':\n                if user in used_users or any(user in word for word in text.split()):\n                    return\n                current_solution.append((user, text))\n                backtrack(index + 1, current_solution)\n                current_solution.pop()\n            else:\n                for u in users:\n                    if u not in used_users and all(u not in word for word in text.split()):\n                        current_solution.append((u, text))\n                        used_users.add(u)\n                        backtrack(index + 1, current_solution)\n                        used_users.remove(u)\n                        current_solution.pop()\n        \n        backtrack(0, [])\n        \n        if possible_solutions:\n            print('\\n'.join(f\"{user}:{text}\" for user, text in possible_solutions[0]))\n        else:\n            print(\"Impossible\")\n\nrecover_senders()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971385598182678,
            0.9967477917671204,
            0.9952456951141357,
            0.9968383312225342,
            0.9968370199203491,
            0.997287929058075,
            0.9972470998764038,
            0.9963623881340027,
            0.9951818585395813,
            0.9964500069618225,
            0.9964538216590881,
            0.9945579171180725,
            0.9961931109428406,
            0.9967362284660339,
            0.996764063835144,
            0.9966256022453308,
            0.9953173398971558,
            0.9964705109596252,
            0.997053861618042,
            0.9946188926696777
        ]
    },
    "1093": {
        "similarity": 0.998073399066925,
        "body": "import sys\n\n    max_climb = 0\n    max_descent = 0\n    current_height = 0\n    \n    for col in range(m):\n        height = 0\n        is_peak = False\n        for row in range(n):\n            if profile[row][col] == '*':\n                height += 1\n                is_peak = True\n        if is_peak:\n            if height > current_height:\n                max_climb = max(max_climb, height - current_height)\n            elif height < current_height:\n                max_descent = max(max_descent, current_height - height)\n            current_height = height\n    \n    print(max_climb, max_descent)\n\n# Read input\nn, m = map(int, input().split())\nprofile = [input().strip() for _ in range(n)]\n\n# Call function with input\nfind_extremes(n, m, profile)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978570342063904,
            0.9979678988456726,
            0.9974956512451172,
            0.9965659976005554,
            0.9966328144073486,
            0.9967681765556335,
            0.9970082640647888,
            0.9972557425498962,
            0.9957923889160156,
            0.9978979229927063,
            0.998073399066925,
            0.9975568652153015,
            0.9974642395973206,
            0.9962322115898132,
            0.9963504672050476,
            0.9980395436286926,
            0.9976765513420105,
            0.9968164563179016,
            0.9979268908500671,
            0.996817946434021
        ]
    },
    "899": {
        "similarity": 0.9981707334518433,
        "body": "import heapq\n\n    graph = [[] for _ in range(n)]\n    for a, b, c in edges:\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n    \n        dist = [float('inf')] * n\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                if dist[u] + weight < dist[v]:\n                    dist[v] = dist[u] + weight\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n    total_edges = set()\n    for i in range(n):\n        dist = dijkstra(i)\n        for j in range(i+1, n):\n            if dist[j] != float('inf'):\n                min_dist = dist[j]\n                path_edges = []\n                u = i\n                while u != j:\n                    for v, weight in graph[u]:\n                        if dist[v] + weight == dist[u] - weight:\n                            path_edges.append((u+1, v+1, weight))\n                            u = v\n                            break\n                total_edges.update(path_edges)\n    \n    return len(edges) - len(total_edges)\n\n# Read input from stdin\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print the result\nprint(count_non_shortest_path_edges(n, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966163635253906,
            0.997056245803833,
            0.9974680542945862,
            0.9979985952377319,
            0.9975252747535706,
            0.9957833886146545,
            0.9972875714302063,
            0.997400164604187,
            0.9978254437446594,
            0.9976144433021545,
            0.9981707334518433,
            0.9974873065948486,
            0.9978436827659607,
            0.9978652000427246,
            0.9974848031997681,
            0.9974005818367004,
            0.9976856708526611,
            0.9975588917732239,
            0.9978261590003967,
            0.9974419474601746
        ]
    },
    "551": {
        "similarity": 0.9968693256378174,
        "body": "    if n < 3:\n        return \"No\"\n    \n    y_coords.sort()\n    min_diff = float('inf')\n    \n    for i in range(1, n-1):\n        diff = abs(y_coords[i] - y_coords[i-1])\n        if diff < min_diff:\n            min_diff = diff\n    \n    return \"Yes\" if min_diff > 0 else \"No\"\n\n# Read input\nn = int(input())\ny_coords = list(map(int, input().split()))\n\n# Output result\nprint(can_draw_lines(n, y_coords))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957665205001831,
            0.9940428733825684,
            0.9948985576629639,
            0.9944149851799011,
            0.9955613017082214,
            0.9951396584510803,
            0.9941233396530151,
            0.996490478515625,
            0.9940235614776611,
            0.9927024841308594,
            0.9963517785072327,
            0.9954332113265991,
            0.9921964406967163,
            0.9965193867683411,
            0.9960845112800598,
            0.9937469959259033,
            0.9968693256378174,
            0.9939562082290649,
            0.9943935871124268,
            0.9964194297790527
        ]
    },
    "1772": {
        "similarity": 0.9976304769515991,
        "body": "    odd_count = sum(1 for flower in flowers if flower % 2 != 0)\n    even_count = n - odd_count\n    \n    large_bouquets = min(even_count // 2, odd_count)\n    \n    return large_bouquets\n\n# Read input\nn = int(input())\nflowers = list(map(int, input().split()))\n\n# Output result\nprint(max_large_bouquets(n, flowers))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971040487289429,
            0.992733895778656,
            0.9967473745346069,
            0.9966251850128174,
            0.9963412880897522,
            0.9943192005157471,
            0.9963499307632446,
            0.9974271059036255,
            0.9972692131996155,
            0.9976304769515991,
            0.9960256814956665,
            0.9960256814956665,
            0.9973845481872559,
            0.9944446086883545,
            0.9966342449188232,
            0.9973103404045105,
            0.9964342713356018,
            0.9974501729011536,
            0.9969195127487183,
            0.9969401955604553
        ]
    },
    "1339": {
        "similarity": 0.997119128704071,
        "body": "import sys\n\n    segments.sort(key=lambda x: (x[1], -x[0]))\n    max_end = 0\n    last_start = -1\n    covering_index = -1\n    \n    for i in range(n):\n        start, end = segments[i]\n        if start <= last_start:\n            continue\n        if end > max_end:\n            max_end = end\n            last_start = start\n            covering_index = i + 1\n    \n    return covering_index\n\nif __name__ == \"__main__\":\n    n = int(input())\n    segments = [tuple(map(int, input().split())) for _ in range(n)]\n    result = find_covering_segment(n, segments)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958126544952393,
            0.996738612651825,
            0.9955541491508484,
            0.9964024424552917,
            0.9962109923362732,
            0.9965790510177612,
            0.9941507577896118,
            0.9965139627456665,
            0.9968410134315491,
            0.9964202046394348,
            0.9961429238319397,
            0.9944038391113281,
            0.9969002604484558,
            0.9968346357345581,
            0.9902036786079407,
            0.996378481388092,
            0.9949747323989868,
            0.9961460828781128,
            0.997119128704071,
            0.9964298605918884
        ]
    },
    "440": {
        "similarity": 0.9979294538497925,
        "body": "    n = int(input())\n    s = input()\n    vowels = \"aeiouy\"\n    i = 0\n    while i < len(s) - 1:\n        if s[i] in vowels and s[i + 1] in vowels:\n            j = i - 1\n            while j >= 0 and s[j] not in vowels:\n                j -= 1\n            if j >= 0:\n                s = s[:j+1] + s[i+1:]\n                i = max(0, j)\n        else:\n            i += 1\n    print(s)\n\ncorrect_word()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966332316398621,
            0.9973470568656921,
            0.9943445920944214,
            0.9966553449630737,
            0.9956275820732117,
            0.9976338744163513,
            0.9974112510681152,
            0.9972234964370728,
            0.9978234171867371,
            0.9975863099098206,
            0.9979294538497925,
            0.9976910948753357,
            0.9968400597572327,
            0.9976557493209839,
            0.9971373677253723,
            0.9971883893013,
            0.9977924823760986,
            0.9978688955307007,
            0.9970901012420654,
            0.9974664449691772
        ]
    },
    "2801": {
        "similarity": 0.9977684020996094,
        "body": "import heapq\nimport sys\n\n    graph = [[] for _ in range(n)]\n    for s, t in connections:\n        graph[s].append(t)\n    \n    max_heap = [(-c[0], 1.0, 0)]\n    visited = set()\n    while max_heap:\n        neg_satisfaction, fraction, pos = heapq.heappop(max_heap)\n        if pos in visited:\n            continue\n        visited.add(pos)\n        satisfaction = -neg_satisfaction * fraction\n        for neighbor in graph[pos]:\n            new_fraction = fraction / 2\n            new_neg_satisfaction = -c[neighbor] * new_fraction\n            heapq.heappush(max_heap, (new_neg_satisfaction, new_fraction, neighbor))\n    \n    return satisfaction\n\n# Read input\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_satisfaction(n, m, c, connections))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959436655044556,
            0.9977684020996094,
            0.9972399473190308,
            0.9956478476524353,
            0.9970835447311401,
            0.9970689415931702,
            0.9955163598060608,
            0.997637927532196,
            0.9974990487098694,
            0.9974567890167236,
            0.9973469972610474,
            0.9967936277389526,
            0.9963411092758179,
            0.9960821866989136,
            0.9970996379852295,
            0.9946435689926147,
            0.9976546764373779,
            0.9974488019943237,
            0.9972227215766907,
            0.9975073933601379
        ]
    },
    "2749": {
        "similarity": 0.997361421585083,
        "body": "import sys\nfrom collections import deque\n\n    grid = [[0] * W for _ in range(H)]\n    colors = list(range(1, N + 1))\n    \n        return 0 <= x < H and 0 <= y < W\n    \n        queue = deque([(start_x, start_y)])\n        grid[start_x][start_y] = color\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid_move(nx, ny) and grid[nx][ny] == 0:\n                    grid[nx][ny] = color\n                    queue.append((nx, ny))\n    \n        for i in range(H):\n            for j in range(W):\n                if grid[i][j] == 0:\n                    bfs(i, j, color)\n                    return\n    \n    remaining_squares = H * W\n    for color in colors:\n        count = a[color - 1]\n        while count > 0:\n            place_color(color)\n            count -= 1\n    \n    for row in grid:\n        print(' '.join(map(str, row)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967371225357056,
            0.9966314435005188,
            0.9951515197753906,
            0.997107982635498,
            0.9962055683135986,
            0.9968974590301514,
            0.9963061809539795,
            0.9968892335891724,
            0.9935268759727478,
            0.9969955086708069,
            0.997361421585083,
            0.9960523247718811,
            0.9939247965812683,
            0.9967145323753357,
            0.9963806867599487,
            0.9964993000030518,
            0.9966301321983337,
            0.9960871338844299,
            0.995147705078125,
            0.9969606995582581
        ]
    },
    "2319": {
        "similarity": 0.9984161257743835,
        "body": "import sys\n\n    n = len(s)\n    for i in range(n):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == t:\n            return 1\n    return -1\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        s = data[index]\n        index += 1\n        t_str = data[index]\n        index += 1\n        \n        result = min_operations(s, t_str)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974730610847473,
            0.9982908368110657,
            0.997397780418396,
            0.9976551532745361,
            0.9974464774131775,
            0.9984161257743835,
            0.9952728152275085,
            0.9968916177749634,
            0.9975530505180359,
            0.997533917427063,
            0.997819721698761,
            0.9976162314414978,
            0.9968948364257812,
            0.9977414011955261,
            0.9976434111595154,
            0.9965636730194092,
            0.9976933002471924,
            0.9973857402801514,
            0.9978190064430237,
            0.9952590465545654
        ]
    },
    "2121": {
        "similarity": 0.9976668357849121,
        "body": "import sys\n\n        nonlocal min_time\n        if len(order) >= k:\n            min_time = min(min_time, times[node])\n        for neighbor in neighbors[node]:\n            if neighbor != parent:\n                dfs(neighbor, node, order + [neighbor])\n\n    max_grade = 0\n    for root in range(n):\n        neighbors = [[] for _ in range(n)]\n        for u, v in edges:\n            u -= 1\n            v -= 1\n            neighbors[u].append(v)\n            neighbors[v].append(u)\n        min_time = float('inf')\n        dfs(root, -1, [root])\n        max_grade = max(max_grade, min_time)\n    return max_grade\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    edges = [(int(data[2+n+2*i]) - 1, int(data[2+n+2*i + 1]) - 1) for i in range(n-1)]\n    \n    result = max_grade(n, k, times, edges)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940540194511414,
            0.9967631101608276,
            0.9973741769790649,
            0.9974947571754456,
            0.9976668357849121,
            0.9967827200889587,
            0.9970692992210388,
            0.9970139265060425,
            0.9966054558753967,
            0.9967671632766724,
            0.9962194561958313,
            0.99530428647995,
            0.9968521595001221,
            0.9969809651374817,
            0.9973247051239014,
            0.9973375201225281,
            0.9954197406768799,
            0.9974775910377502,
            0.9973537921905518,
            0.9953252077102661
        ]
    },
    "2617": {
        "similarity": 0.9979780316352844,
        "body": "    days = 0\n    while n > 1:\n        if n % 2 == 0:\n            n /= 2\n        else:\n            n += 1\n        days += 1\n    return days\n\n    nights = min_nights_to_mass(n)\n    splits = [0] * nights\n    for i in range(nights):\n        if n % 2 == 0:\n            n /= 2\n            splits[-i-1] = 0\n        else:\n            n += 1\n            splits[-i-1] = 1\n    return nights, splits\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        nights, splits = split_bacteria(n)\n        \n        if nights == -1:\n            results.append(-1)\n        else:\n            results.extend([nights] + splits)\n    \n    print('\\n'.join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959132671356201,
            0.9952273964881897,
            0.9977740049362183,
            0.9978081583976746,
            0.9979463219642639,
            0.9979780316352844,
            0.9971060752868652,
            0.9977186918258667,
            0.9971291422843933,
            0.9967986941337585,
            0.9976636171340942,
            0.9975914359092712,
            0.997787594795227,
            0.9968016743659973,
            0.9973098635673523,
            0.9974977374076843,
            0.9970044493675232,
            0.9968963265419006,
            0.9976611137390137,
            0.9965390563011169
        ]
    },
    "175": {
        "similarity": 0.9977003335952759,
        "body": "    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    print(a, b)\n\n# Read input from stdin\na, b = map(int, input().split())\nprocess(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956733584403992,
            0.9974990487098694,
            0.9973426461219788,
            0.9966643452644348,
            0.996439516544342,
            0.9957761168479919,
            0.9971243143081665,
            0.9967183470726013,
            0.9977003335952759,
            0.9971925616264343,
            0.9964677095413208,
            0.9946531057357788,
            0.9970118999481201,
            0.997128427028656,
            0.9968679547309875,
            0.9964959025382996,
            0.9971757531166077,
            0.9972302317619324,
            0.9956711530685425,
            0.9973428845405579
        ]
    },
    "995": {
        "similarity": 0.9972152709960938,
        "body": "    n = len(arr)\n    result = [0] * (n + 1)\n\n    for k in range(1, n + 1):\n        count = 0\n        for i in range(n - k + 1):\n            group_product = 1\n            valid = True\n            for j in range(i, i + k):\n                if (group_product * arr[j]) ** 0.5 != int((group_product * arr[j]) ** 0.5):\n                    valid = False\n                    break\n                group_product *= arr[j]\n            if valid:\n                count += 1\n        result[k] = count\n\n    return result[1:]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    arr = list(map(int, input().split()))\n    print(\" \".join(map(str, min_groups(arr))))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970898032188416,
            0.9966186881065369,
            0.9959729909896851,
            0.9963491559028625,
            0.9955704212188721,
            0.9965987205505371,
            0.9972045421600342,
            0.9968565106391907,
            0.9963324666023254,
            0.9961515665054321,
            0.9965013265609741,
            0.9967318177223206,
            0.9962037801742554,
            0.9972152709960938,
            0.9970574975013733,
            0.9970978498458862,
            0.9967439770698547,
            0.9940012097358704,
            0.9937772154808044,
            0.9957525134086609
        ]
    },
    "582": {
        "similarity": 0.9972930550575256,
        "body": "import sys\n\n    time_required = 0\n    unique_counts = set()\n    \n    for i in range(n):\n        while len(unique_counts) == len(a) or a[i] in unique_counts:\n            a[i] += 1\n            time_required += t[i]\n        \n        unique_counts.add(a[i])\n    \n    return time_required\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_time_to_add_publications(n, a, t))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960428476333618,
            0.9946315288543701,
            0.9913150668144226,
            0.9968193769454956,
            0.9967035055160522,
            0.9961987733840942,
            0.9959321618080139,
            0.9972899556159973,
            0.9961439371109009,
            0.9970163106918335,
            0.9972930550575256,
            0.9972456097602844,
            0.9966647624969482,
            0.9972406029701233,
            0.9954540729522705,
            0.9972670674324036,
            0.9959298968315125,
            0.9969251751899719,
            0.9965830445289612,
            0.99560546875
        ]
    },
    "1402": {
        "similarity": 0.9970588684082031,
        "body": "from collections import Counter\n\n    MOD = 10**9 + 7\n        greater = False\n        less = False\n        for i in range(n):\n            if s[i] != '?' and w[i] != '?':\n                if int(s[i]) > int(w[i]):\n                    greater = True\n                elif int(s[i]) < int(w[i]):\n                    less = True\n                if greater and less:\n                    return True\n        return False\n\n    if not is_comparable(s, w):\n        return 1\n    \n    s_counts = Counter(s)\n    w_counts = Counter(w)\n    \n    total_ways = 1\n    for char in set(s + w):\n        if char != '?':\n            s_count = s_counts[char]\n            w_count = w_counts[char]\n            if s_count > 0 and w_count > 0:\n                total_ways = (total_ways * pow(2, n - s_count - w_count, MOD)) % MOD\n    return total_ways\n\nn = int(input())\ns = input().strip()\nw = input().strip()\n\nresult = count_incomparable_templates(n, s, w)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964750409126282,
            0.9955520629882812,
            0.9962640404701233,
            0.9961728453636169,
            0.9957225322723389,
            0.9962761402130127,
            0.9953339099884033,
            0.9970588684082031,
            0.9966344237327576,
            0.996354341506958,
            0.9961246848106384,
            0.9960451722145081,
            0.9959697723388672,
            0.9928492307662964,
            0.9966729879379272,
            0.9959210157394409,
            0.995059072971344,
            0.995368480682373,
            0.9936620593070984,
            0.9969643354415894
        ]
    },
    "1141": {
        "similarity": 0.9981542229652405,
        "body": "    for l, r, c_1, c_2 in operations:\n        for i in range(l - 1, r):\n            if s[i] == c_1:\n                s = s[:i] + c_2 + s[i+1:]\n    return s\n\n# Read input\nn, m = map(int, input().split())\ns = input().strip()\noperations = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Perform operations and print result\nresult = transform_string(n, m, s, operations)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971385598182678,
            0.9981542229652405,
            0.9980107545852661,
            0.9949408173561096,
            0.9975167512893677,
            0.9967252016067505,
            0.9948555827140808,
            0.9963423013687134,
            0.9953175783157349,
            0.9980322122573853,
            0.9963639974594116,
            0.9980302453041077,
            0.9979954957962036,
            0.9964213967323303,
            0.9980744123458862,
            0.9959185719490051,
            0.9979895353317261,
            0.9963917136192322,
            0.9961692690849304,
            0.9969592690467834
        ]
    },
    "2836": {
        "similarity": 0.9980010986328125,
        "body": "import sys\n\n    max_distance = 0\n    best_name = a\n    \n    for x in range(a, b + 1):\n        if x % 2 != 0:\n            min_distance = float('inf')\n            for p in boys:\n                distance = abs(x - p)\n                if distance < min_distance:\n                    min_distance = distance\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_name = x\n    \n    return best_name\n\nif __name__ == \"__main__\":\n    n = int(input())\n    boys = list(map(int, input().split()))\n    a, b = map(int, input().split())\n    \n    print(find_girl_name(n, boys, a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973917603492737,
            0.9979246258735657,
            0.9975207448005676,
            0.9975352883338928,
            0.9972202181816101,
            0.9976891279220581,
            0.997447669506073,
            0.9976973533630371,
            0.9975499510765076,
            0.9973849058151245,
            0.9972256422042847,
            0.9978798627853394,
            0.9976341128349304,
            0.9973950982093811,
            0.9980010986328125,
            0.9950353503227234,
            0.9950480461120605,
            0.9968394041061401,
            0.9976932406425476,
            0.9973364472389221
        ]
    },
    "1109": {
        "similarity": 0.9976158142089844,
        "body": "import sys\n\n    period = a[:k]\n    changes = 0\n    \n    for i in range(k, n):\n        if a[i] != period[i % k]:\n            changes += 1\n    \n    return changes\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(min_changes_to_k_periodic(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.993361234664917,
            0.9967520833015442,
            0.9956594109535217,
            0.9971120953559875,
            0.9954478740692139,
            0.9966728091239929,
            0.9958469867706299,
            0.9976158142089844,
            0.9968964457511902,
            0.9971629977226257,
            0.9973105192184448,
            0.996557354927063,
            0.9968850016593933,
            0.9966768026351929,
            0.9944382905960083,
            0.9951806664466858,
            0.9975832104682922,
            0.9971225261688232,
            0.9972460865974426,
            0.9975098967552185
        ]
    },
    "2125": {
        "similarity": 0.9975529909133911,
        "body": "    flag_count = 0\n    \n    for i in range(n - 2):\n        for j in range(m):\n            for k in range(i + 1, n - 1):\n                if grid[i][j] == grid[i][j+1] == grid[i][j+2] and \\\n                   grid[k][j] == grid[k][j+1] == grid[k][j+2] and \\\n                   grid[i][j] != grid[k][j]:\n                    flag_count += 1\n                    \n    return flag_count\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print the result\nprint(count_flags(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969123005867004,
            0.9971703290939331,
            0.9965440630912781,
            0.9949959516525269,
            0.995427668094635,
            0.9970148205757141,
            0.9967951774597168,
            0.9960513114929199,
            0.9943772554397583,
            0.9971387982368469,
            0.9968175292015076,
            0.99681556224823,
            0.996020495891571,
            0.9964268207550049,
            0.9970216155052185,
            0.9960626363754272,
            0.9974862933158875,
            0.9952035546302795,
            0.9948608875274658,
            0.9975529909133911
        ]
    },
    "1746": {
        "similarity": 0.997586727142334,
        "body": "import sys\n\n    num_children = [0] * (n + 1)\n    \n    for i in range(1, n):\n        num_children[parent[i]] += 1\n    \n    leaves = sum(1 for i in range(2, n) if num_children[i] == 0)\n    \n    for i in range(2, n):\n        if num_children[i] >= 3 and leaves < 3:\n            return \"No\"\n        leaves -= num_children[i]\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    parent = [int(input()) for _ in range(n - 1)]\n    print(is_spruce(n, parent))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9926610589027405,
            0.9962950348854065,
            0.9969152212142944,
            0.9964374899864197,
            0.9970570802688599,
            0.9973270893096924,
            0.9970126748085022,
            0.9970747232437134,
            0.9949601888656616,
            0.9968119263648987,
            0.9970594048500061,
            0.9961107969284058,
            0.9948118329048157,
            0.9937657713890076,
            0.997586727142334,
            0.9968778491020203,
            0.996638834476471,
            0.9967049956321716,
            0.9964683055877686,
            0.9971176981925964
        ]
    },
    "1294": {
        "similarity": 0.996698260307312,
        "body": "import sys\n\n    n = len(s)\n    working_buttons = set()\n    \n    for i in range(n):\n        if i % 2 == 0:\n            working_buttons.add(s[i])\n        else:\n            working_buttons.discard(s[i])\n    \n    return ''.join(sorted(working_buttons))\n\nt = int(input())\nresults = []\n\nfor _ in range(t):\n    s = input().strip()\n    results.append(determine_working_buttons(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996698260307312,
            0.9910913109779358,
            0.9945550560951233,
            0.9960519671440125,
            0.9933895468711853,
            0.9953155517578125,
            0.99609375,
            0.992813229560852,
            0.9960036277770996,
            0.9958968162536621,
            0.9963347911834717,
            0.996164858341217,
            0.9956598877906799,
            0.9924533367156982,
            0.9956754446029663,
            0.9950137734413147,
            0.992839515209198,
            0.9953194856643677,
            0.9959785342216492,
            0.993751049041748
        ]
    },
    "1159": {
        "similarity": 0.9983331561088562,
        "body": "import sys\n\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n    degrees = [2] * n\n    total_edges = sum(degrees) // 2\n    \n    while not is_prime(total_edges):\n        for i in range(n):\n            if degrees[i] > 3 and is_prime(degrees[i]):\n                degrees[i] -= 1\n                total_edges -= 1\n        if total_edges <= 0:\n            return -1, []\n    \n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if degrees[i] > 2 and degrees[j] > 2:\n                edges.append((i + 1, j + 1))\n                degrees[i] -= 2\n                degrees[j] -= 2\n                total_edges -= 1\n    \n    return total_edges, edges\n\n    n = int(input())\n    \n    result, graph = generate_graph(n)\n    \n    if result == -1:\n        print(result)\n    else:\n        print(result)\n        for u, v in graph:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980298280715942,
            0.9980500936508179,
            0.9978058338165283,
            0.997069239616394,
            0.9983331561088562,
            0.9978662133216858,
            0.9971640706062317,
            0.9979151487350464,
            0.9978894591331482,
            0.9973981976509094,
            0.996422529220581,
            0.9975442290306091,
            0.9981205463409424,
            0.9983100891113281,
            0.997869610786438,
            0.9980686902999878,
            0.9973949790000916,
            0.9971737265586853,
            0.9969228506088257,
            0.9972202181816101
        ]
    },
    "2025": {
        "similarity": 0.9981623291969299,
        "body": "import sys\n\n    if n < 4:\n        return -1\n    count = 0\n    while n >= 4:\n        n -= 4\n        count += 1\n    if n == 2 or n == 3:\n        return -1\n    return count\n\n    q = int(input())\n    results = []\n    for _ in range(q):\n        n = int(input())\n        results.append(max_composite_summands(n))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962297081947327,
            0.9976102113723755,
            0.9976106882095337,
            0.9976437091827393,
            0.9958914518356323,
            0.9980161786079407,
            0.9979796409606934,
            0.9975487589836121,
            0.9975107908248901,
            0.9969636797904968,
            0.996829092502594,
            0.9968338012695312,
            0.9970990419387817,
            0.9974663257598877,
            0.9972795248031616,
            0.9979076385498047,
            0.9981623291969299,
            0.9974455833435059,
            0.9974001049995422,
            0.9971789121627808
        ]
    },
    "1429": {
        "similarity": 0.9967036843299866,
        "body": "import sys\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            t = s[i:j]\n            complementary = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n            permuted_t = ''.join(complementary[c] for c in t[::-1])\n            if all(t.count(c) == permuted_t.count(c) for c in 'ATCG'):\n                count += 1\n    return count\n\nif __name__ == \"__main__\":\n    n, s = input().strip().split()\n    n = int(n)\n    s = s.strip()\n    result = count_complementary_substrings(n, s)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963192343711853,
            0.9960976839065552,
            0.9964653849601746,
            0.9951091408729553,
            0.9964504241943359,
            0.9956412315368652,
            0.9949840903282166,
            0.9942129850387573,
            0.9953619241714478,
            0.9958775043487549,
            0.9943509697914124,
            0.9950346946716309,
            0.9954400658607483,
            0.9895860552787781,
            0.9952376484870911,
            0.9966892600059509,
            0.9966546297073364,
            0.9957413077354431,
            0.9958513975143433,
            0.9967036843299866
        ]
    },
    "1950": {
        "similarity": 0.9965739250183105,
        "body": "import sys\n\n    total_penalty = 0\n    for i in range(n):\n        if a[i] > i + 1:\n            total_penalty += i + 1\n    return total_penalty\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(min_penalty(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951626658439636,
            0.9845132231712341,
            0.9952811002731323,
            0.9949288964271545,
            0.9953300356864929,
            0.9959297180175781,
            0.9938988089561462,
            0.9933302998542786,
            0.9954613447189331,
            0.993011474609375,
            0.9961304068565369,
            0.9958823323249817,
            0.9923595786094666,
            0.9952818155288696,
            0.9950433373451233,
            0.9958234429359436,
            0.9965739250183105,
            0.9962849020957947,
            0.9954009056091309,
            0.9956748485565186
        ]
    },
    "631": {
        "similarity": 0.9973101615905762,
        "body": "import itertools\n\n    results = []\n    \n    for n, m in [(n, m) for n, m, _ in test_cases]:\n        a = test_cases[0][2]\n        \n        for perm in itertools.permutations(a):\n            total_sum = 0\n            for i in range(n):\n                inner_sum = sum(perm[j] / (j + 1) for j in range(i, n))\n                total_sum += inner_sum\n                if total_sum > m:\n                    break\n            if total_sum == m:\n                results.append(\"YES\")\n                break\n        else:\n            results.append(\"NO\")\n    \n    return results\n\n# Read input\nt = int(input())\ntest_cases = []\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    test_cases.append((n, m, a))\n\n# Process and print results\nresults = can_reorder_to_match_sum(t, test_cases)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955251812934875,
            0.9953263998031616,
            0.9964603781700134,
            0.9955374002456665,
            0.9969769716262817,
            0.9971086382865906,
            0.9971957802772522,
            0.9971699118614197,
            0.9973066449165344,
            0.9965571165084839,
            0.9964607954025269,
            0.9973101615905762,
            0.9971703886985779,
            0.9964970946311951,
            0.99672931432724,
            0.9948351979255676,
            0.997003436088562,
            0.9961408376693726,
            0.9961710572242737,
            0.9958528280258179
        ]
    },
    "2480": {
        "similarity": 0.9983012676239014,
        "body": "from collections import defaultdict\n\n    prefix_remainder_count = defaultdict(int)\n    prefix_remainder_count[0] = 1\n    current_sum = 0\n    subsequence_count = 0\n    \n    for i in range(N):\n        current_sum += A[i]\n        remainder = (current_sum % K) - (i + 1) % K\n        if remainder < 0:\n            remainder += K\n        subsequence_count += prefix_remainder_count[remainder]\n        prefix_remainder_count[remainder] += 1\n    \n    return subsequence_count\n\n# Read input from stdin\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_subsequences(N, K, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981819987297058,
            0.9978382587432861,
            0.9978333711624146,
            0.9973970055580139,
            0.9974513649940491,
            0.9978671073913574,
            0.9975541830062866,
            0.9978911876678467,
            0.9970428347587585,
            0.9979475140571594,
            0.9977884888648987,
            0.9975163340568542,
            0.996867835521698,
            0.9965453147888184,
            0.9979450702667236,
            0.9977509379386902,
            0.9983012676239014,
            0.9980398416519165,
            0.9968315958976746,
            0.9981300234794617
        ]
    },
    "2363": {
        "similarity": 0.9978370666503906,
        "body": "    results = []\n    for a, b in pairs:\n        operations = 0\n        while a > 0 and b > 0:\n            if a < b:\n                b -= a\n            else:\n                a -= b\n            operations += 1\n        results.append(operations)\n    return results\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\nresults = calculate_operations(n, pairs)\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976903796195984,
            0.9972231984138489,
            0.9975368976593018,
            0.997432291507721,
            0.997768223285675,
            0.9968374371528625,
            0.9965073466300964,
            0.9978224039077759,
            0.9970924854278564,
            0.9973775148391724,
            0.9975403547286987,
            0.9969109296798706,
            0.9978370666503906,
            0.9964156746864319,
            0.995999813079834,
            0.996584951877594,
            0.9966807961463928,
            0.9970105886459351,
            0.9973572492599487,
            0.997788667678833
        ]
    },
    "909": {
        "similarity": 0.995194673538208,
        "body": "    operations = [a + b * c, a * (b + c), a * b * c]\n    return max(operations)\n\n# Read input from stdin\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the result\nprint(max_value(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939017295837402,
            0.9951105713844299,
            0.9923647046089172,
            0.9950319528579712,
            0.9939017295837402,
            0.9946727752685547,
            0.9918935894966125,
            0.9913219809532166,
            0.9935061931610107,
            0.9939600229263306,
            0.9926044344902039,
            0.9884290099143982,
            0.9892494082450867,
            0.9951047301292419,
            0.9908347725868225,
            0.995194673538208,
            0.9950137734413147,
            0.9931015372276306,
            0.9934365153312683,
            0.9938379526138306
        ]
    },
    "154": {
        "similarity": 0.9969249367713928,
        "body": "MOD = 998244353\n\n    if n == 0 or n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(i // 2 + 1):\n            dp[i] += dp[j] * dp[i - 1 - j]\n            dp[i] %= MOD\n    \n    return dp[n]\n\nn = int(input())\nprint(count_trees(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965090751647949,
            0.996375322341919,
            0.9958311319351196,
            0.9954022765159607,
            0.9937258362770081,
            0.9963534474372864,
            0.9939395785331726,
            0.9906505942344666,
            0.9969249367713928,
            0.9968307018280029,
            0.9914537072181702,
            0.9963122010231018,
            0.9964814782142639,
            0.9956637024879456,
            0.9940183758735657,
            0.9965736269950867,
            0.9957433938980103,
            0.9961165189743042,
            0.9950954914093018,
            0.9959350228309631
        ]
    },
    "39": {
        "similarity": 0.997552752494812,
        "body": "    n = len(s)\n    max_len = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            is_palindrome = True\n            for k in range(len(substring) // 2):\n                if substring[k] != substring[len(substring) - k - 1]:\n                    is_palindrome = False\n                    break\n            if not is_palindrome and len(substring) > max_len:\n                max_len = len(substring)\n\n    return max_len\n\n# Read input from stdin\ns = input().strip()\nresult = longest_non_palindrome_substring(s)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996124267578125,
            0.997552752494812,
            0.9970837831497192,
            0.9955988526344299,
            0.995624840259552,
            0.9974638223648071,
            0.9971249103546143,
            0.9970698952674866,
            0.9973094463348389,
            0.9965354800224304,
            0.9968711733818054,
            0.9972500205039978,
            0.996913731098175,
            0.9964205026626587,
            0.9956247210502625,
            0.9940690398216248,
            0.9954259991645813,
            0.9973417520523071,
            0.9968715310096741,
            0.9966071248054504
        ]
    },
    "1885": {
        "similarity": 0.9974327087402344,
        "body": "from math import comb\n\n    total_variants = 0\n    for group_size in range(5, 8):\n        total_variants += comb(n, group_size)\n    return total_variants\n\nn = int(input())\nprint(count_group_variants(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964438080787659,
            0.9972816109657288,
            0.9957000613212585,
            0.9947749972343445,
            0.9946039915084839,
            0.9960845112800598,
            0.9971054792404175,
            0.9961801767349243,
            0.9974327087402344,
            0.9972168803215027,
            0.9973497986793518,
            0.9973497986793518,
            0.9963804483413696,
            0.9911088347434998,
            0.9959045052528381,
            0.9973497986793518,
            0.9947749972343445,
            0.997271716594696,
            0.996829092502594,
            0.9957141876220703
        ]
    },
    "1180": {
        "similarity": 0.997771143913269,
        "body": "    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][0] = int(digits[:i+1])\n    \n    for j in range(1, k + 1):\n        for i in range(j, n):\n            if digits[i-1] != '0':\n                dp[i][j] = (dp[i-2][j-1] * int(digits[i-1]) + dp[i-1][j]) % MOD\n    \n    return dp[n-1][k]\n\n# Read input\nn, k = map(int, input().split())\ndigits = input().strip()\n\n# Calculate and print the result\nresult = calculate_sums(n, k, digits)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.99704509973526,
            0.9946244955062866,
            0.9968065023422241,
            0.9935318827629089,
            0.9970504641532898,
            0.9976453185081482,
            0.9964656829833984,
            0.9963967204093933,
            0.9968162178993225,
            0.997771143913269,
            0.9975553750991821,
            0.9976975321769714,
            0.9968549013137817,
            0.9962975382804871,
            0.9962973594665527,
            0.9977127909660339,
            0.996394693851471,
            0.9973763227462769,
            0.9971519112586975,
            0.9948694109916687
        ]
    },
    "1856": {
        "similarity": 0.9958488345146179,
        "body": "    groups = {}\n    for password in passwords:\n        sorted_chars = ''.join(sorted(password))\n        if sorted_chars not in groups:\n            groups[sorted_chars] = []\n        groups[sorted_chars].append(password)\n    \n    max_group_size = 0\n    for group in groups.values():\n        max_group_size = max(max_group_size, len(group))\n    \n    return max_group_size\n\n# Read input from stdin\nn = int(input())\npasswords = [input().strip() for _ in range(n)]\n\n# Calculate and print the result\nprint(min_passwords(n, passwords))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954860210418701,
            0.9930578470230103,
            0.9955993294715881,
            0.9912022948265076,
            0.9939262866973877,
            0.9953160881996155,
            0.9863113760948181,
            0.995661199092865,
            0.9948180317878723,
            0.9935433268547058,
            0.9940980672836304,
            0.9941205382347107,
            0.9891034364700317,
            0.992942214012146,
            0.9952873587608337,
            0.9945148825645447,
            0.9945299029350281,
            0.991221010684967,
            0.9952821135520935,
            0.9958488345146179
        ]
    },
    "522": {
        "similarity": 0.9963492155075073,
        "body": "    MOD = 10**9 + 7\n    \n    f_values = [f_1, f_2, f_3]\n    \n    for i in range(3, n):\n        next_value = (c**(2*i - 6) * f_values[i-1] * f_values[i-2] * f_values[i-3]) % MOD\n        f_values.append(next_value)\n    \n    return f_values[n-1]\n\n# Read input\nn, f_1, f_2, f_3, c = map(int, input().split())\n\n# Calculate and print result\nprint(calculate_f_n(n, f_1, f_2, f_3, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962539672851562,
            0.9945897459983826,
            0.9956324696540833,
            0.9953224062919617,
            0.9940952658653259,
            0.9938119649887085,
            0.9931461215019226,
            0.9943255186080933,
            0.9950432181358337,
            0.9927153587341309,
            0.9961236715316772,
            0.9932568073272705,
            0.9957368969917297,
            0.9940077066421509,
            0.9958952069282532,
            0.9962171316146851,
            0.9940153360366821,
            0.9953262209892273,
            0.994498610496521,
            0.9963492155075073
        ]
    },
    "1719": {
        "similarity": 0.9949628114700317,
        "body": "import sys\n\n    MOD = 10**9 + 7\n    if n == 3:\n        return 61\n    \n    dp = [[0] * 4 for _ in range(2)]\n    dp[0][0], dp[0][1], dp[0][2], dp[0][3] = 1, 1, 1, 1\n    \n    for length in range(3, n):\n        dp[1][0] = (dp[0][0] * 3 + dp[0][1] * 3 + dp[0][2] * 2 + dp[0][3] * 2) % MOD\n        dp[1][1] = (dp[0][0] * 3 + dp[0][1] * 2 + dp[0][2] * 2) % MOD\n        dp[1][2] = (dp[0][0] * 3 + dp[0][1] * 3 + dp[0][2] * 2) % MOD\n        dp[1][3] = (dp[0][0] * 3 + dp[0][1] * 2 + dp[0][2] * 2) % MOD\n        \n        dp[0][:] = dp[1][:]\n    \n    result = sum(dp[0]) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    count_valid_strings(n)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937226176261902,
            0.9922003746032715,
            0.9924928545951843,
            0.9949628114700317,
            0.9921804666519165,
            0.9943692088127136,
            0.9941030740737915,
            0.993949294090271,
            0.9910226464271545,
            0.9921286702156067,
            0.9944463968276978,
            0.9940703511238098,
            0.993550181388855,
            0.994207501411438,
            0.9937258362770081,
            0.9935207366943359,
            0.9941037893295288,
            0.9907938241958618,
            0.9812728762626648,
            0.9945827126502991
        ]
    },
    "1842": {
        "similarity": 0.9980241656303406,
        "body": "import math\n\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + math.sqrt(discriminant)) / (2 * a)\n    root2 = (-b - math.sqrt(discriminant)) / (2 * a)\n    return max(root1, root2), min(root1, root2)\n\na, b, c = map(int, input().split())\noptimistic, pessimistic = solve_quadratic_equation(a, b, c)\nprint(f\"{optimistic:.10f}\")\nprint(f\"{pessimistic:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976981282234192,
            0.9977523684501648,
            0.9979906678199768,
            0.9974090456962585,
            0.9980241656303406,
            0.9978674054145813,
            0.9976769685745239,
            0.9949444532394409,
            0.9980179667472839,
            0.9975001811981201,
            0.9969938397407532,
            0.9979268312454224,
            0.9976770281791687,
            0.9975576996803284,
            0.9977089762687683,
            0.9944177269935608,
            0.9977523684501648,
            0.9960682392120361,
            0.9945040345191956,
            0.9979990720748901
        ]
    },
    "806": {
        "similarity": 0.9979071617126465,
        "body": "    MOD = 10**9 + 7\n    total_sum = n * (l + r) // 2\n    if total_sum % 3 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in range(l, r + 1):\n        new_dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            new_dp[i] += dp[i]\n            if i + num <= n:\n                new_dp[i + num] += dp[i]\n            new_dp[i] %= MOD\n        dp = new_dp\n    \n    return dp[0]\n\n# Read input from stdin\nn, l, r = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, l, r))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977676272392273,
            0.9970142245292664,
            0.9969175457954407,
            0.9979071617126465,
            0.9967229962348938,
            0.9974845051765442,
            0.9977641105651855,
            0.9955077171325684,
            0.996440589427948,
            0.9973336458206177,
            0.9966642260551453,
            0.9961961507797241,
            0.996630847454071,
            0.9970719218254089,
            0.9974458813667297,
            0.9968376159667969,
            0.9924043416976929,
            0.9978848695755005,
            0.9942699074745178,
            0.9973688721656799
        ]
    },
    "365": {
        "similarity": 0.9976926445960999,
        "body": "    total = sum(a)\n    if total != x:\n        return \"NO\"\n    \n    max_segment = max(a)\n    if max_segment > n - len(a) + 1:\n        return \"NO\"\n    \n    remaining_length = x - total\n    for i in range(len(a)):\n        if a[i] == 1 and remaining_length > 0:\n            remaining_length -= 1\n        else:\n            break\n    \n    if remaining_length < 0:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input from stdin\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(can_be_unique(n, x, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959439635276794,
            0.9965381622314453,
            0.9974778890609741,
            0.9967542886734009,
            0.9967821836471558,
            0.992602527141571,
            0.9971072673797607,
            0.9943215250968933,
            0.9976429343223572,
            0.997424304485321,
            0.9973676800727844,
            0.9964573383331299,
            0.9976568818092346,
            0.9964681267738342,
            0.9976926445960999,
            0.9971681237220764,
            0.9960997700691223,
            0.9963656067848206,
            0.9976576566696167,
            0.9974889159202576
        ]
    },
    "1158": {
        "similarity": 0.9965161681175232,
        "body": "import collections\n\n    counter = collections.Counter(utensils)\n    max_guests = 0\n    for count in counter.values():\n        max_guests += count // k\n    \n    return n - max_guests * k\n\n# Read input from stdin\nn, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\n# Print the result\nprint(min_stolen_utensils(n, k, utensils))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951515197753906,
            0.9938879609107971,
            0.9951235055923462,
            0.9962196350097656,
            0.9939460754394531,
            0.9910256266593933,
            0.9961088299751282,
            0.990983784198761,
            0.9926300048828125,
            0.9951437711715698,
            0.995066225528717,
            0.9931358695030212,
            0.9950876832008362,
            0.9944524168968201,
            0.9957286715507507,
            0.9959531426429749,
            0.9938898682594299,
            0.996304988861084,
            0.9936974048614502,
            0.9965161681175232
        ]
    },
    "33": {
        "similarity": 0.9965358376502991,
        "body": "    common_count = 0\n    for k in range(R // a1 + 1):\n        x = a1 * k + b1\n        if L <= x <= R:\n            if (x - b1) % a2 == 0:\n                common_count += 1\n    return common_count\n\n# Read input from stdin\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961427450180054,
            0.9951611757278442,
            0.996185302734375,
            0.9940702319145203,
            0.9952812194824219,
            0.9961891174316406,
            0.9959191083908081,
            0.9961308836936951,
            0.995486319065094,
            0.9919102191925049,
            0.9940012693405151,
            0.9955894351005554,
            0.995319664478302,
            0.9917020201683044,
            0.9959489703178406,
            0.9962825775146484,
            0.9965358376502991,
            0.9961229562759399,
            0.9956568479537964,
            0.9955143332481384
        ]
    },
    "2498": {
        "similarity": 0.997687578201294,
        "body": "import sys\n\n    semi_common_multiples = set()\n    \n    for num in a:\n        p = 0.5\n        while True:\n            x = num * p\n            if x > m:\n                break\n            semi_common_multiples.add(int(x))\n            p += 1\n    \n    return len(semi_common_multiples)\n\n# Read input from stdin\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Call the function and print the result\nresult = count_semi_common_multiples(n, m, a)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.997687578201294,
            0.9966091513633728,
            0.9974984526634216,
            0.9971333742141724,
            0.996346652507782,
            0.9962995648384094,
            0.9967357516288757,
            0.997611403465271,
            0.9968020915985107,
            0.9966091513633728,
            0.9976204633712769,
            0.9952955842018127,
            0.997611403465271,
            0.9972917437553406,
            0.9964103698730469,
            0.9968727827072144,
            0.9966763854026794,
            0.9959542155265808,
            0.9973587393760681,
            0.996921956539154
        ]
    },
    "2309": {
        "similarity": 0.9976187348365784,
        "body": "import sys\n\n    return sum(1 for char in word if char in 'aeiou')\n\n    n = len(words)\n    word_count = {}\n    vowels = set('aeiou')\n    \n    # Count the frequency of each word and calculate vowel counts\n    for word in words:\n        if word in word_count:\n            word_count[word][0] += 1\n        else:\n            word_count[word] = [1, count_vowels(word)]\n    \n    # Find all unique words by their vowel counts\n    unique_words_by_vowel_count = {}\n    for word, (freq, vowel_count) in word_count.items():\n        if vowel_count not in unique_words_by_vowel_count:\n            unique_words_by_vowel_count[vowel_count] = []\n        unique_words_by_vowel_count[vowel_count].append(word)\n    \n    # Find beautiful lyrics\n    lyrics = []\n    for words_list1 in unique_words_by_vowel_count.values():\n        for i in range(len(words_list1)):\n            for j in range(i, len(words_list1)):\n                first_word = words_list1[i]\n                second_word = words_list1[j]\n                if word_count[first_word][0] > 1 and word_count[second_word][0] > 1:\n                    lyrics.append((first_word, second_word))\n    \n    return lyrics\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    words = data[1:]\n    \n    beautiful_lyrics = find_beautiful_lyrics(words)\n    \n    m = len(beautiful_lyrics)\n    print(m)\n    for first_word, second_word in beautiful_lyrics:\n        print(first_word + ' ' + second_word)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976187348365784,
            0.9975975751876831,
            0.9968755841255188,
            0.9973185658454895,
            0.9969024658203125,
            0.9971080422401428,
            0.9972516298294067,
            0.9964720010757446,
            0.9966477155685425,
            0.9969109296798706,
            0.9963089823722839,
            0.9973904490470886,
            0.9968635439872742,
            0.9974148273468018,
            0.9974986910820007,
            0.9974272847175598,
            0.995867908000946,
            0.9958594441413879,
            0.9973548054695129,
            0.9974351525306702
        ]
    },
    "1326": {
        "similarity": 0.9973317384719849,
        "body": "import math\n\n    total_sum = 0\n    for k in range(1, n + 1):\n        divisors_count = 0\n        for i in range(1, int(math.sqrt(k)) + 1):\n            if k % i == 0:\n                divisors_count += 2 if i != k // i else 1\n        total_sum += k * divisors_count\n    return total_sum\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(sum_of_divisor_products(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970482587814331,
            0.9957232475280762,
            0.9962407946586609,
            0.9967491626739502,
            0.9957982301712036,
            0.9949377179145813,
            0.996638834476471,
            0.9962208271026611,
            0.9900417327880859,
            0.9963864684104919,
            0.996622622013092,
            0.9961435198783875,
            0.9973019361495972,
            0.9973317384719849,
            0.9962724447250366,
            0.9967113137245178,
            0.9968612194061279,
            0.9962363243103027,
            0.9853110313415527,
            0.9970587491989136
        ]
    },
    "2950": {
        "similarity": 0.9971417784690857,
        "body": "    charges = 0\n    while max(h) > 0:\n        max_height = max(h)\n        for i in range(n):\n            if h[i] >= max_height:\n                h[i] -= max_height\n                if h[i] == 0:\n                    h[i] = 1\n        charges += 1\n    return charges\n\n# Read input\nn = int(input())\nh = list(map(int, input().split()))\n\n# Output the result\nprint(min_charges_to_tear_down_blocks(n, h))",
        "result": "failed: testcase 0",
        "similarities": [
            0.993272066116333,
            0.996536135673523,
            0.9967018961906433,
            0.9964572787284851,
            0.9965711832046509,
            0.9946478009223938,
            0.9948662519454956,
            0.9951067566871643,
            0.9966527223587036,
            0.9964461922645569,
            0.9970817565917969,
            0.9952430725097656,
            0.9959417581558228,
            0.9965603351593018,
            0.9969192147254944,
            0.995433509349823,
            0.9965904951095581,
            0.9960526823997498,
            0.9931910634040833,
            0.9971417784690857
        ]
    },
    "1983": {
        "similarity": 0.997829258441925,
        "body": "import sys\n\n    if not arr:\n        return 0\n    \n    lis = [1] * len(arr)\n    \n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n    \n    return max(lis)\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        new_a = a * n\n        result = length_of_lis(new_a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970085024833679,
            0.9974321126937866,
            0.9975373148918152,
            0.9973395466804504,
            0.9977204203605652,
            0.997829258441925,
            0.9976288676261902,
            0.9963330626487732,
            0.9968811869621277,
            0.9945257306098938,
            0.9971709251403809,
            0.9972161054611206,
            0.9956207275390625,
            0.9961760640144348,
            0.9964209198951721,
            0.996865451335907,
            0.997798502445221,
            0.9977014660835266,
            0.9972826242446899,
            0.9978039264678955
        ]
    },
    "1767": {
        "similarity": 0.9977098107337952,
        "body": "    max_sum = 0\n    for l in range(n):\n        or_a = 0\n        or_b = 0\n        for r in range(l, n):\n            or_a |= a[r]\n            or_b |= b[r]\n            max_sum = max(max_sum, or_a + or_b)\n    return max_sum\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bitwise_or_sum(n, a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937143921852112,
            0.9958930015563965,
            0.9948743581771851,
            0.9955835938453674,
            0.9969508647918701,
            0.9969738721847534,
            0.9976995587348938,
            0.9967086315155029,
            0.9976929426193237,
            0.9971458315849304,
            0.9970773458480835,
            0.9965924620628357,
            0.9964140057563782,
            0.9964087605476379,
            0.9969469308853149,
            0.9976816773414612,
            0.9963234663009644,
            0.9970154166221619,
            0.9977098107337952,
            0.9977098107337952
        ]
    },
    "2382": {
        "similarity": 0.9969282746315002,
        "body": "from collections import Counter\nimport sys\n\n    target = Counter(S)\n    current_healths = [1]\n    \n    for _ in range(N):\n        new_healths = set()\n        for health in current_healths:\n            for i in range(health):\n                if i > 0 and target[i] > 0:\n                    new_healths.add(i)\n                    target[i] -= 1\n        current_healths = list(new_healths)\n    \n    return not target\n\nif __name__ == \"__main__\":\n    N = int(input().strip())\n    S = list(map(int, input().strip().split()))\n    print(\"Yes\" if can_reproduce(N, S) else \"No\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940149188041687,
            0.9937469363212585,
            0.9954653382301331,
            0.9957514405250549,
            0.9957841634750366,
            0.9961473345756531,
            0.9959570169448853,
            0.9968330264091492,
            0.9947176575660706,
            0.9933105111122131,
            0.994731605052948,
            0.9969282746315002,
            0.996279776096344,
            0.993577778339386,
            0.994963526725769,
            0.9954510927200317,
            0.9941998720169067,
            0.996188223361969,
            0.9962965250015259,
            0.9934485554695129
        ]
    },
    "3907": {
        "similarity": 0.997013509273529,
        "body": "    # Sort coupons by cost in ascending order\n    coupons.sort(key=lambda x: x[1])\n    \n    # Initialize the array with zeros\n    a = [0] * n\n    \n    # Fill the array using the cheapest coupons first\n    for i in range(m):\n        q_i, w_i = coupons[i]\n        for j in range(n):\n            if a[j] == 0:\n                a[j] = q_i\n                break\n    \n    # Calculate the total cost\n    total_cost = sum(w_i * a.count(q_i) for q_i, w_i in coupons)\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\ncoupons = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(max_money_to_pay(n, m, coupons))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996787428855896,
            0.9959200024604797,
            0.9964738488197327,
            0.9969558715820312,
            0.9963874816894531,
            0.9946078062057495,
            0.997013509273529,
            0.9963864088058472,
            0.9931633472442627,
            0.996859610080719,
            0.9902849793434143,
            0.9955418109893799,
            0.9961473345756531,
            0.9952803254127502,
            0.9968936443328857,
            0.9955994486808777,
            0.9964926838874817,
            0.9963515400886536,
            0.9970090985298157,
            0.9956525564193726
        ]
    },
    "3676": {
        "similarity": 0.9972690939903259,
        "body": "    if R == 1 or C == 1:\n        return min(R, C)\n    \n    dp = [[0] * (C + 1) for _ in range(R + 1)]\n    dp[1][1] = 1\n    \n    for r in range(2, R + 1):\n        for c in range(2, C + 1):\n            dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\n    \n    return dp[R][C]\n\n# Read input\nR, C = map(int, input().split())\n\n# Print the result\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969494342803955,
            0.9965054392814636,
            0.9950766563415527,
            0.9961827993392944,
            0.9961170554161072,
            0.9943687915802002,
            0.9963820576667786,
            0.9922030568122864,
            0.9941827654838562,
            0.9931002259254456,
            0.9965904951095581,
            0.9953332543373108,
            0.9927808046340942,
            0.9967672228813171,
            0.9972690939903259,
            0.9957227110862732,
            0.995968759059906,
            0.9968301653862,
            0.9968388080596924,
            0.9954661130905151
        ]
    },
    "3293": {
        "similarity": 0.9976186156272888,
        "body": "    n = len(snacks)\n    min_buy_price = float('inf')\n    max_sell_price = 0\n    profit = 0\n\n    for i in range(n):\n        f, p, m, s = snacks[i]\n        if s > 0:\n            if p < min_buy_price:\n                min_buy_price = p\n            if m > max_sell_price:\n                max_sell_price = m\n    \n    profit = (max_sell_price - min_buy_price)\n    return profit\n\n# Read input\nn = int(input())\nsnacks = []\nfor _ in range(n):\n    f, p, m, s = map(int, input().split())\n    snacks.append((f, p, m, s))\n\n# Output result\nprint(max_profit(snacks))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997400164604187,
            0.9947722554206848,
            0.9974862933158875,
            0.9973435997962952,
            0.9974560141563416,
            0.996923565864563,
            0.9972789287567139,
            0.9933202862739563,
            0.9976186156272888,
            0.9959000945091248,
            0.9962442517280579,
            0.9952649474143982,
            0.9968992471694946,
            0.9972056150436401,
            0.9964661002159119,
            0.9967222809791565,
            0.9972056150436401,
            0.9974004030227661,
            0.9973372220993042,
            0.9971426129341125
        ]
    },
    "3587": {
        "similarity": 0.9965673685073853,
        "body": "    if N == 0:\n        return \"1\"\n    \n    max_len = -1\n    for i in range(2 ** N):\n        binary_str = bin(i)[2:].zfill(N)\n        valid = True\n        for taboo in taboo_strings:\n            if taboo in binary_str:\n                valid = False\n                break\n        if valid:\n            max_len = max(max_len, len(binary_str))\n    \n    return \"-1\" if max_len == -1 else \"0\" * (max_len + 1)\n\n# Example usage:\nN = int(input())\ntaboo_strings = [input().strip() for _ in range(N)]\nprint(longest_non_taboo_clue(N, taboo_strings))",
        "result": "failed: testcase 0",
        "similarities": [
            0.98974609375,
            0.9964828491210938,
            0.9954273700714111,
            0.9934338331222534,
            0.9961899518966675,
            0.9960039854049683,
            0.9950736165046692,
            0.9957016706466675,
            0.9957901835441589,
            0.9962718486785889,
            0.9936913251876831,
            0.9965673685073853,
            0.9956730604171753,
            0.9945116639137268,
            0.9956955313682556,
            0.9964549541473389,
            0.9939460754394531,
            0.9941433668136597,
            0.9949277639389038,
            0.9963258504867554
        ]
    },
    "3530": {
        "similarity": 0.9974929690361023,
        "body": "import sys\n\n    results = []\n    for T in times:\n        total_fun = 0\n        for i in range(N):\n            k = 1\n            while True:\n                fun = coasters[i][0] - (k-1)**2 * coasters[i][1]\n                if fun <= 0 or (i+1)*coasters[i][2] < T:\n                    break\n                total_fun += fun\n                k += 1\n        results.append(total_fun)\n    return results\n\nif __name__ == \"__main__\":\n    N = int(input())\n    coasters = []\n    for _ in range(N):\n        a, b, t = map(int, input().split())\n        coasters.append((a, b, t))\n    Q = int(input())\n    times = [int(input()) for _ in range(Q)]\n    results = max_fun(N, coasters, Q, times)\n    for result in results:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962812662124634,
            0.9927611351013184,
            0.9964857697486877,
            0.9967280030250549,
            0.9974929690361023,
            0.9963722229003906,
            0.9967793822288513,
            0.9974004030227661,
            0.9948732256889343,
            0.9962782859802246,
            0.9973578453063965,
            0.9953622221946716,
            0.9934383034706116,
            0.9969592690467834,
            0.9972963929176331,
            0.997458815574646,
            0.9967808127403259,
            0.9972488284111023,
            0.9962137937545776,
            0.9951304197311401
        ]
    },
    "3900": {
        "similarity": 0.9972192645072937,
        "body": "from collections import Counter\nfrom itertools import combinations\n\n    suspects = set()\n    for x, y in coders:\n        suspects.add(x)\n        suspects.add(y)\n    \n    valid_sets = 0\n    for a, b in combinations(suspects, 2):\n        if sum(1 for x, y in coders if (a == x or a == y) or (b == x or b == y)) >= p:\n            valid_sets += 1\n    \n    return valid_sets\n\n# Read input\nn, p = map(int, input().split())\ncoders = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(count_suspect_sets(n, p, coders))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946094155311584,
            0.9969560503959656,
            0.9951825737953186,
            0.9960847496986389,
            0.9969234466552734,
            0.9931685924530029,
            0.9966665506362915,
            0.9965676069259644,
            0.9929875731468201,
            0.9971347451210022,
            0.9972192645072937,
            0.9967405200004578,
            0.9967447519302368,
            0.9939320087432861,
            0.9962959289550781,
            0.9951638579368591,
            0.9972008466720581,
            0.9962519407272339,
            0.9962471723556519,
            0.9957458972930908
        ]
    },
    "3996": {
        "similarity": 0.9965966939926147,
        "body": "from fractions import Fraction\nimport sys\n\nMOD = 1_000_000_007\n\n    return x * y // Fraction(x, y).denominator\n\n    k = int(input())\n    a = list(map(int, input().split()))\n    \n    result = Fraction(1)\n    \n    for num in a:\n        result *= Fraction(num, 2**num)\n        result = result.limit_denominator(MOD)\n    \n    p = result.numerator % MOD\n    q = result.denominator % MOD\n    \n    print(f\"{p}/{q}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963330030441284,
            0.9944786429405212,
            0.9941694140434265,
            0.9958224892616272,
            0.9960174560546875,
            0.9952647686004639,
            0.9962828755378723,
            0.9923458099365234,
            0.996437668800354,
            0.996337890625,
            0.9954522848129272,
            0.9948441386222839,
            0.9954858422279358,
            0.9955278038978577,
            0.9924336671829224,
            0.9932648539543152,
            0.9954833984375,
            0.9960551857948303,
            0.9965966939926147,
            0.9938203692436218
        ]
    },
    "3276": {
        "similarity": 0.9958696961402893,
        "body": "    for i in range(N - 2):\n        for j in range(M - 2):\n            if not all(art[x][y] == 'W' for x in range(i, i + 3) for y in range(j, j + 3)):\n                continue\n            new_art = [list(row) for row in art]\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    new_art[x][y] = 'R'\n            if all(new_art[x][y] == (art[x][y] if art[x][y] != 'W' else 'R') for x in range(N) for y in range(M)):\n                return \"YES\"\n    return \"NO\"\n\n# Read input\nN, M = map(int, input().split())\nart = [input() for _ in range(N)]\n\n# Output result\nprint(can_reproduce_art(N, M, art))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947054982185364,
            0.9958696961402893,
            0.9932926893234253,
            0.9936320781707764,
            0.9949798583984375,
            0.9946060180664062,
            0.9953862428665161,
            0.9940813779830933,
            0.9935750365257263,
            0.9941352009773254,
            0.9946698546409607,
            0.9956386089324951,
            0.9952083230018616,
            0.9957060813903809,
            0.9944546222686768,
            0.9930942058563232,
            0.9830045104026794,
            0.992201566696167,
            0.9938694834709167,
            0.9939124584197998
        ]
    },
    "3834": {
        "similarity": 0.9966054558753967,
        "body": "    changes = 0\n    \n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                count = 1\n                for x in range(i + 1, n):\n                    if a[x][j] != 1:\n                        break\n                    count += 1\n                for y in range(j + 1, m):\n                    if a[i][y] != 1 or (x < n and a[x][y] != 1):\n                        break\n                    count += 1\n                if count < i * j:\n                    changes += (i * j - count)\n    \n    return changes if changes <= k else -1\n\n# Read input\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n# Print result\nprint(min_changes_to_rectangle(n, m, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952701926231384,
            0.9953933358192444,
            0.9929013848304749,
            0.9962850213050842,
            0.9965443015098572,
            0.9933945536613464,
            0.9947933554649353,
            0.9927836060523987,
            0.9955102801322937,
            0.9960272908210754,
            0.9932066202163696,
            0.9946349263191223,
            0.9964320659637451,
            0.9954173564910889,
            0.9960446953773499,
            0.9926766157150269,
            0.9966054558753967,
            0.9924945831298828,
            0.9963018298149109,
            0.9960900545120239
        ]
    },
    "3012": {
        "similarity": 0.9970405101776123,
        "body": "import sys\n\nMOD = 10**9 + 7\n\n    # Initialize dp table\n    dp = [[[0, 0] for _ in range(3)] for _ in range(3)]\n    dp[0][0][0] = a11\n    dp[1][0][0] = a12\n    dp[0][1][0] = a21\n    dp[1][1][0] = a22\n\n    # Fill dp table\n    for _ in range(1, N):\n        new_dp = [[[0, 0] for _ in range(3)] for _ in range(3)]\n        for i in range(3):\n            for j in range(3):\n                if i == j:\n                    continue\n                if (i, j) == (0, 1):\n                    # A attacks successfully\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a21 % MOD\n                elif (i, j) == (1, 0):\n                    # A attacks successfully\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a22 % MOD\n                elif (i, j) == (0, 2):\n                    # A attacks successfully\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a11 % MOD\n                elif (i, j) == (2, 0):\n                    # A attacks successfully\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a12 % MOD\n                elif (i, j) == (1, 2):\n                    # A fails to defend\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a11 % MOD\n                elif (i, j) == (2, 1):\n                    # A fails to defend\n                    new_dp[i][j][0] = dp[j][i][0]\n                    new_dp[i][j][1] = (dp[j][i][0] + dp[j][i][1]) * a12 % MOD\n\n        dp = new_dp\n\n    # Sum up all valid sequences\n    result = 0\n    for i in range(3):\n        for j in range(3):\n            if i != j:\n                result = (result + dp[i][j][0] + dp[i][j][1]) % MOD\n\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    a11 = int(data[0])\n    a12 = int(data[1])\n    a21 = int(data[2])\n    a22 = int(data[3])\n    N = int(data[4])\n\n    print(count_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968349933624268,
            0.9965821504592896,
            0.9960209727287292,
            0.9954418540000916,
            0.9969584941864014,
            0.9953091144561768,
            0.9970126152038574,
            0.9965286254882812,
            0.9952637553215027,
            0.9943345785140991,
            0.9937999248504639,
            0.9957761168479919,
            0.9966856241226196,
            0.9951848387718201,
            0.9967573285102844,
            0.9970405101776123,
            0.9969010949134827,
            0.9964529275894165,
            0.9964674115180969,
            0.9966339468955994
        ]
    },
    "3745": {
        "similarity": 0.9976217150688171,
        "body": "import sys\n\n    if n == 1:\n        return \"Yes\\na\"\n    \n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph can be formed by a string of 'a', 'b', and 'c'\n        visited[node] = True\n        node_char = ord(char) - ord('a')\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if (ord(graph[node][0]) - ord('a') != node_char + 1 and \n                    ord(graph[node][0]) - ord('a') != node_char - 1):\n                    return False\n                if not dfs(neighbor, node, chr(node_char + 1)):\n                    return False\n            elif neighbor == parent:\n                continue\n            else:\n                return False\n        \n        return True\n    \n    visited = [False] * (n + 1)\n    if not dfs(1, -1, 'a'):\n        return \"No\"\n    \n    # Construct the string\n    result = [''] * n\n        node_char = ord(graph[node][0]) - ord('a')\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                result[neighbor-1] = chr(node_char + 1)\n                build_string(neighbor, node)\n    \n    build_string(1, -1)\n    return \"Yes\\n\" + ''.join(result)\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(can_form_string(n, m, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970988035202026,
            0.9971821308135986,
            0.9970958232879639,
            0.9933304190635681,
            0.9974163770675659,
            0.997059166431427,
            0.9965154528617859,
            0.9970807433128357,
            0.9976217150688171,
            0.9971884489059448,
            0.9973521828651428,
            0.996985673904419,
            0.9973459839820862,
            0.9972627758979797,
            0.9969269633293152,
            0.9968770742416382,
            0.9970752596855164,
            0.9968588948249817,
            0.993735671043396,
            0.9971628785133362
        ]
    },
    "3028": {
        "similarity": 0.9976142048835754,
        "body": "    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                moves.append((i + 1) * m + j + 1)\n                for k in range(m):\n                    board[i][k] = (board[i][k] + 1) % p\n                for k in range(n):\n                    board[k][j] = (board[k][j] + 1) % p\n    if all(all(cell == p for cell in row) for row in board):\n        return len(moves), moves\n    else:\n        return -1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    p = int(data[2])\n    board = []\n    index = 3\n    for i in range(n):\n        row = [int(data[index + j]) for j in range(m)]\n        board.append(row)\n        index += m\n    \n    result = find_winning_sequence(n, m, p, board)\n    if isinstance(result, int):\n        print(result)\n    else:\n        k, moves = result\n        print(k)\n        print(' '.join(map(str, moves)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972135424613953,
            0.9969519376754761,
            0.9962617754936218,
            0.9973798394203186,
            0.9951874613761902,
            0.996568500995636,
            0.996168851852417,
            0.9974684715270996,
            0.9963233470916748,
            0.9971154928207397,
            0.9908927083015442,
            0.9973433613777161,
            0.9976142048835754,
            0.9968740344047546,
            0.9971526265144348,
            0.9971641898155212,
            0.9963018298149109,
            0.9969326853752136,
            0.9969795942306519,
            0.9968414306640625
        ]
    },
    "3196": {
        "similarity": 0.9975702166557312,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for a, b in roads:\n        graph[a].append(b)\n    \n    queue = deque([(1, 1)])\n    visited = set()\n    routes = 0\n    \n    while queue:\n        current, count = queue.popleft()\n        if current == n:\n            routes += count\n        else:\n            for neighbor in graph[current]:\n                if (neighbor, count) not in visited:\n                    visited.add((neighbor, count))\n                    queue.append((neighbor, count + 1))\n    \n    return routes % 1000000009 if routes < float('inf') else 'inf'\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    result = count_routes(n, m, roads)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975702166557312,
            0.9972333312034607,
            0.9956832528114319,
            0.9955356121063232,
            0.9959626793861389,
            0.994338870048523,
            0.9964122772216797,
            0.9943598508834839,
            0.997053325176239,
            0.9971630573272705,
            0.9943017363548279,
            0.994529128074646,
            0.9964925050735474,
            0.9969915151596069,
            0.9970849752426147,
            0.9956218600273132,
            0.9963790774345398,
            0.9969679117202759,
            0.9971819519996643,
            0.9971439838409424
        ]
    },
    "3405": {
        "similarity": 0.9982167482376099,
        "body": "import sys\n\n    X_str = str(X)\n    multiplier = int(X_str.replace('.', ''))\n    results = []\n    \n    for i in range(1, 10**7):\n        number = i * multiplier\n        if str(number).endswith(str(i)):\n            results.append(number)\n    \n    return results\n\nif __name__ == \"__main__\":\n    X = float(input())\n    tricks = find_multiplication_tricks(X)\n    if tricks:\n        for trick in tricks:\n            print(trick)\n    else:\n        print(\"No solution\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974499940872192,
            0.9976754784584045,
            0.9974457621574402,
            0.9980508685112,
            0.9973653554916382,
            0.9975196719169617,
            0.9980635643005371,
            0.997151255607605,
            0.9968622922897339,
            0.9982167482376099,
            0.9977758526802063,
            0.996540904045105,
            0.9982019662857056,
            0.9972682595252991,
            0.997165858745575,
            0.9974623322486877,
            0.9957454204559326,
            0.9977840781211853,
            0.9979086518287659,
            0.997763991355896
        ]
    },
    "3126": {
        "similarity": 0.997715413570404,
        "body": "import sys\n\n    frogs.sort()\n    n = len(frogs)\n    min_jumps = float('inf')\n    \n    for i in range(n + 1):\n        left_frogs = frogs[:i]\n        right_frogs = frogs[i:]\n        \n        left_sum = sum(abs(p - tower_position) for p in left_frogs)\n        right_sum = sum(abs(p - tower_position) for p in right_frogs)\n        \n        total_jumps = (sum(range(1, i + 1)) if i > 0 else 0) + left_sum + right_sum\n        min_jumps = min(min_jumps, total_jumps)\n    \n    return min_jumps\n\n    input_lines = sys.stdin.readlines()\n    n, t = map(int, input_lines[0].split())\n    frogs = list(map(int, input_lines[1].split()))\n    C = int(input_lines[2])\n    changes = input_lines[3:C + 3]\n    \n    results = []\n    \n    for change in changes:\n        if change.startswith('+'):\n            a = int(change.split()[1])\n            frogs.append(a)\n        elif change.startswith('-'):\n            a = int(change.split()[1])\n            frogs.remove(a)\n        else:\n            t = int(change.split()[1])\n        \n        min_jumps = calculate_min_jumps(frogs, t)\n        results.append(min_jumps)\n    \n    for result in results:\n        print(result)\n\nprocess_changes()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966673851013184,
            0.9970927834510803,
            0.9973108172416687,
            0.9966779947280884,
            0.9970787763595581,
            0.9976957440376282,
            0.9963842034339905,
            0.9975013732910156,
            0.9974595904350281,
            0.997715413570404,
            0.9969636797904968,
            0.9973071217536926,
            0.9965877532958984,
            0.9968059062957764,
            0.9970964193344116,
            0.9974260926246643,
            0.9969919919967651,
            0.996465802192688,
            0.9973518252372742,
            0.9971361756324768
        ]
    },
    "3279": {
        "similarity": 0.9968282580375671,
        "body": "    n = int(input())\n    rows = [list(map(int, input().split())) for _ in range(n)]\n    cols = [list(map(int, input().split())) for _ in range(n)]\n\n        for i in range(n):\n            groups = 0\n            current_group = 0\n            for j in range(n + 1):\n                if board[i][j] == 1:\n                    current_group += 1\n                else:\n                    if current_group > 0:\n                        groups += 1\n                        current_group = 0\n            if rows[i] != [groups]:\n                return False\n        for j in range(n):\n            groups = 0\n            current_group = 0\n            for i in range(n + 1):\n                if board[i][j] == 1:\n                    current_group += 1\n                else:\n                    if current_group > 0:\n                        groups += 1\n                        current_group = 0\n            if cols[j] != [groups]:\n                return False\n        return True\n\n        if row == n:\n            return is_valid(board)\n        if col == n:\n            return backtrack(board, row + 1, 0)\n        if board[row][col] == 0:\n            for new_val in [0, 1]:\n                board[row][col] = new_val\n                if backtrack(board, row, col + 1):\n                    return True\n            board[row][col] = 0\n        else:\n            if backtrack(board, row, col + 1):\n                return True\n        return False\n\n    initial_board = [[0 for _ in range(n)] for _ in range(n)]\n    backtrack(initial_board)\n    for row in initial_board:\n        print(''.join(map(str, row)))\n\nbar_code()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952791333198547,
            0.9955447316169739,
            0.9962192177772522,
            0.9951773285865784,
            0.9955880045890808,
            0.9967952370643616,
            0.9932851195335388,
            0.99515300989151,
            0.9966979622840881,
            0.9950563311576843,
            0.996427059173584,
            0.9960746765136719,
            0.9968282580375671,
            0.9937112927436829,
            0.9953500628471375,
            0.9964847564697266,
            0.9950366020202637,
            0.9959125518798828,
            0.9958673715591431,
            0.9963052868843079
        ]
    },
    "3599": {
        "similarity": 0.9982566833496094,
        "body": "import sys\n\n    remaining_time = T\n    on_stage = [0] * N\n    \n    for i in range(N):\n        break_length = breaks[i]\n        if remaining_time >= break_length:\n            on_stage[i] = remaining_time - break_length\n            remaining_time -= break_length\n    \n    return on_stage\n\n# Read input from stdin\nT, N = map(int, input().split())\nbreaks = list(map(int, input().split()))\n\n# Get the result\nresult = schedule_breaks(T, N, breaks)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980437755584717,
            0.9971917867660522,
            0.9971558451652527,
            0.9966556429862976,
            0.9939504265785217,
            0.9980380535125732,
            0.9979924559593201,
            0.9959871172904968,
            0.997817873954773,
            0.9982191324234009,
            0.9967319965362549,
            0.9978112578392029,
            0.9978634715080261,
            0.9981683492660522,
            0.9967948794364929,
            0.9972459673881531,
            0.9980745911598206,
            0.9972459673881531,
            0.9974998831748962,
            0.9982566833496094
        ]
    },
    "3687": {
        "similarity": 0.9974451661109924,
        "body": "    for _ in range(n):\n        transfer_limit, *sensor_data = map(int, input().split())\n        for i in range(s):\n            if sensor_data[i] > 0:\n                if sensor_queues[i] == -1 or sensor_queues[i] + sensor_data[i] <= queue_sizes[sensor_queues[i]]:\n                    sensor_queues[i] += sensor_data[i]\n                else:\n                    return \"impossible\"\n    for queue in sensor_queues:\n        if queue != -1 and queue > 0:\n            return \"impossible\"\n    return \"possible\"\n\nif __name__ == \"__main__\":\n    n, q, s = map(int, input().split())\n    sensor_queues = list(map(int, input().split()))\n    queue_sizes = list(map(int, input().split()))\n    downlink_windows = [list(map(int, input().split())) for _ in range(n)]\n    print(can_transfer_all_data(n, q, s, sensor_queues, queue_sizes, downlink_windows))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965420961380005,
            0.9950318932533264,
            0.9974099397659302,
            0.9963089823722839,
            0.997031569480896,
            0.9971038699150085,
            0.9974451661109924,
            0.9973118305206299,
            0.9965959787368774,
            0.9972584247589111,
            0.99721759557724,
            0.9960873126983643,
            0.997360348701477,
            0.995671808719635,
            0.9970629811286926,
            0.9973825216293335,
            0.99651700258255,
            0.9967113137245178,
            0.9953595399856567,
            0.995163083076477
        ]
    },
    "3864": {
        "similarity": 0.9948006868362427,
        "body": "    MOD = 998244353\n    \n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for length in range(2, n + 1):\n        new_dp = [0] * (length + 1)\n        for i in range(length):\n            if i == 0:\n                new_dp[i + 1] = dp[i]\n            elif i == length - 1:\n                new_dp[i + 1] = dp[i] + dp[i - 1]\n            else:\n                new_dp[i + 1] = (dp[i] + dp[i - 1]) * 2\n        dp = [x % MOD for x in new_dp]\n    \n    result = sum(dp) // n\n    return result % MOD\n\nn = int(input())\nfor i in range(1, n + 1):\n    print(expected_black_stones(i))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936270713806152,
            0.9909292459487915,
            0.9947236776351929,
            0.9914556741714478,
            0.992966890335083,
            0.9908201098442078,
            0.9878331422805786,
            0.9942760467529297,
            0.991058349609375,
            0.9934903383255005,
            0.9910491108894348,
            0.9770792126655579,
            0.9945616722106934,
            0.9938549399375916,
            0.9934403300285339,
            0.9948006868362427,
            0.9918426871299744,
            0.993696928024292,
            0.9943923950195312,
            0.9890952110290527
        ]
    },
    "3504": {
        "similarity": 0.9960805177688599,
        "body": "import sys\n\n    results = []\n    for drop in drops:\n        x, y = drop\n        disintegrated_y = 0\n        for sensor in sensors:\n            x1, x2, sy = sensor\n            if x1 <= x <= x2 and y == sy:\n                disintegrated_y = max(disintegrated_y, sy)\n        results.append(disintegrated_y)\n    return results\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    D = int(data[index])\n    S = int(data[index + 1])\n    index += 2\n    \n    drops = []\n    for _ in range(D):\n        x = int(data[index])\n        y = int(data[index + 1])\n        drops.append((x, y))\n        index += 2\n    \n    sensors = []\n    for _ in range(S):\n        x1 = int(data[index])\n        x2 = int(data[index + 1])\n        sy = int(data[index + 2])\n        sensors.append((x1, x2, sy))\n        index += 3\n    \n    results = find_disintegration_y(drops, sensors)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958698749542236,
            0.9952842593193054,
            0.9943973422050476,
            0.9959965944290161,
            0.9943349957466125,
            0.9959198832511902,
            0.994635820388794,
            0.9916552305221558,
            0.995715320110321,
            0.9950599670410156,
            0.9951761364936829,
            0.9942554831504822,
            0.995125412940979,
            0.988866925239563,
            0.9960805177688599,
            0.9959031939506531,
            0.9959959983825684,
            0.993475079536438,
            0.9951145648956299,
            0.9933335185050964
        ]
    },
    "3451": {
        "similarity": 0.9974567890167236,
        "body": "    if k == 0:\n        return sum(costs) if not is_balanced(seq) else '?'\n    \n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n    \n    min_effort = float('inf')\n    \n    for i in range(n):\n        new_seq = seq[:i] + ('(' if seq[i] == ')' else ')') + seq[i+1:]\n        if is_balanced(new_seq) and k >= 1:\n            effort = sum(costs[:i]) + costs[i] * (-1) + sum(costs[i+1:])\n            min_effort = min(min_effort, effort)\n    \n    return '?' if min_effort == float('inf') else min_effort\n\n# Read input\nn, k = map(int, input().split())\nseq = input()\ncosts = [int(input()) for _ in range(n)]\n\n# Output result\nprint(min_effort_to_impossible(n, k, seq, costs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968422651290894,
            0.9969359040260315,
            0.9955775737762451,
            0.9966915845870972,
            0.9960616230964661,
            0.9970321655273438,
            0.9969497323036194,
            0.9966659545898438,
            0.9970445036888123,
            0.9962225556373596,
            0.9971979856491089,
            0.9959377646446228,
            0.9974567890167236,
            0.9956952333450317,
            0.9962065815925598,
            0.9955163598060608,
            0.9972469210624695,
            0.9966222047805786,
            0.9967249631881714,
            0.9963605999946594
        ]
    },
    "3156": {
        "similarity": 0.9980131387710571,
        "body": "from collections import defaultdict, deque\n\n    store_inventory = defaultdict(list)\n    for store_id, item in stores:\n        store_inventory[store_id].append(item)\n\n    visited = [False] * len(store_inventory)\n    path = []\n    \n        if len(current_path) == len(bought_items):\n            path.append(current_path[:])\n            return True\n        for next_item in store_inventory[current_store]:\n            if next_item == bought_items[len(current_path)]:\n                current_path.append(next_item)\n                if dfs(current_store + 1, current_path):\n                    return True\n                current_path.pop()\n        return False\n\n    for start_store, _ in stores:\n        if dfs(start_store, []):\n            break\n    \n    if len(path) == 0:\n        print(\"impossible\")\n    elif len(path) == 1:\n        print(\"unique\")\n    else:\n        print(\"ambiguous\")\n\n# Read input\nn = int(input())\nk = int(input())\nstores = []\nfor _ in range(k):\n    store_id, item = map(str, input().split())\n    stores.append((int(store_id), item))\n\nm = int(input())\nbought_items = [input().strip() for _ in range(m)]\n\n# Find the path\nfind_path(stores, bought_items)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976646900177002,
            0.9962186217308044,
            0.9980131387710571,
            0.9974203705787659,
            0.9969859719276428,
            0.99652099609375,
            0.9951243996620178,
            0.9971793293952942,
            0.996612548828125,
            0.9972913861274719,
            0.9975330829620361,
            0.9968801736831665,
            0.9971970319747925,
            0.9972582459449768,
            0.9965153932571411,
            0.9976359009742737,
            0.9974867105484009,
            0.9971458315849304,
            0.9969618916511536,
            0.9971098899841309
        ]
    },
    "3697": {
        "similarity": 0.9980512261390686,
        "body": "import sys\n\n    vote_counts = [0] * (n + 1)\n    last_votes = [-1] * (n + 1)\n    \n    for j in range(a):\n        candidate = votes[j]\n        vote_counts[candidate] += 1\n        if last_votes[candidate] < j:\n            last_votes[candidate] = j\n    \n    sorted_candidates = sorted(range(1, n + 1), key=lambda x: (-vote_counts[x], -last_votes[x]))\n    \n    outcomes = [0] * (n + 1)\n    \n    guaranteed_elected = sorted_candidates[:k]\n    for candidate in range(1, n + 1):\n        if candidate in guaranteed_elected:\n            outcomes[candidate] = 1\n        elif any(vote_counts[sorted_candidates[i]] < vote_counts[candidate] and last_votes[sorted_candidates[i]] < j for i in range(k) for j in range(m)):\n            outcomes[candidate] = 2\n        else:\n            outcomes[candidate] = 3\n    \n    return outcomes[1:]\n\nif __name__ == \"__main__\":\n    n, k, m, a = map(int, input().split())\n    votes = list(map(int, input().split()))\n    results = determine_outcomes(n, k, m, a, votes)\n    print(\" \".join(map(str, results)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975023865699768,
            0.9967886209487915,
            0.9971020221710205,
            0.9973258972167969,
            0.9967826008796692,
            0.9967677593231201,
            0.9975337982177734,
            0.9972356557846069,
            0.9975262880325317,
            0.9972038269042969,
            0.9979050159454346,
            0.995103120803833,
            0.9967472553253174,
            0.9980512261390686,
            0.9963306784629822,
            0.9972902536392212,
            0.9972649812698364,
            0.9978034496307373,
            0.997829258441925,
            0.9979337453842163
        ]
    },
    "3647": {
        "similarity": 0.9983378052711487,
        "body": "import sys\n\n    C, R = len(maze[0]), len(maze)\n    moves = [[-1] * C for _ in range(R)]\n    \n        return 0 <= x < C and 0 <= y < R\n    \n    queue = []\n    goal_pos = None\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    for y in range(R):\n        for x in range(C):\n            if maze[y][x] == 'M':\n                goal_pos = (y, x)\n            elif maze[y][x] == '.':\n                queue.append((y, x, 0))\n    \n    while queue:\n        cy, cx, cmoves = queue.pop(0)\n        \n        for dy, dx in directions:\n            ny, nx = cy + dy, cx + dx\n            if is_valid(ny, nx):\n                nchar = maze[ny][nx]\n                if moves[ny][nx] == -1 or moves[ny][nx] > cmoves + 1:\n                    moves[ny][nx] = cmoves + 1\n                    if nchar != '#':\n                        queue.append((ny, nx, cmoves + 1))\n    \n    return moves\n\n# Read input\nC, R = map(int, input().split())\nmaze = [input().strip() for _ in range(R)]\n\n# Compute and print result\nresult = min_moves_to_goal(maze)\nfor row in result:\n    print(' '.join(map(str, row)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983378052711487,
            0.9972168803215027,
            0.9979063272476196,
            0.9974193572998047,
            0.9966163635253906,
            0.9983099102973938,
            0.9982918500900269,
            0.9975152611732483,
            0.9980012774467468,
            0.9982388019561768,
            0.9976893067359924,
            0.9968388080596924,
            0.9978906512260437,
            0.9971767067909241,
            0.9978925585746765,
            0.995989978313446,
            0.9976208209991455,
            0.9957031607627869,
            0.9970566630363464,
            0.9981749653816223
        ]
    },
    "3699": {
        "similarity": 0.9965695738792419,
        "body": "import sys\nimport math\n\n    # Read input values\n    a_x, a_y, b_x, b_y, t_x, t_y = map(int, input().split())\n    n = int(input())\n    bottles = []\n    \n    for _ in range(n):\n        x_i, y_i = map(int, input().split())\n        bottles.append((x_i, y_i))\n    \n    # Calculate the total distance using a simple strategy\n    # Each person takes half of the bottles and walks to the recycling bin\n    \n    adil_distance = 0\n    bera_distance = 0\n    \n    for i in range(n):\n        if i % 2 == 0:\n            adil_distance += math.sqrt((bottles[i][0] - a_x)**2 + (bottles[i][1] - a_y)**2)\n            adil_distance += abs(t_x - a_x) + abs(t_y - a_y)\n        else:\n            bera_distance += math.sqrt((bottles[i][0] - b_x)**2 + (bottles[i][1] - b_y)**2)\n            bera_distance += abs(t_x - b_x) + abs(t_y - b_y)\n    \n    # Print the total distance\n    print(adil_distance + bera_distance)\n\ncalculate_min_distance()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995395839214325,
            0.995763897895813,
            0.9953022003173828,
            0.995039701461792,
            0.9934118390083313,
            0.9962294697761536,
            0.9952264428138733,
            0.9960184693336487,
            0.9964857697486877,
            0.9951613545417786,
            0.9959696531295776,
            0.9955618977546692,
            0.9956288933753967,
            0.9950957298278809,
            0.9945899844169617,
            0.9962125420570374,
            0.9965695738792419,
            0.9960185885429382,
            0.9952183961868286,
            0.9961248636245728
        ]
    },
    "3145": {
        "similarity": 0.99737149477005,
        "body": "import sys\n\n    count = 0\n    for num in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(num)) and num % X == 0:\n            count += 1\n    return count\n\nif __name__ == \"__main__\":\n    X, A, B = map(int, input().split())\n    allowed_digits = set(input().strip())\n    print(count_multiples(X, A, B, allowed_digits))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972661733627319,
            0.9966474771499634,
            0.9955272674560547,
            0.9960564374923706,
            0.9968200325965881,
            0.9952244162559509,
            0.9964307546615601,
            0.9970267415046692,
            0.9964244365692139,
            0.9964157938957214,
            0.99737149477005,
            0.9954193830490112,
            0.9962264895439148,
            0.9964166879653931,
            0.9966896772384644,
            0.9964041709899902,
            0.9941777586936951,
            0.9962430596351624,
            0.997269868850708,
            0.9965390563011169
        ]
    },
    "3795": {
        "similarity": 0.996953547000885,
        "body": "    min_r = n\n    for e_bills in range(n // e + 1):\n        rub_from_euros = e_bills * e\n        remaining_rub = n - rub_from_euros\n        d_bills = remaining_rub // d\n        total_r = rub_from_euros + (remaining_rub % d)\n        if total_r < min_r:\n            min_r = total_r\n    return min_r\n\n# Read input from stdin\nn = int(input())\nd = int(input())\ne = int(input())\n\n# Print the result\nprint(min_rubles(n, d, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953941702842712,
            0.994093656539917,
            0.996559739112854,
            0.9954311847686768,
            0.9962586164474487,
            0.9962677359580994,
            0.9966549277305603,
            0.9959056377410889,
            0.9955055713653564,
            0.9951733946800232,
            0.9941869974136353,
            0.996953547000885,
            0.992817223072052,
            0.9942348003387451,
            0.9965965151786804,
            0.9969156980514526,
            0.9966722130775452,
            0.995085597038269,
            0.993075430393219,
            0.9958701133728027
        ]
    },
    "3353": {
        "similarity": 0.9975321888923645,
        "body": "import sys\n\n    if P == 0:\n        return 0\n    \n    # Create adjacency list for graph\n    graph = [[] for _ in range(R + 1)]\n    for log in logs:\n        e1, e2 = log\n        graph[e1].append(e2)\n        graph[e2].append(e1)\n    \n    left_bank = [-2]\n    right_bank = [-1]\n    visited = set([-2])\n    \n        nonlocal min_time\n        if current == -1:\n            min_time = max(min_time, steps)\n            return\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                dfs(neighbor, steps + 1)\n                visited.remove(neighbor)\n    \n    # Try to find a path from left_bank to right_bank using DFS\n    min_time = float('inf')\n    for person in range(P):\n        if -2 not in graph[person]:\n            print(person)\n            sys.exit()\n        visited.add(-2)\n        dfs(person, 0)\n        visited.remove(-2)\n    \n    return min_time\n\n# Read input\nP, R, L = map(int, input().split())\nlogs = [tuple(map(int, input().split())) for _ in range(L)]\n\n# Output result\nprint(min_time_to_cross(P, R, L, logs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966395497322083,
            0.997519850730896,
            0.9971125721931458,
            0.9972660541534424,
            0.9975321888923645,
            0.9968439340591431,
            0.9970494508743286,
            0.9972447752952576,
            0.9972365498542786,
            0.9974530935287476,
            0.9964913725852966,
            0.9969369769096375,
            0.9965227246284485,
            0.9961318969726562,
            0.9975228905677795,
            0.9969808459281921,
            0.9972363710403442,
            0.9966882467269897,
            0.9969125390052795,
            0.9974070191383362
        ]
    },
    "3065": {
        "similarity": 0.9974170327186584,
        "body": "import sys\nfrom collections import deque\n\n    start = walk[0]\n    end = walk[-1]\n    \n        queue = deque([(start_node, 0)])\n        visited = {start_node}\n        while queue:\n            current, time = queue.popleft()\n            if current == end_node and time == L - 1:\n                return True\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, time + 1))\n        return False\n    \n    chance = bfs(start, end) * 0.5 ** (L - 2)\n    return chance\n\nif __name__ == \"__main__\":\n    N = int(input())\n    L = int(input())\n    walk = list(map(int, input().split()))\n    graph = {}\n    \n    for _ in range(N):\n        node_info = list(map(int, input().split()))\n        node = node_info[0]\n        neighbors = node_info[1:]\n        graph[node] = neighbors\n    \n    result = calculate_chances(N, L, walk, graph)\n    print(f\"{result:.6f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.996905505657196,
            0.996671199798584,
            0.9950366616249084,
            0.9965987801551819,
            0.9971362948417664,
            0.9966036081314087,
            0.9964053630828857,
            0.9966891407966614,
            0.9970126748085022,
            0.9966623187065125,
            0.9968616962432861,
            0.9948937296867371,
            0.9971705079078674,
            0.9967942833900452,
            0.9971567392349243,
            0.997208833694458,
            0.9959666728973389,
            0.9974170327186584,
            0.9934204816818237,
            0.9965911507606506
        ]
    },
    "3250": {
        "similarity": 0.9952932000160217,
        "body": "    if b <= 1 or d <= 1:\n        return False\n    m = 1\n    while True:\n        f = 0\n        sign = 1\n        for i in range(m - 1, len(str(n)), m * 2):\n            a = int(str(n)[i:i+m])\n            if a == 0:\n                break\n            f += sign * a\n            sign *= -1\n        if f % d != 0 and n % d == 0:\n            return False\n        if f % d == 0 and n % d != 0:\n            return False\n        m += 1\n\nn = input().strip()\nb, d = map(int, n.split())\nprint(\"yes\" if is_valid_divisibility_hack(b, d) else \"no\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925699830055237,
            0.9908802509307861,
            0.9944157004356384,
            0.9946809411048889,
            0.9947038888931274,
            0.9923336505889893,
            0.9922102093696594,
            0.9926806092262268,
            0.9927749633789062,
            0.9888724088668823,
            0.9912694692611694,
            0.9918181896209717,
            0.9915169477462769,
            0.995043933391571,
            0.99309241771698,
            0.9944477081298828,
            0.9952574372291565,
            0.9952932000160217,
            0.9884573221206665,
            0.9945510029792786
        ]
    },
    "3306": {
        "similarity": 0.9968898296356201,
        "body": "import sys\n\n    detectors.sort(key=lambda x: x[0])\n    total_calls = 0\n    \n    for i in range(n - 1):\n        p1, c1 = detectors[i]\n        p2, c2 = detectors[i + 1]\n        total_calls += max(0, c1 + c2 - detectors[i + 1][0] + p1)\n    \n    return total_calls\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\ndetectors = []\n\nfor i in range(n):\n    p = int(data[2 + 2 * i]) - 1\n    c = int(data[3 + 2 * i])\n    detectors.append((p, c))\n\nprint(min_phone_calls(n, m, detectors))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941397309303284,
            0.992075502872467,
            0.9960989952087402,
            0.9960960745811462,
            0.9957486987113953,
            0.996225893497467,
            0.9963082075119019,
            0.9962359070777893,
            0.9931639432907104,
            0.9949575662612915,
            0.9961421489715576,
            0.9952461123466492,
            0.9959343671798706,
            0.9959071278572083,
            0.9968898296356201,
            0.9951398968696594,
            0.9958793520927429,
            0.9957696795463562,
            0.9957131147384644,
            0.9964577555656433
        ]
    },
    "3970": {
        "similarity": 0.9979453086853027,
        "body": "import sys\n\n    a.sort()\n    dp = [1] * n\n    max_size = 1\n    \n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0 and a[i] // a[j] == k:\n                break\n        else:\n            dp[i] = dp[j] + 1\n            max_size = max(max_size, dp[i])\n    \n    print(max_size)\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\nlargest_k_multiple_free_subset(n, k, a)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977269768714905,
            0.9975429177284241,
            0.9964166283607483,
            0.9966930747032166,
            0.9968697428703308,
            0.9976099729537964,
            0.9967249631881714,
            0.9957327842712402,
            0.9977216124534607,
            0.9967698454856873,
            0.9979453086853027,
            0.9971970915794373,
            0.9978561401367188,
            0.9977445006370544,
            0.9974533915519714,
            0.9964081645011902,
            0.9971030354499817,
            0.9972889423370361,
            0.9974952340126038,
            0.9972597360610962
        ]
    },
    "3655": {
        "similarity": 0.9977084994316101,
        "body": "    robot_w, robot_h = map(int, input().split())\n    robot_image = [list(map(int, input().split())) for _ in range(robot_h)]\n    \n    floor_w, floor_h = map(int, input().split())\n    floor_image = [list(map(int, input().split())) for _ in range(floor_h)]\n    \n    max_matches = 0\n    candidate_locations = []\n    \n    for x in range(floor_w - robot_w + 1):\n        for y in range(floor_h - robot_h + 1):\n            matches = sum(\n                (robot_image[i][j] == floor_image[y+i][x+j]) \n                for i in range(robot_h) \n                for j in range(robot_w)\n            )\n            if matches > max_matches:\n                max_matches = matches\n                candidate_locations = [(x, y)]\n            elif matches == max_matches:\n                candidate_locations.append((x, y))\n    \n    for x, y in sorted(candidate_locations):\n        print(f\"{x} {y}\")\n\nfind_candidate_locations()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977084994316101,
            0.9971792101860046,
            0.9955363869667053,
            0.9970689415931702,
            0.9972423911094666,
            0.9965637922286987,
            0.9966645836830139,
            0.9971269369125366,
            0.9974120259284973,
            0.9973160624504089,
            0.9972128868103027,
            0.9974510073661804,
            0.9970430135726929,
            0.9965783953666687,
            0.9970446228981018,
            0.9959624409675598,
            0.9973779916763306,
            0.9969813823699951,
            0.9976770281791687,
            0.9967683553695679
        ]
    },
    "3589": {
        "similarity": 0.9982502460479736,
        "body": "import sys\n\n    product = 1\n    while n > 0:\n        digit = n % 10\n        if digit != 0:\n            product *= digit\n        n //= 10\n    return product\n\n    distribution = [0] * 9\n    for x in range(L, R + 1):\n        result_digit = product_of_nonzero_digits(x)\n        distribution[result_digit - 1] += 1\n    return distribution\n\nL, R = map(int, input().split())\nresult = count_distribution(L, R)\nprint(*result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939458966255188,
            0.9976504445075989,
            0.9961377382278442,
            0.9980360269546509,
            0.9980889558792114,
            0.9981300830841064,
            0.9982502460479736,
            0.9978442788124084,
            0.9979848265647888,
            0.9979493021965027,
            0.9976739287376404,
            0.9977983236312866,
            0.9977548718452454,
            0.9967088103294373,
            0.9978376030921936,
            0.9978894591331482,
            0.9978179931640625,
            0.9976614117622375,
            0.9977735280990601,
            0.9977957010269165
        ]
    },
    "3257": {
        "similarity": 0.9976997375488281,
        "body": "import math\n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1.0\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return round(area, 9)\n\nif __name__ == \"__main__\":\n    a, b, c = map(float, input().split())\n    print(calculate_carpet_area(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956503510475159,
            0.9965218305587769,
            0.9976335167884827,
            0.9974903464317322,
            0.9973933696746826,
            0.994724690914154,
            0.9971137046813965,
            0.9964986443519592,
            0.997241199016571,
            0.9943830370903015,
            0.9964413046836853,
            0.9974395632743835,
            0.9976997375488281,
            0.9968101978302002,
            0.9974443316459656,
            0.9968462586402893,
            0.9949546456336975,
            0.9970781207084656,
            0.9956454038619995,
            0.9962772727012634
        ]
    },
    "3927": {
        "similarity": 0.9974684715270996,
        "body": "from itertools import combinations\n\n    a.sort()\n    max_learned = 0\n    for k in range(1, n + 1):\n        for m in range(k, sum(a) // k + 1):\n            found = False\n            for combo in combinations(a, k):\n                if sum(combo) == m:\n                    found = True\n                    break\n            if not found:\n                break\n        else:\n            max_learned = max(max_learned, n - k)\n    return max_learned\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print result\nprint(max_weights_to_learn(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971343874931335,
            0.9947982430458069,
            0.9956094026565552,
            0.9974684715270996,
            0.9968178272247314,
            0.9968339204788208,
            0.9970346689224243,
            0.9965264201164246,
            0.9970980286598206,
            0.996997058391571,
            0.996965229511261,
            0.9927210807800293,
            0.9964718222618103,
            0.9960228800773621,
            0.9970178008079529,
            0.9946580529212952,
            0.9970825910568237,
            0.996940016746521,
            0.9971928000450134,
            0.9959459900856018
        ]
    },
    "3319": {
        "similarity": 0.9968324303627014,
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, nx, ny, nz = int(data[0]), int(data[1]), int(data[2]), int(data[3])\n    planetoids = []\n    \n    for i in range(n):\n        m, x, y, z, vx, vy, vz = map(int, data[4 + 7 * i: 11 + 7 * i])\n        planetoids.append((m, (x % nx, y % ny, z % nz), (vx, vy, vz)))\n    \n    while True:\n        collisions = {}\n        for i in range(n):\n            x, y, z = planetoids[i][1]\n            vx, vy, vz = planetoids[i][2]\n            for dx in range(-1000, 1001):\n                for dy in range(-1000, 1001):\n                    for dz in range(-1000, 1001):\n                        if (dx != 0 or dy != 0 or dz != 0) and (abs(dx * vx + dy * vy + dz * vz) <= n):\n                            new_x = (x + dx) % nx\n                            new_y = (y + dy) % ny\n                            new_z = (z + dz) % nz\n                            for j in range(n):\n                                if i != j and planetoids[j][1] == (new_x, new_y, new_z):\n                                    key = tuple(sorted([(planetoids[i][0], planetoids[i][1]), (planetoids[j][0], planetoids[j][1])]))\n                                    if key not in collisions:\n                                        collisions[key] = []\n                                    collisions[key].append((planetoids[i][0] + planetoids[j][0], \n                                                            ((planetoids[i][2][0] + planetoids[j][2][0]) // 2, \n                                                             (planetoids[i][2][1] + planetoids[j][2][1]) // 2, \n                                                             (planetoids[i][2][2] + planetoids[j][2][2]) // 2)))\n                                    planetoids.pop(j)\n                                    n -= 1\n                                    break\n        \n        if not collisions:\n            break\n        \n        for key in collisions:\n            new_planetoid = max(collisions[key], key=lambda x: (x[0], -x[1][0], -x[1][1], -x[1][2]))\n            planetoids.append(new_planetoid)\n    \n    planetoids.sort(key=lambda x: (-x[0], -x[1][0], -x[1][1], -x[1][2]))\n    \n    print(len(planetoids))\n    for i, (m, loc, vel) in enumerate(planetoids):\n        print(f\"P{i}: {m} {loc[0]} {loc[1]} {loc[2]} {vel[0]} {vel[1]} {vel[2]}\")\n\nsimulate_planetoid_collisions()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956761598587036,
            0.9953767657279968,
            0.99658203125,
            0.9943561553955078,
            0.9962665438652039,
            0.9965971112251282,
            0.9944319725036621,
            0.9943549633026123,
            0.9968324303627014,
            0.9935563802719116,
            0.9955065846443176,
            0.9935946464538574,
            0.9961156249046326,
            0.9957038760185242,
            0.9965713024139404,
            0.996181070804596,
            0.9958644509315491,
            0.9949802756309509,
            0.9953292012214661,
            0.9965623617172241
        ]
    },
    "3009": {
        "similarity": 0.9966455101966858,
        "body": "import itertools\nimport math\nimport sys\n\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    x_coords = [x for x, y, e in lamps]\n    y_coords = [y for x, y, e in lamps]\n    min_x, max_x = min(x_coords), max(x_coords)\n    min_y, max_y = min(y_coords), max(y_coords)\n    \n        inside_energy = 0\n        outside_energy = 0\n        for x, y, e in lamps:\n            if line[0] <= x <= line[1]:\n                inside_energy += e\n            else:\n                outside_energy += e\n        return abs(inside_energy - outside_energy) < 1e-6\n    \n    for i in range(min_x, max_x + 2):\n        for j in range(min_y, max_y + 2):\n            line = (i, j)\n            if is_feasible(line):\n                return distance((min_x, min_y), (max_x, max_y))\n    \n    return \"IMPOSSIBLE\"\n\n    n = int(input())\n    lamps = [tuple(map(int, input().split())) for _ in range(n)]\n    result = find_balancing_line(lamps)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964528679847717,
            0.9946710467338562,
            0.9965525269508362,
            0.9965429902076721,
            0.9795786142349243,
            0.9966455101966858,
            0.995554506778717,
            0.9953218698501587,
            0.9960899353027344,
            0.9951286315917969,
            0.9953645467758179,
            0.9952663779258728,
            0.9960684776306152,
            0.9958962202072144,
            0.9955083131790161,
            0.9963101744651794,
            0.9960971474647522,
            0.9953786134719849,
            0.9956117272377014,
            0.9949132204055786
        ]
    },
    "3896": {
        "similarity": 0.9965560436248779,
        "body": "    n = len(x)\n    complexity = 0\n    mod = 1000000007\n    \n    for i in range(n):\n        if x[i] == '1':\n            complexity += (2**(n-i-1)) * (2**i) % mod\n            complexity %= mod\n    \n    return complexity\n\n# Read input\nx = input().strip()\n\n# Calculate and print the result\nprint(calculate_dance_complexity(x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9918884634971619,
            0.9895849823951721,
            0.9946907758712769,
            0.9953950643539429,
            0.992889404296875,
            0.9965560436248779,
            0.9952401518821716,
            0.9960492849349976,
            0.9940617084503174,
            0.9962024688720703,
            0.9949331879615784,
            0.9961975812911987,
            0.9942237734794617,
            0.9951536059379578,
            0.9958626627922058,
            0.9936686158180237,
            0.9935024976730347,
            0.9924520254135132,
            0.9960516095161438,
            0.9943693280220032
        ]
    },
    "3509": {
        "similarity": 0.998671293258667,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    # Build adjacency list for the graph\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v, t in roads:\n        adj_list[u].append((v, t))\n    \n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            \n            for v, t in adj_list[u]:\n                new_dist = current_dist + t\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heappush(pq, (new_dist, v))\n        \n        return dist\n    \n    # Calculate the shortest path from Richard's house to Janet's house\n    dist_to_janet = dijkstra(1)\n    \n    max_wait_time = 0\n    for wait in range(a, b + 1):\n        # Calculate the worst-case waiting time if Janet calls after wait minutes\n        current_max_wait = wait\n        for i in range(wait, wait + b - a + 1):\n            min_distance_to_janet = float('inf')\n            for u in range(1, n + 1):\n                min_distance_to_janet = min(min_distance_to_janet, dist_to_janet[u] + (i - wait))\n            current_max_wait = max(current_max_wait, min_distance_to_janet)\n        \n        max_wait_time = max(max_wait_time, current_max_wait)\n    \n    return max_wait_time\n\n# Read input\na, b = map(int, input().split())\nn, m = map(int, input().split())\nroads = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(min_worst_case_waiting_time(a, b, n, m, roads))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982615113258362,
            0.9984482526779175,
            0.9975696206092834,
            0.9982782602310181,
            0.9977632761001587,
            0.9983605146408081,
            0.997920572757721,
            0.9985024333000183,
            0.9984343647956848,
            0.998671293258667,
            0.9980537295341492,
            0.9972096681594849,
            0.9985471963882446,
            0.998435378074646,
            0.9978744387626648,
            0.9984962940216064,
            0.9971363544464111,
            0.9983748197555542,
            0.9978938698768616,
            0.9982956647872925
        ]
    },
    "3547": {
        "similarity": 0.9958258271217346,
        "body": "    n = int(input())\n    plots = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        plots.append((x1, y1, x2, y2))\n    \n    total_area = 0.0\n    for i in range(n):\n        area_i = (plots[i][2] - plots[i][0]) * (plots[i][3] - plots[i][1])\n        is_overlapping = False\n        for j in range(i + 1, n):\n            x1_j, y1_j, x2_j, y2_j = plots[j]\n            if max(plots[i][0], x1_j) < min(plots[i][2], x2_j) and max(plots[i][1], y1_j) < min(plots[i][3], y2_j):\n                is_overlapping = True\n                break\n        if not is_overlapping:\n            total_area += area_i\n    \n    print(f\"{total_area:.2f}\")\n\ncalculate_total_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9906875491142273,
            0.9948379397392273,
            0.9949284791946411,
            0.9946046471595764,
            0.9940625429153442,
            0.9947723746299744,
            0.9949198365211487,
            0.9953207969665527,
            0.9944848418235779,
            0.9941781759262085,
            0.9894458651542664,
            0.9952645897865295,
            0.9951553344726562,
            0.9958258271217346,
            0.9950166940689087,
            0.9932460784912109,
            0.9949567914009094,
            0.995029866695404,
            0.9957646727561951,
            0.9954205751419067
        ]
    },
    "3017": {
        "similarity": 0.9971869587898254,
        "body": "import math\n\n    power_of_two = 2 ** e\n    str_power_of_two = str(power_of_two)\n    count = 0\n    \n    for k in range(1, n + 1):\n        if str_power_of_two in str(k):\n            count += 1\n            \n    return count\n\n# Read input from stdin\nn, e = map(int, input().split())\n\n# Print the result\nprint(count_numbers_with_power_of_two(n, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962853193283081,
            0.9952041506767273,
            0.9968048930168152,
            0.9970970153808594,
            0.9964185357093811,
            0.9952490925788879,
            0.9955837726593018,
            0.9966186881065369,
            0.9971869587898254,
            0.9969006776809692,
            0.9971805214881897,
            0.9958744049072266,
            0.9956263303756714,
            0.9958156943321228,
            0.9967061281204224,
            0.9969645142555237,
            0.9951563477516174,
            0.9967027902603149,
            0.9939529895782471,
            0.9966826438903809
        ]
    },
    "3076": {
        "similarity": 0.9978795647621155,
        "body": "import sys\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        s, v = jewels[i - 1]\n        for j in range(1, k + 1):\n            if s <= j:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - s] + v)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    result = [dp[n][i] for i in range(1, k + 1)]\n    return result\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    jewels = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(n)]\n    \n    result = max_jewel_values(n, k, jewels)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963874816894531,
            0.9938212037086487,
            0.9966644644737244,
            0.997138500213623,
            0.9961298704147339,
            0.9977296590805054,
            0.9971109628677368,
            0.9974092245101929,
            0.9965476989746094,
            0.9978795647621155,
            0.997697651386261,
            0.9946091175079346,
            0.9967854022979736,
            0.9976627826690674,
            0.9975184202194214,
            0.9955891966819763,
            0.9951003193855286,
            0.9972707033157349,
            0.9971951842308044,
            0.9961991906166077
        ]
    },
    "3923": {
        "similarity": 0.9976091980934143,
        "body": "import sys\n\n    if N == 1:\n        return [1] if A == 1 else -1\n    \n    P = [-1] * (N + 1)\n    available = set(range(1, N + 1))\n    \n        nonlocal P\n        if j == 1:\n            P[i] = i\n        else:\n            P[i] = assign(P[i], j - 1)\n    \n    for i in range(N):\n        if A <= i + 1 < B or B <= i + 1 < A:\n            continue\n        while True:\n            candidate = available.pop()\n            if not (A <= P[candidate] < B or B <= P[candidate] < A):\n                assign(i + 1, A)\n                break\n    \n    if -1 in P[1:]:\n        return -1\n    \n    return P[1:]\n\n    input_line = sys.stdin.readline().strip()\n    N, A, B = map(int, input_line.split())\n    \n    result = find_permutation(N, A, B)\n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972196221351624,
            0.9966242909431458,
            0.9963667988777161,
            0.9950242638587952,
            0.9973686933517456,
            0.9967333078384399,
            0.9970833659172058,
            0.9963568449020386,
            0.9961729645729065,
            0.9976091980934143,
            0.9965771436691284,
            0.9968916177749634,
            0.9965868592262268,
            0.9965155720710754,
            0.99651700258255,
            0.9936720132827759,
            0.9974369406700134,
            0.996629536151886,
            0.9954619407653809,
            0.9963788390159607
        ]
    },
    "3332": {
        "similarity": 0.9979215860366821,
        "body": "import sys\n\n    # Sort streams by start time\n    streams.sort(key=lambda x: x[0])\n    \n    stack = []\n    current_time = 0\n    max_priority_sum = 0\n    \n    for s, d, p in streams:\n        # Process completed streams\n        while stack and stack[-1][2] < s:\n            _, end_time, _ = stack.pop()\n            if end_time <= current_time:\n                current_time += end_time - current_time\n        \n        # Push new stream onto the stack\n        stack.append((s + d, s + d, p))\n        max_priority_sum += p\n    \n    return max_priority_sum\n\n# Read input\nn = int(input().strip())\nstreams = []\nfor _ in range(n):\n    s, d, p = map(int, input().strip().split())\n    streams.append((s, d, p))\n\n# Output the result\nprint(max_priority(n, streams))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972586631774902,
            0.9956635236740112,
            0.9965484142303467,
            0.9976281523704529,
            0.9967781901359558,
            0.9958177804946899,
            0.9963505268096924,
            0.9965828657150269,
            0.9974045157432556,
            0.9974702596664429,
            0.9969550967216492,
            0.9975095391273499,
            0.9979215860366821,
            0.9959094524383545,
            0.9972074627876282,
            0.9967936277389526,
            0.9972955584526062,
            0.9968534708023071,
            0.9972905516624451,
            0.9974580407142639
        ]
    },
    "3240": {
        "similarity": 0.9978715181350708,
        "body": "import sys\n\n    p = [voters[i][0] for i in range(1, v)]\n    b = [voters[i][1] for i in range(1, v)]\n    \n    max_expected = -1\n    optimal_b = 0\n    \n    for my_b in range(2**k):\n        total_ballots = my_b\n        expected_positions = 0\n        \n        for p_i, b_i in zip(p, b):\n            if random.random() < p_i:\n                total_ballots += b_i\n        \n        for j in range(k):\n            if (total_ballots >> j) & 1:\n                expected_positions += 1\n        \n        if expected_positions > max_expected:\n            max_expected = expected_positions\n            optimal_b = my_b\n    \n    return optimal_b\n\nif __name__ == \"__main__\":\n    import random\n    k, v = map(int, input().split())\n    voters = [tuple(map(float, input().split())) for _ in range(v - 1)]\n    print(max_ballots(k, v, voters))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978111982345581,
            0.9958627820014954,
            0.9974344372749329,
            0.9978715181350708,
            0.9970657825469971,
            0.996232271194458,
            0.9974023699760437,
            0.9935197234153748,
            0.9972749948501587,
            0.9978593587875366,
            0.9975062012672424,
            0.9977997541427612,
            0.9975260496139526,
            0.9977742433547974,
            0.9974183440208435,
            0.9966512322425842,
            0.9951249957084656,
            0.9977033734321594,
            0.9967426657676697,
            0.9971004128456116
        ]
    },
    "3368": {
        "similarity": 0.9962379932403564,
        "body": "    animal_counts = {}\n    \n    for i in range(n):\n        _, num_animals, *animals = enclosures[i].split()\n        num_animals = int(num_animals)\n        for _ in range(num_animals):\n            animal_type = animals.pop()\n            if animal_type in animal_counts:\n                animal_counts[animal_type] += 1\n            else:\n                animal_counts[animal_type] = 1\n    \n    for animal_type, count in animal_counts.items():\n        if count % n != 0:\n            return \"IMPOSSIBLE\"\n    \n    return \"POSSIBLE\" if any(count > 0 for count in animal_counts.values()) else \"FALSE ALARM\"\n\n# Read input from stdin\nn, m = map(int, input().split())\nenclosures = [input() for _ in range(n)]\n\n# Output the result\nprint(is_possible(n, m, enclosures))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936506152153015,
            0.9945811033248901,
            0.9937834739685059,
            0.9937324523925781,
            0.9943050742149353,
            0.9962244629859924,
            0.9961740374565125,
            0.9954031109809875,
            0.9949172139167786,
            0.9943591952323914,
            0.9953731894493103,
            0.9961053729057312,
            0.9905281066894531,
            0.9959398508071899,
            0.9962379932403564,
            0.9944895505905151,
            0.9901384115219116,
            0.995131254196167,
            0.9950801730155945,
            0.9954239726066589
        ]
    },
    "3538": {
        "similarity": 0.9975502490997314,
        "body": "    frogs.sort(key=lambda x: (-x[2], -x[0]))\n    total_weight = 0\n    escaped_frogs = 0\n    \n    for frog in frogs:\n        if frog[1] <= total_weight:\n            continue\n        if frog[2] + frog[0] > d:\n            escaped_frogs += 1\n            total_weight += frog[1]\n    \n    return escaped_frogs\n\n# Read input\nn, d = map(int, input().split())\nfrogs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_frogs_escaping(n, d, frogs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963009357452393,
            0.9966796040534973,
            0.99730384349823,
            0.9972473978996277,
            0.9963246583938599,
            0.9952353239059448,
            0.9965090751647949,
            0.9936587810516357,
            0.9964942932128906,
            0.9971430897712708,
            0.9954515099525452,
            0.9960584044456482,
            0.9960625171661377,
            0.9968795776367188,
            0.9957002401351929,
            0.9971938133239746,
            0.9966163635253906,
            0.9975502490997314,
            0.9966785907745361,
            0.9972626566886902
        ]
    },
    "3183": {
        "similarity": 0.9985358715057373,
        "body": "import sys\n\n    import heapq\n    \n    graph = [[] for _ in range(n)]\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))  # Reverse edge with negative cost\n    \n        dist = [float('inf')] * n\n        dist[s] = 0\n        prev = [-1] * n\n        queue = [(0, s)]\n        \n        while queue:\n            d, u = heapq.heappop(queue)\n            if d != dist[u]:\n                continue\n            for v, cap, cost in graph[u]:\n                if cap > 0 and dist[v] > dist[u] + cost:\n                    dist[v] = dist[u] + cost\n                    prev[v] = u\n                    heapq.heappush(queue, (dist[v], v))\n        \n        return prev\n    \n        if u == t:\n            return flow\n        \n        for i in range(len(graph[u])):\n            v, cap, _ = graph[u][i]\n            if cap > 0 and dist[v] == dist[u] + graph[u][i][2]:\n                f = dfs(v, t, min(flow, cap))\n                if f > 0:\n                    graph[u][i] = (v, cap - f, graph[u][i][2])\n                    for j in range(len(graph[v])):\n                        if graph[v][j][0] == u:\n                            graph[v][j] = (u, graph[v][j][1] + f, -graph[v][j][2])\n                            break\n                    return f\n        return 0\n    \n    flow = 0\n    cost = 0\n    dist = [float('inf')] * n\n    \n    while True:\n        prev = bfs()\n        if prev[t] == -1:\n            break\n        \n        path_flow = float('inf')\n        s = t\n        while s != t:\n            for v, _, _ in graph[prev[s]]:\n                if v == s:\n                    u = prev[s]\n                    for edge in graph[u]:\n                        if edge[0] == v and edge[1] > 0:\n                            path_flow = min(path_flow, edge[1])\n                            break\n        \n        flow += path_flow\n        cost += path_flow * dist[t]\n    \n    return flow, -cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = int(data[2])\n    t = int(data[3])\n    \n    edges = []\n    index = 4\n    for _ in range(m):\n        u = int(data[index])\n        v = int(data[index + 1])\n        c = int(data[index + 2])\n        w = int(data[index + 3])\n        edges.append((u, v, c, w))\n        index += 4\n    \n    result = min_cost_flow(n, m, s, t, edges)\n    print(result[0], result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980834126472473,
            0.9978391528129578,
            0.9979208111763,
            0.9974384307861328,
            0.9982346296310425,
            0.9968345165252686,
            0.9974122643470764,
            0.9977320432662964,
            0.9965741038322449,
            0.9976539611816406,
            0.9981777667999268,
            0.9983040690422058,
            0.9973275065422058,
            0.9981768727302551,
            0.9983307719230652,
            0.9968144297599792,
            0.9976316094398499,
            0.9982002973556519,
            0.9985358715057373,
            0.9980442523956299
        ]
    },
    "3916": {
        "similarity": 0.9980060458183289,
        "body": "import math\n\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\n    graph = {}\n    visited = set()\n    \n        if node in visited:\n            return\n        visited.add(node)\n        for next_node in [node // find_lowest_prime_divisor(node)]:\n            if next_node not in graph:\n                graph[next_node] = []\n            graph[next_node].append(node)\n            dfs(next_node)\n    \n    max_node = max(math.factorial(k) for k in k_values)\n    dfs(max_node)\n    \n    distances = {node: float('inf') for node in range(1, max_node + 1)}\n    distances[1] = 0\n    \n    queue = [1]\n    while queue:\n        current_node = queue.pop(0)\n        for neighbor in graph.get(current_node, []):\n            if distances[current_node] + 1 < distances[neighbor]:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    min_path_sum = sum(distances[k_i!] for k_i in k_values)\n    return min_path_sum\n\n# Read input\nn = int(input())\nk_values = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_min_path_sum(n, k_values))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977455139160156,
            0.9977173209190369,
            0.9969590902328491,
            0.9971810579299927,
            0.9971369504928589,
            0.9974367022514343,
            0.9975438714027405,
            0.9980060458183289,
            0.9971256256103516,
            0.996491014957428,
            0.9967535734176636,
            0.9974743723869324,
            0.9948126077651978,
            0.9976975321769714,
            0.9976626038551331,
            0.9977794289588928,
            0.9976579546928406,
            0.9973650574684143,
            0.9979972839355469,
            0.997197687625885
        ]
    },
    "3195": {
        "similarity": 0.9960551857948303,
        "body": "import sys\n\n    T = observations[0][0]\n    cycle_length = Tg + Ty + Tr\n    \n    # Find all possible starting times T that are consistent with observations\n    possible_Ts = []\n    for i in range(len(observations)):\n        for j in range(i+1, len(observations)):\n            observed_time1, observed_color1 = observations[i]\n            observed_time2, observed_color2 = observations[j]\n            time_diff = observed_time2 - observed_time1\n            if time_diff >= cycle_length:\n                possible_Ts.append(observed_time1 % cycle_length)\n    \n    # Count the number of times each color appears in the observation sequence\n    color_count = {'green': 0, 'yellow': 0, 'red': 0}\n    for _, observed_color in observations:\n        color_count[observed_color] += 1\n    \n    # Calculate the probability that the lights will be c_q at time t_q\n    if t_q % cycle_length + T < Tq:\n        target_color = 'green'\n    elif t_q % cycle_length + T >= Tq and t_q % cycle_length + T < Tq + Ty:\n        target_color = 'yellow'\n    else:\n        target_color = 'red'\n    \n    probability = color_count[target_color] / len(possible_Ts)\n    return probability\n\n# Read input from stdin\ninput_lines = sys.stdin.readlines()\nTg, Ty, Tr = map(int, input_lines[0].strip().split())\nn = int(input_lines[1].strip())\nobservations = [tuple(map(int, line.strip().split())) for line in input_lines[2:2+n]]\nt_q, c_q = input_lines[2+n].strip().split()\n\n# Calculate and print the result\nresult = calculate_probability(Tg, Ty, Tr, observations, int(t_q), c_q)\nprint(f\"{result:.3f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9931728839874268,
            0.9960551857948303,
            0.9940826892852783,
            0.9957975149154663,
            0.9948312640190125,
            0.9958959817886353,
            0.9946959614753723,
            0.9957799315452576,
            0.9957128167152405,
            0.9946120381355286,
            0.993069589138031,
            0.9934331774711609,
            0.9928265810012817,
            0.9950951337814331,
            0.9958849549293518,
            0.9908931255340576,
            0.995387613773346,
            0.9951356649398804,
            0.9959756135940552,
            0.9958382844924927
        ]
    },
    "3998": {
        "similarity": 0.9969390034675598,
        "body": "import sys\n\n    n = len(ratings)\n    max_rating = 0\n    \n    for rating in ratings:\n        if rating > max_rating:\n            max_rating = rating\n    \n    t = (n * max_rating - sum(ratings)) // (max_rating - 1) + (n * max_rating - sum(ratings)) % (max_rating - 1)\n    \n    matches = []\n    remaining_ratings = [max_rating] * n\n    for _ in range(t):\n        current_match = []\n        for i in range(n):\n            if remaining_ratings[i] > max_rating:\n                continue\n            current_match.append(1)\n            remaining_ratings[i] += 1\n        matches.append(current_match)\n    \n    return max_rating, len(matches), matches\n\nif __name__ == \"__main__\":\n    n = int(input())\n    ratings = list(map(int, input().split()))\n    \n    final_rating, num_matches, match_details = maximize_rating(ratings)\n    \n    print(final_rating)\n    print(num_matches)\n    for match in match_details:\n        print(''.join(map(str, match)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965981245040894,
            0.9962065815925598,
            0.9943554401397705,
            0.9969390034675598,
            0.9945446848869324,
            0.9951680898666382,
            0.9968515634536743,
            0.9955195188522339,
            0.9963415861129761,
            0.9952939748764038,
            0.9961778521537781,
            0.9922271370887756,
            0.9939723610877991,
            0.9968777894973755,
            0.9950782656669617,
            0.9967360496520996,
            0.9967312216758728,
            0.9960535764694214,
            0.9957689046859741,
            0.9960511922836304
        ]
    },
    "3150": {
        "similarity": 0.9962752461433411,
        "body": "        while b:\n            a, b = b, a % b\n        return a\n\n        return a * b // gcd(a, b)\n\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if on_line(trenches[i], trenches[j]):\n                continue\n            for k in range(j + 1, n):\n                if on_line(trenches[i], trenches[k]) or on_line(trenches[j], trenches[k]):\n                    continue\n                ways += 1\n\n    return ways\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    trenches = [(int(data[i * 4 + 1]), int(data[i * 4 + 2]), int(data[i * 4 + 3]), int(data[i * 4 + 4])) for i in range(n)]\n    \n    result = count_ways_to_place_guards(n, trenches)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950634837150574,
            0.9961332082748413,
            0.9951625466346741,
            0.9922611117362976,
            0.9943105578422546,
            0.9959829449653625,
            0.9955834150314331,
            0.9962752461433411,
            0.9951727986335754,
            0.9960718750953674,
            0.9941766858100891,
            0.9951685667037964,
            0.9948249459266663,
            0.995784342288971,
            0.991225004196167,
            0.9920846223831177,
            0.9951260089874268,
            0.9952610731124878,
            0.9951078295707703,
            0.995591402053833
        ]
    },
    "3566": {
        "similarity": 0.9973628520965576,
        "body": "import sys\nfrom collections import deque\n\n    for _ in range(q):\n        i, x = map(int, input().split())\n        huts[i] = x\n        \n        left_sum = sum(huts[:i])\n        right_sum = sum(huts[i+1:])\n        \n        diff = abs(left_sum - right_sum)\n        min_diff = float('inf')\n        optimal_pos = -1\n        \n        for j in range(n):\n            new_left_sum = left_sum + huts[j] - huts[i]\n            new_right_sum = right_sum - huts[j]\n            new_diff = abs(new_left_sum - new_right_sum)\n            \n            if new_diff < min_diff:\n                min_diff = new_diff\n                optimal_pos = j\n        \n        print(optimal_pos)\n\n# Read input\nn, q = map(int, input().split())\nhuts = list(map(int, input().split()))\n\noptimal_food_truck_position(n, q, huts)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969576597213745,
            0.9951892495155334,
            0.9907675385475159,
            0.9967271685600281,
            0.9962758421897888,
            0.9968679547309875,
            0.9970075488090515,
            0.9959670901298523,
            0.9956342577934265,
            0.9947575330734253,
            0.9960915446281433,
            0.9940069317817688,
            0.9970570802688599,
            0.9973016977310181,
            0.9973315000534058,
            0.9970898032188416,
            0.9973628520965576,
            0.9954681396484375,
            0.9964097738265991,
            0.9949858784675598
        ]
    },
    "3401": {
        "similarity": 0.9977577924728394,
        "body": "import heapq\nfrom typing import List\n\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heapq.heappop(pq)\n            \n            if current_dist > dist[u]:\n                continue\n            \n            for v, weight in adj_list[u]:\n                distance = current_dist + weight\n                \n                if distance < dist[v]:\n                    dist[v] = distance\n                    heapq.heappush(pq, (distance, v))\n        \n        return dist\n\n    adj_list = [[] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        x1, y1, h1 = hills[i - 1]\n        for j in range(i + 1, n + 1):\n            x2, y2, h2 = hills[j - 1]\n            height_diff = abs(h1 - h2)\n            distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n            if distance <= q:\n                adj_list[i].append((j, height_diff))\n                adj_list[j].append((i, height_diff))\n\n    result = float('inf')\n    \n    for i in range(s):\n        spring_hill = spring_hills[i]\n        town_hill = town_hills[i]\n        \n        dist_to_spring = dijkstra(spring_hill)\n        dist_to_town = dijkstra(town_hill)\n        \n        if dist_to_town[town_hill] == float('inf'):\n            return \"IMPOSSIBLE\"\n        \n        result = min(result, dist_to_town[spring_hill])\n    \n    return result\n\n# Input handling\nn, s, t, q = map(int, input().split())\nhills = [list(map(int, input().split())) for _ in range(n)]\nspring_hills = list(map(int, input().split()))\ntown_hills = list(map(int, input().split()))\n\n# Output the result\nprint(min_aqueduct_length(n, s, t, q, hills, spring_hills, town_hills))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971913695335388,
            0.9969201683998108,
            0.9963487386703491,
            0.9964081645011902,
            0.9971150159835815,
            0.9977164268493652,
            0.9946306943893433,
            0.9973859190940857,
            0.9956073760986328,
            0.997363269329071,
            0.9977577924728394,
            0.9949052929878235,
            0.9972755312919617,
            0.9965966939926147,
            0.9970161318778992,
            0.9975845217704773,
            0.9969913959503174,
            0.9966573119163513,
            0.9959907531738281,
            0.9974520802497864
        ]
    },
    "3660": {
        "similarity": 0.9978131651878357,
        "body": "import sys\n\n    message = input().strip()\n    n = int(input().strip())\n    stickers = {}\n    \n    for _ in range(n):\n        word, price = input().strip().split()\n        stickers[word] = int(price)\n    \n    m = len(message)\n    dp = [[float('inf')] * (m + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, m + 1):\n        for j in range(i):\n            sub_message = message[j:i]\n            if sub_message in stickers:\n                dp[i][j] = min(dp[i][j], dp[j][j] + stickers[sub_message])\n    \n    min_cost = float('inf')\n    for i in range(m):\n        if dp[m][i] < float('inf'):\n            min_cost = min(min_cost, dp[m][i] + (dp[m][i+1] if i+1 <= m else 0))\n    \n    if min_cost == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        print(min_cost)\n\nmin_cost_message()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958668947219849,
            0.9970883727073669,
            0.9973618388175964,
            0.9972895383834839,
            0.996547281742096,
            0.9976083636283875,
            0.9971261620521545,
            0.9971613883972168,
            0.9947556257247925,
            0.9933445453643799,
            0.9968051910400391,
            0.997730553150177,
            0.9964589476585388,
            0.9963558912277222,
            0.996610164642334,
            0.9974551796913147,
            0.9978131651878357,
            0.9966073632240295,
            0.9973909258842468,
            0.9960892200469971
        ]
    },
    "3721": {
        "similarity": 0.9958639740943909,
        "body": "    # Create a set of all available elements\n    available = set(elements)\n    \n    # Iterate through each cell in the grid\n    for r in range(1, n + 1):\n        for c in range(1, m + 1):\n            # If the element is not available, check if it can be produced by fusion\n            if (r, c) not in available:\n                found = False\n                for r2 in range(r + 1, n + 1):\n                    for c2 in range(c + 1, m + 1):\n                        if (r2, c) in available and (r, c2) in available and (r2, c2) not in available:\n                            found = True\n                            break\n                    if found:\n                        break\n                if not found:\n                    return -1  # It's impossible to produce this element\n    \n    return 0\n\n# Read input from stdin\nn, m, q = map(int, input().split())\nelements = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Calculate the result and print it\nresult = min_elements_to_purchase(n, m, q, elements)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943670034408569,
            0.9944229125976562,
            0.9937105774879456,
            0.9951663017272949,
            0.9941190481185913,
            0.9958639740943909,
            0.9929520487785339,
            0.9908557534217834,
            0.9951997995376587,
            0.9954603314399719,
            0.9954426288604736,
            0.9950670003890991,
            0.9923393130302429,
            0.9922061562538147,
            0.9947502017021179,
            0.9887412190437317,
            0.9934977293014526,
            0.9925073385238647,
            0.9941695332527161,
            0.9940641522407532
        ]
    },
    "3811": {
        "similarity": 0.9968324899673462,
        "body": "import math\n\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n    if not pairs:\n        return -1\n    \n    current_gcd = pairs[0][0]\n    \n    for a, b in pairs:\n        current_gcd = gcd(current_gcd, gcd(a, b))\n        if current_gcd <= 1:\n            break\n    \n    return current_gcd if current_gcd > 1 else -1\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\n\nresult = calculate_wcd(pairs)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957049489021301,
            0.9956535696983337,
            0.9964997172355652,
            0.9945929646492004,
            0.9963533282279968,
            0.9951645731925964,
            0.9951176047325134,
            0.9955158233642578,
            0.9943363666534424,
            0.9947160482406616,
            0.9949641823768616,
            0.9961625337600708,
            0.9937978982925415,
            0.9949324727058411,
            0.9903588891029358,
            0.9966502785682678,
            0.9949227571487427,
            0.9967740774154663,
            0.9968324899673462,
            0.9963177442550659
        ]
    },
    "3528": {
        "similarity": 0.9981533885002136,
        "body": "import sys\nfrom typing import List, Tuple\n\n    x_coords = sorted([nail[0] for nail in nails])\n    y_coords = sorted([nail[1] for nail in nails])\n    return (x_coords[-1] - x_coords[0]) * (y_coords[-1] - y_coords[0])\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    nails = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    pick_order = [data[N*2+i] for i in range(N-2)]\n    \n    areas = []\n    while len(nails) > 2:\n        area = calculate_area(nails)\n        areas.append(area)\n        \n        if pick_order.pop(0) == 'L':\n            nails.remove(min(nails, key=lambda x: x[0]))\n        elif pick_order.pop(0) == 'R':\n            nails.remove(max(nails, key=lambda x: x[0]))\n        elif pick_order.pop(0) == 'U':\n            nails.remove(max(nails, key=lambda x: x[1]))\n        else:\n            nails.remove(min(nails, key=lambda x: x[1]))\n    \n    for area in areas:\n        print(f\"{area:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996881365776062,
            0.997493326663971,
            0.9978248476982117,
            0.9955935478210449,
            0.9960389733314514,
            0.9976570010185242,
            0.9939894676208496,
            0.9972646832466125,
            0.9980145692825317,
            0.9977270364761353,
            0.9974607229232788,
            0.9981533885002136,
            0.9971824288368225,
            0.9972504377365112,
            0.9974805116653442,
            0.9962266683578491,
            0.9977270364761353,
            0.9968504905700684,
            0.9973182678222656,
            0.9977189898490906
        ]
    },
    "3890": {
        "similarity": 0.9969350099563599,
        "body": "import math\n\n    mod = 10**9 + 7\n    fact = [1] * (n + 1)\n    inv_fact = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % mod\n        inv_fact[i] = pow(fact[i], mod - 2, mod)\n\n        return (fact[a] * inv_fact[b] * inv_fact[a - b]) % mod\n\n    ways = 0\n    for i in range(1, k + 1):\n        if i == 1:\n            ways += n\n        else:\n            ways += choose(n - 1, i - 2) * (k - i + 1)\n    return ways\n\n    n, k = map(int, input().split())\n    print(count_ways(n, k))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969307780265808,
            0.9931918978691101,
            0.9941586852073669,
            0.9965541362762451,
            0.9953869581222534,
            0.9967608451843262,
            0.9961088299751282,
            0.9964420795440674,
            0.9962840676307678,
            0.9946674704551697,
            0.9954426288604736,
            0.9948505759239197,
            0.9967280030250549,
            0.9961268901824951,
            0.996695876121521,
            0.9958572387695312,
            0.9956044554710388,
            0.9965499043464661,
            0.9969350099563599,
            0.9948941469192505
        ]
    },
    "3534": {
        "similarity": 0.9982491731643677,
        "body": "import sys\n\n    max_correct = 0\n    best_k = 0\n    \n    for k in range(2 * 10**9 + 1):\n        correct = 1\n        prev_key = a[0]\n        \n        for i in range(1, n):\n            if a[i] > prev_key:\n                if a[i] - prev_key <= k:\n                    correct += 1\n                else:\n                    break\n            elif a[i] < prev_key:\n                if prev_key - a[i] <= k:\n                    correct += 1\n                else:\n                    break\n            prev_key = a[i]\n        \n        if correct > max_correct:\n            max_correct = correct\n            best_k = k\n    \n    return max_correct, best_k\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Find the maximum number of correct pitches and the best K\nresult = find_best_k(n, a)\n\n# Print the result\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971080422401428,
            0.9975918531417847,
            0.9980404376983643,
            0.9981129169464111,
            0.9981312155723572,
            0.9982491731643677,
            0.9980461597442627,
            0.9982098937034607,
            0.9979346394538879,
            0.9982173442840576,
            0.9891654849052429,
            0.998066782951355,
            0.9981027245521545,
            0.9982456564903259,
            0.9982098937034607,
            0.9978295564651489,
            0.99233478307724,
            0.9976019859313965,
            0.9981968402862549,
            0.9981223940849304
        ]
    },
    "3371": {
        "similarity": 0.9978179931640625,
        "body": "import sys\n\n    participants = set(range(1, n + 1))\n    year_to_encounters = {}\n    \n    for a, b, y in encounters:\n        if y not in year_to_encounters:\n            year_to_encounters[y] = []\n        year_to_encounters[y].append((a, b))\n    \n    years = sorted(year_to_encounters.keys())\n    \n    for Y in years:\n        first_part = set()\n        second_part = participants.copy()\n        \n        for a, b in year_to_encounters[Y]:\n            if (a, b) not in encounters or encounters[(a, b)][1] != Y:\n                continue\n            if a in first_part and b in second_part:\n                first_part.remove(a)\n                second_part.add(a)\n            elif a in second_part and b in first_part:\n                second_part.remove(b)\n                first_part.add(b)\n        \n        if len(first_part) <= n / 3 and len(second_part) <= n / 3:\n            return Y\n    \n    return 'Impossible'\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    c = int(data[1])\n    encounters = [(int(data[i * 3 + 2]), int(data[i * 3 + 3]), int(data[i * 3 + 4])) for i in range(c)]\n    \n    result = find_division_year(n, c, encounters)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975700378417969,
            0.9975633025169373,
            0.996621310710907,
            0.9966665506362915,
            0.9977531433105469,
            0.9973845481872559,
            0.9968387484550476,
            0.9971182942390442,
            0.997191309928894,
            0.9972817301750183,
            0.9963748455047607,
            0.9978179931640625,
            0.9970110654830933,
            0.9972913861274719,
            0.9976428151130676,
            0.9972073435783386,
            0.9967723488807678,
            0.997424304485321,
            0.9971741437911987,
            0.9972056150436401
        ]
    },
    "3621": {
        "similarity": 0.9975184202194214,
        "body": "import sys\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\n    if node in visited:\n        return 0\n    visited.add(node)\n    size = 1\n    for nei in range(len(graph)):\n        if graph[node][nei] == color and nei != node:\n            size += f(graph, nei, color)\n    return size\n\n    total_sum = 0\n    for start in range(n):\n        visited = set()\n        for color in range(1, 301):\n            if graph[start][color] > 0 and color not in visited:\n                size = f(graph, start, color)\n                for i in range(size):\n                    total_sum += size - i\n                    total_sum %= MOD\n    return total_sum\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    graph = [list(map(int, input().strip().split())) for _ in range(n)]\n    print(solve(n, graph))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965906739234924,
            0.9974185824394226,
            0.9957674145698547,
            0.9948717355728149,
            0.9966492056846619,
            0.9964569807052612,
            0.9966555237770081,
            0.9966766834259033,
            0.9967905282974243,
            0.9960494637489319,
            0.9960504174232483,
            0.9970293641090393,
            0.9960861206054688,
            0.9966310262680054,
            0.9972558617591858,
            0.9966622591018677,
            0.9947341084480286,
            0.9975184202194214,
            0.9970867037773132,
            0.9972909688949585
        ]
    },
    "3392": {
        "similarity": 0.9979824423789978,
        "body": "import sys\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < N and 0 <= y < N\n    \n        stack = [(x, y)]\n        visited.add((x, y))\n        \n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited and heights[nx][ny] == target_height:\n                    stack.append((nx, ny))\n                    visited.add((nx, ny))\n        \n        return len(visited)\n    \n    max_size = 0\n    \n    for i in range(N):\n        for j in range(N):\n            target_height = heights[i][j]\n            visited = set()\n            size = dfs(i, j, target_height)\n            if size > max_size:\n                max_size = size\n    \n    return max_size\n\n# Read input\nN = int(input())\nheights = [list(map(int, input().split())) for _ in range(N)]\ngrowth_speeds = [list(map(int, input().split())) for _ in range(N)]\n\n# Output result\nprint(largest_connected_group(N, heights, growth_speeds))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963306784629822,
            0.9963249564170837,
            0.9979824423789978,
            0.9970921874046326,
            0.9961249828338623,
            0.9979069232940674,
            0.9977666735649109,
            0.9952788352966309,
            0.9975560903549194,
            0.997208833694458,
            0.9979003071784973,
            0.9977108836174011,
            0.9978232383728027,
            0.9973552227020264,
            0.9978187084197998,
            0.997578501701355,
            0.9954227805137634,
            0.9967507719993591,
            0.9975273013114929,
            0.9966809153556824
        ]
    },
    "3095": {
        "similarity": 0.9970837831497192,
        "body": "import sys\n\n    return matrix[r1][c1] + matrix[r2][c2] <= matrix[r1][c2] + matrix[r2][c1]\n\n    max_elements = 0\n    for r1 in range(R - 1):\n        for c1 in range(S - 1):\n            for r2 in range(r1 + 1, R):\n                for c2 in range(c1 + 1, S):\n                    if is_cool_submatrix(A, r1, c1, r2, c2):\n                        max_elements = max(max_elements, (r2 - r1 + 1) * (c2 - c1 + 1))\n    return max_elements\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    R = int(data[0])\n    S = int(data[1])\n    A = []\n    for i in range(R):\n        row = list(map(int, data[2 + i * S : 2 + (i + 1) * S]))\n        A.append(row)\n    \n    result = max_elements_in_extremely_cool_submatrix(R, S, A)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945018291473389,
            0.9953097105026245,
            0.9940667748451233,
            0.9969512820243835,
            0.9970837831497192,
            0.9929618835449219,
            0.9961495995521545,
            0.9953868389129639,
            0.9951683878898621,
            0.9964631795883179,
            0.9955188632011414,
            0.9963815808296204,
            0.9957960844039917,
            0.9968443512916565,
            0.9967225790023804,
            0.9959478974342346,
            0.9956125020980835,
            0.996484637260437,
            0.9966126680374146,
            0.9970462322235107
        ]
    },
    "3769": {
        "similarity": 0.9972337484359741,
        "body": "    modulo = 10**9 + 7\n    if k == 0:\n        return 1\n    else:\n        result = pow(k, p - 2, modulo)\n        return (result * result) % modulo\n\nif __name__ == \"__main__\":\n    p, k = map(int, input().split())\n    print(count_functions(p, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925936460494995,
            0.9954009056091309,
            0.9958717226982117,
            0.9965038299560547,
            0.9963816404342651,
            0.9939683675765991,
            0.9959160685539246,
            0.996211588382721,
            0.996293842792511,
            0.9964222311973572,
            0.9967088103294373,
            0.9972337484359741,
            0.9960240721702576,
            0.991132915019989,
            0.995897114276886,
            0.9944777488708496,
            0.9962125420570374,
            0.9955394268035889,
            0.9958080649375916,
            0.9968845844268799
        ]
    },
    "3563": {
        "similarity": 0.9967480897903442,
        "body": "import sys\n\n    # Sort the holes by x-coordinate, and for ties, by y-coordinate\n    sorted_holes = sorted(holes, key=lambda h: (h[0], h[1]))\n    \n    lines = 0\n    last_line_end_y = -sys.maxsize\n    \n    for i in range(n):\n        if i == 0 or sorted_holes[i][1] > last_line_end_y:\n            lines += 1\n            last_line_end_y = sorted_holes[i][1]\n    \n    return lines\n\nif __name__ == \"__main__\":\n    n = int(input())\n    holes = [tuple(map(int, input().split())) for _ in range(n * 2)]\n    result = min_lines_to_cover_holes(n, holes)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952358603477478,
            0.9958617687225342,
            0.9943452477455139,
            0.9945396780967712,
            0.9953669309616089,
            0.9950780272483826,
            0.9951515197753906,
            0.9948907494544983,
            0.994096040725708,
            0.9958265423774719,
            0.9940926432609558,
            0.9955624938011169,
            0.9942597150802612,
            0.9963963031768799,
            0.9963188171386719,
            0.9967480897903442,
            0.9953864216804504,
            0.9963535666465759,
            0.9959710836410522,
            0.9960202574729919
        ]
    },
    "3618": {
        "similarity": 0.9970358610153198,
        "body": "    if n == 1:\n        return 10 % 998244353\n    mod = 998244353\n    dp = [0] * (n + 1)\n    dp[1] = 10\n    for i in range(2, n + 1):\n        dp[i] = ((dp[i - 1] * 9) % mod + dp[i - 1]) % mod\n    return dp[n]\n\n# Read input from stdin\nn = int(input().strip())\n\n# Print the result\nprint(count_best_friend_pairs(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970323443412781,
            0.9948976635932922,
            0.9968145489692688,
            0.9967755079269409,
            0.9895990490913391,
            0.9970358610153198,
            0.9962658286094666,
            0.9965977072715759,
            0.9968448281288147,
            0.9957463145256042,
            0.9968276619911194,
            0.9960899353027344,
            0.9925046563148499,
            0.9968374967575073,
            0.996601939201355,
            0.9965664744377136,
            0.9954743981361389,
            0.996212899684906,
            0.9966671466827393,
            0.9908065795898438
        ]
    },
    "3830": {
        "similarity": 0.9967790246009827,
        "body": "    returnable_count = 0\n    for i in range(n):\n        can_leave = True\n        current_room = i\n        for _ in range(2 * n):\n            if s[(current_room + 1) % n] == '>':\n                current_room = (current_room + 1) % n\n            elif s[current_room] == '<':\n                current_room = (current_room - 1) % n\n            else:\n                break\n            if current_room == i:\n                can_leave = True\n                break\n        if not can_leave:\n            returnable_count += 1\n    return n - returnable_count\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n = int(input())\n    s = input().strip()\n    results.append(count_returnable_rooms(n, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996462881565094,
            0.994961678981781,
            0.9954995512962341,
            0.9946284890174866,
            0.9944839477539062,
            0.9958997964859009,
            0.995985746383667,
            0.9950773119926453,
            0.9948746562004089,
            0.9966214895248413,
            0.9956713318824768,
            0.9967790246009827,
            0.996138334274292,
            0.9919416308403015,
            0.9953011870384216,
            0.9960688352584839,
            0.993770182132721,
            0.9961192607879639,
            0.9966054558753967,
            0.9936856627464294
        ]
    },
    "3912": {
        "similarity": 0.997697114944458,
        "body": "import collections\nimport sys\n\n    n = len(s)\n    char_count = collections.Counter(s)\n    total_chars = sum(char_count.values())\n    \n    # Determine the minimum length of each palindrome part\n    for length in range(1, n + 1):\n        if total_chars % length == 0:\n            break\n    \n    k = total_chars // length\n    result = [''] * k\n    i = 0\n    \n    while char_count and length > 0:\n        for char, count in sorted(char_count.items()):\n            if count > 0:\n                result[i] += char\n                char_count[char] -= 1\n                total_chars -= 1\n                length -= 1\n                if char_count[char] == 0:\n                    del char_count[char]\n        \n        i += 1\n    \n    return k, result\n\n# Read input from stdin\nn = int(input())\ns = input().strip()\n\nk, palindromes = min_palindrome_parts(s)\nprint(k)\nprint(*palindromes)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971479177474976,
            0.9962580800056458,
            0.9944459795951843,
            0.9964474439620972,
            0.9963774681091309,
            0.9973069429397583,
            0.9960567951202393,
            0.9972193837165833,
            0.9959844350814819,
            0.9976280927658081,
            0.997697114944458,
            0.9971327781677246,
            0.9967659711837769,
            0.9971259236335754,
            0.9972515106201172,
            0.996306300163269,
            0.9976229667663574,
            0.9965634942054749,
            0.9972891807556152,
            0.9966429471969604
        ]
    },
    "3878": {
        "similarity": 0.9977656006813049,
        "body": "import sys\n\n    friends = [set() for _ in range(n)]\n    for u, v in edges:\n        friends[u-1].add(v-1)\n        friends[v-1].add(u-1)\n\n    steps = 0\n    selected_guests = []\n    \n    while len(friends[0]) < n - 1:  # Assuming guest 1 is the starting point\n        found = False\n        for i in range(1, n):\n            if friends[i]:\n                selected_guests.append(i + 1)\n                steps += 1\n                for friend_i in friends[i]:\n                    friends[0].add(friend_i)\n                    for f_f in friends[friend_i]:\n                        friends[0].add(f_f)\n                found = True\n                break\n        if not found:\n            return -1  # In case no valid guest can be selected\n    \n    print(steps)\n    print(\" \".join(map(str, selected_guests)))\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    edges = [(int(data[i*2+2]), int(data[i*2+3])) for i in range(m)]\n    \n    min_steps_to_make_friends(n, m, edges)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977656006813049,
            0.9976593852043152,
            0.9948456287384033,
            0.9968902468681335,
            0.9970584511756897,
            0.9967687726020813,
            0.9969834089279175,
            0.9973926544189453,
            0.9963064789772034,
            0.9968785643577576,
            0.9972682595252991,
            0.9964348673820496,
            0.9966025948524475,
            0.997413158416748,
            0.9973337054252625,
            0.9977595806121826,
            0.9968217611312866,
            0.9958195090293884,
            0.9973383545875549,
            0.9970474243164062
        ]
    },
    "3010": {
        "similarity": 0.9964451193809509,
        "body": "    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        if x0 == x1:\n            min_y = min(y0, y1)\n            max_y = max(y0, y1)\n            for j in range(min_y, max_y + 1):\n                points.add((x0, j))\n        else:\n            slope = (y1 - y0) / (x1 - x0)\n            intercept = y0 - slope * x0\n            for j in range(n):\n                if i != j:\n                    x2, y2, x3, y3 = lines[j]\n                    if x2 == x3:\n                        y = int(slope * x2 + intercept)\n                        if y == y2 or y == y3:\n                            points.add((x2, y))\n        if len(points) > 1000000:\n            return -1\n    return len(points)\n\nn = int(input())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\nprint(count_distinct_points(n, lines))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9857904314994812,
            0.9964451193809509,
            0.9929947257041931,
            0.9946582317352295,
            0.9959995746612549,
            0.9949235320091248,
            0.9951865673065186,
            0.9958205819129944,
            0.9958105683326721,
            0.9951950907707214,
            0.9956974387168884,
            0.9956936240196228,
            0.9949490427970886,
            0.995462954044342,
            0.9954338073730469,
            0.9953322410583496,
            0.9939579367637634,
            0.994338870048523,
            0.9953935742378235,
            0.9950993061065674
        ]
    },
    "3068": {
        "similarity": 0.9969960451126099,
        "body": "from collections import defaultdict\n\n    suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    counts = [defaultdict(int) for _ in range(3)]\n    \n    for _ in range(investigations):\n        a, b, player, reply = input().split()\n        a, b = ord(a) - ord('A'), ord(b) - ord('A')\n        \n        counts[player][a] += 1\n        counts[player][b] += 1\n    \n    admissible_solutions = set()\n    \n    for combo in suspects:\n        if len(combo) != 3:\n            continue\n        \n        valid = True\n        for player in range(2):\n            if (counts[player][combo[0]] + counts[player][combo[1]] + counts[player][combo[2]]) != 1:\n                valid = False\n                break\n        \n        if valid:\n            admissible_solutions.add(tuple(sorted(combo)))\n    \n    return len(admissible_solutions)\n\n# Read input and output the result\ninvestigations = int(input())\nresult = count_admissible_solutions(investigations)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957047700881958,
            0.9966061115264893,
            0.9952501058578491,
            0.9959122538566589,
            0.9917759299278259,
            0.9965620636940002,
            0.9931737184524536,
            0.9955806732177734,
            0.9961775541305542,
            0.9969960451126099,
            0.996728777885437,
            0.9956930875778198,
            0.9937567710876465,
            0.9969303607940674,
            0.9933177828788757,
            0.9968530535697937,
            0.9942042827606201,
            0.9954686760902405,
            0.9954478740692139,
            0.9965293407440186
        ]
    },
    "3030": {
        "similarity": 0.9967443346977234,
        "body": "import sys\nfrom collections import defaultdict\n\n    parent_map = defaultdict(list)\n    for i in range(1, n):\n        parent_map[nodes[i][1]].append(i)\n    \n        if not parent_map[node]:\n            return 1\n        max_count = 0\n        for child in parent_map[node]:\n            max_count = max(max_count, dfs(child))\n        return 1 + max_count\n    \n    return max(dfs(node) for node in range(n))\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    nodes = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    print(max_heap_subset_size(n, nodes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965323209762573,
            0.9953921437263489,
            0.9967168569564819,
            0.9967443346977234,
            0.9964589476585388,
            0.9963409304618835,
            0.9959154725074768,
            0.9933756589889526,
            0.9966066479682922,
            0.987030029296875,
            0.9959496259689331,
            0.9954861998558044,
            0.9949039816856384,
            0.9964087605476379,
            0.9962798953056335,
            0.9966518878936768,
            0.9962792992591858,
            0.9958385825157166,
            0.996512770652771,
            0.9960283041000366
        ]
    },
    "3630": {
        "similarity": 0.9977692365646362,
        "body": "    n = len(s1)\n    moves = 0\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            diff = ord(s2[i]) - ord(s1[i])\n            if diff < 0:\n                diff += 26\n            moves += diff\n    \n    return moves\n\n# Read input\ns1, s2 = input().split()\n# Print the result\nprint(min_moves_to_modify(s1, s2))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974251985549927,
            0.9974071979522705,
            0.9960684776306152,
            0.995410144329071,
            0.9969010949134827,
            0.9970546364784241,
            0.9949063658714294,
            0.9973308444023132,
            0.9973412752151489,
            0.9977692365646362,
            0.9960391521453857,
            0.9964345693588257,
            0.9965214133262634,
            0.9975662231445312,
            0.9970881938934326,
            0.9960934519767761,
            0.9968858361244202,
            0.9969526529312134,
            0.9971357583999634,
            0.9969854950904846
        ]
    },
    "3133": {
        "similarity": 0.9969271421432495,
        "body": "import sys\n\n    stack_a = [a]\n    stack_b = [b]\n    \n    while True:\n        if not stack_a or not stack_b:\n            return \"indistinguishable\"\n        \n        current_a = stack_a.pop()\n        current_b = stack_b.pop()\n        \n        for _ in range(2):\n            next_a = intersections[current_a][0] if _ == 0 else intersections[current_a][1]\n            next_b = intersections[current_b][0] if _ == 0 else intersections[current_b][1]\n            \n            if next_a != current_a and next_b != current_b:\n                stack_a.append(next_a)\n                stack_b.append(next_b)\n    \n    return \"indistinguishable\"\n\n# Read input\nn, a, b = map(int, input().split())\nintersections = []\nfor _ in range(n):\n    l, r, t = map(int, input().split())\n    intersections.append((l, r, t))\n\n# Calculate and print result\nprint(min_turns_to_distinguish(n, a, b, intersections))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962449669837952,
            0.9945396780967712,
            0.9963728189468384,
            0.9962011575698853,
            0.9960548877716064,
            0.9963775277137756,
            0.9963667988777161,
            0.9940506815910339,
            0.9937576651573181,
            0.9959266185760498,
            0.9950191974639893,
            0.9948059916496277,
            0.99591463804245,
            0.9969271421432495,
            0.9928094148635864,
            0.996403157711029,
            0.9952692985534668,
            0.9961186647415161,
            0.9962411522865295,
            0.9958574175834656
        ]
    },
    "3480": {
        "similarity": 0.9971838593482971,
        "body": "    L, D = map(int, input().split())\n    for _ in range(L):\n        first_voice_line = input()\n        second_voice_times = list(map(int, input().split()))\n        first_voice_syllables = first_voice_line.split()\n        \n        for i in range(len(first_voice_syllables)):\n            first_voice_start = D + sum(second_voice_times[:i])\n            first_voice_end = first_voice_start + second_voice_times[i]\n            second_voice_start = 0\n            second_voice_end = 128\n            \n            if first_voice_start < second_voice_end and second_voice_start <= first_voice_end:\n                second_voice_offset = max(0, first_voice_start - second_voice_start)\n                print(f\"{first_voice_syllables[i]}{'_' * second_voice_offset}{second_voice_syllables[i]}\")\n            else:\n                print(first_voice_syllables[i] + '_' * (128 - len(first_voice_syllables[i])))\n\ngenerate_round()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971838593482971,
            0.997037410736084,
            0.9966779947280884,
            0.9965659976005554,
            0.9944795370101929,
            0.9947032928466797,
            0.996211588382721,
            0.9970307946205139,
            0.9968365430831909,
            0.992996096611023,
            0.9967125654220581,
            0.996890127658844,
            0.9965137839317322,
            0.9969710111618042,
            0.9961455464363098,
            0.995898425579071,
            0.9961597919464111,
            0.9966565370559692,
            0.9967384338378906,
            0.9929774403572083
        ]
    },
    "3389": {
        "similarity": 0.9979827404022217,
        "body": "import sys\n\n    current_video = None\n    clicks = 0\n    \n    for video_type in video_types:\n        if video_type != current_video:\n            clicks += 1\n            current_video = video_type\n            \n    return clicks\n\n# Read input from stdin\nn, k = map(int, input().split())\nvideo_types = input().strip()\n\n# Output the result\nprint(min_clicks_to_watch_videos(n, k, video_types))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979539513587952,
            0.996017336845398,
            0.9976555705070496,
            0.9977595806121826,
            0.9961761832237244,
            0.9979796409606934,
            0.9962868094444275,
            0.9974824786186218,
            0.997333824634552,
            0.9955326914787292,
            0.997633695602417,
            0.9974046945571899,
            0.9979827404022217,
            0.9971814751625061,
            0.9974344372749329,
            0.9947304129600525,
            0.9974949359893799,
            0.9956815838813782,
            0.9973230957984924,
            0.9970787763595581
        ]
    },
    "3925": {
        "similarity": 0.9980849027633667,
        "body": "    n = len(s)\n    max_len = 0\n    for i in range(n):\n        current_len = 1\n        for j in range(i + 1, n):\n            if s[j] != s[j - 1]:\n                current_len += 1\n            else:\n                break\n        max_len = max(max_len, current_len)\n    return max_len\n\n# Read input from stdin\ns = input().strip()\n\n# Print the result\nprint(max_zebra_length(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974721670150757,
            0.9952627420425415,
            0.9970224499702454,
            0.9977292418479919,
            0.9976142048835754,
            0.9970870614051819,
            0.9971304535865784,
            0.9960780739784241,
            0.9974400401115417,
            0.9968031048774719,
            0.9977117776870728,
            0.9931081533432007,
            0.9976164102554321,
            0.9980849027633667,
            0.9979630708694458,
            0.9971169829368591,
            0.9975172281265259,
            0.9905897378921509,
            0.9971550703048706,
            0.9979641437530518
        ]
    },
    "3700": {
        "similarity": 0.9979380369186401,
        "body": "    count = 0\n    for i in range(1, n+1):\n        j = k - i\n        if j > i and j <= n:\n            count += 1\n    return count\n\nn, k = map(int, input().split())\nprint(count_ways(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978172183036804,
            0.9978960752487183,
            0.9954127073287964,
            0.9976979494094849,
            0.9977633953094482,
            0.9940362572669983,
            0.9970541596412659,
            0.9979380369186401,
            0.9975286722183228,
            0.9956827759742737,
            0.9970622658729553,
            0.9966621398925781,
            0.9946297407150269,
            0.9972544312477112,
            0.9971655607223511,
            0.9971602559089661,
            0.9978322386741638,
            0.9977218508720398,
            0.9970709085464478,
            0.9974194765090942
        ]
    },
    "3944": {
        "similarity": 0.9939609169960022,
        "body": "import sys\n\nMOD = 10**9 + 7\n\n    total_patterns = pow(3, n + m + k, MOD)\n    winning_patterns = 0\n    \n    for i in range(n):\n        if i % 3 == 0:\n            winning_patterns += (3 * pow(3, m + k - 1, MOD)) % MOD\n        elif i % 3 == 1:\n            winning_patterns += ((2 * pow(3, m - 1, MOD) + pow(3, k - 1, MOD)) % MOD)\n        else:\n            winning_patterns += ((2 * pow(3, k - 1, MOD) + pow(3, m - 1, MOD)) % MOD)\n    \n    return (winning_patterns * pow(3**(n + m + k), MOD - 2, MOD)) % MOD\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(count_winning_decks(n, m, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938595294952393,
            0.9920018911361694,
            0.9939609169960022,
            0.9912788271903992,
            0.9939099550247192,
            0.9913956522941589,
            0.991959810256958,
            0.9927903413772583,
            0.9938914775848389,
            0.9917994141578674,
            0.9865691661834717,
            0.9806113243103027,
            0.991188645362854,
            0.9917270541191101,
            0.991519033908844,
            0.9930986166000366,
            0.9902142882347107,
            0.9902829527854919,
            0.9938316345214844,
            0.9917046427726746
        ]
    },
    "3821": {
        "similarity": 0.9969369769096375,
        "body": "import itertools\nimport sys\n\n    max_probability = 0\n    for k in range(1, n + 1):\n        for subset in itertools.combinations(p, k):\n            probability = 1 * (1 - sum(subset)) ** (n - k)\n            for prob in subset:\n                probability *= prob\n            if probability > max_probability:\n                max_probability = probability\n    return max_probability\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\np = list(map(float, data[1:]))\n\nprint(f\"{max_prob(n, p):.12f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936419129371643,
            0.9966717958450317,
            0.9957737326622009,
            0.9951109886169434,
            0.9952573180198669,
            0.9963957071304321,
            0.9960259199142456,
            0.9969369769096375,
            0.9958980083465576,
            0.9967896342277527,
            0.9968087077140808,
            0.9964115619659424,
            0.9952663779258728,
            0.9930307269096375,
            0.9968804121017456,
            0.9960912466049194,
            0.9953548908233643,
            0.9968174695968628,
            0.9960859417915344,
            0.994480550289154
        ]
    },
    "3667": {
        "similarity": 0.9964309334754944,
        "body": "import sys\n\n    intersections = set()\n    for s, x1, y1 in pipes:\n        for t, x2, y2 in pipes:\n            if s != t and (x1 == x2 or y1 == y2) and abs(x1 - x2) + abs(y1 - y2) == 0:\n                intersections.add((min(x1, x2), min(y1, y2)))\n    \n    for i, (sx, sy) in enumerate(wells):\n        if any(sx == px or sy == py for _, px, py in pipes[:i+1]):\n            continue\n        for j, (tx, ty) in enumerate(wells[i+1:], start=i+1):\n            if tx == sx and ty == sy:\n                return \"possible\"\n    \n    return \"impossible\"\n\n# Read input from stdin\nw, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for _ in range(w)]\npipes = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output the result\nprint(can_clean_pipes(w, p, wells, pipes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950372576713562,
            0.9943784475326538,
            0.9956358075141907,
            0.9922369122505188,
            0.9964309334754944,
            0.995289146900177,
            0.9955062866210938,
            0.9948531985282898,
            0.9956761598587036,
            0.9912609457969666,
            0.994770348072052,
            0.994594156742096,
            0.995508074760437,
            0.9952543377876282,
            0.9941243529319763,
            0.9942959547042847,
            0.9915456175804138,
            0.9950840473175049,
            0.9941784739494324,
            0.9941147565841675
        ]
    },
    "3959": {
        "similarity": 0.9976624846458435,
        "body": "import sys\nfrom collections import Counter\n\n    MOD = 10**9 + 7\n    \n        result = 1\n        for i in range(2, x + 1):\n            result = (result * i) % MOD\n        return result\n    \n    type_counts = Counter()\n    \n    for gym in gyms:\n        types = set(gym[1:])\n        for t in types:\n            type_counts[t] += 1\n    \n    valid_plans = factorial(m)\n    for count in type_counts.values():\n        valid_plans = (valid_plans * pow(factorial(count), MOD - 2, MOD)) % MOD\n    \n    return valid_plans\n\n# Read input\nn, m = map(int, input().split())\ngyms = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(count_evolution_plans(n, m, gyms))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963542819023132,
            0.9953109622001648,
            0.9955573678016663,
            0.9970431923866272,
            0.9958571195602417,
            0.9952929615974426,
            0.9968195557594299,
            0.9966393709182739,
            0.9952582120895386,
            0.9964106678962708,
            0.9972997903823853,
            0.9971650838851929,
            0.9964547753334045,
            0.9960240721702576,
            0.9969533681869507,
            0.9964954257011414,
            0.9976624846458435,
            0.996354341506958,
            0.9955011606216431,
            0.9972946643829346
        ]
    },
    "3692": {
        "similarity": 0.997955858707428,
        "body": "import sys\n\n    n = len(circles)\n    regions = 1  # At least one region outside all circles\n\n    for i in range(n):\n        x1, y1, r1 = circles[i]\n        for j in range(i + 1, n):\n            x2, y2, r2 = circles[j]\n            d = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n            if d <= r1 + r2:\n                regions += 1\n\n    return regions\n\nif __name__ == \"__main__\":\n    n = int(input())\n    circles = []\n    for _ in range(n):\n        x, y, r = map(int, input().split())\n        circles.append((x, y, r))\n    \n    print(count_regions(circles))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977805614471436,
            0.9950373768806458,
            0.9978047609329224,
            0.9931150674819946,
            0.99785315990448,
            0.9976450204849243,
            0.9971635937690735,
            0.9977988004684448,
            0.9974461793899536,
            0.997829020023346,
            0.9973954558372498,
            0.9974375367164612,
            0.9977565407752991,
            0.9963921308517456,
            0.9973219633102417,
            0.997955858707428,
            0.9959840178489685,
            0.9974355101585388,
            0.9963198304176331,
            0.9967621564865112
        ]
    },
    "3894": {
        "similarity": 0.9965904951095581,
        "body": "    total_cows = sum(a)\n    parity_sum = sum(1 if x % 2 != 0 else 0 for x in a)\n    \n    if total_cows == 1:\n        return \"Kevin\"\n    elif total_cows % 2 == 0 and parity_sum > 0:\n        return \"Nicky\"\n    else:\n        return \"Kevin\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(determine_winner(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950806498527527,
            0.9951121807098389,
            0.992268443107605,
            0.9946779012680054,
            0.9949979186058044,
            0.9959586262702942,
            0.992764949798584,
            0.9950690269470215,
            0.9957460165023804,
            0.9960278868675232,
            0.9965904951095581,
            0.9954173564910889,
            0.9932400584220886,
            0.9816445708274841,
            0.9931119680404663,
            0.9953404664993286,
            0.9953945875167847,
            0.9932955503463745,
            0.9955924153327942,
            0.9962520599365234
        ]
    },
    "3856": {
        "similarity": 0.996570885181427,
        "body": "import sys\n\n    friends.sort()\n    vertical = sorted([(w, h) for w, h in friends])\n    horizontal = [(h, w) for w, h in friends]\n    vertical.sort(reverse=True)\n    \n    min_area = float('inf')\n    \n    for i in range(0, n + 1, 2):\n        if i > n // 2:\n            break\n        area = sum(w * max(h, vertical[i + j][1]) for j in range(i)) + sum(w * max(h, horizontal[j][1]) for j in range(n - i))\n        min_area = min(min_area, area)\n    \n    return min_area\n\nif __name__ == \"__main__\":\n    n = int(input())\n    friends = [tuple(map(int, input().split())) for _ in range(n)]\n    print(min_photo_area(n, friends))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957773089408875,
            0.9949902296066284,
            0.9954295754432678,
            0.9961395263671875,
            0.9956554770469666,
            0.9961246848106384,
            0.9896011352539062,
            0.9936946034431458,
            0.9959297180175781,
            0.9924235343933105,
            0.9932196736335754,
            0.9950124621391296,
            0.9961848855018616,
            0.9947365522384644,
            0.9930945038795471,
            0.996570885181427,
            0.9958932995796204,
            0.9897133708000183,
            0.9945743083953857,
            0.9953619241714478
        ]
    },
    "3282": {
        "similarity": 0.998015284538269,
        "body": "import sys\n\n    digits = set(str(P))\n    valid_bills = []\n    for beverage in range(1, P // 2):\n        if str(beverage).intersection(digits):\n            continue\n        for main_dish in range(beverage + 1, P - beverage):\n            if str(main_dish).intersection(digits):\n                continue\n            total = beverage + main_dish\n            if str(total).intersection(digits) or total != P:\n                continue\n            valid_bills.append((beverage, main_dish))\n    return len(valid_bills), valid_bills[:5000]\n\nif __name__ == \"__main__\":\n    P = int(input())\n    count, bills = count_desserts(P)\n    print(count)\n    for bill in bills:\n        print(f\"{bill[0]} {bill[1]}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.998015284538269,
            0.9975067973136902,
            0.9976277947425842,
            0.9965782165527344,
            0.9975461363792419,
            0.9970590472221375,
            0.9973471760749817,
            0.9976617097854614,
            0.9978327751159668,
            0.9976139068603516,
            0.9974066019058228,
            0.9947933554649353,
            0.9961422681808472,
            0.9973107576370239,
            0.9974359273910522,
            0.9964445233345032,
            0.997757077217102,
            0.9944221377372742,
            0.9977439045906067,
            0.9975100159645081
        ]
    },
    "3596": {
        "similarity": 0.9979017376899719,
        "body": "import math\nfrom scipy.special import erf, gamma, jn\n\n        return c * (t1 * gamma(x) + x**(1/t2) * math.log(erf(t3 * x)) - jn(k, x)**t4)\n    \n        p = 0\n        for i in range(r + 1):\n            coeff = f(math.factorial(i))\n            p += coeff / math.factorial(i) * x**i\n        return p\n    \n    Ps = P(n)\n    g = Ps\n    for _ in range(s):\n        g = sum(Ps(i) * x**i for i, x in enumerate(range(r + s + 1)))\n    \n    degree = r + s\n    diff_g = 0\n    for i in range(degree, -1, -1):\n        diff_g *= n\n        if i > 0:\n            diff_g += g / i\n    \n    location = (diff_g + l)**2 / math.pi * math.e + 1 / (l + 1)\n    return round(location, 2)\n\n# Read input from stdin\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\nn, k, r, s, l = map(int, input().split())\n\n# Calculate and print the location of Arnar's opponent\nlocation = calculate_location(a, b, c, t1, t2, t3, t4, n, k, r, s, l)\nprint(location)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969323873519897,
            0.9974403381347656,
            0.9976451396942139,
            0.9965482354164124,
            0.9966849088668823,
            0.9978840351104736,
            0.9968839883804321,
            0.9979017376899719,
            0.9953447580337524,
            0.9974199533462524,
            0.9978370666503906,
            0.9967363476753235,
            0.997434139251709,
            0.9977061748504639,
            0.9976279735565186,
            0.9967225790023804,
            0.997306227684021,
            0.9974510073661804,
            0.9973270297050476,
            0.9970151782035828
        ]
    },
    "3540": {
        "similarity": 0.9963998198509216,
        "body": "import sys\n\n    rows = [list(input().strip()) for _ in range(4)]\n    \n    target_rows = ['R', 'G', 'B', 'Y']\n    moves = 0\n    \n    for i in range(4):\n        current_row = ''.join(rows[i])\n        if current_row != ''.join(target_rows):\n            min_moves = float('inf')\n            for j in range(4):\n                if rows[i][j] == target_rows[0]:\n                    left_moves = (j + 1) % 4\n                    right_moves = (3 - j) % 4\n                    moves_needed = min(left_moves, right_moves)\n                    min_moves = min(min_moves, moves_needed)\n            moves += min_moves\n    \n    return moves\n\nif __name__ == \"__main__\":\n    result = min_moves_to_solve_puzzle()\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955084919929504,
            0.9954277873039246,
            0.9951416850090027,
            0.9929925799369812,
            0.9918955564498901,
            0.9937700033187866,
            0.9947736859321594,
            0.9955474734306335,
            0.9923688769340515,
            0.9939786195755005,
            0.9955745339393616,
            0.9960828423500061,
            0.9959486126899719,
            0.9963998198509216,
            0.9961128234863281,
            0.9950539469718933,
            0.9959829449653625,
            0.9956973195075989,
            0.9953548312187195,
            0.9958572387695312
        ]
    },
    "3354": {
        "similarity": 0.9980137348175049,
        "body": "import math\n\n    total_area = math.pi * s**2\n    pickle_area = math.pi * r**2\n    max_area_covered = (z / 100) * total_area\n    \n    num_p pickles = 0\n    for _ in range(n):\n        if num_pickles >= max_area_covered // pickle_area:\n            break\n        num_p pickles += 1\n    \n    return int(num_p pickles)\n\n# Read input from stdin\ns, r, n, z = map(float, input().split())\nn, z = map(int, input().split())\n\n# Output the result\nprint(max_pickles_on_sandwich(s, r, n, z))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979701638221741,
            0.997952938079834,
            0.9976599812507629,
            0.9968104362487793,
            0.9980137348175049,
            0.9954797625541687,
            0.992883563041687,
            0.9968388080596924,
            0.9977039694786072,
            0.9978810548782349,
            0.9954166412353516,
            0.9951142072677612,
            0.9973214864730835,
            0.9972923994064331,
            0.9978822469711304,
            0.9979836344718933,
            0.9971396923065186,
            0.9939943552017212,
            0.9964168071746826,
            0.9976640939712524
        ]
    },
    "3217": {
        "similarity": 0.9963302612304688,
        "body": "import sys\n\n    x_min = y_min = z_min = float('inf')\n    x_max = y_max = z_max = float('-inf')\n    \n    for cell in defective_cells:\n        x, y, z = cell\n        if x < x_min: x_min = x\n        if y < y_min: y_min = y\n        if z < z_min: z_min = z\n        if x > x_max: x_max = x\n        if y > y_max: y_max = y\n        if z > z_max: z_max = z\n    \n    width = x_max - x_min + 1\n    height = y_max - y_min + 1\n    depth = z_max - z_min + 1\n    \n    return 2 * (width + height + depth) - 4\n\n    n = int(input())\n    \n    result = min_panels(defective_cells)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941595196723938,
            0.9947401285171509,
            0.9944488406181335,
            0.9929764270782471,
            0.9946622252464294,
            0.9952943921089172,
            0.9945612549781799,
            0.9950030446052551,
            0.9928925037384033,
            0.9956178069114685,
            0.9950475096702576,
            0.9963302612304688,
            0.9960739016532898,
            0.9945823550224304,
            0.9960126280784607,
            0.9943426251411438,
            0.9959949851036072,
            0.9960416555404663,
            0.995216965675354,
            0.9931287169456482
        ]
    },
    "3520": {
        "similarity": 0.9966440796852112,
        "body": "import sys\n\n    # Initialize variables\n    current_age = 0\n    current_pill_time = -1\n    best_time = 0\n    \n    for t, x, y in sorted(pills):\n        if t > current_pill_time:\n            current_age += min(x, t - current_pill_time)\n            current_pill_time = t\n        else:\n            current_age += y\n        \n        best_time = max(best_time, current_age + (n - t))\n    \n    return best_time\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\np = int(data[1])\nc = int(data[2])\npills = [(int(data[i*3+3]), int(data[i*3+4]), int(data[i*3+5])) for i in range(p)]\n\n# Calculate and print the result\nprint(max_life(n, p, c, pills))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954789876937866,
            0.9955737590789795,
            0.9953424334526062,
            0.9961503744125366,
            0.9944883584976196,
            0.9966440796852112,
            0.9942249655723572,
            0.996170163154602,
            0.9942131042480469,
            0.9942182302474976,
            0.992750346660614,
            0.9933713674545288,
            0.9951024651527405,
            0.9960933327674866,
            0.9957311749458313,
            0.9957863688468933,
            0.9955317974090576,
            0.9928014874458313,
            0.9941856861114502,
            0.9949192404747009
        ]
    },
    "3475": {
        "similarity": 0.9968255758285522,
        "body": "import sys\n\n    t, n = map(int, input().split())\n    transport_types = [tuple(map(int, input().split())) for _ in range(t)]\n    distances_angles = [tuple(map(int, input().split())) for _ in range(n-1)]\n\n        current_distance = 0\n        last_heading = None\n        used_type = start_type\n\n        for i in range(end_index - start_type + 1):\n            d_i, h_i = distances_angles[i]\n            if last_heading is not None:\n                heading_change = abs(h_i - last_heading)\n                if heading_change > r_max or (heading_change < -r_max and heading_change + 360000 <= r_max):\n                    return False\n            current_distance += d_i\n            if i != end_index - start_type:\n                last_heading = h_i\n\n        return current_distance >= d_min\n\n    min_swaps = float('inf')\n    for i in range(t):\n        for j in range(i, n-1):\n            if is_valid_route(i, j):\n                min_swaps = min(min_swaps, j - i + 1)\n\n    print(min_swaps if min_swaps != float('inf') else 'IMPOSSIBLE')\n\nmin_transfers()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963257312774658,
            0.9959090352058411,
            0.9953659772872925,
            0.9963477253913879,
            0.9968255758285522,
            0.9963843822479248,
            0.9955859780311584,
            0.995253324508667,
            0.9967591166496277,
            0.9954527020454407,
            0.9960485696792603,
            0.9963775277137756,
            0.9965258240699768,
            0.9961113333702087,
            0.9946522116661072,
            0.9966701865196228,
            0.9961344003677368,
            0.9954354166984558,
            0.9967196583747864,
            0.9958456158638
        ]
    },
    "3977": {
        "similarity": 0.9969666004180908,
        "body": "import sys\n\n    # Create adjacency list for the graph\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n    \n    # Sort countries to process smaller ones first\n    c.sort()\n    \n    max_added_edges = 0\n    \n    # Try adding an edge from each country to every other non-country node\n    for i in range(k):\n        current_country = c[i]\n        for j in range(1, n + 1):\n            if j != current_country and j not in adj_list[current_country]:\n                max_added_edges += 1\n    \n    return max_added_edges\n\n# Read input from stdin\nn, m, k = map(int, input().split())\nc = list(map(int, input().split()))\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_edges(n, m, k, c, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944233298301697,
            0.9956207275390625,
            0.9954942464828491,
            0.993204653263092,
            0.9953338503837585,
            0.9951613545417786,
            0.995090901851654,
            0.9938011169433594,
            0.9959311485290527,
            0.9968822002410889,
            0.9969666004180908,
            0.9948517680168152,
            0.9954349398612976,
            0.9942951202392578,
            0.9952134490013123,
            0.9959123730659485,
            0.9966884255409241,
            0.9955665469169617,
            0.9968544840812683,
            0.9966139793395996
        ]
    },
    "3626": {
        "similarity": 0.9984836578369141,
        "body": "    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, x2, y2 = rectangles[i]\n            x3, y3, x4, y4 = rectangles[j]\n            if not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1):\n                return 1\n    return 0\n\nif __name__ == \"__main__\":\n    n = int(input())\n    rectangles = [tuple(map(int, input().split())) for _ in range(n)]\n    print(check_rectangle_intersection(n, rectangles))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997938871383667,
            0.9978538155555725,
            0.9971675872802734,
            0.997816801071167,
            0.9967564940452576,
            0.9963651895523071,
            0.99832683801651,
            0.9974722862243652,
            0.9971243143081665,
            0.9967023134231567,
            0.9976136088371277,
            0.9977107644081116,
            0.9976406097412109,
            0.9979822039604187,
            0.9981133341789246,
            0.9984836578369141,
            0.9974895119667053,
            0.9960406422615051,
            0.9975028038024902,
            0.9983150959014893
        ]
    },
    "3584": {
        "similarity": 0.9968696236610413,
        "body": "import sys\nfrom itertools import combinations\n\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\n    n = len(points)\n    if n < 3:\n        return points\n    \n    l = min(range(n), key=lambda i: (points[i][0], points[i][1]))\n    hull = []\n    p = l\n    q = (l + 1) % n\n    while True:\n        hull.append(p)\n        q = (q + 1) % n\n        for r in range(n):\n            if orientation(points[p], points[q], points[r]) == 2:\n                q = r\n        p = q\n        if p == l:\n            break\n    \n    return [points[i] for i in hull]\n\n    convex_posts = convex_hull(posts)\n    m = len(convex_posts)\n    \n    max_protected = 0\n    for k in range(K + 1):\n        for combo in combinations(range(m), m - K + k):\n            selected_posts = [convex_posts[i] for i in combo]\n            protected_onions = sum(orientation(selected_posts[-2], selected_posts[-1], onion) == 0 or orientation(selected_posts[-2], selected_posts[-1], onion) > 0 for onion in onions)\n            max_protected = max(max_protected, protected_onions)\n    \n    return max_protected\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    K = int(data[index])\n    index += 1\n    \n    onions = []\n    for _ in range(N):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        index += 2\n        onions.append((X, Y))\n    \n    posts = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        index += 2\n        posts.append((A, B))\n    \n    result = max_onions(N, M, K, onions, posts)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963788390159607,
            0.996651291847229,
            0.9967803955078125,
            0.9965471029281616,
            0.9962317943572998,
            0.9967944622039795,
            0.9959166646003723,
            0.9964414238929749,
            0.9960178732872009,
            0.9958177804946899,
            0.9965448975563049,
            0.9899008870124817,
            0.9925841093063354,
            0.9965922832489014,
            0.9963019490242004,
            0.9968696236610413,
            0.9950366616249084,
            0.9966964721679688,
            0.9960803985595703,
            0.9946151375770569
        ]
    },
    "3950": {
        "similarity": 0.9970798492431641,
        "body": "    if any(x == 0 for x in a):\n        return \"NO\"\n    \n    result = [0] * n\n    queries = []\n    \n    for i in range(q):\n        segment = list(range(1, n + 1))\n        for j in range(n):\n            if a[j] <= i + 1:\n                segment.remove(j + 1)\n        \n        if not segment:\n            return \"NO\"\n        \n        l = min(segment) - 1\n        r = max(segment)\n        queries.append((l, r))\n        for k in range(l, r + 1):\n            result[k] = i + 1\n    \n    return \"YES\\n\" + ' '.join(map(str, result))\n\n# Read input from stdin\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the output\nprint(can_be_obtained(n, q, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967470765113831,
            0.9941655397415161,
            0.9952679872512817,
            0.9961594343185425,
            0.9950540661811829,
            0.9965647459030151,
            0.9942418336868286,
            0.995822012424469,
            0.9950714111328125,
            0.9961326122283936,
            0.9961529970169067,
            0.9964385032653809,
            0.9965184926986694,
            0.9947638511657715,
            0.9947025775909424,
            0.9960881471633911,
            0.9944249391555786,
            0.9961240887641907,
            0.9967103600502014,
            0.9970798492431641
        ]
    },
    "3075": {
        "similarity": 0.9976904988288879,
        "body": "import sys\n\n    gas_stations.sort()\n    total_cost = 0\n    current_fuel = g\n    \n    for i in range(n - 1):\n        distance_to_next_station = gas_stations[i + 1] - gas_stations[i]\n        \n        if current_fuel < distance_to_next_station:\n            return \"cancel road trip\"\n        \n        refuel_amount = min(distance_to_next_station, current_fuel)\n        total_cost += refuel_amount * gas_stations[i][1]\n        current_fuel -= refuel_amount\n    \n    return total_cost\n\n# Read input\nn, g = map(int, input().split())\ngas_stations = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(min_cost_to_travel(n, g, gas_stations))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996648907661438,
            0.997653067111969,
            0.9963732361793518,
            0.9975670576095581,
            0.9960494041442871,
            0.9958447813987732,
            0.9961488842964172,
            0.9975376129150391,
            0.9967043995857239,
            0.9970588684082031,
            0.9944797158241272,
            0.9967886209487915,
            0.9968312978744507,
            0.995394766330719,
            0.996791422367096,
            0.9975185394287109,
            0.9976904988288879,
            0.9974998831748962,
            0.9972532391548157,
            0.9961224794387817
        ]
    },
    "3711": {
        "similarity": 0.9973164796829224,
        "body": "    if n * m - k < 1:\n        return -1\n    pieces = [n, m]\n    for _ in range(k):\n        pieces.sort()\n        small = pieces.pop(0)\n        pieces.append((small + pieces[0]) // 2)\n    pieces.sort()\n    return pieces[0]\n\n# Read input from stdin\nn, m, k = map(int, input().split())\nprint(max_min_piece_area(n, m, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962411522865295,
            0.9958208203315735,
            0.9963639974594116,
            0.9957361817359924,
            0.9954873323440552,
            0.9950592517852783,
            0.9962612986564636,
            0.9941601157188416,
            0.9968599081039429,
            0.9962058663368225,
            0.9958865642547607,
            0.9964603781700134,
            0.9955434203147888,
            0.9963688254356384,
            0.9955621957778931,
            0.9973164796829224,
            0.9964386820793152,
            0.9971093535423279,
            0.9966376423835754,
            0.9964119791984558
        ]
    }
}