{
    "4693": {
        "similarity": 0.999345064163208,
        "body": "A, B = map(int, input().split())\nresult = A + B\nif result >= 10:\n    print(\"error\")\nelse:\n    print(result)",
        "result": "passed",
        "similarities": [
            0.999345064163208,
            0.999345064163208,
            0.999345064163208,
            0.999345064163208,
            0.9991088509559631,
            0.9989076256752014,
            0.9989076256752014,
            0.9991088509559631,
            0.9989076256752014,
            0.9989076256752014,
            0.9989076256752014,
            0.9989076256752014,
            0.999345064163208,
            0.999345064163208,
            0.9989076256752014,
            0.9990460276603699,
            0.9991088509559631,
            0.999345064163208,
            0.9991088509559631,
            0.999345064163208
        ]
    },
    "4077": {
        "similarity": 0.9971413016319275,
        "body": "    from sortedcontainers import SortedList\n        n = len(lst)\n        return lst[n // 2] if n % 2 == 1 else lst[n // 2 - 1]\n    \n    count = 0\n    sl = SortedList()\n    for i in range(n):\n        sl.add(a[i])\n        left, right = 0, len(sl) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if median(sl[mid:right+1]) == m:\n                count += len(sl[:mid])\n                break\n            elif median(sl[left:mid+1]) < m:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return count\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_median_pairs(n, m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971413016319275,
            0.9953033924102783,
            0.9968170523643494,
            0.9964194893836975,
            0.9964780211448669,
            0.9965777397155762,
            0.9967246055603027,
            0.9956845641136169,
            0.9874932169914246,
            0.9946582317352295,
            0.9960997700691223,
            0.9952499270439148,
            0.9962224364280701,
            0.9959172606468201,
            0.9922230243682861,
            0.9955717325210571,
            0.995874285697937,
            0.9947091341018677,
            0.9956406950950623,
            0.9949749708175659
        ]
    },
    "4006": {
        "similarity": 0.9984865784645081,
        "body": "    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current += 1\n        while str(current).endswith('0'):\n            current //= 10\n    return len(reachable)\n\n# Read input from stdin\nn = int(input().strip())\n# Print the result\nprint(count_reachable_numbers(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973901510238647,
            0.998142659664154,
            0.9980286359786987,
            0.9983768463134766,
            0.9980169534683228,
            0.9984865784645081,
            0.9981715679168701,
            0.9976378083229065,
            0.9983768463134766,
            0.9977619647979736,
            0.9973264336585999,
            0.9979532957077026,
            0.9984669089317322,
            0.998346209526062,
            0.9982153177261353,
            0.9980442523956299,
            0.9983395338058472,
            0.9974027872085571,
            0.9977161884307861,
            0.9983671307563782
        ]
    },
    "4556": {
        "similarity": 0.9943757653236389,
        "body": "s = input().split()[1]\nprint(s[0].upper() + s[2:].replace(' ', ''))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9934293031692505,
            0.9924598336219788,
            0.9932203888893127,
            0.9921417236328125,
            0.992073655128479,
            0.9897096753120422,
            0.9943757653236389,
            0.9924197793006897,
            0.994072675704956,
            0.991582989692688,
            0.9923734068870544,
            0.9935508370399475,
            0.9935626983642578,
            0.9935626983642578,
            0.9938952922821045,
            0.9930325746536255,
            0.9936017394065857,
            0.9843853712081909,
            0.9928258657455444,
            0.9876517057418823
        ]
    },
    "4571": {
        "similarity": 0.9969369769096375,
        "body": "import sys\n\n    total_time = 0\n    success_probability = 1 / 2\n    failure_probability = 1 - success_probability\n    \n    for i in range(1, M + 1):\n        total_time += (i * 1900) * (success_probability ** (i - 1)) * failure_probability\n    \n    for i in range(M, N):\n        total_time += (100)\n    \n    return int(total_time)\n\n# Read input from stdin\nN, M = map(int, input().split())\n\n# Print the result\nprint(expected_execution_time(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962559938430786,
            0.9946364164352417,
            0.995477557182312,
            0.9939912557601929,
            0.996242344379425,
            0.9941149353981018,
            0.9946495890617371,
            0.9941596984863281,
            0.9957646727561951,
            0.9958434104919434,
            0.9953422546386719,
            0.9959483742713928,
            0.9952232241630554,
            0.9953083395957947,
            0.9854964017868042,
            0.9958510994911194,
            0.9963942170143127,
            0.9948611855506897,
            0.9959744811058044,
            0.9969369769096375
        ]
    },
    "4019": {
        "similarity": 0.9980069398880005,
        "body": "import sys\n\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    \n    from collections import defaultdict, deque\n    \n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        degree = defaultdict(int)\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree[node] += 1\n                    degree[neighbor] += 1\n        \n        return degree\n    \n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    degree = bfs(graph, 1)\n    \n    if degree[1] == D:\n        print(\"YES\")\n        for v, u in edges:\n            if u == degree[v]:\n                print(f\"{v} {u}\")\n                break\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    n, m, D = map(int, input().split())\n    find_spanning_tree(n, m, D)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970908164978027,
            0.9966980814933777,
            0.9979259967803955,
            0.9963290691375732,
            0.9978556632995605,
            0.9965482950210571,
            0.9961652159690857,
            0.997434139251709,
            0.9976807832717896,
            0.9980069398880005,
            0.9956840872764587,
            0.9963980317115784,
            0.9972198009490967,
            0.9974648356437683,
            0.9969431161880493,
            0.9974796175956726,
            0.9968528747558594,
            0.9974158406257629,
            0.9972246289253235,
            0.9976093769073486
        ]
    },
    "4265": {
        "similarity": 0.9917691946029663,
        "body": "    return sum(s != t for s, t in zip(S, T))\n\n# Read input\nS = input().strip()\nT = input().strip()\n\n# Output the result\nprint(min_operations(S, T))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9917691946029663,
            0.9842916131019592,
            0.9917066693305969,
            0.9912658333778381,
            0.9906507730484009,
            0.9886740446090698,
            0.9917691946029663,
            0.9902129173278809,
            0.9912658333778381,
            0.9862203001976013,
            0.9878221154212952,
            0.9895876049995422,
            0.9895949959754944,
            0.9907155632972717,
            0.9895876049995422,
            0.9884892702102661,
            0.9678906202316284,
            0.9884175658226013,
            0.9749129414558411,
            0.9678906202316284
        ]
    },
    "4657": {
        "similarity": 0.9981733560562134,
        "body": "    odd_count = sum(1 for x in a if x % 2 != 0)\n    if odd_count < k or odd_count % 2 != k % 2:\n        return \"NO\"\n    \n    result = []\n    current_sum = 0\n    count = 0\n    i = 0\n    \n    while i < n:\n        while i < n and (current_sum + a[i]) % 2 == 0:\n            current_sum += a[i]\n            i += 1\n        if i >= n:\n            break\n        result.append(i)\n        current_sum = a[i]\n        i += 1\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_divide_into_odd_sum_subsegments(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.992592453956604,
            0.9978091716766357,
            0.9976649880409241,
            0.9978162050247192,
            0.9965871572494507,
            0.9979519248008728,
            0.997173011302948,
            0.9981733560562134,
            0.9979581236839294,
            0.9978826642036438,
            0.9968352317810059,
            0.9976692199707031,
            0.9978175759315491,
            0.9975706338882446,
            0.9978684782981873,
            0.9981254935264587,
            0.997970461845398,
            0.9975584149360657,
            0.9976720213890076,
            0.9966734647750854
        ]
    },
    "4599": {
        "similarity": 0.9958357810974121,
        "body": "import sys\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    \n    # Initialize dp arrays\n    dp_take = [0] * (N + 1)\n    dp_pass = [0] * (N + 1)\n    \n    for i in range(N - 1, -1, -1):\n        dp_take[i] = max(a[i] + dp_pass[i + 1], dp_take[i + 1])\n        dp_pass[i] = dp_take[i + 1]\n    \n    return dp_take[0]\n\nif __name__ == \"__main__\":\n    result = optimal_game_score()\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950848817825317,
            0.9933782815933228,
            0.9950848817825317,
            0.9943875670433044,
            0.9952052235603333,
            0.9950043559074402,
            0.9941359162330627,
            0.9942324757575989,
            0.9947785139083862,
            0.9950595498085022,
            0.9943404197692871,
            0.9957719445228577,
            0.9852322936058044,
            0.9954224824905396,
            0.9958357810974121,
            0.992562472820282,
            0.9946765899658203,
            0.9938951134681702,
            0.9957677125930786,
            0.9925671815872192
        ]
    },
    "4774": {
        "similarity": 0.9966012239456177,
        "body": "    operators = ['+', '-', '*', '/']\n    valid_expressions = []\n\n    for op1 in operators:\n        for op2 in operators:\n            if op2 == '/' and (c == 0 or d == 0):\n                continue\n            expr1 = f\"{a} {op1} {b}\"\n            expr2 = f\"{c} {op2} {d}\"\n            value1 = eval(expr1)\n            value2 = eval(expr2)\n            if value1 == value2:\n                valid_expressions.append(f\"{expr1} = {expr2}\")\n\n    if not valid_expressions:\n        print(\"problems ahead\")\n    else:\n        for expr in sorted(valid_expressions):\n            print(expr)\n\n# Read input from stdin\na, b, c, d = map(int, input().split())\nfind_valid_expressions(a, b, c, d)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943656921386719,
            0.9883898496627808,
            0.9956167936325073,
            0.9883679747581482,
            0.9964007139205933,
            0.9923906922340393,
            0.9954091310501099,
            0.988078773021698,
            0.9944066405296326,
            0.9964553713798523,
            0.9957837462425232,
            0.9959184527397156,
            0.9958327412605286,
            0.9966012239456177,
            0.9960463643074036,
            0.9942659139633179,
            0.9959660768508911,
            0.9961580038070679,
            0.9954020977020264,
            0.9961807131767273
        ]
    },
    "4851": {
        "similarity": 0.998511552810669,
        "body": "    digit_sum = sum(int(digit) for digit in str(num))\n    return num % digit_sum == 0\n\nn = int(input())\nwhile not is_harshad_number(n):\n    n += 1\nprint(n)",
        "result": "failed: testcase 0",
        "similarities": [
            0.998511552810669,
            0.998511552810669,
            0.998511552810669,
            0.9983016848564148,
            0.9983016848564148,
            0.9983016848564148,
            0.9978025555610657,
            0.9971888661384583,
            0.998511552810669,
            0.9983566999435425,
            0.998511552810669,
            0.9971382021903992,
            0.998511552810669,
            0.9973864555358887,
            0.9966902732849121,
            0.9982582926750183,
            0.997096598148346,
            0.996654212474823,
            0.9976603984832764,
            0.998511552810669
        ]
    },
    "4655": {
        "similarity": 0.9963350892066956,
        "body": "    piles = sorted([a, b, c])\n    if piles[2] - piles[0] > piles[1]:\n        return 2 * (piles[2] - piles[0]) // 3 + piles[0]\n    else:\n        return 2 * piles[1]\n\nq = int(input())\nresults = []\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    results.append(max_candies(a, b, c))\n    \nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.995795726776123,
            0.9948337078094482,
            0.9962228536605835,
            0.9955693483352661,
            0.9925742745399475,
            0.9956114888191223,
            0.9963350892066956,
            0.9958238005638123,
            0.9868881106376648,
            0.9949992299079895,
            0.9946439862251282,
            0.9858323335647583,
            0.9941886067390442,
            0.9918491244316101,
            0.9945817589759827,
            0.9954527020454407,
            0.9949899315834045,
            0.9950845837593079,
            0.9955157041549683,
            0.9944233298301697
        ]
    },
    "4132": {
        "similarity": 0.9962881803512573,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    heap = []\n    for a in A:\n        heappush(heap, -a)\n    \n    while len(heap) > 1:\n        x = -heappop(heap)\n        y = -heappop(heap)\n        z = x - y\n        if z > 0:\n            heappush(heap, -z)\n    \n    return -heap[0]\n\nprint(min_final_health())",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957947134971619,
            0.9955456256866455,
            0.9861962199211121,
            0.9952716827392578,
            0.9962881803512573,
            0.995416522026062,
            0.9961833953857422,
            0.9952936768531799,
            0.9936259388923645,
            0.9956547617912292,
            0.9921615123748779,
            0.9956330060958862,
            0.9961264729499817,
            0.9957834482192993,
            0.9947647452354431,
            0.9959483742713928,
            0.9949682950973511,
            0.9944126009941101,
            0.9949985146522522,
            0.9928619861602783
        ]
    },
    "4085": {
        "similarity": 0.9972016215324402,
        "body": "import sys\nfrom math import sqrt\n\n    divisors = set(divisors)\n    if len(divisors) < 2:\n        return -1\n    \n    x = max(divisors)\n    for i in range(2, int(sqrt(x)) + 1):\n        if x % i == 0 and i not in divisors or (x // i != i and x // i not in divisors):\n            return -1\n    return x\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        divisors = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_minimum_x(divisors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944207072257996,
            0.9956635236740112,
            0.9969035983085632,
            0.9955939054489136,
            0.9950868487358093,
            0.996179461479187,
            0.9963451027870178,
            0.9930713176727295,
            0.9931573271751404,
            0.9970546364784241,
            0.9969703555107117,
            0.9972016215324402,
            0.9966285228729248,
            0.9964332580566406,
            0.9956943988800049,
            0.9953717589378357,
            0.9928691387176514,
            0.9931802153587341,
            0.9963802695274353,
            0.9952483773231506
        ]
    },
    "4399": {
        "similarity": 0.9956128001213074,
        "body": "    companies = list(S)\n    if 'A' in companies and 'B' in companies:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input from stdin\nS = input().strip()\n# Print the result\nprint(check_bus_service(S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942275881767273,
            0.9940441846847534,
            0.99224454164505,
            0.9929592609405518,
            0.9939038157463074,
            0.9943830370903015,
            0.9948025941848755,
            0.9956128001213074,
            0.9939280152320862,
            0.9937211871147156,
            0.9940945506095886,
            0.9950552582740784,
            0.9946146607398987,
            0.9805362224578857,
            0.9955297708511353,
            0.9937649965286255,
            0.9949477314949036,
            0.9947739839553833,
            0.9955761432647705,
            0.9916537404060364
        ]
    },
    "4999": {
        "similarity": 0.99870765209198,
        "body": "    operations = 0\n    while a < b:\n        if b % 2 == 0:\n            b //= 2\n        else:\n            b += 1\n        operations += 1\n    return operations + (a - b)\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9987044334411621,
            0.9969379305839539,
            0.9967285990715027,
            0.9972825646400452,
            0.9985815286636353,
            0.9934297800064087,
            0.9984564781188965,
            0.9973856210708618,
            0.998654842376709,
            0.9987044334411621,
            0.9983147382736206,
            0.998654842376709,
            0.996372640132904,
            0.9987044334411621,
            0.99870765209198,
            0.99870765209198,
            0.9987044334411621,
            0.9987044334411621,
            0.9960322976112366,
            0.9987044334411621
        ]
    },
    "4727": {
        "similarity": 0.9980269074440002,
        "body": "import sys\n\n    for row in grid:\n        non_zeros = [x for x in row if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        row[:len(merged)] = merged\n        row[len(merged):] = [0] * (4 - len(merged))\n    return grid\n\n    for row in grid:\n        non_zeros = [x for x in row if x != 0]\n        merged = []\n        i = len(non_zeros) - 1\n        while i >= 0:\n            if i > 0 and non_zeros[i] == non_zeros[i - 1]:\n                merged.insert(0, 2 * non_zeros[i])\n                i -= 2\n            else:\n                merged.insert(0, non_zeros[i])\n                i -= 1\n        row[:len(merged)] = merged\n        row[len(merged):] = [0] * (4 - len(merged))\n    return grid\n\n    for j in range(4):\n        column = [grid[i][j] for i in range(4)]\n        non_zeros = [x for x in column if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(2 * non_zeros[i])\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        for i in range(4):\n            grid[i][j] = merged[i] if i < len(merged) else 0\n    return grid\n\n    for j in range(4):\n        column = [grid[i][j] for i in range(4)]\n        non_zeros = [x for x in column if x != 0]\n        merged = []\n        i = len(non_zeros) - 1\n        while i >= 0:\n            if i > 0 and non_zeros[i] == non_zeros[i - 1]:\n                merged.insert(0, 2 * non_zeros[i])\n                i -= 2\n            else:\n                merged.insert(0, non_zeros[i])\n                i -= 1\n        for i in range(4):\n            grid[3 - i][j] = merged[i] if i < len(merged) else 0\n    return grid\n\n    grid = []\n    for _ in range(4):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    \n    direction = int(input())\n    \n    if direction == 0:\n        new_grid = move_left(grid)\n    elif direction == 1:\n        new_grid = move_up(grid)\n    elif direction == 2:\n        new_grid = move_right(grid)\n    elif direction == 3:\n        new_grid = move_down(grid)\n    else:\n        raise ValueError(\"Invalid direction\")\n    \n    for row in new_grid:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978141784667969,
            0.9967859983444214,
            0.9973571300506592,
            0.9978291392326355,
            0.9954994916915894,
            0.9974573254585266,
            0.9968218803405762,
            0.9956720471382141,
            0.9966597557067871,
            0.9971259236335754,
            0.9958506226539612,
            0.9980269074440002,
            0.9965494275093079,
            0.99697345495224,
            0.9977298378944397,
            0.9979760050773621,
            0.9977182149887085,
            0.9976445436477661,
            0.9964765310287476,
            0.9975559711456299
        ]
    },
    "4906": {
        "similarity": 0.9978662133216858,
        "body": "import sys\n\n    encoded = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            encoded.append(s[i-1] + str(count))\n            count = 1\n    encoded.append(s[-1] + str(count))\n    return ''.join(encoded)\n\n    decoded = []\n    i = 0\n    while i < len(s):\n        char = s[i]\n        i += 1\n        num = ''\n        while i < len(s) and s[i].isdigit():\n            num += s[i]\n            i += 1\n        decoded.append(char * int(num))\n    return ''.join(decoded)\n\n    command, message = input().split(' ', 1)\n    if command == 'E':\n        print(run_length_encoding(message))\n    elif command == 'D':\n        print(run_length_decoding(message))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9910985231399536,
            0.9972561597824097,
            0.9966585040092468,
            0.996986985206604,
            0.9954270124435425,
            0.996864914894104,
            0.9978662133216858,
            0.9972707033157349,
            0.9977491497993469,
            0.997150719165802,
            0.9976812601089478,
            0.9970895648002625,
            0.9936345815658569,
            0.9974074363708496,
            0.9977258443832397,
            0.9968773722648621,
            0.9974309802055359,
            0.9970180988311768,
            0.9975431561470032,
            0.9973435997962952
        ]
    },
    "4011": {
        "similarity": 0.9980286955833435,
        "body": "    max_val = int(a)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment = a[i:j]\n            new_segment = ''.join(str(f[int(d) - 1]) for d in segment)\n            new_number = a[:i] + new_segment + a[j:]\n            max_val = max(max_val, int(new_number))\n    return max_val\n\n# Read input\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_number(n, a, f))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978876709938049,
            0.9974873065948486,
            0.9936918020248413,
            0.9977717995643616,
            0.9975214600563049,
            0.9977732300758362,
            0.997920572757721,
            0.9967269897460938,
            0.9973483681678772,
            0.9964436292648315,
            0.9980286955833435,
            0.9963886141777039,
            0.9945480823516846,
            0.9969291687011719,
            0.9968518614768982,
            0.9977067708969116,
            0.9970026612281799,
            0.9974458813667297,
            0.9965390563011169,
            0.9976706504821777
        ]
    },
    "4099": {
        "similarity": 0.9982629418373108,
        "body": "import sys\n\n    total_needed = N * M\n    current_total = sum(A)\n    needed_on_final = total_needed - current_total\n    \n    if needed_on_final <= 0 or needed_on_final > K:\n        return -1\n    else:\n        return needed_on_final\n\n# Read input from stdin\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_points_to_achieve_average(N, K, M, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997888445854187,
            0.9981210827827454,
            0.9982381463050842,
            0.9982073903083801,
            0.9982629418373108,
            0.9946290850639343,
            0.9971668124198914,
            0.997902512550354,
            0.9968908429145813,
            0.9979972839355469,
            0.9977575540542603,
            0.9969339966773987,
            0.9976050853729248,
            0.9962786436080933,
            0.997342586517334,
            0.9970282316207886,
            0.9981073141098022,
            0.995517909526825,
            0.9978796243667603,
            0.9974895119667053
        ]
    },
    "4465": {
        "similarity": 0.9952462911605835,
        "body": "import sys\n\n    A, B = map(int, input().split())\n    yield_area = (A - 1) * (B - 1)\n    print(yield_area)\n\ncalculate_yield_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.991019606590271,
            0.991019606590271,
            0.9918607473373413,
            0.9947336912155151,
            0.9941799640655518,
            0.9945724010467529,
            0.9941799640655518,
            0.9952462911605835,
            0.994897723197937,
            0.9947336912155151,
            0.9939841032028198,
            0.9939733147621155,
            0.994897723197937,
            0.991019606590271,
            0.994897723197937,
            0.9941799640655518,
            0.9906044006347656,
            0.9939841032028198,
            0.991019606590271,
            0.9910218119621277
        ]
    },
    "4315": {
        "similarity": 0.999530017375946,
        "body": "import math\n\nR = int(input())\ncircumference = 2 * math.pi * R\nprint(circumference)",
        "result": "passed",
        "similarities": [
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.999530017375946,
            0.9994667768478394,
            0.9978162050247192,
            0.999530017375946,
            0.999530017375946,
            0.9994667768478394,
            0.9929903745651245,
            0.999530017375946,
            0.999530017375946
        ]
    },
    "4633": {
        "similarity": 0.9972704648971558,
        "body": "import sys\n\n    moves = 0\n    while sum(int(digit) for digit in str(n)) > s:\n        n += 1\n        moves += 1\n    return moves\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, s = map(int, input().split())\n    results.append(min_moves_to_digit_sum(n, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936226606369019,
            0.9943156838417053,
            0.9969680309295654,
            0.9947035908699036,
            0.997248113155365,
            0.9939050078392029,
            0.9967018961906433,
            0.9965789318084717,
            0.9958139061927795,
            0.9968129992485046,
            0.9956175088882446,
            0.9969537854194641,
            0.9966294169425964,
            0.9922972321510315,
            0.9948491454124451,
            0.9959174990653992,
            0.9972704648971558,
            0.9962897300720215,
            0.9964103698730469,
            0.9949145913124084
        ]
    },
    "4734": {
        "similarity": 0.9988463521003723,
        "body": "    if Y.endswith('ex'):\n        return Y + P\n    elif Y[-1] in 'aeiou':\n        return Y[:-1] + 'ex' + P\n    else:\n        return Y + 'ex' + P\n\n# Read input from stdin\nY, P = input().split()\n\n# Print the result\nprint(extend_name(Y, P))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9988463521003723,
            0.9988463521003723,
            0.9981385469436646,
            0.9986485838890076,
            0.9985858798027039,
            0.9980374574661255,
            0.9983030557632446,
            0.997116208076477,
            0.9966486692428589,
            0.998013436794281,
            0.997589647769928,
            0.9986645579338074,
            0.9978857636451721,
            0.9984742999076843,
            0.9975826144218445,
            0.9972987771034241,
            0.9987073540687561,
            0.9981966614723206,
            0.9988463521003723,
            0.9987459778785706
        ]
    },
    "4229": {
        "similarity": 0.9974241852760315,
        "body": "    total = 0\n    for i in range(1, N + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            continue\n        elif i % 3 == 0:\n            continue\n        elif i % 5 == 0:\n            continue\n        else:\n            total += i\n    print(total)\n\nN = int(input())\nfizz_buzz_sum(N)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967247843742371,
            0.9959232211112976,
            0.9962344169616699,
            0.9964812397956848,
            0.9952788352966309,
            0.997320294380188,
            0.9971562623977661,
            0.9974241852760315,
            0.9973989725112915,
            0.996906578540802,
            0.9973139762878418,
            0.9965448975563049,
            0.9964812397956848,
            0.9969018697738647,
            0.9973018169403076,
            0.9973539113998413,
            0.9829849600791931,
            0.9955906271934509,
            0.9959909319877625,
            0.9966330528259277
        ]
    },
    "4321": {
        "similarity": 0.9964573383331299,
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\n# Read input\nn, k = map(int, input().split())\n\n# Print result\nprint(tanya_decrease(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9913567304611206,
            0.9953908324241638,
            0.9913567304611206,
            0.9953908324241638,
            0.9954129457473755,
            0.9953908324241638,
            0.9953908324241638,
            0.9943539500236511,
            0.9952353239059448,
            0.9946224689483643,
            0.9941735863685608,
            0.9953908324241638,
            0.9952353239059448,
            0.9913567304611206,
            0.9953908324241638,
            0.9913567304611206,
            0.9953908324241638,
            0.9964573383331299,
            0.9913567304611206,
            0.9913567304611206
        ]
    },
    "4503": {
        "similarity": 0.9976535439491272,
        "body": "    used = set()\n    for move in A:\n        if H % move not in used:\n            used.add(H % move)\n            H -= move\n            if H <= 0:\n                return \"Yes\"\n    return \"No\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nN = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(can_win(H, N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997360110282898,
            0.9961140155792236,
            0.9968816041946411,
            0.9952982068061829,
            0.9971755146980286,
            0.9969592094421387,
            0.9958410859107971,
            0.9976535439491272,
            0.9975187182426453,
            0.9975101947784424,
            0.9964967966079712,
            0.9970116019248962,
            0.9967988729476929,
            0.9965255260467529,
            0.9973592162132263,
            0.9957922101020813,
            0.9974693655967712,
            0.9971535205841064,
            0.9965966939926147,
            0.9972450137138367
        ]
    },
    "4855": {
        "similarity": 0.9948376417160034,
        "body": "import math\n\n    current_impact_factor = 0 if A == 0 else sum(range(1, I + 1)) * A // A\n    bribes_needed = max(I - current_impact_factor, 0)\n    return bribes_needed\n\nA, I = map(int, input().split())\nprint(calculate_bribes(A, I))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938356280326843,
            0.9932060241699219,
            0.992863118648529,
            0.9935113787651062,
            0.9942305684089661,
            0.9921587705612183,
            0.9918441772460938,
            0.9932489991188049,
            0.9927406311035156,
            0.9925144910812378,
            0.9919540286064148,
            0.9927168488502502,
            0.9937589764595032,
            0.9912623167037964,
            0.9943555593490601,
            0.9903448224067688,
            0.9896668195724487,
            0.9946784973144531,
            0.9926983714103699,
            0.9948376417160034
        ]
    },
    "4704": {
        "similarity": 0.9977902173995972,
        "body": "import sys\n\n    total_sum = sum(cards)\n    left_sum = 0\n    min_diff = float('inf')\n    \n    for i in range(N - 1):\n        left_sum += cards[i]\n        right_sum = total_sum - left_sum\n        diff = abs(left_sum - right_sum)\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\ncards = list(map(int, data[1:]))\n\nresult = min_difference(N, cards)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962902069091797,
            0.9964009523391724,
            0.9977484345436096,
            0.9972917437553406,
            0.9968599081039429,
            0.9970985054969788,
            0.9977902173995972,
            0.9972611665725708,
            0.997646152973175,
            0.9970147013664246,
            0.9970151782035828,
            0.9969548583030701,
            0.9972644448280334,
            0.9971798658370972,
            0.9970380067825317,
            0.9970450401306152,
            0.9976879954338074,
            0.995932936668396,
            0.9965286254882812,
            0.9974481463432312
        ]
    },
    "4829": {
        "similarity": 0.997117280960083,
        "body": "left, right = map(int, input().split())\nif left == right == 0:\n    print(\"Not a moose\")\nelif left == right:\n    points = left + right\n    print(f\"Even {points}\")\nelse:\n    max_tines = max(left, right)\n    if max_tines * 2 != left + right:\n        print(\"Not a moose\")\n    else:\n        print(f\"Odd {max_tines * 2}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963797330856323,
            0.9928204417228699,
            0.9965187907218933,
            0.9965187907218933,
            0.9963591694831848,
            0.997117280960083,
            0.9962949156761169,
            0.996323823928833,
            0.9965974688529968,
            0.995419979095459,
            0.9946240186691284,
            0.9969844818115234,
            0.9958680868148804,
            0.9938406944274902,
            0.993874192237854,
            0.9961776733398438,
            0.9955011010169983,
            0.9967353343963623,
            0.9960570335388184,
            0.9963182210922241
        ]
    },
    "4730": {
        "similarity": 0.9977767467498779,
        "body": "import sys\n\n    length = int(input())\n    program = input()\n    \n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for i, char in enumerate(program):\n        if char in '([{':\n            stack.append((char, i))\n        elif char in ')]}':\n            if not stack or stack[-1][0] != mapping[char]:\n                print(char, i)\n                return\n            else:\n                stack.pop()\n    \n    if stack:\n        first_unmatched = stack[0]\n        print(first_unmatched[0], first_unmatched[1])\n    else:\n        print(\"ok so far\")\n\nvalidate_delimiters()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976743459701538,
            0.9961725473403931,
            0.9965505003929138,
            0.9970455169677734,
            0.9975425601005554,
            0.9970446228981018,
            0.9966812133789062,
            0.9913482666015625,
            0.9972158670425415,
            0.9957401752471924,
            0.9950812458992004,
            0.9974604249000549,
            0.9976187348365784,
            0.9977767467498779,
            0.9974724650382996,
            0.997144877910614,
            0.9964222311973572,
            0.9976646304130554,
            0.9966864585876465,
            0.9964483380317688
        ]
    },
    "4729": {
        "similarity": 0.9975979328155518,
        "body": "    password_set = set(password)\n    index = 0\n    for char in message:\n        if char in password_set:\n            if char == password[index]:\n                index += 1\n                if index == len(password):\n                    return \"PASS\"\n            else:\n                break\n    return \"FAIL\"\n\n# Read input from stdin\npassword, message = input().split()\nprint(is_valid_message(password, message))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973464012145996,
            0.9945217967033386,
            0.9966033101081848,
            0.9958324432373047,
            0.9933753609657288,
            0.9973915815353394,
            0.9975979328155518,
            0.9965846538543701,
            0.9963535666465759,
            0.9958142638206482,
            0.9965911507606506,
            0.9971056580543518,
            0.9965360760688782,
            0.9956039786338806,
            0.9966177940368652,
            0.9971992373466492,
            0.9955840110778809,
            0.9970831871032715,
            0.9969960451126099,
            0.9962257742881775
        ]
    },
    "4582": {
        "similarity": 0.9983500242233276,
        "body": "a = input()\nb = input()\n\nif a == 'H':\n    if b == 'H':\n        print('H')\n    else:\n        print('D')\nelse:\n    if b == 'H':\n        print('D')\n    else:\n        print('H')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977670311927795,
            0.996367335319519,
            0.9982456564903259,
            0.9982456564903259,
            0.9983500242233276,
            0.9983500242233276,
            0.9982456564903259,
            0.9975927472114563,
            0.9907772541046143,
            0.9983500242233276,
            0.9983500242233276,
            0.9983500242233276,
            0.9963564872741699,
            0.9977670311927795,
            0.9929426312446594,
            0.9975927472114563,
            0.9966943860054016,
            0.9983500242233276,
            0.9977670311927795,
            0.9983500242233276
        ]
    },
    "4910": {
        "similarity": 0.9971773028373718,
        "body": "from collections import Counter\nimport sys\n\n    N = int(input())\n    costumes = [input().strip() for _ in range(N)]\n    costume_counts = Counter(costumes)\n    \n    max_count = max(costume_counts.values())\n    winning_costumes = sorted([costume for costume, count in costume_counts.items() if count == max_count])\n    \n    print('\\n'.join(winning_costumes))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968091249465942,
            0.9941739439964294,
            0.9967938661575317,
            0.9966699481010437,
            0.992570698261261,
            0.9969775676727295,
            0.9960870146751404,
            0.9966707825660706,
            0.9964830279350281,
            0.9945512413978577,
            0.9933041334152222,
            0.9971773028373718,
            0.9923660755157471,
            0.9966707825660706,
            0.9967895150184631,
            0.9970600605010986,
            0.9959162473678589,
            0.9967895150184631,
            0.993884265422821,
            0.9907726645469666
        ]
    },
    "4323": {
        "similarity": 0.9970200061798096,
        "body": "    a = [s[0] for s in songs]\n    b = [s[1] for s in songs]\n    \n    if sum(a) <= m:\n        return 0\n    \n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            if j >= a[i - 1]:\n                dp[j][i] = min(dp[j][i], dp[j - a[i - 1]][i - 1])\n            if j >= b[i - 1]:\n                dp[j][i] = min(dp[j][i], dp[j - b[i - 1]][i - 1])\n    \n    for i in range(n, -1, -1):\n        if dp[m][i] != float('inf'):\n            return n - i\n    \n    return -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nsongs = []\n\nindex = 2\nfor _ in range(n):\n    a_i = int(data[index])\n    b_i = int(data[index + 1])\n    songs.append((a_i, b_i))\n    index += 2\n\nresult = min_songs_to_compress(n, m, songs)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958139061927795,
            0.9962467551231384,
            0.9965440034866333,
            0.9969761371612549,
            0.9961757659912109,
            0.9969271421432495,
            0.9965420961380005,
            0.996027410030365,
            0.9970200061798096,
            0.9956635236740112,
            0.9969630837440491,
            0.9966729879379272,
            0.9964646697044373,
            0.9964207410812378,
            0.9961073994636536,
            0.9967567920684814,
            0.9914833903312683,
            0.9961686730384827,
            0.9952453970909119,
            0.9965929985046387
        ]
    },
    "4626": {
        "similarity": 0.9948644042015076,
        "body": "import sys\n\n    positions = sorted([a, b, c])\n    return sum(abs(positions[i] - positions[j]) for i in range(3) for j in range(i+1, 3))\n\nq = int(input())\nresults = []\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    results.append(min_distance(a, b, c))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9936963319778442,
            0.992183268070221,
            0.988533616065979,
            0.9921044707298279,
            0.9933951497077942,
            0.9941149353981018,
            0.9932273030281067,
            0.994229257106781,
            0.9930864572525024,
            0.9926110506057739,
            0.994175374507904,
            0.9940506815910339,
            0.9896674156188965,
            0.9914638996124268,
            0.9935939311981201,
            0.9915934205055237,
            0.991956889629364,
            0.9948644042015076,
            0.9892796874046326,
            0.9947034120559692
        ]
    },
    "4400": {
        "similarity": 0.9945351481437683,
        "body": "print(max(S.count('R'), S[::-1].count('R')))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9920604228973389,
            0.9928327202796936,
            0.9928327202796936,
            0.9938254952430725,
            0.9717917442321777,
            0.9945351481437683,
            0.992157518863678,
            0.9934208393096924,
            0.9865577220916748,
            0.99235999584198,
            0.9914597272872925,
            0.9945351481437683,
            0.9921891093254089,
            0.9896383881568909,
            0.9945351481437683,
            0.9906772971153259,
            0.9941207766532898,
            0.9934883117675781,
            0.9945351481437683,
            0.9928327202796936
        ]
    },
    "4794": {
        "similarity": 0.996494710445404,
        "body": "        return 0 <= x < R and 0 <= y < C\n\n        return grid[x][y] == 'X' or grid[x][y] == '#'\n\n        if not (is_valid(i, j) and is_valid(i + 1, j) and is_valid(i, j + 1) and is_valid(i + 1, j + 1)):\n            return False\n        for dx in range(2):\n            for dy in range(2):\n                if is_occupied(i + dx, j + dy):\n                    return True\n        return False\n\n    counts = [0] * 5\n    for i in range(R - 1):\n        for j in range(C - 1):\n            if can_park(i, j):\n                parked_cars = 0\n                for dx in range(2):\n                    for dy in range(2):\n                        if grid[i + dx][j + dy] == 'X':\n                            parked_cars += 1\n                counts[parked_cars] += 1\n\n    return counts\n\n# Read input from stdin\nR, C = map(int, input().split())\ngrid = [input().strip() for _ in range(R)]\n\n# Calculate and print the result\nresult = count_parking_spaces(R, C, grid)\nfor count in result:\n    print(count)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925968647003174,
            0.994687557220459,
            0.9963011741638184,
            0.995442271232605,
            0.9917555451393127,
            0.995116114616394,
            0.996494710445404,
            0.9925138354301453,
            0.9957389831542969,
            0.9940101504325867,
            0.9952093362808228,
            0.9956948161125183,
            0.9952204823493958,
            0.9951609373092651,
            0.9956690073013306,
            0.9953160881996155,
            0.9947584867477417,
            0.9962632060050964,
            0.9962146282196045,
            0.9943516254425049
        ]
    },
    "4096": {
        "similarity": 0.997857928276062,
        "body": "    a.sort(reverse=True)\n    pages_written = 0\n    days = 0\n    \n    for i in range(n):\n        if pages_written >= m:\n            break\n        coffee_caffeine = a[i]\n        day_pages = max(0, coffee_caffeine - days + 1)\n        pages_written += day_pages\n        days += 1\n    \n    return days if pages_written >= m else -1\n\n# Read input from stdin\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_days_to_complete_coursework(n, m, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978048205375671,
            0.9970592856407166,
            0.9968603253364563,
            0.9974613189697266,
            0.9972720742225647,
            0.9964131712913513,
            0.9965026378631592,
            0.9974080324172974,
            0.9973662495613098,
            0.9958371520042419,
            0.9975435137748718,
            0.9974180459976196,
            0.9915454387664795,
            0.9972838163375854,
            0.9971380829811096,
            0.9969382286071777,
            0.9964439272880554,
            0.9970418214797974,
            0.9977515339851379,
            0.997857928276062
        ]
    },
    "4530": {
        "similarity": 0.9973138570785522,
        "body": "import sys\n\n    from collections import Counter\n    \n    skill_counter = Counter(skills)\n    \n    unique_skills = list(skill_counter.keys())\n    max_size = 0\n    \n    for skill in unique_skills:\n        team1_size = len(set(skills[:skill_counter[skill]]))\n        remaining_students = n - skill_counter[skill]\n        if remaining_students > 0 and remaining_students % 2 == 0:\n            team2_size = remaining_students // 2\n            max_size = max(max_size, min(team1_size, team2_size))\n    \n    return max_size\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        skills = list(map(int, data[index + 1:index + n + 1]))\n        index += n + 1\n        result = max_team_size(n, skills)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971970915794373,
            0.9973138570785522,
            0.9945160746574402,
            0.9960206747055054,
            0.9970079064369202,
            0.9969283938407898,
            0.9958221316337585,
            0.9965841174125671,
            0.9962552785873413,
            0.9971853494644165,
            0.9949634075164795,
            0.9971935153007507,
            0.9966874718666077,
            0.9961453676223755,
            0.9972624778747559,
            0.9962156414985657,
            0.9964755177497864,
            0.9972031116485596,
            0.996202290058136,
            0.9970943927764893
        ]
    },
    "4724": {
        "similarity": 0.9960473775863647,
        "body": "R = int(input())\nG = int(input())\nperformance = (2 * G - R)\nprint(performance)",
        "result": "passed",
        "similarities": [
            0.9952184557914734,
            0.9959370493888855,
            0.9944728016853333,
            0.9955677390098572,
            0.9952184557914734,
            0.9944728016853333,
            0.9960473775863647,
            0.9804496765136719,
            0.9959370493888855,
            0.9959370493888855,
            0.9959370493888855,
            0.9947417378425598,
            0.9960473775863647,
            0.9887761473655701,
            0.9960473775863647,
            0.9944728016853333,
            0.9952184557914734,
            0.98448646068573,
            0.9865953326225281,
            0.9952183961868286
        ]
    },
    "4276": {
        "similarity": 0.9963943362236023,
        "body": "    min_cost = float('inf')\n    for c, t in routes:\n        if t <= T and c < min_cost:\n            min_cost = c\n    return min_cost if min_cost != float('inf') else 'TLE'\n\n# Read input\nN, T = map(int, input().split())\nroutes = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Find and print the result\nresult = find_min_cost(N, T, routes)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953717589378357,
            0.996322751045227,
            0.9956839680671692,
            0.9953133463859558,
            0.9956164360046387,
            0.9958395957946777,
            0.9950798749923706,
            0.9947076439857483,
            0.9956418871879578,
            0.9931417107582092,
            0.9956102967262268,
            0.9963943362236023,
            0.9958214163780212,
            0.9946885704994202,
            0.995928943157196,
            0.9954279661178589,
            0.9961624145507812,
            0.9948725700378418,
            0.9956181049346924,
            0.9960140585899353
        ]
    },
    "4708": {
        "similarity": 0.9949827790260315,
        "body": "N = int(input())\nK = int(input())\nX = int(input())\nY = int(input())\n\ntotal_fee = min(N, K) * X + max(0, N - K) * Y\nprint(total_fee)",
        "result": "passed",
        "similarities": [
            0.9946923851966858,
            0.9934576153755188,
            0.9946923851966858,
            0.9946923851966858,
            0.994742751121521,
            0.9946923851966858,
            0.9897585511207581,
            0.9834762215614319,
            0.9929381012916565,
            0.9946923851966858,
            0.9946923851966858,
            0.9946923851966858,
            0.9946923851966858,
            0.9939486980438232,
            0.993556797504425,
            0.9949827790260315,
            0.9943504333496094,
            0.9914390444755554,
            0.994525134563446,
            0.9928737282752991
        ]
    },
    "4396": {
        "similarity": 0.9973083138465881,
        "body": "import sys\n\n    N = int(input())\n    total_value = 0.0\n    conversion_rate = 380000.0\n\n    for _ in range(N):\n        x, u = input().split()\n        x = float(x)\n        \n        if u == \"JPY\":\n            total_value += x\n        elif u == \"BTC\":\n            total_value += x * conversion_rate\n    \n    print(total_value)\n\ncalculate_total_value()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996584951877594,
            0.9966017007827759,
            0.9967711567878723,
            0.9968768954277039,
            0.9937871694564819,
            0.9968687295913696,
            0.9966878294944763,
            0.9969463348388672,
            0.9961847066879272,
            0.99545818567276,
            0.9970937371253967,
            0.9947521686553955,
            0.9969661235809326,
            0.9967045187950134,
            0.9942277669906616,
            0.9951676726341248,
            0.9957422018051147,
            0.9949167370796204,
            0.9973083138465881,
            0.996036946773529
        ]
    },
    "4155": {
        "similarity": 0.9982896447181702,
        "body": "    operations = 0\n    current_height = [0] * N\n    \n    for i in range(N):\n        if h[i] > current_height[i]:\n            operations += 1\n            diff = h[i] - current_height[i]\n            for j in range(i, min(N, i + diff)):\n                current_height[j] += 1\n    \n    return operations\n\n# Read input\nN = int(input())\nh = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_watering_operations(N, h))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971562623977661,
            0.9961198568344116,
            0.997222900390625,
            0.9969117045402527,
            0.9981318116188049,
            0.9978620409965515,
            0.9981154203414917,
            0.9982189536094666,
            0.9978317618370056,
            0.9974228739738464,
            0.9975206255912781,
            0.9980534911155701,
            0.9977957010269165,
            0.9982896447181702,
            0.9977079033851624,
            0.9979577660560608,
            0.9967628121376038,
            0.9975007772445679,
            0.9975610971450806,
            0.9977396130561829
        ]
    },
    "4557": {
        "similarity": 0.9975627064704895,
        "body": "A, B, X = map(int, input().split())\nif A <= X <= A + B:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
        "result": "passed",
        "similarities": [
            0.9957074522972107,
            0.9957074522972107,
            0.9963192343711853,
            0.9963192343711853,
            0.9957074522972107,
            0.9963192343711853,
            0.9963192343711853,
            0.9975627064704895,
            0.9957074522972107,
            0.9963192343711853,
            0.9975627064704895,
            0.9975627064704895,
            0.9975627064704895,
            0.9975627064704895,
            0.9957074522972107,
            0.9939866662025452,
            0.9975627064704895,
            0.9963192343711853,
            0.9975627064704895,
            0.9929578900337219
        ]
    },
    "4930": {
        "similarity": 0.9970874786376953,
        "body": "    vowels = \"aeiou\"\n    decoded_word = []\n    i = 0\n    while i < len(encoded_sentence):\n        char = encoded_sentence[i]\n        if char in vowels:\n            decoded_word.append(char)\n            i += 3\n        else:\n            decoded_word.append(char)\n            i += 1\n    return ''.join(decoded_word)\n\n# Read input from stdin\nencoded_sentence = input().strip()\ndecoded_sentence = decode_sentence(encoded_sentence)\nprint(decoded_sentence)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964712262153625,
            0.9958365559577942,
            0.9958752989768982,
            0.9955753684043884,
            0.9953624606132507,
            0.9960469603538513,
            0.9959668517112732,
            0.9957051873207092,
            0.9970784783363342,
            0.9970874786376953,
            0.9938346743583679,
            0.9967516660690308,
            0.9945590496063232,
            0.9966579079627991,
            0.9963258504867554,
            0.9955542683601379,
            0.996592104434967,
            0.9939890503883362,
            0.9962399005889893,
            0.9955042004585266
        ]
    },
    "4715": {
        "similarity": 0.9953060150146484,
        "body": "    return len({a, b, c})\n\n# Read input\na, b, c = map(int, input().split())\n\n# Print the result\nprint(count_colors(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9879837036132812,
            0.9934662580490112,
            0.994318425655365,
            0.9952817559242249,
            0.995144784450531,
            0.9943755269050598,
            0.9953060150146484,
            0.9917385578155518,
            0.9934662580490112,
            0.9948907494544983,
            0.9948907494544983,
            0.993103563785553,
            0.9948907494544983,
            0.99388587474823,
            0.9937453269958496,
            0.9879837036132812,
            0.99388587474823,
            0.99388587474823,
            0.9933662414550781,
            0.9888695478439331
        ]
    },
    "4008": {
        "similarity": 0.9973134398460388,
        "body": "    if n < k or len(set(a)) < k:\n        return \"NO\"\n    \n    colors = [0] * n\n    used_colors = set()\n    for i in range(n):\n        if a[i] not in used_colors:\n            colors[i] = k - len(used_colors)\n            used_colors.add(a[i])\n        else:\n            colors[i] = k - 1\n    \n    return \"YES\\n\" + \" \".join(map(str, colors))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output result\nprint(color_array(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961435198783875,
            0.9967113137245178,
            0.9969052672386169,
            0.9956466555595398,
            0.9962053894996643,
            0.9963433146476746,
            0.9923506379127502,
            0.9945369362831116,
            0.9964436888694763,
            0.9951145648956299,
            0.9929099082946777,
            0.9967958331108093,
            0.9966782331466675,
            0.9936074018478394,
            0.9953444600105286,
            0.9962489604949951,
            0.9943196177482605,
            0.9956962466239929,
            0.9973134398460388,
            0.9941647052764893
        ]
    },
    "4257": {
        "similarity": 0.9989507794380188,
        "body": "A, B = map(int, input().split())\nprint(A * B)",
        "result": "passed",
        "similarities": [
            0.9989507794380188,
            0.9989507794380188,
            0.9983655214309692,
            0.998867928981781,
            0.9989507794380188,
            0.9989507794380188,
            0.9988678693771362,
            0.9989507794380188,
            0.9988678693771362,
            0.9989507794380188,
            0.9988678693771362,
            0.983233630657196,
            0.9989507794380188,
            0.9988678693771362,
            0.9988678693771362,
            0.9988678693771362,
            0.9989507794380188,
            0.9989507794380188,
            0.9983655214309692,
            0.998867928981781
        ]
    },
    "4584": {
        "similarity": 0.9971347451210022,
        "body": "import sys\n\n    subordinates = [0] * (N + 1)\n    for i in range(2, N + 1):\n        subordinates[A[i - 1]] += 1\n    return subordinates[1:]\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    A = list(map(int, data[1:]))\n    result = count_subordinates(N, A)\n    for num in result:\n        print(num)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948843121528625,
            0.9933807253837585,
            0.996791660785675,
            0.9952115416526794,
            0.9941271543502808,
            0.9969251751899719,
            0.9952216148376465,
            0.9970144033432007,
            0.9967736005783081,
            0.9971347451210022,
            0.9952216148376465,
            0.9963198304176331,
            0.9970144033432007,
            0.9970740079879761,
            0.9967554211616516,
            0.992002010345459,
            0.9952216148376465,
            0.9952216148376465,
            0.9958899617195129,
            0.9943646788597107
        ]
    },
    "4195": {
        "similarity": 0.9988162517547607,
        "body": "    count = 0\n    num = 0\n    while True:\n        if D == 0 and num % 100 != 0:\n            count += 1\n        elif D == 1 and num % 100 == 0:\n            count += 1\n        elif D == 2 and num % 100 == 0 and (num // 100) % 100 == 0:\n            count += 1\n        if count == N:\n            return num\n        num += 1\n\nif __name__ == \"__main__\":\n    import sys\n    D, N = map(int, input().split())\n    print(find_happy_integer(D, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973765015602112,
            0.9982810616493225,
            0.9982425570487976,
            0.9987180829048157,
            0.9985744953155518,
            0.9987457990646362,
            0.9986590147018433,
            0.9986914396286011,
            0.9972768425941467,
            0.9967842102050781,
            0.9987489581108093,
            0.9981825947761536,
            0.9988162517547607,
            0.9982737302780151,
            0.9981683492660522,
            0.9978964924812317,
            0.9973631501197815,
            0.9978342652320862,
            0.9967752695083618,
            0.9982057213783264
        ]
    },
    "4176": {
        "similarity": 0.9963298439979553,
        "body": "from math import gcd\n\nA, B = map(int, input().split())\nprint(A * B // gcd(A, B))",
        "result": "passed",
        "similarities": [
            0.9952377676963806,
            0.9930943846702576,
            0.9960311055183411,
            0.9960311055183411,
            0.9957530498504639,
            0.9948453307151794,
            0.9951450824737549,
            0.9953715801239014,
            0.9907330274581909,
            0.9955630898475647,
            0.9957530498504639,
            0.9920895099639893,
            0.9960311055183411,
            0.9957530498504639,
            0.9903597831726074,
            0.9957530498504639,
            0.9960358142852783,
            0.9901763796806335,
            0.9963298439979553,
            0.9960311055183411
        ]
    },
    "4166": {
        "similarity": 0.9974287152290344,
        "body": "    from sys import stdin\n    input = stdin.read\n    data = input().split()\n    \n    digits = [0] * N\n    for s, c in conditions:\n        digits[s - 1] = c\n    \n        num_str = str(num)\n        if len(num_str) != N:\n            return False\n        for s, c in conditions:\n            if int(num_str[s - 1]) != c:\n                return False\n        return True\n    \n    for i in range(10**N):\n        if is_valid(i):\n            return i\n    return -1\n\n# Example usage:\nN = int(input().strip())\nM = int(input().strip())\nconditions = [tuple(map(int, input().strip().split())) for _ in range(M)]\n\nprint(find_smallest_integer(N, M, conditions))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967708587646484,
            0.9941385388374329,
            0.9957448244094849,
            0.9957454204559326,
            0.9954451322555542,
            0.9933986663818359,
            0.9970311522483826,
            0.9960475564002991,
            0.9974287152290344,
            0.9970365762710571,
            0.9959784150123596,
            0.9964897036552429,
            0.9966077208518982,
            0.9971897602081299,
            0.9967667460441589,
            0.9958832263946533,
            0.9968096017837524,
            0.9970846772193909,
            0.9968631267547607,
            0.9956493377685547
        ]
    },
    "4827": {
        "similarity": 0.9981603026390076,
        "body": "    if n == 0: return \"zero\"\n    units = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    hundreds = [\"\", \"onehundred\", \"twohundred\", \"threehundred\", \"fourhundred\", \"fivehundred\", \"sixhundred\", \"sevenhundred\", \"eighthundred\", \"ninehundred\"]\n\n    if n < 10: return units[n]\n    elif n < 20: return teens[n - 11]\n    elif n < 100:\n        if n % 10 == 0: return tens[n // 10]\n        else: return tens[n // 10] + number_to_words(n % 10)\n    elif n < 1000:\n        if n % 100 == 0: return hundreds[n // 100]\n        elif n % 100 < 10: return hundreds[n // 100] + \"and\" + number_to_words(n % 100)\n        else: return hundreds[n // 100] + number_to_words(n % 100)\n\n    N = int(input())\n    words = [input().strip() for _ in range(N)]\n    sentence_parts = []\n    \n    for word in words:\n        if word == '$':\n            num_letters = sum(len(w) for w in sentence_parts)\n            sentence_parts.append(number_to_words(num_letters))\n        else:\n            sentence_parts.append(word)\n    \n    print(' '.join(sentence_parts))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981189370155334,
            0.9979175925254822,
            0.9979475736618042,
            0.9954233765602112,
            0.9976401329040527,
            0.9978058338165283,
            0.9980661273002625,
            0.9979950785636902,
            0.9973164796829224,
            0.997617244720459,
            0.9973782896995544,
            0.9981603026390076,
            0.9975970387458801,
            0.9979497790336609,
            0.9978384971618652,
            0.9964549541473389,
            0.9979828596115112,
            0.9971020221710205,
            0.9977861046791077,
            0.9973122477531433
        ]
    },
    "4871": {
        "similarity": 0.9970520734786987,
        "body": "import sys\n\n    n = len(scores)\n    group_score = 0\n    sum_weights = sum((4/5)**i for i in range(n))\n    total_sum = sum(s * (4/5)**i for i, s in enumerate(scores))\n    group_score = total_sum / (5 * sum_weights)\n    \n    average_new_group_scores = [(total_sum - s * (4/5)**i) / (5 * sum_weights - (4/5)**i) for i, s in enumerate(scores)]\n    avg_new_group_score = sum(average_new_group_scores) / n\n    \n    return group_score, avg_new_group_score\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    scores = [int(input().strip()) for _ in range(n)]\n    \n    current_group_score, avg_new_group_score = calculate_group_score(scores)\n    \n    print(current_group_score)\n    print(avg_new_group_score)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966952800750732,
            0.9960954785346985,
            0.996234118938446,
            0.9961182475090027,
            0.9968889951705933,
            0.997035562992096,
            0.9970520734786987,
            0.9961684346199036,
            0.9969510436058044,
            0.9933642148971558,
            0.9952563047409058,
            0.996238112449646,
            0.9969344139099121,
            0.9960045218467712,
            0.9926005005836487,
            0.9950275421142578,
            0.9967930316925049,
            0.9966088533401489,
            0.9963893890380859,
            0.9968780875205994
        ]
    },
    "4148": {
        "similarity": 0.9964156150817871,
        "body": "    result = []\n    for char in S:\n        if 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + N) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    print(''.join(result))\n\n# Read input\nN = int(input())\nS = input().strip()\n\n# Call the function with the provided input\nshift_string(N, S)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9907455444335938,
            0.9903080463409424,
            0.9945248365402222,
            0.996152400970459,
            0.9949503540992737,
            0.9961614012718201,
            0.9955652952194214,
            0.9955652952194214,
            0.9949503540992737,
            0.9953634142875671,
            0.995969295501709,
            0.9941617846488953,
            0.9960765838623047,
            0.9908620119094849,
            0.9961716532707214,
            0.9964156150817871,
            0.9924349784851074,
            0.9892648458480835,
            0.9963284730911255,
            0.9958974123001099
        ]
    },
    "4316": {
        "similarity": 0.9961734414100647,
        "body": "    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    values = list(char_count.values())\n    if len(set(values)) == 2 and 2 in values:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Read input from stdin\ns = input().strip()\ncheck_string(s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958217144012451,
            0.9960152506828308,
            0.9863899946212769,
            0.9947503805160522,
            0.9946306943893433,
            0.9959072470664978,
            0.9950740337371826,
            0.9956129193305969,
            0.9955940246582031,
            0.9936574697494507,
            0.9951390027999878,
            0.9956044554710388,
            0.9947360157966614,
            0.9915031790733337,
            0.9917142987251282,
            0.9961734414100647,
            0.9940738677978516,
            0.9942589998245239,
            0.9960761070251465,
            0.9943721294403076
        ]
    },
    "4397": {
        "similarity": 0.9999259114265442,
        "body": "N, i = map(int, input().split())\nj = N - i + 1\nprint(j)",
        "result": "passed",
        "similarities": [
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9999259114265442,
            0.9985906481742859
        ]
    },
    "4180": {
        "similarity": 0.9986591339111328,
        "body": "N = int(input())\nchange = N % 1000\nprint(change)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9986591339111328,
            0.9986591339111328,
            0.9962684512138367,
            0.9909257292747498,
            0.9986591339111328,
            0.9986591339111328,
            0.9948471784591675,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9891210794448853,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328,
            0.9986591339111328
        ]
    },
    "4907": {
        "similarity": 0.9960628151893616,
        "body": "    if n % 2 == 0:\n        return \"Bob\", 1\n    else:\n        return \"Alice\", 1\n\nn = int(input())\nwinner, move = bob_and_alice_pastime_conundrum(n)\nprint(winner)\nif winner == \"Alice\":\n    print(move)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9933040142059326,
            0.9941151142120361,
            0.9926611185073853,
            0.9897850751876831,
            0.9914377331733704,
            0.993791401386261,
            0.994171142578125,
            0.9952701926231384,
            0.9960335493087769,
            0.9959902763366699,
            0.9889795184135437,
            0.9913077354431152,
            0.9960628151893616,
            0.9922837018966675,
            0.9958886504173279,
            0.993882954120636,
            0.9889795184135437,
            0.9960331320762634,
            0.9948984384536743,
            0.9960615038871765
        ]
    },
    "4839": {
        "similarity": 0.997554361820221,
        "body": "    balloons = list(range(1, n + 1))\n    canisters.sort()\n    balloons.sort(reverse=True)\n    \n    for i in range(n):\n        if canisters[i] < balloons[i]:\n            return \"impossible\"\n    \n    total_canister_volume = sum(canisters)\n    total_balloon_capacity = sum(balloons)\n    max_fraction = total_canister_volume / total_balloon_capacity\n    \n    return max_fraction\n\n# Read input\nn = int(input())\ncanisters = list(map(int, input().split()))\n\n# Output result\nresult = max_fraction(n, canisters)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.997554361820221,
            0.9971963763237,
            0.994748055934906,
            0.996362566947937,
            0.9961987733840942,
            0.9947198629379272,
            0.9973760843276978,
            0.9970458149909973,
            0.9969837069511414,
            0.9963235259056091,
            0.9966642260551453,
            0.9970194101333618,
            0.9966006278991699,
            0.9965434074401855,
            0.9960429668426514,
            0.9971085786819458,
            0.9970036745071411,
            0.9938690066337585,
            0.9926081299781799,
            0.9972847700119019
        ]
    },
    "4665": {
        "similarity": 0.9989619851112366,
        "body": "from collections import namedtuple\n\n    N = int(input())\n    columns = input().split()\n    Student = namedtuple('Student', columns)\n    \n    total_marks = 0\n    for _ in range(N):\n        student_data = input().split()\n        student = Student(*student_data)\n        total_marks += float(student.MARKS)\n    \n    average_marks = total_marks / N\n    print(f\"{average_marks:.2f}\")\n\ncalculate_average_marks()",
        "result": "failed: testcase 0",
        "similarities": [
            0.998468279838562,
            0.9988899230957031,
            0.9987817406654358,
            0.9974774718284607,
            0.9989619851112366,
            0.9988714456558228,
            0.9988476634025574,
            0.99889075756073,
            0.9989619851112366,
            0.9989619851112366,
            0.9988332986831665,
            0.9989510774612427,
            0.9989619851112366,
            0.9988133311271667,
            0.9987817406654358,
            0.991939127445221,
            0.998468279838562,
            0.9966034293174744,
            0.9984179139137268,
            0.9983932375907898
        ]
    },
    "4785": {
        "similarity": 0.9949741363525391,
        "body": "if 'ss' in input():\n    print('hiss')\nelse:\n    print('no hiss')",
        "result": "passed",
        "similarities": [
            0.9925283193588257,
            0.9915902018547058,
            0.9925284385681152,
            0.9949741363525391,
            0.9949741363525391,
            0.9892101287841797,
            0.9934884905815125,
            0.9949741363525391,
            0.981322169303894,
            0.9934884905815125,
            0.9949741363525391,
            0.9928610920906067,
            0.9785600900650024,
            0.9949741363525391,
            0.9949741363525391,
            0.9925284385681152,
            0.9925283193588257,
            0.9893546104431152,
            0.9925284385681152,
            0.9949741363525391
        ]
    },
    "4272": {
        "similarity": 0.9952774047851562,
        "body": "    N = int(input())\n    S = input()\n    count = 0\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            count += 1\n    print(count)\n\ncount_abc_subsequences()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951688051223755,
            0.9952774047851562,
            0.9907130002975464,
            0.9907130002975464,
            0.9952328205108643,
            0.9907130002975464,
            0.990239679813385,
            0.9907130002975464,
            0.9950881004333496,
            0.9952774047851562,
            0.9950881004333496,
            0.9920278787612915,
            0.990732729434967,
            0.9951453804969788,
            0.9952328205108643,
            0.9951453804969788,
            0.9951480031013489,
            0.9918206930160522,
            0.9951688051223755,
            0.9951453804969788
        ]
    },
    "4092": {
        "similarity": 0.9978922605514526,
        "body": "    insertions = 0\n    current_sum = 0\n    seen_sums = set()\n    \n    for i in range(n):\n        current_sum += a[i]\n        if current_sum in seen_sums:\n            insertions += 1\n            current_sum = a[i]\n            seen_sums.clear()\n        seen_sums.add(current_sum)\n    \n    return insertions\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_insertions_to_avoid_zero_sum_subsegments(n, a)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978101849555969,
            0.9961345195770264,
            0.9977126121520996,
            0.9974415302276611,
            0.9974180459976196,
            0.9966439008712769,
            0.9965372681617737,
            0.9976985454559326,
            0.9955132007598877,
            0.9972381591796875,
            0.9975751638412476,
            0.9967557191848755,
            0.9956003427505493,
            0.9978922605514526,
            0.9963691234588623,
            0.9970679879188538,
            0.9936918020248413,
            0.9974748492240906,
            0.9956486225128174,
            0.9974272847175598
        ]
    },
    "4023": {
        "similarity": 0.9975641965866089,
        "body": "    max_height = max(a)\n    total_bricks_needed = 0\n    \n    for height in a:\n        if height < max_height:\n            total_bricks_needed += (max_height - height) // 2\n    \n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975641965866089,
            0.9962911009788513,
            0.9959947466850281,
            0.9969143271446228,
            0.9953033328056335,
            0.9959327578544617,
            0.9943687319755554,
            0.9964302778244019,
            0.9959327578544617,
            0.99657142162323,
            0.9974128603935242,
            0.9973349571228027,
            0.9973421692848206,
            0.9951282143592834,
            0.9922530651092529,
            0.9975641965866089,
            0.9964772462844849,
            0.9960519671440125,
            0.9943650960922241,
            0.9923631548881531
        ]
    },
    "4160": {
        "similarity": 0.9982456564903259,
        "body": "import sys\n\n    X = int(input())\n    balance = 100\n    years = 0\n    \n    while balance < X:\n        balance += balance // 100\n        years += 1\n    \n    print(years)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968875050544739,
            0.9979199767112732,
            0.9967591166496277,
            0.9982456564903259,
            0.9980795979499817,
            0.9964059591293335,
            0.9982456564903259,
            0.9980795979499817,
            0.9982456564903259,
            0.9980795979499817,
            0.9967716932296753,
            0.9982456564903259,
            0.9967347383499146,
            0.9980795979499817,
            0.9978989362716675,
            0.9979007244110107,
            0.9935246706008911,
            0.9979723691940308,
            0.9968581199645996,
            0.9982456564903259
        ]
    },
    "4815": {
        "similarity": 0.997604250907898,
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = int(data[1])\n    m = int(data[2])\n    \n    players = data[3:3+n]\n    scores = {player: 0 for player in players}\n    \n    index = 3 + n\n    winners = []\n    \n    for _ in range(m):\n        player = data[index]\n        points = int(data[index+1])\n        scores[player] += points\n        if scores[player] >= p and player not in winners:\n            winners.append(player)\n            print(f\"{player} wins!\")\n        index += 2\n    \n    if not winners:\n        print(\"No winner!\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971719980239868,
            0.997604250907898,
            0.9972877502441406,
            0.9970148801803589,
            0.9963527321815491,
            0.9955488443374634,
            0.9964081645011902,
            0.996738851070404,
            0.9969943165779114,
            0.9963523745536804,
            0.996446430683136,
            0.9973630309104919,
            0.9975939393043518,
            0.9956603050231934,
            0.9937048554420471,
            0.9958533048629761,
            0.9966898560523987,
            0.9967458844184875,
            0.9959036111831665,
            0.9966663718223572
        ]
    },
    "4514": {
        "similarity": 0.9977826476097107,
        "body": "from collections import defaultdict, deque\nimport sys\n\n    queue = deque([node])\n    order = []\n    while queue:\n        current = queue.popleft()\n        if level[current] % 2 == 0:\n            order.append(current)\n        for neighbor in adj_list[current]:\n            if neighbor != parent:\n                queue.append(neighbor)\n    return order\n\n    adj_list = defaultdict(list)\n    for i in range(1, n):\n        adj_list[p[i]].append(i)\n    \n    results = []\n    for u, k in queries:\n        if k > len(adj_list[u]) + 1:\n            results.append(-1)\n            continue\n        order = dfs(u, -1, 0)\n        results.append(order[k-1])\n    \n    return results\n\n# Read input\nn, q = map(int, input().split())\np = list(map(int, input().split()))\nqueries = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Process queries and print results\nresults = process_queries(n, q, p, queries)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974671602249146,
            0.9976284503936768,
            0.9931321740150452,
            0.9971338510513306,
            0.9960644245147705,
            0.9943913221359253,
            0.9977826476097107,
            0.9974308013916016,
            0.9976903796195984,
            0.9971861839294434,
            0.9968774914741516,
            0.9975050091743469,
            0.997501790523529,
            0.997502863407135,
            0.9969618916511536,
            0.9972100853919983,
            0.9942626953125,
            0.9976757764816284,
            0.9973404407501221,
            0.9968504905700684
        ]
    },
    "4585": {
        "similarity": 0.9916960000991821,
        "body": "import sys\n\n    i = 1\n    while True:\n        if X <= i * (i + 1) // 2:\n            return i\n        i += 1\n\nif __name__ == \"__main__\":\n    X = int(input().strip())\n    print(min_time_to_reach_nest(X))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9822958707809448,
            0.9841327667236328,
            0.9909663200378418,
            0.9909519553184509,
            0.9895681142807007,
            0.9822958707809448,
            0.9916960000991821,
            0.9915295839309692,
            0.9879355430603027,
            0.9904780983924866,
            0.9902490377426147,
            0.9886780977249146,
            0.9903398752212524,
            0.9863572716712952,
            0.9841694235801697,
            0.9841327667236328,
            0.9914050698280334,
            0.984995424747467,
            0.9916094541549683,
            0.9915624856948853
        ]
    },
    "4781": {
        "similarity": 0.9971552491188049,
        "body": "    players = list(range(1, 9))\n    current_index = players.index(K)\n    \n    for _ in range(N):\n        time_passed, answer = input().split()\n        time_passed = int(time_passed)\n        if answer == 'P':\n            continue\n        current_index = (current_index + 1) % len(players)\n    \n    return players[current_index]\n\n# Read input from stdin\nK = int(input())\nN = int(input())\n\n# Determine and print the exploding player\nprint(determine_exploding_player(K, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964505434036255,
            0.9960426688194275,
            0.9962626099586487,
            0.9952354431152344,
            0.9970491528511047,
            0.9968976378440857,
            0.9964496493339539,
            0.9957200884819031,
            0.9936816692352295,
            0.9927002787590027,
            0.9967674612998962,
            0.996372401714325,
            0.9967675805091858,
            0.9958917498588562,
            0.9934287667274475,
            0.9971552491188049,
            0.9962162375450134,
            0.9956339597702026,
            0.9963810443878174,
            0.9963334798812866
        ]
    },
    "4551": {
        "similarity": 0.9993259906768799,
        "body": "A, B, C, D = map(int, input().split())\nL = A + B\nR = C + D\nif L > R:\n    print(\"Left\")\nelif L < R:\n    print(\"Right\")\nelse:\n    print(\"Balanced\")",
        "result": "passed",
        "similarities": [
            0.9993259310722351,
            0.9993259310722351,
            0.9993259310722351,
            0.9993143677711487,
            0.9992649555206299,
            0.9993259310722351,
            0.9983569979667664,
            0.9993259310722351,
            0.9992649555206299,
            0.9993259906768799,
            0.998444139957428,
            0.9920953512191772,
            0.9993259310722351,
            0.998444139957428,
            0.9993259310722351,
            0.9993259310722351,
            0.9993259310722351,
            0.9993259310722351,
            0.9983569979667664,
            0.9993259310722351
        ]
    },
    "4345": {
        "similarity": 0.9973073601722717,
        "body": "    increasing = []\n    decreasing = []\n    \n    i = 0\n    while i < n:\n        if not increasing or increasing[-1] <= a[i]:\n            increasing.append(a[i])\n        else:\n            break\n        i += 1\n    \n    if i == n:\n        return \"NO\"\n    \n    j = i\n    while j < n:\n        if not decreasing or decreasing[-1] >= a[j]:\n            decreasing.append(a[j])\n        else:\n            break\n        j += 1\n    \n    if j != n:\n        return \"NO\"\n    \n    res = [0] * n\n    for k in range(i):\n        res[k] = 0\n    for k in range(i, n):\n        res[k] = 1\n    \n    return \"YES\\n\" + \" \".join(map(str, res))\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(split_sequence(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966194033622742,
            0.994973361492157,
            0.9962752461433411,
            0.9953268766403198,
            0.9958958029747009,
            0.9973073601722717,
            0.9966386556625366,
            0.9966888427734375,
            0.9968398213386536,
            0.996813952922821,
            0.9958149790763855,
            0.9971728920936584,
            0.9962013959884644,
            0.9972614645957947,
            0.9943612813949585,
            0.9956242442131042,
            0.9916070699691772,
            0.9940842390060425,
            0.995334804058075,
            0.9970781207084656
        ]
    },
    "4075": {
        "similarity": 0.9975796937942505,
        "body": "from itertools import product\n\n    switch_states = list(product([0, 1], repeat=N))\n    count = 0\n    \n    for state in switch_states:\n        is_lighted = True\n        for bulb in range(M):\n            if sum(state[s-1] for s in connections[bulb]) % 2 != parity[bulb]:\n                is_lighted = False\n                break\n        if is_lighted:\n            count += 1\n    \n    print(count)\n\n# Read input from stdin\nN, M = map(int, input().split())\nconnections = []\nparity = []\nfor _ in range(M):\n    k, *s = map(int, input().split())\n    connections.append(s)\nfor p in map(int, input().split()):\n    parity.append(p)\n\n# Call the function with the input\ncount_lighted_combinations(N, M, connections, parity)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973440766334534,
            0.9971210360527039,
            0.9964938163757324,
            0.9963975548744202,
            0.9954946637153625,
            0.9965136647224426,
            0.9975796937942505,
            0.9973490834236145,
            0.9948365092277527,
            0.9965484142303467,
            0.9962312579154968,
            0.9959489703178406,
            0.9968032836914062,
            0.9959028363227844,
            0.9968093037605286,
            0.997206449508667,
            0.9973788857460022,
            0.9967402219772339,
            0.9971131682395935,
            0.996645987033844
        ]
    },
    "4408": {
        "similarity": 0.9972493052482605,
        "body": "    from collections import Counter\n\n    # Count the frequency of each card number\n    card_count = Counter(cards)\n    \n    # Initialize total joy level\n    total_joy = 0\n    \n    # Distribute cards to maximize joy levels\n    for i in range(n):\n        player_favorite = favorites[i]\n        player_joy = 0\n        \n        for j in range(k):\n            if player_favorite in card_count and card_count[player_favorite] > 0:\n                player_joy += 1\n                card_count[player_favorite] -= 1\n        \n        # Calculate joy level based on the count of favorite cards\n        total_joy += joy_levels[player_joy]\n    \n    return total_joy\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\ncards = list(map(int, data[2:2*n+k]))\nfavorites = list(map(int, data[2*n+k:2*n+2*k]))\njoy_levels = list(map(int, data[2*n+2*k:]))\n\n# Calculate and print the result\nresult = max_joy_levels(n, k, cards, favorites, joy_levels)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953727722167969,
            0.9943538308143616,
            0.9960358142852783,
            0.9963449239730835,
            0.99609375,
            0.9958930015563965,
            0.9932256937026978,
            0.9969891905784607,
            0.9970617890357971,
            0.9961597919464111,
            0.9954956769943237,
            0.996902346611023,
            0.9972493052482605,
            0.9965764880180359,
            0.9954366087913513,
            0.9952066540718079,
            0.9958773255348206,
            0.9968591928482056,
            0.9966806173324585,
            0.9957132935523987
        ]
    },
    "4282": {
        "similarity": 0.9972931742668152,
        "body": "    kids = set(range(1, n + 1))\n    adj_list = {i: [] for i in range(1, n + 1)}\n    \n    for i, (a, b) in enumerate(pairs, start=1):\n        if a not in adj_list[i]:\n            adj_list[i].append(a)\n        if b not in adj_list[i]:\n            adj_list[i].append(b)\n    \n        for i in range(1, n + 1):\n            if len(adj_list[i]) == 2:\n                return i\n        return None\n    \n    start = find_start()\n    order = []\n    seen = set()\n    \n    while len(order) < n:\n        order.append(start)\n        seen.add(start)\n        next_kid = adj_list[start].pop(0)\n        if next_kid in seen:\n            next_kid = adj_list[start][0]\n        start = next_kid\n    \n    return ' '.join(map(str, order))\n\n# Read input\nn = int(input().strip())\npairs = [tuple(map(int, input().strip().split())) for _ in range(n)]\n\n# Output the result\nprint(restore_dance_order(n, pairs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964429140090942,
            0.9967213869094849,
            0.9965354800224304,
            0.9972931742668152,
            0.997164785861969,
            0.9961395263671875,
            0.9965081810951233,
            0.9971888661384583,
            0.9968970417976379,
            0.996086835861206,
            0.9972787499427795,
            0.9944391846656799,
            0.9966604113578796,
            0.9971888661384583,
            0.9963067770004272,
            0.9968260526657104,
            0.9964662194252014,
            0.9966420531272888,
            0.9964525103569031,
            0.9956361651420593
        ]
    },
    "4331": {
        "similarity": 0.998753011226654,
        "body": "N = input()\nif '7' in N:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed",
        "similarities": [
            0.9985027313232422,
            0.9985429048538208,
            0.9985429048538208,
            0.9985429048538208,
            0.9975201487541199,
            0.9985836744308472,
            0.998753011226654,
            0.9985027313232422,
            0.9985836744308472,
            0.998753011226654,
            0.9985027313232422,
            0.9983301758766174,
            0.9958757162094116,
            0.9960997700691223,
            0.9985027313232422,
            0.9985429048538208,
            0.9985429048538208,
            0.9985429048538208,
            0.998753011226654,
            0.9960997700691223
        ]
    },
    "4550": {
        "similarity": 0.994277834892273,
        "body": "    total = a + b + c\n    if total % 2 != 0:\n        return \"No\"\n    target = total // 2\n    if a == target or b == target or c == target:\n        return \"Yes\"\n    if a + b == target or a + c == target or b + c == target:\n        return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9863853454589844,
            0.9937992095947266,
            0.993608295917511,
            0.994277834892273,
            0.9942450523376465,
            0.9855716228485107,
            0.9933847188949585,
            0.9815961122512817,
            0.9813445210456848,
            0.9931789040565491,
            0.991651713848114,
            0.9942450523376465,
            0.9936490654945374,
            0.9903655052185059,
            0.9926669597625732,
            0.9941363334655762,
            0.9904853701591492,
            0.9910852313041687,
            0.9924665093421936,
            0.986666738986969
        ]
    },
    "4271": {
        "similarity": 0.9963088035583496,
        "body": "import sys\n\n    total_points = sum(B)\n    \n    for i in range(N - 1):\n        if A[i] + 1 == A[i + 1]:\n            total_points += C[i]\n    \n    return total_points\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    C = list(map(int, data[2*N+1:2*N+N-1]))\n    \n    result = calculate_satisfaction_points(N, A, B, C)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9932299256324768,
            0.9950042366981506,
            0.9932073354721069,
            0.9954926371574402,
            0.9961214661598206,
            0.9943608641624451,
            0.9942870736122131,
            0.9958958029747009,
            0.9960156679153442,
            0.9953049421310425,
            0.993174135684967,
            0.9949327111244202,
            0.9929875731468201,
            0.9948726296424866,
            0.9961056113243103,
            0.9963088035583496,
            0.9955506920814514,
            0.9952785968780518,
            0.9959970116615295,
            0.9948683381080627
        ]
    },
    "4848": {
        "similarity": 0.9971210956573486,
        "body": "import sys\n\n    for i in range(2, int(num**0.5) + 1):\n        if num % (i * i) == 0:\n            return False\n    return True\n\n    for m in range(2, n):\n        if is_squarefree(m * n):\n            return m\n\nn = int(input().strip())\nprint(find_m(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995978593826294,
            0.9971210956573486,
            0.99419105052948,
            0.9938165545463562,
            0.9903410077095032,
            0.9971176981925964,
            0.9966028928756714,
            0.9947629570960999,
            0.9961968660354614,
            0.995108962059021,
            0.996209979057312,
            0.9950677752494812,
            0.9952775835990906,
            0.9965560436248779,
            0.9965333342552185,
            0.9961832761764526,
            0.9938201904296875,
            0.9955758452415466,
            0.9955237507820129,
            0.9961921572685242
        ]
    },
    "4694": {
        "similarity": 0.9955171346664429,
        "body": "import sys\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    \n    # Sort the coordinates to easily find the minimum distance\n    a.sort()\n    \n    # The minimum distance is between the first and last house\n    min_distance = abs(a[0] - a[-1])\n    \n    print(min_distance)\n\nmin_travel_distance()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953631162643433,
            0.9947205781936646,
            0.9942775368690491,
            0.9942193627357483,
            0.9909838438034058,
            0.9951858520507812,
            0.9945663809776306,
            0.9924269318580627,
            0.9955171346664429,
            0.9942606091499329,
            0.9931269288063049,
            0.9930791258811951,
            0.9953981041908264,
            0.9898826479911804,
            0.9944305419921875,
            0.9858648180961609,
            0.9914657473564148,
            0.9910184144973755,
            0.9948242902755737,
            0.9946911334991455
        ]
    },
    "4213": {
        "similarity": 0.9947138428688049,
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    min_val = min(A)\n    max_val = max(A)\n    \n    print(max_val - min_val)\n\nmax_absolute_difference()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930535554885864,
            0.9887805581092834,
            0.9914041757583618,
            0.9873855113983154,
            0.9937097430229187,
            0.9931210875511169,
            0.9900751709938049,
            0.9918911457061768,
            0.9914041757583618,
            0.991940975189209,
            0.9933159351348877,
            0.9914041757583618,
            0.9879742860794067,
            0.991940975189209,
            0.9944667816162109,
            0.9947138428688049,
            0.9914750456809998,
            0.9904012084007263,
            0.9902421832084656,
            0.9917649030685425
        ]
    },
    "4471": {
        "similarity": 0.9969500303268433,
        "body": "    while any(height > 1 for height in heights):\n        placed = False\n        for i in range(n):\n            if heights[i] % 2 == 0:\n                heights[i] += 2\n                placed = True\n                break\n        if not placed:\n            return \"NO\"\n        heights = [height - 1 for height in heights]\n    return \"YES\"\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        heights = list(map(int, data[index+1:index+n+1]))\n        index += n + 1\n        results.append(can_clear_tetris_field(n, heights))\n    \n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964950084686279,
            0.9964865446090698,
            0.9961059093475342,
            0.9969500303268433,
            0.9950928092002869,
            0.9942317605018616,
            0.9960700869560242,
            0.9935513734817505,
            0.9966672658920288,
            0.9961469769477844,
            0.9960818886756897,
            0.9955039024353027,
            0.9955784678459167,
            0.9940958619117737,
            0.9964486956596375,
            0.995466947555542,
            0.9918795228004456,
            0.995965838432312,
            0.994938313961029,
            0.9881348013877869
        ]
    },
    "4802": {
        "similarity": 0.9939695000648499,
        "body": "    H -= M // 60 + (H < (M % 60 > 45))\n    M = (M - 45) % 60\n    if H < 0:\n        H += 24\n    return f\"{H:02d} {M:02d}\"\n\n# Read input from stdin\nH, M = map(int, input().split())\n\n# Print the result\nprint(adjust_alarm(H, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925328493118286,
            0.991061270236969,
            0.9911468029022217,
            0.9912102222442627,
            0.9921699166297913,
            0.9933732748031616,
            0.9929448366165161,
            0.9890556335449219,
            0.9894464612007141,
            0.9939573407173157,
            0.9909340739250183,
            0.9852821230888367,
            0.9923776388168335,
            0.9922840595245361,
            0.9889540672302246,
            0.9925695061683655,
            0.992991030216217,
            0.9939695000648499,
            0.9933903217315674,
            0.990952730178833
        ]
    },
    "4890": {
        "similarity": 0.997321605682373,
        "body": "import sys\nfrom typing import List\n\n    free_slots = [d - c for c in current_sodas if c < d]\n    \n    if len(free_slots) < n:\n        return \"impossible\"\n    \n    new_bottles = [0] * s\n    remaining_students = m\n    \n    while remaining_students > 0 and free_slots:\n        max_free_slot_index = free_slots.index(max(free_slots))\n        if current_sodas[max_free_slot_index] + n < d:\n            new_bottles[max_free_slot_index] += 1\n            n -= 1\n            remaining_students -= 1\n        free_slots[max_free_slot_index] -= 1\n    \n    return ' '.join(map(str, new_bottles))\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = int(data[2])\n    d = int(data[3])\n    current_sodas = list(map(int, data[4:]))\n    \n    result = refill_fridge(n, m, s, d, current_sodas)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972835183143616,
            0.9966737031936646,
            0.9950894713401794,
            0.9949436187744141,
            0.9966684579849243,
            0.9955652952194214,
            0.9965338706970215,
            0.997321605682373,
            0.997263491153717,
            0.9973019957542419,
            0.997024655342102,
            0.9971312284469604,
            0.9969164133071899,
            0.9956393837928772,
            0.9958704710006714,
            0.9959312081336975,
            0.996543288230896,
            0.9968462586402893,
            0.9950793385505676,
            0.9969985485076904
        ]
    },
    "4286": {
        "similarity": 0.9981070160865784,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    edges = []\n    for x, y, w in offers:\n        edges.append((w, x-1, y-1))\n    \n    # Add all possible edges without special offers\n    for i in range(n):\n        for j in range(i+1, n):\n            heappush(edges, (a[i] + a[j], i, j))\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    min_cost = 0\n    for cost, u, v in edges:\n        if find(u) != find(v):\n            union(u, v)\n            min_cost += cost\n            n -= 1\n            if n == 1:\n                break\n    \n    return min_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    offers = []\n    for i in range(m):\n        x = int(data[2+n+i*3]) - 1\n        y = int(data[2+n+i*3+1]) - 1\n        w = int(data[2+n+i*3+2])\n        offers.append((x, y, w))\n    \n    result = find_min_cost_to_connect_graph(n, m, a, offers)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973732829093933,
            0.9961668252944946,
            0.9978542327880859,
            0.9976159334182739,
            0.9979711771011353,
            0.9979966878890991,
            0.9972139000892639,
            0.9975330233573914,
            0.9977611899375916,
            0.9977594614028931,
            0.9972946047782898,
            0.9965966939926147,
            0.9972889423370361,
            0.9977244138717651,
            0.9976576566696167,
            0.9974070191383362,
            0.9976593852043152,
            0.9976467490196228,
            0.9974898099899292,
            0.9981070160865784
        ]
    },
    "4713": {
        "similarity": 0.9971188902854919,
        "body": "N = int(input())\nS = input()\nx = 0\nmax_x = 0\n\nfor char in S:\n    if char == 'I':\n        x += 1\n    else:\n        x -= 1\n    max_x = max(max_x, x)\n\nprint(max_x)",
        "result": "passed",
        "similarities": [
            0.9970481395721436,
            0.9950630068778992,
            0.9952796101570129,
            0.9965968728065491,
            0.9956873655319214,
            0.9949938058853149,
            0.9971188902854919,
            0.9962313771247864,
            0.9969605207443237,
            0.9969350695610046,
            0.9962557554244995,
            0.9968553185462952,
            0.9970226287841797,
            0.9963729381561279,
            0.9971188902854919,
            0.9968267679214478,
            0.9971188902854919,
            0.9967987537384033,
            0.9947373270988464,
            0.9971014261245728
        ]
    },
    "4698": {
        "similarity": 0.997877836227417,
        "body": "import sys\n\n    N = int(input())\n    T = list(map(int, input().split()))\n    M = int(input())\n    drinks = []\n    for _ in range(M):\n        P, X = map(int, input().split())\n        drinks.append((P-1, X))\n    \n    results = []\n    for P, X in drinks:\n        total_time = sum(max(T[i], T[P] + (X - T[P]) * (i == P)) for i in range(N))\n        results.append(total_time)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997277021408081,
            0.9954763054847717,
            0.9972150921821594,
            0.9975804686546326,
            0.994636058807373,
            0.9965966939926147,
            0.9976686239242554,
            0.997871994972229,
            0.9975845217704773,
            0.9975370168685913,
            0.9970069527626038,
            0.9977115988731384,
            0.9976994395256042,
            0.9974644184112549,
            0.997877836227417,
            0.9974235892295837,
            0.9970363974571228,
            0.9971914887428284,
            0.9976816773414612,
            0.9972423911094666
        ]
    },
    "4841": {
        "similarity": 0.9976479411125183,
        "body": "    n = int(input())\n    bites = input().split()\n    \n    last_number = 0\n    for bite in bites:\n        if bite == \"mumble\":\n            continue\n        number = int(bite)\n        if number <= last_number:\n            print(\"something is fishy\")\n            return\n        last_number = number\n    \n    print(\"makes sense\")\n\ncheck_arild_counting()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965152740478516,
            0.9976479411125183,
            0.9965152740478516,
            0.9972234964370728,
            0.9975072145462036,
            0.993238627910614,
            0.9964848756790161,
            0.997019350528717,
            0.9967873096466064,
            0.9969869256019592,
            0.9972999095916748,
            0.9974125623703003,
            0.9969265460968018,
            0.9949138164520264,
            0.9965623617172241,
            0.9965154528617859,
            0.9973018169403076,
            0.9973616600036621,
            0.9915950298309326,
            0.9926490783691406
        ]
    },
    "4865": {
        "similarity": 0.9973412752151489,
        "body": "import sys\n\n    if direction == 'F':\n        new_minute = (current_minute + duration) % 60\n        new_hour = (current_hour + (current_minute + duration) // 60) % 24\n    else:\n        new_minute = (current_minute - duration) % 60\n        new_hour = (current_hour - (duration - current_minute) // 60) % 24\n    \n    return f\"{new_hour} {new_minute}\"\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    for _ in range(n):\n        direction, duration, current_hour, current_minute = input().strip().split()\n        duration = int(duration)\n        current_hour = int(current_hour)\n        current_minute = int(current_minute)\n        print(calculate_new_time(direction, duration, current_hour, current_minute))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946489930152893,
            0.9968404173851013,
            0.9967891573905945,
            0.9940399527549744,
            0.9969216585159302,
            0.9956490397453308,
            0.9923694133758545,
            0.9965383410453796,
            0.9965571165084839,
            0.994891345500946,
            0.9960489869117737,
            0.9961158633232117,
            0.9973412752151489,
            0.9954878091812134,
            0.9967769980430603,
            0.9957965016365051,
            0.9930500388145447,
            0.9967532157897949,
            0.9964731931686401,
            0.9967188835144043
        ]
    },
    "4957": {
        "similarity": 0.9959113597869873,
        "body": "import sys\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check adjacent cells\n                if (i > 0 and grid[i-1][j] != 'E') or \\\n                   (i < n-1 and grid[i+1][j] != 'E') or \\\n                   (j > 0 and grid[i][j-1] != 'E') or \\\n                   (j < m-1 and grid[i][j+1] != 'E'):\n                    # Place coffee shop if adjacent cells are not coffee shops\n                    grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n    return grid\n\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    grid = data[2:]\n    result = place_coffee_shops(n, m, grid)\n    for row in result:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946449995040894,
            0.9956535696983337,
            0.9958356618881226,
            0.9953014850616455,
            0.9955145120620728,
            0.9948613047599792,
            0.9946605563163757,
            0.9934125542640686,
            0.9959113597869873,
            0.9948357343673706,
            0.9957208037376404,
            0.9957747459411621,
            0.9952422976493835,
            0.9926161766052246,
            0.9957976937294006,
            0.9952610731124878,
            0.9908081889152527,
            0.9946545958518982,
            0.9947662353515625,
            0.9950166344642639
        ]
    },
    "4382": {
        "similarity": 0.9975693225860596,
        "body": "import sys\n\nN = int(input())\nprint(N**3)",
        "result": "passed",
        "similarities": [
            0.9975693225860596,
            0.9975365400314331,
            0.9975365400314331,
            0.9935035705566406,
            0.9883480072021484,
            0.9927428364753723,
            0.9963580965995789,
            0.996081531047821,
            0.9975365400314331,
            0.996081531047821,
            0.9963580965995789,
            0.9975365400314331,
            0.9975693225860596,
            0.9963580965995789,
            0.9975365400314331,
            0.9975693225860596,
            0.9963580965995789,
            0.9963580965995789,
            0.9927761554718018,
            0.9958441853523254
        ]
    },
    "4456": {
        "similarity": 0.9972391724586487,
        "body": "    if n < k:\n        return \"NO\"\n    \n    distinct_chars = list('abcdefghijklmnopqrstuvwxyz')[:k]\n    s = [''] * n\n    \n    i, j = 0, 0\n    while i < n and j < n:\n        if s[p[i] - 1] == '':\n            s[p[i] - 1] = distinct_chars.pop(0)\n            i += 1\n        elif s[q[j] - 1] == '':\n            s[q[j] - 1] = distinct_chars.pop(0)\n            j += 1\n    \n    if any(char == '' for char in s):\n        return \"NO\"\n    \n    return \"YES\\n\" + ''.join(s)\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# Print result\nresult = restore_string(n, k, p, q)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972391724586487,
            0.9963286519050598,
            0.9910882711410522,
            0.9963588714599609,
            0.9955793619155884,
            0.995544970035553,
            0.9950539469718933,
            0.9968798756599426,
            0.9966368675231934,
            0.997106671333313,
            0.9965760111808777,
            0.9967174530029297,
            0.9964631795883179,
            0.9969950318336487,
            0.99578857421875,
            0.9954739809036255,
            0.9950520396232605,
            0.9934322834014893,
            0.9962693452835083,
            0.9943199157714844
        ]
    },
    "4594": {
        "similarity": 0.9973998069763184,
        "body": "    diameters.sort()\n    max_layer = 1\n    current_diameter = diameters[0]\n    \n    for i in range(1, N):\n        if diameters[i] < current_diameter:\n            max_layer += 1\n            current_diameter = diameters[i]\n    \n    return max_layer\n\n# Read input from stdin\nN = int(input().strip())\ndiameters = [int(input().strip()) for _ in range(N)]\n\n# Print the result\nprint(max_layers(N, diameters))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954421520233154,
            0.9968689680099487,
            0.9957665205001831,
            0.997127115726471,
            0.9973883628845215,
            0.9955065846443176,
            0.989904522895813,
            0.9972317218780518,
            0.9929512739181519,
            0.9972140789031982,
            0.9973998069763184,
            0.9971708059310913,
            0.9970827698707581,
            0.996921718120575,
            0.9968889951705933,
            0.9973413348197937,
            0.9969309568405151,
            0.9971961975097656,
            0.9960441589355469,
            0.9971905946731567
        ]
    },
    "4560": {
        "similarity": 0.9973027110099792,
        "body": "    for i in range(A + 1):\n        if (N - 500 * i) % 1 == 0:\n            return \"Yes\"\n    return \"No\"\n\nN = int(input())\nA = int(input())\nprint(can_pay(N, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9939156770706177,
            0.9969083070755005,
            0.9968582987785339,
            0.9969894289970398,
            0.9969002604484558,
            0.9961850047111511,
            0.9968934655189514,
            0.9963981509208679,
            0.9961273670196533,
            0.9969894289970398,
            0.9964407086372375,
            0.9970243573188782,
            0.9963993430137634,
            0.996616780757904,
            0.9970152974128723,
            0.9969765543937683,
            0.9973027110099792,
            0.98920077085495,
            0.988373339176178,
            0.9969049692153931
        ]
    },
    "4320": {
        "similarity": 0.9966751933097839,
        "body": "import sys\n\n    for k in range(2, n.bit_length()):\n        if n % (2**k - 1) == 0:\n            x = n // (2**k - 1)\n            return x\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(find_x(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9918952584266663,
            0.9945976138114929,
            0.9830734133720398,
            0.9957882761955261,
            0.9961706399917603,
            0.9939701557159424,
            0.9966477155685425,
            0.9943842887878418,
            0.9959718585014343,
            0.9955998659133911,
            0.996551513671875,
            0.9966751933097839,
            0.996551513671875,
            0.9962320923805237,
            0.9961323142051697,
            0.9939500689506531,
            0.995570957660675,
            0.9959058165550232,
            0.9932889342308044,
            0.995303213596344
        ]
    },
    "4500": {
        "similarity": 0.999541163444519,
        "body": "A, B, C = map(int, input().split())\nif A + B >= C:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed",
        "similarities": [
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.9945749044418335,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.9965997934341431,
            0.999541163444519,
            0.9993525147438049,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519,
            0.999541163444519
        ]
    },
    "4739": {
        "similarity": 0.9969945549964905,
        "body": "import sys\n\n    possible_speeds = set()\n    distances = []\n    \n    for i in range(1, M):\n        time_diff = T[i] - T[0]\n        distance_diff = X[T.index(T[i])] - X[0]\n        speed = distance_diff / time_diff\n        if speed not in possible_speeds:\n            possible_speeds.add(speed)\n            distances.append(distance_diff)\n    \n    distinct_speeds_count = len(possible_speeds)\n    sorted_distances = sorted(distances)\n    \n    print(distinct_speeds_count)\n    print(' '.join(map(str, sorted_distances)))\n\n# Read input from stdin\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\nfind_possible_speeds_and_distances(M, N, T, X)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9935919046401978,
            0.9961965680122375,
            0.9911110401153564,
            0.993291974067688,
            0.9957711100578308,
            0.9955538511276245,
            0.9959085583686829,
            0.9946284890174866,
            0.9966601133346558,
            0.9959846138954163,
            0.9951949119567871,
            0.9965688586235046,
            0.9966985583305359,
            0.9938531517982483,
            0.9969945549964905,
            0.9961333274841309,
            0.9945630431175232,
            0.9929944276809692,
            0.9961961507797241,
            0.995445966720581
        ]
    },
    "4410": {
        "similarity": 0.9978536367416382,
        "body": "import sys\n\n    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '1':\n            i += k + 1\n        else:\n            count += 1\n            i += 1\n    return count\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    s = data[index + 2]\n    index += 3\n    results.append(max_tables_to_occupy(n, k, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977792501449585,
            0.9971960186958313,
            0.9971761107444763,
            0.9963129758834839,
            0.9976083636283875,
            0.9978199005126953,
            0.9958730936050415,
            0.997830331325531,
            0.9974485635757446,
            0.9978536367416382,
            0.9975212812423706,
            0.9975136518478394,
            0.9966657757759094,
            0.9977390170097351,
            0.9974227547645569,
            0.9972172975540161,
            0.997847318649292,
            0.997796893119812,
            0.9975625872612,
            0.9958174824714661
        ]
    },
    "2441": {
        "similarity": 0.9981294870376587,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    MOD = 10**9 + 7\n    \n    # Build adjacency list for directed graph\n    adj_list = defaultdict(list)\n    for u, v in roads:\n        adj_list[u].append(v)\n    \n    # Initialize distance and checkpost count arrays\n    dist = [float('inf')] * (n + 1)\n    checkpoint_count = [0] * (n + 1)\n    \n        queue = deque([start])\n        dist[start] = 0\n        checkpoint_count[start] = 1\n        \n        while queue:\n            current = queue.popleft()\n            for neighbor in adj_list[current]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[current] + 1\n                    checkpoint_count[neighbor] = checkpoint_count[current]\n                    queue.append(neighbor)\n                elif dist[neighbor] == dist[current] + 1:\n                    checkpoint_count[neighbor] += checkpoint_count[current]\n        \n        return sum(costs[i-1] * checkpoint_count[i] for i in range(1, n+1))\n    \n    # Find the minimum cost and number of ways\n    min_cost = float('inf')\n    min_ways = 0\n    \n    for i in range(1, n + 1):\n        current_cost = bfs(i)\n        if current_cost < min_cost:\n            min_cost = current_cost\n            min_ways = 1\n        elif current_cost == min_cost:\n            min_ways += 1\n    \n    return min_cost % MOD, min_ways % MOD\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    costs = list(map(int, data[1:n+1]))\n    m = int(data[n+1])\n    roads = [(int(data[n+2 + 2*i]) - 1, int(data[n+3 + 2*i]) - 1) for i in range(m)]\n    \n    min_cost, min_ways = min_cost_and_ways(n, costs, m, roads)\n    print(min_cost, min_ways)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962709546089172,
            0.9978119730949402,
            0.9975525736808777,
            0.9981294870376587,
            0.9976269602775574,
            0.9953224062919617,
            0.9975156188011169,
            0.9962990283966064,
            0.9968156218528748,
            0.9978362917900085,
            0.9979296326637268,
            0.997481107711792,
            0.9972304105758667,
            0.9975097179412842,
            0.9975084066390991,
            0.9978600740432739,
            0.9975298643112183,
            0.9979050159454346,
            0.9979149699211121,
            0.997201144695282
        ]
    },
    "276": {
        "similarity": 0.9958730340003967,
        "body": "    gems = [\"purple\", \"green\", \"blue\", \"orange\", \"red\", \"yellow\"]\n    seen_colors = set(input().strip() for _ in range(int(input())))\n    \n    absent_gems = [gem.capitalize() for gem in gems if gem not in seen_colors]\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956295490264893,
            0.9916900992393494,
            0.9948170185089111,
            0.9958730340003967,
            0.9943273663520813,
            0.9949384927749634,
            0.9952167868614197,
            0.9936726093292236,
            0.9927021861076355,
            0.9873379468917847,
            0.9865407347679138,
            0.9917821288108826,
            0.9958482384681702,
            0.9922099113464355,
            0.9947182536125183,
            0.98822420835495,
            0.9938464760780334,
            0.9951465129852295,
            0.9955819845199585,
            0.992377519607544
        ]
    },
    "2635": {
        "similarity": 0.9965598583221436,
        "body": "import sys\n\n    if not matrix or not matrix[0]:\n        return []\n    \n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows - 1, 0, cols - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_matrix = eval(input())\n    print(spiralOrder(input_matrix))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964292645454407,
            0.993503749370575,
            0.9956993460655212,
            0.996250331401825,
            0.9959008097648621,
            0.9937213063240051,
            0.9957984089851379,
            0.9964169859886169,
            0.9951242208480835,
            0.9959923624992371,
            0.9965039491653442,
            0.9959136843681335,
            0.9957730174064636,
            0.9965145587921143,
            0.9950706362724304,
            0.9956733584403992,
            0.9965598583221436,
            0.9956456422805786,
            0.9961672425270081,
            0.9962489604949951
        ]
    },
    "281": {
        "similarity": 0.9977723360061646,
        "body": "        if n == 0:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % 10\n        return result\n    \n    last_digit_a_fact = factorial(a)\n    last_digit_b_fact = factorial(b)\n    \n    if a == b:\n        return 1\n    elif b - a >= 4:\n        return 0\n    else:\n        return (last_digit_b_fact * pow(last_digit_a_fact, 10, 10)) % 10\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(last_digit_of_factorial_division(a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973678588867188,
            0.9943274259567261,
            0.9964574575424194,
            0.996830403804779,
            0.9974290728569031,
            0.9944618940353394,
            0.9943422079086304,
            0.9967155456542969,
            0.9963428378105164,
            0.9970297813415527,
            0.9968665242195129,
            0.9977723360061646,
            0.997261643409729,
            0.9956296682357788,
            0.9972611665725708,
            0.9975094199180603,
            0.9972211718559265,
            0.9966960549354553,
            0.9973397850990295,
            0.9960837364196777
        ]
    },
    "2300": {
        "similarity": 0.9978610873222351,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    f = [1, 1]\n    for i in range(2, n):\n        f.append(f[i-1] - 1 + f[i-2])\n    \n    index = 2 + n\n    queries = []\n    for _ in range(m):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index+1]) - 1\n            v = int(data[index+2])\n            a[x] = v\n        elif t == 2:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            queries.append((l, r, f[r-l]))\n        else:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            d = int(data[index+3])\n            for x in range(l, r):\n                a[x] += d\n        index += t + (3 if t == 3 else 2)\n    \n    for l, r, multiplier in queries:\n        result = sum(f[i] * a[l+i] for i in range(r-l)) % 1000000000\n        print(result)\n\nsolve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974008202552795,
            0.9978610873222351,
            0.9968883991241455,
            0.9977695941925049,
            0.9965047240257263,
            0.996684730052948,
            0.9962136149406433,
            0.9949813485145569,
            0.9972200989723206,
            0.9973747134208679,
            0.9973085522651672,
            0.9973640441894531,
            0.9948218464851379,
            0.9969732165336609,
            0.997464656829834,
            0.9970152974128723,
            0.9974950551986694,
            0.9976246356964111,
            0.9974004030227661,
            0.9973627328872681
        ]
    },
    "2104": {
        "similarity": 0.9973987936973572,
        "body": "import sys\nfrom math import gcd\n\n    pairs = []\n    if (r - l + 1) % 2 != 0:\n        return \"NO\"\n    for i in range(l, r + 1):\n        for j in range(i + 1, r + 1):\n            if gcd(i, j) == 1:\n                pairs.append((i, j))\n                break\n        else:\n            continue\n        break\n    if len(pairs) != (r - l + 1) // 2:\n        return \"NO\"\n    return \"YES\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in pairs)\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    result = find_pairs(l, r)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964169263839722,
            0.9966035485267639,
            0.9960718750953674,
            0.9965465068817139,
            0.9964766502380371,
            0.9956972002983093,
            0.997268557548523,
            0.9973987936973572,
            0.9963183403015137,
            0.9957178235054016,
            0.996465802192688,
            0.996462881565094,
            0.9972167015075684,
            0.997220516204834,
            0.9939866662025452,
            0.9963000416755676,
            0.997178316116333,
            0.9968926310539246,
            0.9967878460884094,
            0.9935069680213928
        ]
    },
    "1995": {
        "similarity": 0.9983331561088562,
        "body": "    s = list(s)\n    for l, r, k in queries:\n        l -= 1\n        r -= 1\n        substring = s[l:r+1]\n        k %= len(substring)  # In case k is larger than the length of the substring\n        s[l:r+1] = substring[-k:] + substring[:-k]\n    return ''.join(s)\n\n# Read input from stdin\ns = input().strip()\nm = int(input().strip())\nqueries = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\n# Process queries and print the result\nresult = process_queries(s, m, queries)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975717663764954,
            0.9977262616157532,
            0.9968945384025574,
            0.9965739846229553,
            0.9958764314651489,
            0.9981974363327026,
            0.9981510639190674,
            0.998325526714325,
            0.9980286359786987,
            0.9955030679702759,
            0.997585117816925,
            0.9981516599655151,
            0.9981381297111511,
            0.9983331561088562,
            0.9981065392494202,
            0.9978840351104736,
            0.9976065754890442,
            0.9982371926307678,
            0.9979796409606934,
            0.9982430338859558
        ]
    },
    "2064": {
        "similarity": 0.9973015189170837,
        "body": "    if n < 2:\n        return 1\n    sections = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n    digits = []\n    for i in range(9, -1, -1):\n        while n >= sections[i]:\n            digits.append(str(i))\n            n -= sections[i]\n    return int(''.join(digits))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(max_number(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962884783744812,
            0.9973015189170837,
            0.9969738721847534,
            0.9969468712806702,
            0.9959200024604797,
            0.994566798210144,
            0.9971221089363098,
            0.9972295165061951,
            0.9972946047782898,
            0.9963030815124512,
            0.9957218170166016,
            0.9967650175094604,
            0.9910328388214111,
            0.9951944947242737,
            0.9969505667686462,
            0.9960092306137085,
            0.9957557320594788,
            0.9967296123504639,
            0.9957791566848755,
            0.9951039552688599
        ]
    },
    "1715": {
        "similarity": 0.9966176748275757,
        "body": "    results = []\n    for xi in x:\n        min_dist = float('inf')\n        for si in s:\n            if si <= xi:\n                dist_to_si = xi - si\n                for ti in t:\n                    if ti >= xi:\n                        dist_to_ti = ti - xi\n                        min_dist = min(min_dist, dist_to_si + dist_to_ti)\n                        break\n                    else:\n                        dist_to_ti = xi - ti\n                        min_dist = min(min_dist, dist_to_si + dist_to_ti)\n        results.append(min_dist)\n    return results\n\n# Read input\nA, B, Q = map(int, input().split())\ns = [int(input()) for _ in range(A)]\nt = [int(input()) for _ in range(B)]\nx = [int(input()) for _ in range(Q)]\n\n# Calculate and print results\nresults = min_distance_to_visit_shrine_and_temple(A, B, Q, s, t, x)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963788390159607,
            0.9956555962562561,
            0.9950428009033203,
            0.9956867694854736,
            0.9957371950149536,
            0.995178759098053,
            0.9961138367652893,
            0.995432436466217,
            0.9953179955482483,
            0.9963609576225281,
            0.9953017234802246,
            0.9960005879402161,
            0.9959628582000732,
            0.9957044720649719,
            0.9966176748275757,
            0.9954085350036621,
            0.9957091808319092,
            0.9959655404090881,
            0.9946157336235046,
            0.996537983417511
        ]
    },
    "2074": {
        "similarity": 0.9948726296424866,
        "body": "import sys\n\n    min_costs = [min(row) for row in costs]\n    max_min_cost = max(min_costs)\n    return max_min_cost\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    costs = []\n    for _ in range(n):\n        costs.append(list(map(int, input().split())))\n    \n    result = optimal_restaurant(n, m, costs)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9932299256324768,
            0.9925016164779663,
            0.9923424124717712,
            0.9922870993614197,
            0.9916300773620605,
            0.9948040843009949,
            0.992568850517273,
            0.9913102984428406,
            0.990217924118042,
            0.9940065145492554,
            0.9913792014122009,
            0.9932469725608826,
            0.9916587471961975,
            0.9927476644515991,
            0.9917237162590027,
            0.9935258626937866,
            0.9944738149642944,
            0.9948726296424866,
            0.9929505586624146,
            0.9907136559486389
        ]
    },
    "2921": {
        "similarity": 0.9976938962936401,
        "body": "import sys\nfrom itertools import combinations_with_replacement\n\n    m, u, d = map(float, input().split())\n    drinks = []\n    \n    for _ in range(int(d)):\n        name, strength, size, price = input().split()\n        strength = float(strength)\n        price = float(price)\n        if size == '1/1':\n            size_val = 1\n        elif size == '1/2':\n            size_val = 0.5\n        else:\n            size_val = 1/3\n        drinks.append((name, strength, size_val, price))\n    \n    for r in range(1, int(u / min(drink[1] for drink in drinks)) + 1):\n        for combo in combinations_with_replacement(drinks, r):\n            total_strength = sum(drink[1] * drink[2] * count for drink, count in zip(combo, range(r+1)))\n            total_cost = sum(drink[3] * count for drink, count in zip(combo, range(r+1)))\n            if abs(total_cost - m) < 0.01 and abs(total_strength - u) < 0.01:\n                print('\\n'.join(f\"{drink[0]} {count}\" for drink, count in zip(combo, range(r+1))))\n                return\n    \n    print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946259260177612,
            0.9975031614303589,
            0.9967023730278015,
            0.9971612691879272,
            0.9973022937774658,
            0.9975113272666931,
            0.993988037109375,
            0.9976938962936401,
            0.9968047142028809,
            0.9958415627479553,
            0.9976096749305725,
            0.9963691234588623,
            0.9974154233932495,
            0.9976486563682556,
            0.997228741645813,
            0.9972787499427795,
            0.9975336194038391,
            0.9971488118171692,
            0.9969744682312012,
            0.9976417422294617
        ]
    },
    "1642": {
        "similarity": 0.9975602030754089,
        "body": "import sys\n\n    min_distance = float('inf')\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        dx = x2 - x1\n        dy = y2 - y1\n        distance = (dx * dx + dy * dy) ** 0.5\n        min_distance = min(min_distance, distance / 2)\n    return min_distance\n\nif __name__ == \"__main__\":\n    n = int(input())\n    vertices = [tuple(map(int, input().split())) for _ in range(n)]\n    result = max_movement(n, vertices)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963628649711609,
            0.9967723488807678,
            0.9972726702690125,
            0.9968540072441101,
            0.9966856241226196,
            0.9973879456520081,
            0.9966189861297607,
            0.9942805767059326,
            0.9975602030754089,
            0.9958183169364929,
            0.9960599541664124,
            0.9954747557640076,
            0.9965918660163879,
            0.9970346093177795,
            0.9962553977966309,
            0.9954556822776794,
            0.9973421692848206,
            0.9965993762016296,
            0.9953771233558655,
            0.9947226643562317
        ]
    },
    "947": {
        "similarity": 0.9976974129676819,
        "body": "import sys\n\n    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return (n - 1) // 2, (n + 1) // 2\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a, b = find_min_lcm_pair(n)\n    print(a, b)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969689249992371,
            0.9976697564125061,
            0.9969493746757507,
            0.9922809600830078,
            0.9904186725616455,
            0.9970384240150452,
            0.9967369437217712,
            0.9969872832298279,
            0.9969445466995239,
            0.995916485786438,
            0.9969493746757507,
            0.9971794486045837,
            0.9976974129676819,
            0.9974976778030396,
            0.9975633025169373,
            0.997691810131073,
            0.9935483336448669,
            0.9959640502929688,
            0.9957364797592163,
            0.9971843361854553
        ]
    },
    "743": {
        "similarity": 0.9966474771499634,
        "body": "    numbers.sort()\n    for i in range(1, n):\n        numbers[i] -= numbers[0]\n    return sum(numbers)\n\n# Read input\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Output the result\nprint(minimize_sum(n, numbers))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965782165527344,
            0.9965047240257263,
            0.9959712028503418,
            0.9957748055458069,
            0.9956135153770447,
            0.9959932565689087,
            0.9964471459388733,
            0.9955908060073853,
            0.9961395263671875,
            0.9961776733398438,
            0.9955888986587524,
            0.9963180422782898,
            0.9932066202163696,
            0.9966474771499634,
            0.9957748055458069,
            0.9962780475616455,
            0.9962261915206909,
            0.9951338768005371,
            0.9955846667289734,
            0.9948218464851379
        ]
    },
    "1397": {
        "similarity": 0.99676913022995,
        "body": "import sys\n\n    # Create a list of sets to represent the adjacency list of the graph\n    adj = [set() for _ in range(n + 1)]\n    \n    # Add edges that are not forbidden\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in forbidden_pairs and (j, i) not in forbidden_pairs:\n                adj[i].add(j)\n                adj[j].add(i)\n    \n    # Add edges to ensure the graph is connected with at most two hops\n    roads = []\n    for u in range(1, n + 1):\n        if len(adj[u]) < n - 1:\n            for v in range(u + 1, n + 1):\n                if v not in adj[u]:\n                    found = False\n                    for w in adj[v]:\n                        if w in adj[u]:\n                            roads.append((u, v))\n                            roads.append((v, u))\n                            found = True\n                            break\n                    if found:\n                        break\n    \n    # Ensure each node is connected to at least two nodes within two hops\n    while any(len(adj[u]) < 2 for u in range(1, n + 1)):\n        for u in range(1, n + 1):\n            if len(adj[u]) < 2:\n                for v in adj[u]:\n                    for w in adj[v]:\n                        if u not in adj[w]:\n                            roads.append((u, w))\n                            roads.append((w, u))\n                            break\n                    else:\n                        continue\n                    break\n    \n    # Return the number of roads and the roads themselves\n    return len(roads), roads\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\nforbidden_pairs = set()\nindex = 2\nfor _ in range(m):\n    a = int(data[index])\n    b = int(data[index + 1])\n    forbidden_pairs.add((a, b))\n    index += 2\n\n# Construct the roads\nnum_roads, roads = construct_roads(n, m, forbidden_pairs)\n\n# Print the result\nprint(num_roads)\nfor u, v in roads:\n    print(u, v)",
        "result": "failed: testcase 0",
        "similarities": [
            0.99676913022995,
            0.9958546161651611,
            0.9939188957214355,
            0.9963491559028625,
            0.9953857064247131,
            0.9952370524406433,
            0.9962620139122009,
            0.9965347647666931,
            0.9912565350532532,
            0.9951177835464478,
            0.9960391521453857,
            0.9960885643959045,
            0.9955869913101196,
            0.9960853457450867,
            0.9964486360549927,
            0.9966952800750732,
            0.9965587258338928,
            0.9954992532730103,
            0.9871278405189514,
            0.996501624584198
        ]
    },
    "1144": {
        "similarity": 0.997025728225708,
        "body": "    t = 'a' * (m // 2 + m % 2) + 'b' * (m // 2)\n    replacements = 0\n    \n    for i in range(m - 1):\n        if s[i] == '?' and s[i + 1] == '?':\n            replacements += 1\n        elif s[i] != '?' and s[i + 1] != '?' and (s[i] != 'a' or s[i + 1] != 'b'):\n            replacements += 2\n    \n    if i + 1 < n:\n        replacements += sum(s[i:] != t)\n    \n    return replacements\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ns = data[1]\nm = int(data[2])\n\nprint(max_replacements(n, s, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953516721725464,
            0.9945521950721741,
            0.9965842366218567,
            0.9930658936500549,
            0.9964681267738342,
            0.9957252144813538,
            0.9966264367103577,
            0.9968854188919067,
            0.9957678914070129,
            0.9961387515068054,
            0.9970111846923828,
            0.9964423775672913,
            0.996433436870575,
            0.9959977865219116,
            0.997025728225708,
            0.9968095421791077,
            0.9951660633087158,
            0.9926103353500366,
            0.9960419535636902,
            0.9964551329612732
        ]
    },
    "890": {
        "similarity": 0.9990484118461609,
        "body": "from itertools import combinations\n\n    count = 0\n    for i in range(2, n + 1):\n        for combo in combinations(difficulties, i):\n            if min(combo) + x <= max(combo) and l <= sum(combo) <= r:\n                count += 1\n    return count\n\n# Read input from stdin\nn, l, r, x = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Print the result\nprint(count_problemsets(n, l, r, x, difficulties))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9984911680221558,
            0.9983474612236023,
            0.9987769722938538,
            0.9979742169380188,
            0.9982755780220032,
            0.9987432360649109,
            0.9983516335487366,
            0.9980683922767639,
            0.9989356994628906,
            0.998458743095398,
            0.9990436434745789,
            0.9983713030815125,
            0.9984247088432312,
            0.9990162253379822,
            0.9990484118461609,
            0.9990091919898987,
            0.9984474182128906,
            0.998065173625946,
            0.9983200430870056,
            0.9988228678703308
        ]
    },
    "2410": {
        "similarity": 0.9963003396987915,
        "body": "    yasser_total = sum(a)\n    min_adel_total = float('inf')\n    \n    current_sum = 0\n    for i in range(1, n):\n        current_sum += a[i-1]\n        if current_sum < min_adel_total:\n            min_adel_total = current_sum\n    \n    return yasser_total > min_adel_total\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index+n]))\n    index += n\n    \n    result = \"YES\" if is_yasser_happy(n, a) else \"NO\"\n    results.append(result)\n\nprint(\"\\n\".join(results))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963003396987915,
            0.9943586587905884,
            0.9939848184585571,
            0.9953535795211792,
            0.994071364402771,
            0.994476854801178,
            0.9948889017105103,
            0.9940835237503052,
            0.9952378869056702,
            0.9959103465080261,
            0.9956060647964478,
            0.9949304461479187,
            0.9924836754798889,
            0.994502604007721,
            0.9955565929412842,
            0.9951677918434143,
            0.9961777925491333,
            0.9952455163002014,
            0.9957404136657715,
            0.9957689046859741
        ]
    },
    "1004": {
        "similarity": 0.9977234601974487,
        "body": "    stack = []\n    days = []\n    day_length = 0\n\n    for event in events:\n        if event > 0:\n            stack.append(event)\n            day_length += 1\n        else:\n            if not stack or stack[-1] != -event:\n                return -1\n            stack.pop()\n            day_length += 1\n            if not stack:\n                days.append(day_length)\n                day_length = 0\n\n    if stack:\n        return -1\n\n    if days:\n        return len(days), days\n    else:\n        return -1\n\n# Read input from stdin\nn = int(input())\nevents = list(map(int, input().split()))\n\nresult = partition_events(n, events)\n\nif result == -1:\n    print(-1)\nelse:\n    d, c = result\n    print(d)\n    print(' '.join(map(str, c)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968510866165161,
            0.9970254302024841,
            0.9969635009765625,
            0.9952611327171326,
            0.9954043030738831,
            0.99462890625,
            0.9962000846862793,
            0.9971052408218384,
            0.9973578453063965,
            0.9969195127487183,
            0.9968188405036926,
            0.9959690570831299,
            0.9969926476478577,
            0.9971078634262085,
            0.9971019625663757,
            0.9956191182136536,
            0.9960459470748901,
            0.9960210919380188,
            0.9977234601974487,
            0.9975245594978333
        ]
    },
    "531": {
        "similarity": 0.9965139627456665,
        "body": "import sys\n\n    n = int(input())\n    x = list(map(int, input().split()))\n    \n    min_val = min(x)\n    max_val = max(x)\n    target_avg = sum(x) / n\n    \n    if max_val - min_val > 2:\n        raise ValueError(\"The difference between the maximum and minimum values exceeds 2.\")\n    \n    count_equal = 0\n    result = []\n    \n    for num in x:\n        if num == target_avg:\n            result.append(num)\n            count_equal += 1\n        else:\n            if min_val <= target_avg < num:\n                result.append(int(target_avg))\n            elif max_val > target_avg >= num:\n                result.append(int(target_avg))\n            else:\n                result.append(num)\n    \n    print(count_equal)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964354634284973,
            0.9953956604003906,
            0.9947012662887573,
            0.9945581555366516,
            0.9957798719406128,
            0.996252179145813,
            0.9951744079589844,
            0.9937725067138672,
            0.9958821535110474,
            0.9909172058105469,
            0.9946138262748718,
            0.9932006001472473,
            0.9964935183525085,
            0.9961968660354614,
            0.9943557381629944,
            0.9964262247085571,
            0.9953469038009644,
            0.9965139627456665,
            0.9962535500526428,
            0.9958208799362183
        ]
    },
    "510": {
        "similarity": 0.9965237975120544,
        "body": "import sys\n\n    # Sort the positions to simplify calculations\n    a, b, c = sorted([a, b, c])\n    \n    # Calculate the minimum moves needed for each pair to be at least distance d apart\n    moves_a_b = max(0, d - (b - a) - 1)\n    moves_b_c = max(0, d - (c - b) - 1)\n    \n    # The total duration is the maximum of the two moves needed\n    return max(moves_a_b, moves_b_c)\n\n# Read input from stdin\na, b, c, d = map(int, input().split())\n\n# Output the result\nprint(min_performance_duration(a, b, c, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9924222230911255,
            0.9952030181884766,
            0.9962602257728577,
            0.9957490563392639,
            0.9945132732391357,
            0.9959183931350708,
            0.9961177706718445,
            0.9948180317878723,
            0.9950965046882629,
            0.9954584240913391,
            0.995822012424469,
            0.9934093952178955,
            0.9953436851501465,
            0.9960709810256958,
            0.996494472026825,
            0.9948215484619141,
            0.9965237975120544,
            0.9942247271537781,
            0.9940767884254456,
            0.9946975708007812
        ]
    },
    "2555": {
        "similarity": 0.9975374341011047,
        "body": "import sys\n\n    sorted_a = sorted(a)\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + sorted_a[i - 1]\n    \n    max_strength = prefix_sum[n] - prefix_sum[n // 2]\n    return max_strength\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        q = int(data[index + 1])\n        index += 2\n        \n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        max_strength_before_swaps = max_strength_of_army(n, a)\n        results.append(max_strength_before_swaps)\n        \n        for _ in range(q):\n            l = int(data[index]) - 1\n            r = int(data[index + 1]) - 1\n            index += 2\n            \n            if a[l] > a[r]:\n                a[l], a[r] = a[r], a[l]\n            \n            max_strength_after_swaps = max_strength_of_army(n, a)\n            results.append(max_strength_after_swaps)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975371360778809,
            0.9971950054168701,
            0.9937294721603394,
            0.9968190789222717,
            0.9973381757736206,
            0.9967148303985596,
            0.9951661825180054,
            0.9971785545349121,
            0.9965844750404358,
            0.9972570538520813,
            0.9974866509437561,
            0.9965860247612,
            0.9965115785598755,
            0.996641993522644,
            0.9954411387443542,
            0.9954107999801636,
            0.9975374341011047,
            0.9967606067657471,
            0.9959849119186401,
            0.9961949586868286
        ]
    },
    "324": {
        "similarity": 0.9986582398414612,
        "body": "import sys\n\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return True\n        return False\n    \n    a = n + 3\n    while not is_composite(a):\n        a += 2\n    \n    b = a - n\n    print(a, b)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    find_composite_pair(n)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965102672576904,
            0.9985271096229553,
            0.9986582398414612,
            0.9985028505325317,
            0.9984034299850464,
            0.9976266622543335,
            0.9986535906791687,
            0.9982442259788513,
            0.996569812297821,
            0.9983705282211304,
            0.9980872273445129,
            0.9980871081352234,
            0.9978306293487549,
            0.9976927042007446,
            0.9981819987297058,
            0.9978333711624146,
            0.9981459379196167,
            0.9977997541427612,
            0.9983156323432922,
            0.9971479177474976
        ]
    },
    "2912": {
        "similarity": 0.9969233274459839,
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nstrings = data[1:N+1]\noperations = [(int(data[N+i*2])-1, int(data[N+i*2+1])-1) for i in range(N-1)]\n\nfor a, b in operations:\n    strings[a] += strings[b]\n    strings[b] = \"\"\n\nprint(strings[0])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961899518966675,
            0.9929275512695312,
            0.9961899518966675,
            0.9954524636268616,
            0.9940072298049927,
            0.9949935078620911,
            0.996618390083313,
            0.9967396259307861,
            0.9937636852264404,
            0.993053138256073,
            0.9969233274459839,
            0.9967563152313232,
            0.9968349933624268,
            0.9964697957038879,
            0.9966634511947632,
            0.9966161847114563,
            0.9938181638717651,
            0.996649980545044,
            0.9962092041969299,
            0.9950549602508545
        ]
    },
    "9": {
        "similarity": 0.9959954619407654,
        "body": "import sys\n\n    d = int(input().strip())\n    n, m = map(int, input().strip().split())\n    sofas = []\n    for _ in range(d):\n        x1, y1, x2, y2 = map(int, input().strip().split())\n        sofas.append(((x1, y1), (x2, y2)))\n    \n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().strip().split())\n    \n    for i in range(d):\n        left, right, top, bottom = 0, 0, 0, 0\n        x1, y1 = sofas[i][0]\n        x2, y2 = sofas[i][1]\n        \n        if (x1 == x2 and y1 > y2) or (y1 == y2 and x1 < x2):\n            for j in range(d):\n                if i != j:\n                    x3, y3 = sofas[j][0]\n                    x4, y4 = sofas[j][1]\n                    if (x3 == x4 and y3 > y4) or (y3 == y4 and x3 < x4):\n                        if x1 < x3 <= x2: left += 1\n                        elif x3 < x1 <= x4: right += 1\n                        elif y1 < y3 <= y2: top += 1\n                        elif y3 < y1 <= y4: bottom += 1\n        \n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    find_grandpas_sofa()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957283735275269,
            0.9912862181663513,
            0.9957720041275024,
            0.9932136535644531,
            0.9959954619407654,
            0.9931800365447998,
            0.995611310005188,
            0.9944860339164734,
            0.9944213032722473,
            0.9913131594657898,
            0.9951368570327759,
            0.9933629631996155,
            0.9926201701164246,
            0.9953790307044983,
            0.9931741952896118,
            0.9942086935043335,
            0.9945162534713745,
            0.9940201640129089,
            0.9929197430610657,
            0.995762288570404
        ]
    },
    "249": {
        "similarity": 0.9967711567878723,
        "body": "    marks_set = set(a)\n    additional_marks = []\n    \n    for d in range(x, y + 1):\n        if d not in marks_set:\n            for i in range(l + 1):\n                if (i - d) in marks_set and (i + d) in marks_set:\n                    additional_marks.append(i)\n                    break\n                elif (d - i) in marks_set and (i + d) in marks_set:\n                    additional_marks.append(i)\n                    break\n    \n    return len(additional_marks), additional_marks\n\n# Read input from stdin\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nv, p = min_additional_marks(n, l, x, y, a)\n\n# Print the result\nprint(v)\nfor mark in p:\n    print(mark, end=' ')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9938415884971619,
            0.9945487976074219,
            0.9953941702842712,
            0.995200514793396,
            0.9957262277603149,
            0.9962514638900757,
            0.9960103631019592,
            0.9951227903366089,
            0.9944949746131897,
            0.9952254891395569,
            0.9966636300086975,
            0.9952423572540283,
            0.9955672025680542,
            0.9940059185028076,
            0.9961307048797607,
            0.9949771761894226,
            0.9967711567878723,
            0.9950791597366333,
            0.9912245869636536,
            0.9966318011283875
        ]
    },
    "2999": {
        "similarity": 0.9965011477470398,
        "body": "    import itertools\n    \n    # Generate all possible sums of subsets of bets\n    possible_sums = set()\n    for r in range(1, n + 1):\n        for subset in itertools.combinations(bets, r):\n            possible_sums.add(sum(subset))\n    \n    # Find all participants whose total bet is equal to s or one of its divisors\n    winners = []\n    for t, b in bets:\n        if s % b == 0 and (s // b) in possible_sums:\n            winners.append(t)\n    \n    return len(winners), winners\n\n# Read input\nn, s = map(int, input().split())\nbets = [input().split() for _ in range(n)]\nbets = [(t, int(b)) for t, b in bets]\n\n# Find and print the winners\nk, winners = find_winners(n, s, bets)\nprint(k)\nfor w in winners:\n    print(w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962997436523438,
            0.9942904114723206,
            0.9960911273956299,
            0.9956194162368774,
            0.995106041431427,
            0.9951890707015991,
            0.9958590269088745,
            0.9952973127365112,
            0.9956220388412476,
            0.9953847527503967,
            0.9965011477470398,
            0.9944183826446533,
            0.9928851127624512,
            0.9950956106185913,
            0.9961084127426147,
            0.9960228800773621,
            0.9962541460990906,
            0.9947822093963623,
            0.9944149851799011,
            0.9940756559371948
        ]
    },
    "2239": {
        "similarity": 0.992680013179779,
        "body": "    if x <= 7:\n        return 1\n    return (x + 6) // 7\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nt = int(data[0])\nqueries = list(map(int, data[1:]))\n\nresults = [min_rolls(x) for x in queries]\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9878745079040527,
            0.9915837645530701,
            0.9850078225135803,
            0.9841423034667969,
            0.9850497841835022,
            0.9900298714637756,
            0.992680013179779,
            0.9915589094161987,
            0.9904661774635315,
            0.9914301633834839,
            0.9919873476028442,
            0.9909511208534241,
            0.9869489073753357,
            0.9804518818855286,
            0.9914366006851196,
            0.9890387654304504,
            0.9908948540687561,
            0.991943895816803,
            0.9877451062202454,
            0.9911067485809326
        ]
    },
    "2615": {
        "similarity": 0.9976772665977478,
        "body": "import sys\n\n        factors = []\n        while x % 2 == 0:\n            factors.append(1)\n            x //= 2\n        for i in range(3, int(x**0.5) + 1, 2):\n            k = 0\n            while x % i == 0:\n                k += 1\n                x //= i\n            if k > 0:\n                factors.append(k)\n        if x > 2:\n            factors.append(1)\n        return factors\n    \n        while b:\n            a, b = b, a % b\n        return a\n    \n        return gcd(*factors) == 1\n    \n    count = 0\n    for x in range(2, n + 1):\n        factors = prime_factors(x)\n        if is_elegant(factors):\n            count += 1\n    return count\n\nT = int(input().strip())\nresults = []\nfor _ in range(T):\n    n = int(input().strip())\n    results.append(count_elegant_numbers(n))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971331357955933,
            0.9974498748779297,
            0.9976416230201721,
            0.9961708784103394,
            0.9973464012145996,
            0.9969530701637268,
            0.9968650341033936,
            0.9971106648445129,
            0.9965533018112183,
            0.9965915679931641,
            0.9976772665977478,
            0.9968441724777222,
            0.9922882914543152,
            0.9970267415046692,
            0.9951742887496948,
            0.9972946047782898,
            0.997585117816925,
            0.9976611733436584,
            0.9974944591522217,
            0.9962822794914246
        ]
    },
    "2542": {
        "similarity": 0.9983325600624084,
        "body": "    n = len(s)\n    for i in range(n):\n        if s[:i] == s[-i:]:\n            return n - 2 * i\n    return n - 1\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input().strip()\n    results.append(min_erasures_to_good_string(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983169436454773,
            0.998162031173706,
            0.9975329041481018,
            0.9955028891563416,
            0.9972624778747559,
            0.997517466545105,
            0.9979538321495056,
            0.995849609375,
            0.9975056052207947,
            0.9974417686462402,
            0.9980461597442627,
            0.9972569346427917,
            0.9968207478523254,
            0.9976420402526855,
            0.9960740804672241,
            0.9974399209022522,
            0.9976375102996826,
            0.9980886578559875,
            0.9983325600624084,
            0.9968273043632507
        ]
    },
    "511": {
        "similarity": 0.998202383518219,
        "body": "import math\n\n    if b == 0:\n        return 0\n    else:\n        return 1 + f(a, b - math.gcd(a, b))\n\nx, y = map(int, input().split())\nprint(f(x, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976428151130676,
            0.9964430928230286,
            0.998202383518219,
            0.9970528483390808,
            0.9976809620857239,
            0.9980286359786987,
            0.998202383518219,
            0.9981376528739929,
            0.9971014261245728,
            0.9981493949890137,
            0.9965654611587524,
            0.9974377155303955,
            0.9978015422821045,
            0.9979551434516907,
            0.9980021119117737,
            0.9962300658226013,
            0.9979289174079895,
            0.9979403614997864,
            0.9981493949890137,
            0.998202383518219
        ]
    },
    "1409": {
        "similarity": 0.9970512390136719,
        "body": "from collections import Counter\n\n    count = Counter(y)\n    teams = 0\n    \n    for i in range(6):\n        if count[i] >= k:\n            if i == 5:\n                teams += count[i] // 3\n                count[i] %= 3\n            else:\n                pairs = min(count[i], count[5 - i])\n                teams += pairs\n                count[i] -= pairs\n                count[5 - i] -= pairs\n    \n    return teams\n\n# Read input from stdin\nn, k = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Print the result\nprint(max_teams(n, k, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996679425239563,
            0.9949689507484436,
            0.9970512390136719,
            0.996252179145813,
            0.9964061379432678,
            0.9968858361244202,
            0.9959667921066284,
            0.9942048788070679,
            0.9968101382255554,
            0.9950382113456726,
            0.9965623617172241,
            0.992440402507782,
            0.9959055185317993,
            0.9958299398422241,
            0.9970208406448364,
            0.9946984052658081,
            0.9969050884246826,
            0.9957749247550964,
            0.9944123029708862,
            0.9959976673126221
        ]
    },
    "2274": {
        "similarity": 0.996843159198761,
        "body": "    changes = 0\n    for i in range(n):\n        for j in range(m):\n            if (i == n - 1 and j == m - 1) or (directions[i][j] != 'C'):\n                continue\n            if (i + 1 < n and directions[i + 1][j] == 'D') and (j + 1 < m and directions[i][j + 1] == 'R'):\n                changes += 1\n    return changes\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        directions = [list(data[index + 2 + i]) for i in range(n)]\n        index += 2 + n\n        results.append(min_changes_to_functional(n, m, directions))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946641325950623,
            0.9966763854026794,
            0.9962742328643799,
            0.9958911538124084,
            0.9967495799064636,
            0.9956817626953125,
            0.9932592511177063,
            0.9957649111747742,
            0.992680013179779,
            0.9856359362602234,
            0.995705783367157,
            0.9954632520675659,
            0.9959873557090759,
            0.9957652688026428,
            0.996843159198761,
            0.996407687664032,
            0.9964738488197327,
            0.996742844581604,
            0.9964286684989929,
            0.9964040517807007
        ]
    },
    "2420": {
        "similarity": 0.9971191883087158,
        "body": "    max_covered = 0\n    \n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) <= r:\n                count += 1\n        max_covered = max(max_covered, count)\n    \n    return max_covered\n\n# Read input\nn, r = map(int, input().split())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_points_in_L1_ball(n, r, points))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966417551040649,
            0.992570161819458,
            0.9945257902145386,
            0.9959826469421387,
            0.996296763420105,
            0.9937716126441956,
            0.9961401224136353,
            0.9965938925743103,
            0.996866762638092,
            0.9945060610771179,
            0.9961062073707581,
            0.9947140216827393,
            0.9967856407165527,
            0.9960370659828186,
            0.9955505728721619,
            0.9955744743347168,
            0.9970456957817078,
            0.9908595085144043,
            0.9966342449188232,
            0.9971191883087158
        ]
    },
    "1267": {
        "similarity": 0.9971686005592346,
        "body": "    max_score = max(scores)\n    dp = [0] * (max_score + 1)\n    dp[0] = 1\n    \n    for score in scores:\n        if score == 0:\n            continue\n        for j in range(max_score, score - 1, -1):\n            dp[j] += dp[j - score]\n    \n    return sum(dp)\n\n# Read input\nn = int(input())\nscores = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways_to_choose_diplomas(n, scores))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970849752426147,
            0.9922767281532288,
            0.9955064058303833,
            0.9966173768043518,
            0.9952349662780762,
            0.993508517742157,
            0.9928669333457947,
            0.9959429502487183,
            0.9965521097183228,
            0.9964690208435059,
            0.9970770478248596,
            0.9971326589584351,
            0.9971616864204407,
            0.9940310120582581,
            0.9965220093727112,
            0.9967035055160522,
            0.9943747520446777,
            0.9964289665222168,
            0.9971686005592346,
            0.9961355328559875
        ]
    },
    "2356": {
        "similarity": 0.9974865317344666,
        "body": "import sys\nfrom collections import defaultdict\n\n    n = len(a)\n    diff_map = defaultdict(list)\n    for i, x in enumerate(a):\n        diff_map[i - x].append(i)\n    \n    if any(len(v) > 1 for v in diff_map.values()):\n        return False\n    return True\n\n    while not can_be_good(a):\n        a = [a.pop(0)] + a[1:]\n    return a\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    good_a = shuffle_to_good(a)\n    results.append(good_a)\n\nfor result in results:\n    print(len(result))\n    print(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995834231376648,
            0.993381679058075,
            0.9973015189170837,
            0.997135579586029,
            0.9966956973075867,
            0.9949434995651245,
            0.9966615438461304,
            0.9963037371635437,
            0.9969609975814819,
            0.995735764503479,
            0.9952768087387085,
            0.9957979321479797,
            0.996558427810669,
            0.9974865317344666,
            0.9954770803451538,
            0.9954204559326172,
            0.9928977489471436,
            0.9961703419685364,
            0.9932504892349243,
            0.9963390827178955
        ]
    },
    "108": {
        "similarity": 0.9970641136169434,
        "body": "import sys\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = 0\n    for char in s:\n        if char == alphabet[index]:\n            index += 1\n        if index == len(alphabet):\n            break\n    return index == len(alphabet)\n\nif __name__ == \"__main__\":\n    s = input().strip()\n    if can_form_alphabet_subsequence(s):\n        print(\"abcdefghijklmnopqrstuvwxyz\")\n    else:\n        print(\"-1\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937543272972107,
            0.9966588616371155,
            0.9963246583938599,
            0.996963381767273,
            0.9961583018302917,
            0.9957989454269409,
            0.9964819550514221,
            0.9948780536651611,
            0.9960125684738159,
            0.9967309236526489,
            0.996262788772583,
            0.9966587424278259,
            0.995296061038971,
            0.9962875247001648,
            0.9953759908676147,
            0.9963383078575134,
            0.9955281019210815,
            0.9963246583938599,
            0.9965593218803406,
            0.9970641136169434
        ]
    },
    "1833": {
        "similarity": 0.9975587725639343,
        "body": "    MOD = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in a:\n        for i in range(n - 1, 0, -1):\n            if num % i == 0:\n                dp[i] += dp[i - 1]\n                dp[i] %= MOD\n    \n    return sum(dp) - 1 % MOD\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_good_subsequences(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968773722648621,
            0.9970152974128723,
            0.9949249625205994,
            0.9974401593208313,
            0.9947995543479919,
            0.9964935183525085,
            0.9973993897438049,
            0.9975587725639343,
            0.9965913891792297,
            0.9956139326095581,
            0.9972745776176453,
            0.9958787560462952,
            0.9971600770950317,
            0.9974042773246765,
            0.9948748350143433,
            0.996864914894104,
            0.9954456686973572,
            0.9942485690116882,
            0.9972325563430786,
            0.993544340133667
        ]
    },
    "2324": {
        "similarity": 0.9981899261474609,
        "body": "    n = len(s)\n    dp = [[[0, 0] for _ in range(n)] for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j][0] = 1\n            elif s[i] == s[j]:\n                dp[i][j][0] = dp[i + 1][j - 1][0] + 2 * (length % 2 == 0) + 1\n                dp[i][j][1] = dp[i + 1][j - 1][1] + 1\n            else:\n                dp[i][j][0] = max(dp[i + 1][j][0], dp[i][j - 1][0])\n    \n    result = []\n    for i in range(n):\n        total = 0\n        for j in range(i, n):\n            total += dp[i][j][0]\n        result.append(total)\n    \n    print(' '.join(map(str, result)))\n\n# Read input from stdin\ns = input().strip()\npalindromic_characteristics(s)",
        "result": "failed: testcase 0",
        "similarities": [
            0.997909426689148,
            0.998124361038208,
            0.9978296160697937,
            0.9977275729179382,
            0.9969165325164795,
            0.9976086020469666,
            0.9974210858345032,
            0.9976063966751099,
            0.9975918531417847,
            0.9970102906227112,
            0.9980546236038208,
            0.9946638345718384,
            0.9980150461196899,
            0.9978248476982117,
            0.9966921806335449,
            0.9978485107421875,
            0.9981116056442261,
            0.9981899261474609,
            0.9977731108665466,
            0.99680095911026
        ]
    },
    "2372": {
        "similarity": 0.9985736012458801,
        "body": "import sys\nfrom collections import deque\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n        return 0 <= x < H and 0 <= y < W and S[x][y] == '.'\n    \n    queue = deque([(C_h, C_w, 0)])\n    visited = set()\n    visited.add((C_h, C_w))\n    \n    while queue:\n        x, y, moves = queue.popleft()\n        \n        if (x, y) == (D_h, D_w):\n            return moves\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, moves))\n        \n        # Check 5x5 area around the current position for magic warp\n        for i in range(max(0, x-2), min(H, x+3)):\n            for j in range(max(0, y-2), min(W, y+3)):\n                if is_valid(i, j) and (i, j) not in visited:\n                    visited.add((i, j))\n                    queue.append((i, j, moves + 1))\n    \n    return -1\n\n# Read input\nH, W = map(int, input().split())\nC_h, C_w = map(int, input().split()) - 1, map(int, input().split()) - 1\nS = [input().strip() for _ in range(H)]\n\n# Calculate and print the result\nprint(min_magic_moves(H, W, C_h, C_w, D_h, D_w, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981410503387451,
            0.9981216788291931,
            0.9970636963844299,
            0.997943103313446,
            0.9983005523681641,
            0.9982624053955078,
            0.9977867007255554,
            0.9983901977539062,
            0.9983780384063721,
            0.9985736012458801,
            0.9984908103942871,
            0.9978019595146179,
            0.9979912638664246,
            0.9975521564483643,
            0.9985548257827759,
            0.998518705368042,
            0.9981855154037476,
            0.998331606388092,
            0.9984283447265625,
            0.9984578490257263
        ]
    },
    "1984": {
        "similarity": 0.9977228045463562,
        "body": "import sys\nfrom collections import defaultdict\n\n    levels = [input().strip() for _ in range(k)]\n    \n    # Function to calculate the number of different cells between two levels\n        return sum(1 for a, b in zip(level1, level2) if a != b)\n    \n    # Calculate the full size of the first level\n    total_size = n * m\n    \n    # Dictionary to store the minimum bytes needed to transfer each level from another level\n    min_bytes = defaultdict(lambda: float('inf'))\n    for i in range(k):\n        min_bytes[i, 0] = total_size\n    \n    # Fill the DP table\n    for j in range(1, k):\n        for i in range(j):\n            d = diff(levels[j], levels[i])\n            min_bytes[j, i+1] = min(min_bytes[j, i+1], min_bytes[i, 0] + d * w)\n    \n    # Find the optimal way to transfer each level\n    transfers = []\n    remaining_levels = list(range(k))\n    while remaining_levels:\n        current_level = remaining_levels.pop(0)\n        min_transfer = float('inf')\n        prev_level = -1\n        for i in range(k):\n            if min_bytes[current_level, i+1] < min_transfer:\n                min_transfer = min_bytes[current_level, i+1]\n                prev_level = i\n        transfers.append((current_level + 1, prev_level + 1))\n    \n    # Print the total bytes transferred and the transfer plan\n    print(total_size + sum(min_bytes[i, j] for i, j in transfers))\n    for t in transfers:\n        print(t[0], t[1])\n\n# Read input from stdin\nn, m, k, w = map(int, input().split())\nmin_transferred_bytes(n, m, k, w)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976451396942139,
            0.9973013997077942,
            0.9975346922874451,
            0.9973505735397339,
            0.9977228045463562,
            0.9976754784584045,
            0.9965856671333313,
            0.9962390065193176,
            0.9972635507583618,
            0.996211588382721,
            0.9972383379936218,
            0.9972459673881531,
            0.9969215393066406,
            0.9972537159919739,
            0.9975523948669434,
            0.9964736104011536,
            0.9966551065444946,
            0.9974150657653809,
            0.9972164630889893,
            0.9967865347862244
        ]
    },
    "1253": {
        "similarity": 0.9973253011703491,
        "body": "    negative_count = sum(1 for x in a if x < 0)\n    positive_count = n - negative_count\n    \n    if negative_count == 0:\n        return sum(a) + (k // 2) * 2 if k % 2 else sum(a)\n    \n    if k <= negative_count:\n        return sum(x if x > 0 else -x for x in a) + (-1) ** k * sum(sorted(abs(x) for x in a[:k]))\n    \n    k -= negative_count\n    positive_sum = sum(max(0, x) for x in a)\n    negative_sum = sum(min(0, x) for x in a)\n    \n    if k % 2 == 0:\n        return positive_sum - negative_sum\n    else:\n        return positive_sum - negative_sum + min(abs(positive_sum), abs(negative_sum))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970333576202393,
            0.9965399503707886,
            0.9968502521514893,
            0.9969595074653625,
            0.99713134765625,
            0.9971699118614197,
            0.9939565062522888,
            0.9947503805160522,
            0.9958810210227966,
            0.9934116005897522,
            0.9969711303710938,
            0.9973253011703491,
            0.9972044229507446,
            0.9950481057167053,
            0.9972104430198669,
            0.9947808980941772,
            0.9970130920410156,
            0.9969363212585449,
            0.9947172403335571,
            0.9908860921859741
        ]
    },
    "523": {
        "similarity": 0.9969304800033569,
        "body": "        return s == s[::-1]\n\n    max_length = 0\n    best_palindrome = \"\"\n\n    for i in range(1 << n):\n        selected = [strings[j] for j in range(n) if (i & (1 << j))]\n        concatenation = \"\".join(selected)\n        reversed_concatenation = concatenation[::-1]\n        \n        for j in range(len(concatenation)):\n            candidate = concatenation[:j + 1] + reversed_concatenation\n            if is_palindrome(candidate):\n                length = len(candidate)\n                if length > max_length:\n                    max_length = length\n                    best_palindrome = candidate\n\n    return max_length, best_palindrome\n\n# Read input from stdin\nn, m = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nmax_length, best_palindrome = longest_palindrome(n, m, strings)\n\n# Print the result\nprint(max_length)\nif best_palindrome:\n    print(best_palindrome)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956530332565308,
            0.996015727519989,
            0.9950520396232605,
            0.9969047904014587,
            0.9967604279518127,
            0.9968209862709045,
            0.9957109093666077,
            0.9969304800033569,
            0.9915341734886169,
            0.9957156181335449,
            0.9955618977546692,
            0.9954195618629456,
            0.9947462677955627,
            0.9960305094718933,
            0.995818018913269,
            0.996650218963623,
            0.9962899088859558,
            0.9958189129829407,
            0.9918928742408752,
            0.9955535531044006
        ]
    },
    "2934": {
        "similarity": 0.9978699088096619,
        "body": "    MOD = 10**9\n    if N == 1:\n        return (2 * M + 1) % MOD\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(N + 1):\n        for j in range(M + 1):\n            if i >= 1:\n                dp[i][j] += dp[i - 1][j]\n            if j >= 2 and i >= 1:\n                dp[i][j] += dp[i - 1][j - 2]\n            dp[i][j] %= MOD\n    return dp[N][M]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nM = int(data[1])\n\nprint(tiling_table(N, M))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970864057540894,
            0.9970991015434265,
            0.9975317716598511,
            0.9972785115242004,
            0.9959080219268799,
            0.9967701435089111,
            0.9976019859313965,
            0.9967759847640991,
            0.9965304136276245,
            0.9975678324699402,
            0.9976277947425842,
            0.9964357614517212,
            0.9969187378883362,
            0.9959985613822937,
            0.997299313545227,
            0.9977173209190369,
            0.997714102268219,
            0.9974848031997681,
            0.9978699088096619,
            0.9975162148475647
        ]
    },
    "1745": {
        "similarity": 0.9976344108581543,
        "body": "import sys\n\n        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n        if (x, y, dx, dy, turns) in memo:\n            return memo[(x, y, dx, dy, turns)]\n        \n        if turns > 2 or (x, y) in borders and not is_valid(x + dx, y + dy):\n            return 0\n        \n        if x == n - 1 or y == m - 1 or x == 0 or y == 0:\n            if (x, y) not in borders:\n                return 0\n            if turns > 1 and (dx != 0 and dy != 0):\n                return 0\n        \n        result = 0\n        for nx, ny in [(x + dx, y + dy), (x - dy, y + dx), (x + dy, y - dx)]:\n            if is_valid(nx, ny):\n                result += dfs(nx, ny, dx, dy, turns)\n        \n        memo[(x, y, dx, dy, turns)] = result\n        return result\n\n    borders = set()\n    for i in range(n):\n        borders.add((i, 0))\n        borders.add((i, m - 1))\n        if i > 0 and grid[i][0] != '#' or i < n - 1 and grid[i][m - 1] != '#':\n            borders.add((0, i))\n            borders.add((n - 1, i))\n\n    memo = {}\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j) and (i, j) not in borders:\n                result += dfs(i, j, 0, 1, 0)\n                result += dfs(i, j, 1, 0, 0)\n    print(result)\n\n# Read input from stdin\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\ncount_pipes(n, m, grid)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973307251930237,
            0.9959803223609924,
            0.9963016510009766,
            0.9966201782226562,
            0.9968412518501282,
            0.9958491921424866,
            0.9965581297874451,
            0.9944797158241272,
            0.9971722364425659,
            0.9970594644546509,
            0.9971718192100525,
            0.9967639446258545,
            0.9965466856956482,
            0.9961627125740051,
            0.9969590902328491,
            0.9976344108581543,
            0.9969554543495178,
            0.9945102334022522,
            0.9949854016304016,
            0.994709312915802
        ]
    },
    "1422": {
        "similarity": 0.9971277117729187,
        "body": "    for i in range(1, 11):\n        if weights[i-1] == '0':\n            continue\n        left = []\n        right = []\n        count = 0\n        total_left = 0\n        total_right = 0\n        weight = i\n        while count < m:\n            if (count % 2 == 0 and total_left <= total_right) or (count % 2 != 0 and total_right <= total_left):\n                if total_left + weight > total_right:\n                    left.append(weight)\n                    total_left += weight\n                else:\n                    right.append(weight)\n                    total_right += weight\n                count += 1\n            weight += 1\n        if count == m:\n            return \"YES\\n\" + ' '.join(map(str, left + right))\n    return \"NO\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nweights = data[0]\nm = int(data[1])\nprint(can_place_weights(weights, m))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9910495281219482,
            0.9959295392036438,
            0.9952595233917236,
            0.9970638751983643,
            0.9966147541999817,
            0.9963400959968567,
            0.9962440133094788,
            0.9971277117729187,
            0.9969865679740906,
            0.9958750009536743,
            0.9968540668487549,
            0.9964204430580139,
            0.9965491890907288,
            0.9953470826148987,
            0.996148943901062,
            0.9965838193893433,
            0.9954958558082581,
            0.9958004355430603,
            0.9964555501937866,
            0.994685709476471
        ]
    },
    "1763": {
        "similarity": 0.9954811930656433,
        "body": "import sys\nfrom collections import deque\n\n    total_cost = 0\n    min_height = min(heights)\n    for height in heights:\n        diff = height - min_height\n        if diff > 0:\n            if A + M <= R:\n                total_cost += (A + M) * diff\n            else:\n                total_cost += R * diff\n        elif diff < 0:\n            total_cost += abs(diff) * A\n    return total_cost\n\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = int(data[1])\nR = int(data[2])\nM = int(data[3])\n\nheights = list(map(int, data[4:]))\n\nprint(min_cost_to_restore_wall(N, A, R, M, heights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9884117841720581,
            0.9952260851860046,
            0.9942548871040344,
            0.991908609867096,
            0.9921930432319641,
            0.9937613606452942,
            0.995425283908844,
            0.9930590391159058,
            0.9938665628433228,
            0.9954054951667786,
            0.9938197135925293,
            0.9935970306396484,
            0.9944943785667419,
            0.9930664896965027,
            0.9934335350990295,
            0.9954811930656433,
            0.9947469830513,
            0.992235004901886,
            0.9928016662597656,
            0.9939569234848022
        ]
    },
    "974": {
        "similarity": 0.9979619383811951,
        "body": "    stack = []\n    reorder_count = 0\n    remove_order = list(range(1, n + 1))\n    \n    for command in commands:\n        if command.startswith(\"add\"):\n            x = int(command.split()[1])\n            stack.append(x)\n        else:\n            while stack and stack[-1] != remove_order[0]:\n                stack.pop()\n                reorder_count += 1\n            if stack:\n                stack.pop()\n                remove_order.pop(0)\n    \n    return reorder_count\n\n# Read input from stdin\nn = int(input().strip())\ncommands = [input().strip() for _ in range(2 * n)]\n\n# Calculate and print the result\nprint(min_reorders(n, commands))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970981478691101,
            0.9972627758979797,
            0.9979619383811951,
            0.9952189922332764,
            0.9976268410682678,
            0.9970046877861023,
            0.9975906014442444,
            0.9973372220993042,
            0.9969755411148071,
            0.9972392916679382,
            0.9973787069320679,
            0.9973864555358887,
            0.9974891543388367,
            0.9964014291763306,
            0.9967671632766724,
            0.9973503947257996,
            0.9962624907493591,
            0.9974117279052734,
            0.9970141053199768,
            0.9970488548278809
        ]
    },
    "2343": {
        "similarity": 0.9974272847175598,
        "body": "import sys\n\n    if n == 0:\n        return True, 0\n    max_splits = (n * (n + 1)) // 2\n    if k > max_splits:\n        return False, -1\n    path_size = n - k\n    return True, path_size\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        possible, path_size = can_split(n, k)\n        if possible:\n            print(\"YES\", path_size)\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9937838315963745,
            0.9967500567436218,
            0.9974272847175598,
            0.9971385598182678,
            0.9960322976112366,
            0.9957862496376038,
            0.9950752258300781,
            0.996799886226654,
            0.995967447757721,
            0.997253954410553,
            0.9958635568618774,
            0.9967437386512756,
            0.9967024922370911,
            0.9973589181900024,
            0.9970642924308777,
            0.9967406392097473,
            0.9970883727073669,
            0.9966796040534973,
            0.9960683584213257,
            0.9958658814430237
        ]
    },
    "627": {
        "similarity": 0.9989393353462219,
        "body": "    n = len(s)\n    for i in range(n):\n        if i == 0 or s[i] < s[i - 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get result and print\nresult = remove_one_char(s)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9989393353462219,
            0.9975311160087585,
            0.9971991181373596,
            0.9988369345664978,
            0.9986461997032166,
            0.9988752603530884,
            0.9988979697227478,
            0.998615562915802,
            0.9984731078147888,
            0.9987329244613647,
            0.9989192485809326,
            0.998661458492279,
            0.9989203214645386,
            0.9988260865211487,
            0.9988979697227478,
            0.9986006021499634,
            0.9967196583747864,
            0.9976703524589539,
            0.9982542991638184,
            0.9978810548782349
        ]
    },
    "1655": {
        "similarity": 0.9985989928245544,
        "body": "    alive = [True] * n\n    for i in range(1, n):\n        if L[i] > 0:\n            start = max(0, i - L[i])\n            for j in range(start, i):\n                alive[j] = False\n    return sum(alive)\n\n# Read input\nn = int(input())\nL = list(map(int, input().split()))\n\n# Output result\nprint(count_alive_people(n, L))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9985449910163879,
            0.9962783455848694,
            0.998514711856842,
            0.9985389709472656,
            0.9985068440437317,
            0.9977101683616638,
            0.9966543912887573,
            0.998514711856842,
            0.9985345602035522,
            0.9985989928245544,
            0.9980512857437134,
            0.998437762260437,
            0.9983968138694763,
            0.9985483884811401,
            0.9956669211387634,
            0.998498797416687,
            0.9985345602035522,
            0.998498797416687,
            0.9984749555587769,
            0.9984707236289978
        ]
    },
    "2124": {
        "similarity": 0.997911274433136,
        "body": "import sys\n\n    for chat in chats:\n        n = int(input())\n        users = input().split()\n        m = int(input())\n        messages = []\n        unknown_messages = []\n        \n        for _ in range(m):\n            msg = input().strip()\n            if msg.startswith('?'):\n                unknown_messages.append(msg)\n            else:\n                messages.append((msg, True))\n        \n        if len(unknown_messages) > n * (m - len(unknown_messages)):\n            print(\"Impossible\")\n            continue\n        \n        user_indices = list(range(n))\n        sender_index = 0\n        recovered_messages = []\n        \n        for msg in unknown_messages:\n            while True:\n                new_msg = f\"{users[sender_index]}:{msg.split(':')[1]}\"\n                if any(word.isalpha() and word.lower() == users[sender_index].lower() for word in new_msg.split()):\n                    sender_index = (sender_index + 1) % n\n                else:\n                    recovered_messages.append(new_msg)\n                    break\n            sender_index = (sender_index + 1) % n\n        \n        recovered_messages.extend(msg for msg, _ in messages)\n        \n        print('\\n'.join(recovered_messages))\n\nif __name__ == \"__main__\":\n    t = int(input())\n    chats = [None] * t\n    for i in range(t):\n        chat = []\n        chat.append(int(input()))\n        chat.append(input().split())\n        chat.append(int(input()))\n        for _ in range(chat[2]):\n            chat.append(input())\n        chats[i] = chat\n    recover_senders(chats)",
        "result": "failed: testcase 0",
        "similarities": [
            0.997911274433136,
            0.9965437054634094,
            0.9976429343223572,
            0.9973302483558655,
            0.9975477457046509,
            0.9969145059585571,
            0.9976826906204224,
            0.9947188496589661,
            0.9976359009742737,
            0.997411847114563,
            0.9974945783615112,
            0.9974230527877808,
            0.9975813627243042,
            0.9977497458457947,
            0.9976247549057007,
            0.996741533279419,
            0.9964922070503235,
            0.9964655041694641,
            0.9974654316902161,
            0.997383713722229
        ]
    },
    "1093": {
        "similarity": 0.9976370930671692,
        "body": "    n, m = map(int, input().split())\n    terrain = [list(input()) for _ in range(n)]\n    \n    max_ascent = 0\n    max_descent = 0\n    \n    current_height = None\n    for col in range(m):\n        for row in range(n-1, -1, -1):\n            if terrain[row][col] == '*':\n                height = n - row\n                if current_height is not None:\n                    ascent = height - current_height\n                    descent = current_height - height\n                    max_ascent = max(max_ascent, ascent)\n                    max_descent = max(max_descent, descent)\n                current_height = height\n                break\n    \n    print(max_ascent, max_descent)\n\nfind_max_elevation_changes()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970253705978394,
            0.9954492449760437,
            0.9966570138931274,
            0.995969295501709,
            0.9975267648696899,
            0.9966467022895813,
            0.9975057244300842,
            0.997232973575592,
            0.9958736300468445,
            0.9964338541030884,
            0.9962413311004639,
            0.9961336851119995,
            0.997597336769104,
            0.997278094291687,
            0.9976370930671692,
            0.9971281290054321,
            0.9967108368873596,
            0.99703449010849,
            0.996468186378479,
            0.9974196553230286
        ]
    },
    "899": {
        "similarity": 0.9990419149398804,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heappop(pq)\n        \n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            \n            if distance < dist[v]:\n                dist[v] = distance\n                heappush(pq, (distance, v))\n    \n    return dist\n\n    graph = [[] for _ in range(N)]\n    for a, b, c in edges:\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n    \n    total_edges = len(edges)\n    shortest_paths_count = 0\n    \n    for i in range(N):\n        dist = dijkstra(graph, i)\n        for j in range(i+1, N):\n            if dist[j] != float('inf'):\n                shortest_paths_count += 1\n    \n    non_shortest_edges = total_edges - shortest_paths_count\n    return non_shortest_edges\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    edges = [(int(data[3*i+2]), int(data[3*i+3]), int(data[3*i+4])) for i in range(M)]\n    \n    result = count_non_shortest_edges(N, edges)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.998038649559021,
            0.9989598989486694,
            0.9983900189399719,
            0.9984466433525085,
            0.9983432292938232,
            0.9989767670631409,
            0.9986281991004944,
            0.9982566833496094,
            0.9989101886749268,
            0.99801105260849,
            0.9985705018043518,
            0.9988344311714172,
            0.9981268644332886,
            0.998157799243927,
            0.9980077147483826,
            0.9990296959877014,
            0.9989858865737915,
            0.998630940914154,
            0.9990419149398804,
            0.9988862872123718
        ]
    },
    "551": {
        "similarity": 0.9969438314437866,
        "body": "    if n % 2 != 0:\n        return \"No\"\n    sorted_y = sorted(y)\n    half_n = n // 2\n    for i in range(half_n):\n        if sorted_y[i] != sorted_y[half_n + i]:\n            return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\nn = int(input())\ny = list(map(int, input().split()))\n\n# Print the result\nprint(can_draw_lines(n, y))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969438314437866,
            0.9954829812049866,
            0.9915225505828857,
            0.9963510632514954,
            0.9963657855987549,
            0.9967941641807556,
            0.9955875873565674,
            0.9969290494918823,
            0.9963858723640442,
            0.9954431653022766,
            0.9956042766571045,
            0.9965526461601257,
            0.9928311705589294,
            0.9966656565666199,
            0.9913532733917236,
            0.9967201948165894,
            0.9968750476837158,
            0.9963657855987549,
            0.9966027140617371,
            0.996020495891571
        ]
    },
    "1772": {
        "similarity": 0.9977864623069763,
        "body": "    odd_count = sum(1 for x in a if x % 2 != 0)\n    even_count = n - odd_count\n    \n    return min(odd_count, even_count)\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(max_large_bouquets(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974744915962219,
            0.9953299164772034,
            0.9967678785324097,
            0.9977001547813416,
            0.997096836566925,
            0.9948421120643616,
            0.9968157410621643,
            0.9968920350074768,
            0.9969478249549866,
            0.9977864623069763,
            0.9967576265335083,
            0.996329665184021,
            0.9974658489227295,
            0.9966896772384644,
            0.9966358542442322,
            0.9939619302749634,
            0.9967020750045776,
            0.9976568818092346,
            0.9965853691101074,
            0.9942052960395813
        ]
    },
    "1339": {
        "similarity": 0.9970384240150452,
        "body": "    segments = sorted(segments, key=lambda x: (x[1], -x[0]))\n    if n == 1:\n        return 1\n    max_right = segments[0][1]\n    for i in range(1, n):\n        if segments[i][0] <= max_right:\n            return i + 1\n        else:\n            max_right = segments[i][1]\n    return -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    segments = [tuple(map(int, input().split())) for _ in range(n)]\n    print(find_covering_segment(n, segments))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957239031791687,
            0.9953033328056335,
            0.9966904520988464,
            0.9946491122245789,
            0.9961983561515808,
            0.996134340763092,
            0.9964109659194946,
            0.9956135153770447,
            0.9956223368644714,
            0.9920212626457214,
            0.9964708089828491,
            0.9954544901847839,
            0.9959433674812317,
            0.9962306618690491,
            0.9961745738983154,
            0.9970384240150452,
            0.9968333840370178,
            0.9955306053161621,
            0.9947468638420105,
            0.9963791370391846
        ]
    },
    "440": {
        "similarity": 0.9972165822982788,
        "body": "    vowels = \"aeiouy\"\n    s_list = list(s)\n    i = 0\n    while i < len(s_list) - 1:\n        if s_list[i] in vowels and s_list[i+1] in vowels:\n            j = i - 1\n            while j >= 0 and s_list[j] not in vowels:\n                j -= 1\n            if j >= 0:\n                del s_list[i]\n                i -= 1\n        i += 1\n    return ''.join(s_list)\n\n# Read input from stdin\nn = int(input())\ns = input().strip()\n\n# Print the result\nprint(correct_word(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955344200134277,
            0.9964174032211304,
            0.9971291422843933,
            0.9972165822982788,
            0.9867815971374512,
            0.9952750205993652,
            0.9962676167488098,
            0.9966049194335938,
            0.9962950348854065,
            0.996528148651123,
            0.996508777141571,
            0.99602210521698,
            0.9954600930213928,
            0.9966583251953125,
            0.994887113571167,
            0.9967004656791687,
            0.992903470993042,
            0.9942914247512817,
            0.9963541626930237,
            0.9954527020454407
        ]
    },
    "2801": {
        "similarity": 0.9983395934104919,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    graph = [[] for _ in range(n)]\n    for s, t in connections:\n        graph[s].append(t)\n\n        pq = [(-c[start], start, 1.0)]\n        visited = set()\n        best_satisfaction = 0\n        while pq:\n            neg_sat, node, fraction = heappop(pq)\n            if node in visited:\n                continue\n            visited.add(node)\n            best_satisfaction = max(best_satisfaction, -neg_sat * fraction)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    new_fraction = fraction / 2.0\n                    heappush(pq, (new_fraction * neg_sat, neighbor, new_fraction))\n        return best_satisfaction\n\n    return dfs(0)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    c = list(map(int, data[2:2+n]))\n    connections = []\n    for i in range(m):\n        s = int(data[2+n+2*i])\n        t = int(data[2+n+2*i+1])\n        connections.append((s, t))\n    \n    result = max_satisfaction(n, m, c, connections)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982838034629822,
            0.9979932904243469,
            0.9982689619064331,
            0.9977745413780212,
            0.9974899291992188,
            0.998085618019104,
            0.9977256655693054,
            0.9982265830039978,
            0.9982926249504089,
            0.9981071352958679,
            0.9978316426277161,
            0.9981186389923096,
            0.9983121156692505,
            0.9981870055198669,
            0.9983395934104919,
            0.9976391196250916,
            0.9981324076652527,
            0.9974800944328308,
            0.9952327609062195,
            0.9979962706565857
        ]
    },
    "2749": {
        "similarity": 0.9964568614959717,
        "body": "import sys\n\n    grid = [[0] * W for _ in range(H)]\n    colors = list(range(1, N + 1))\n    \n        return 0 <= x < H and 0 <= y < W\n    \n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            if grid[cx][cy] != 0 or not is_valid(cx, cy):\n                continue\n            grid[cx][cy] = color\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and grid[nx][ny] == 0:\n                    stack.append((nx, ny))\n    \n    color_index = 0\n    for i in range(N):\n        count = a[i]\n        while count > 0:\n            found = False\n            for x in range(H):\n                for y in range(W):\n                    if grid[x][y] == 0:\n                        dfs(x, y, colors[color_index])\n                        found = True\n                        break\n                if found:\n                    break\n            color_index += 1\n            count -= 1\n    \n    for row in grid:\n        print(' '.join(map(str, row)))\n\n# Read input from stdin\nH, W = map(int, input().split())\nN = int(input())\na = list(map(int, input().split()))\n\npaint_grid(H, W, N, a)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958022236824036,
            0.995780348777771,
            0.9948856830596924,
            0.9959005117416382,
            0.9950099587440491,
            0.9943255186080933,
            0.9957887530326843,
            0.9962517619132996,
            0.9964568614959717,
            0.9953121542930603,
            0.9958441853523254,
            0.9926966428756714,
            0.9955887198448181,
            0.9947358965873718,
            0.9957209229469299,
            0.9947572350502014,
            0.9948888421058655,
            0.9956250786781311,
            0.9916436076164246,
            0.9876097440719604
        ]
    },
    "2319": {
        "similarity": 0.9985470175743103,
        "body": "    if s == t:\n        return 0\n    \n    n = len(s)\n    for i in range(n):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == t:\n            return 1\n    \n    return -1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        t_str = data[index + 2]\n        index += 3\n        \n        result = min_operations(s, t_str)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965910911560059,
            0.9983475208282471,
            0.998237133026123,
            0.9975295662879944,
            0.9955283999443054,
            0.9977952837944031,
            0.9965583682060242,
            0.9985470175743103,
            0.9984306693077087,
            0.9982462525367737,
            0.9965505003929138,
            0.9983630180358887,
            0.9950025677680969,
            0.9982069730758667,
            0.9982333779335022,
            0.9985176920890808,
            0.9965977072715759,
            0.9982693195343018,
            0.9976878762245178,
            0.9984049797058105
        ]
    },
    "2121": {
        "similarity": 0.9980646371841431,
        "body": "import sys\n\n        nonlocal max_grade\n        visited[root] = True\n        min_time = float('inf')\n        count = 0\n        \n        for neighbor in sorted(edges[root], key=lambda x: times[x]):\n            if not visited[neighbor]:\n                count += 1\n                if count > k:\n                    break\n                min_time = min(min_time, times[neighbor])\n                dfs(neighbor, root)\n        \n        max_grade = max(max_grade, min_time)\n\n    edges = [[] for _ in range(n)]\n    for u, v in edges:\n        edges[u-1].append(v-1)\n        edges[v-1].append(u-1)\n\n    visited = [False] * n\n    max_grade = 0\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, -1)\n\n    return max_grade\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    times = list(map(int, data[2:2+n]))\n    edges = []\n    \n    index = 2 + n\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges.append((u, v))\n        index += 2\n\n    print(max_grade(n, k, times, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975380301475525,
            0.9978030323982239,
            0.9975957274436951,
            0.9978182911872864,
            0.9966092705726624,
            0.9974074363708496,
            0.9980646371841431,
            0.9953824877738953,
            0.9974557757377625,
            0.9967795014381409,
            0.9971989989280701,
            0.9967394471168518,
            0.9977663159370422,
            0.9976549744606018,
            0.997629702091217,
            0.9969765543937683,
            0.9977210164070129,
            0.9979905486106873,
            0.9977611899375916,
            0.9972352385520935
        ]
    },
    "2617": {
        "similarity": 0.9980706572532654,
        "body": "import sys\n\n    days = 0\n    target_mass = n\n    split_counts = []\n    \n    while True:\n        if target_mass == 1:\n            split_counts.append(0)\n            break\n        \n        max_split = 1\n        for i in range(days + 1):\n            if (target_mass - (2 ** i)) % (2 ** (i + 1)) == 0:\n                max_split = i + 1\n        \n        split_counts.append(max_split)\n        target_mass -= (2 ** max_split) // 2\n        days += 1\n    \n    return days, split_counts\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        result = min_nights(n)\n        if result[0] == -1:\n            results.append(-1)\n        else:\n            results.append(result[0])\n            results.extend(result[1])\n    \n    output = '\\n'.join(map(str, results))\n    print(output)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956101179122925,
            0.9979298114776611,
            0.9970329999923706,
            0.9974080324172974,
            0.9977656006813049,
            0.9975584149360657,
            0.996832013130188,
            0.9978894591331482,
            0.9955033659934998,
            0.9980180859565735,
            0.9978436231613159,
            0.9978961944580078,
            0.9968855977058411,
            0.9969418048858643,
            0.9973514080047607,
            0.9979880452156067,
            0.9978684782981873,
            0.9965270161628723,
            0.99765545129776,
            0.9980706572532654
        ]
    },
    "175": {
        "similarity": 0.9981493949890137,
        "body": "    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    print(a, b)\n\n# Read input\nn, m = map(int, input().split())\n\n# Process the variables\nprocess(n, m)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967589378356934,
            0.9979873299598694,
            0.9967344403266907,
            0.9979782104492188,
            0.9977889060974121,
            0.9977531433105469,
            0.9977619647979736,
            0.9945760369300842,
            0.9964316487312317,
            0.9967380166053772,
            0.9977248311042786,
            0.9969331622123718,
            0.9975034594535828,
            0.9969418048858643,
            0.9939427971839905,
            0.997444748878479,
            0.9978822469711304,
            0.998134434223175,
            0.9981493949890137,
            0.9979407787322998
        ]
    },
    "995": {
        "similarity": 0.9965806603431702,
        "body": "import sys\nfrom collections import defaultdict\n\n        return x >= 0 and int(x**0.5)**2 == x\n    \n    result = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        count = 0\n        current_product = 1\n        freq = defaultdict(int)\n        \n        for i in range(n):\n            current_product *= A[i]\n            if is_perfect_square_product(current_product):\n                count += 1\n            \n            target = current_product // k\n            if target >= 0 and int(target**0.5)**2 == target:\n                count -= freq[target]\n            \n            freq[current_product % k] += 1\n        \n        result[k] = count\n    \n    return ' '.join(map(str, result[1:]))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    A = list(map(int, input().split()))\n    print(count_subarrays(n, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9943210482597351,
            0.9963781237602234,
            0.9957521557807922,
            0.9961437582969666,
            0.9944847822189331,
            0.9953802824020386,
            0.9948190450668335,
            0.9919002056121826,
            0.9935961365699768,
            0.9960394501686096,
            0.9958080649375916,
            0.9957636594772339,
            0.9965806603431702,
            0.9959114789962769,
            0.9964324831962585,
            0.9951685667037964,
            0.9964109659194946,
            0.9938703775405884,
            0.9956327676773071,
            0.9951694011688232
        ]
    },
    "582": {
        "similarity": 0.9967870116233826,
        "body": "from collections import Counter\n\n    # Count the frequency of each publication count\n    freq = Counter(a)\n    \n    # Find the next available distinct number for distribution\n    max_a = max(a)\n    next_distinct = max_a + 1\n    \n    total_time = 0\n    \n    for category in range(1, n + 1):\n        if freq[category] > 1:\n            target = next_distinct\n            time_needed = (target - category) * t[category]\n            total_time += time_needed\n            next_distinct += 1\n    \n    return total_time\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_time_to_distribute_publications(n, a, t))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9956978559494019,
            0.9941613078117371,
            0.9967632293701172,
            0.9928584098815918,
            0.9966150522232056,
            0.9948832988739014,
            0.9958480000495911,
            0.9965804219245911,
            0.9947594404220581,
            0.9967870116233826,
            0.9963290691375732,
            0.9955934286117554,
            0.9959627389907837,
            0.994218111038208,
            0.9914065003395081,
            0.9954725503921509,
            0.9954522848129272,
            0.9964461922645569,
            0.9948058128356934,
            0.9957711100578308
        ]
    },
    "1402": {
        "similarity": 0.9971300363540649,
        "body": "    MOD = 10**9 + 7\n    \n        greater, smaller = False, False\n        for i in range(n):\n            if t1[i] != '?' and t2[i] != '?':\n                if int(t1[i]) > int(t2[i]):\n                    greater = True\n                elif int(t1[i]) < int(t2[i]):\n                    smaller = True\n                if greater and smaller:\n                    return True\n        return False\n    \n    if not can_compare(template1, template2):\n        return 0\n    \n    ways = 1\n    for i in range(n):\n        if template1[i] != '?' and template2[i] != '?':\n            continue\n        min_val = 0 if template1[i] == '?' else int(template1[i])\n        max_val = 9 if template2[i] == '?' else int(template2[i])\n        ways *= (max_val - min_val + 1)\n        ways %= MOD\n    \n    return ways\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ntemplate1 = data[1]\ntemplate2 = data[2]\n\nresult = count_ways(n, template1, template2)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9971094727516174,
            0.9954502582550049,
            0.9952723979949951,
            0.9952369332313538,
            0.9968966245651245,
            0.996860682964325,
            0.9942120909690857,
            0.996656596660614,
            0.9961697459220886,
            0.9917691946029663,
            0.9968433380126953,
            0.9950533509254456,
            0.9967869520187378,
            0.9965041279792786,
            0.9961996674537659,
            0.9952159523963928,
            0.9969325065612793,
            0.9971300363540649,
            0.9961022138595581,
            0.9970831871032715
        ]
    },
    "1141": {
        "similarity": 0.9973612427711487,
        "body": "    for l, r, c1, c2 in operations:\n        s = s[:l-1] + s[l-1:r].replace(c1, c2) + s[r:]\n    return s\n\n# Read input\nn, m = map(int, input().split())\ns = input().strip()\noperations = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get result and print it\nresult = modify_string(n, m, s, operations)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973612427711487,
            0.9971368908882141,
            0.9945172071456909,
            0.9962608218193054,
            0.9969123005867004,
            0.99496990442276,
            0.9966386556625366,
            0.9965227842330933,
            0.9948930144309998,
            0.996895968914032,
            0.9918804168701172,
            0.9970654845237732,
            0.9964567422866821,
            0.9971285462379456,
            0.9971553683280945,
            0.9952197670936584,
            0.9961186647415161,
            0.9970940351486206,
            0.9965852499008179,
            0.9943453073501587
        ]
    },
    "2836": {
        "similarity": 0.9983218312263489,
        "body": "    max_distance = 0\n    best_name = None\n    \n    for name in range(A, B + 1):\n        if name % 2 != 0:\n            distances = [abs(name - boy) for boy in boys]\n            min_distance = min(distances)\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_name = name\n                \n    return best_name\n\n# Read input from stdin\nN = int(input())\nboys = list(map(int, input().split()))\nA, B = map(int, input().split())\n\n# Find and print the best girl's name\nprint(find_girl_name(N, boys, A, B))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9980896711349487,
            0.9981184601783752,
            0.9978268146514893,
            0.9975546002388,
            0.9979131817817688,
            0.9966232180595398,
            0.9979509115219116,
            0.9979476928710938,
            0.9967052936553955,
            0.9975789785385132,
            0.998088538646698,
            0.9979817271232605,
            0.9973247051239014,
            0.9965303540229797,
            0.9951474070549011,
            0.9981897473335266,
            0.9980844259262085,
            0.9979122877120972,
            0.9983218312263489,
            0.9973854422569275
        ]
    },
    "1109": {
        "similarity": 0.9968664050102234,
        "body": "    a = list(map(int, input().split()))\n    period = a[:k]\n    required_changes = 0\n    \n    for i in range(k, n, k):\n        if a[i:i+k] != period:\n            required_changes += sum(1 for j in range(k) if a[i+j] != period[j])\n    \n    return required_changes\n\nn, k = map(int, input().split())\nprint(min_changes_to_k_periodic(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966826438903809,
            0.9934717416763306,
            0.9952587485313416,
            0.9949350953102112,
            0.9964505434036255,
            0.9947157502174377,
            0.9925031065940857,
            0.9964866638183594,
            0.994260311126709,
            0.9959208965301514,
            0.9968664050102234,
            0.9966597557067871,
            0.9953188896179199,
            0.9965875744819641,
            0.994431734085083,
            0.9958290457725525,
            0.9966195821762085,
            0.9936763644218445,
            0.9951321482658386,
            0.9954386353492737
        ]
    },
    "2125": {
        "similarity": 0.9978643655776978,
        "body": "    count = 0\n    for i in range(n - 2):\n        for j in range(m):\n            for k in range(i + 1, n - 1):\n                if grid[i][j] == grid[k][j] and grid[i][j] != grid[i + 1][j]:\n                    count += 1\n    return count\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Print the result\nprint(count_flags(n, m, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995500385761261,
            0.9937433004379272,
            0.9974438548088074,
            0.9970428347587585,
            0.9971795678138733,
            0.9978643655776978,
            0.9977452158927917,
            0.9973555207252502,
            0.99750155210495,
            0.9977447986602783,
            0.9966681599617004,
            0.9972777366638184,
            0.9976302981376648,
            0.9968652129173279,
            0.9972875714302063,
            0.9977180361747742,
            0.9970141053199768,
            0.9977943301200867,
            0.9976980090141296,
            0.9972456097602844
        ]
    },
    "1746": {
        "similarity": 0.9977661967277527,
        "body": "    child_count = [0] * (n + 1)\n    leaf_count = [0] * (n + 1)\n    \n    for i in range(1, n):\n        parent = parents[i - 1]\n        child_count[parent] += 1\n        if child_count[parent] == 1:\n            leaf_count[parent] += 1\n    \n    for i in range(2, n + 1):\n        if child_count[i] > 0 and leaf_count[i] < 3:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nparents = list(map(int, input().split()))\n\n# Print output\nprint(is_spruce(n, parents))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962643384933472,
            0.9971945881843567,
            0.9969643354415894,
            0.9973099231719971,
            0.9969345927238464,
            0.9931769371032715,
            0.997252345085144,
            0.9953159689903259,
            0.997364342212677,
            0.9967968463897705,
            0.9968669414520264,
            0.9945658445358276,
            0.9960799217224121,
            0.9971717000007629,
            0.997626781463623,
            0.9967840313911438,
            0.9970062971115112,
            0.9977661967277527,
            0.9971791505813599,
            0.9965132474899292
        ]
    },
    "1294": {
        "similarity": 0.9973923563957214,
        "body": "    working_buttons = set()\n    malfunctioning_buttons = set()\n    \n    i = 0\n    while i < len(s):\n        if i + 1 < len(s) and s[i] == s[i + 1]:\n            malfunctioning_buttons.add(s[i])\n            i += 2\n        else:\n            working_buttons.add(s[i])\n            i += 1\n    \n    return ''.join(sorted(working_buttons - malfunctioning_buttons))\n\n    import sys\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    t = int(data[0])\n    results = []\n    \n    for i in range(t):\n        s = data[i + 1]\n        result = find_working_buttons(s)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972789287567139,
            0.9967085123062134,
            0.9969807863235474,
            0.9971156716346741,
            0.996346116065979,
            0.9970750212669373,
            0.9968839883804321,
            0.996947169303894,
            0.9958487153053284,
            0.9965469241142273,
            0.9961276650428772,
            0.9973923563957214,
            0.9961543083190918,
            0.9971150159835815,
            0.9936442375183105,
            0.9964429140090942,
            0.994889497756958,
            0.9961513876914978,
            0.9970325827598572,
            0.9958041310310364
        ]
    },
    "1159": {
        "similarity": 0.9979485273361206,
        "body": "import sys\n\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    total_edges = sum(is_prime(i) for i in range(1, n+1))\n    if not is_prime(total_edges):\n        return -1\n\n    edges = []\n    degrees = [is_prime(i) for i in range(n)]\n    \n    for u in range(n):\n        for v in range(u + 1, n):\n            if degrees[u] and degrees[v]:\n                edges.append((u + 1, v + 1))\n                degrees[u] -= 1\n                degrees[v] -= 1\n    \n    return total_edges, edges\n\n    n = int(input().strip())\n    result = generate_prime_graph(n)\n    if result == -1:\n        print(-1)\n    else:\n        total_edges, edges = result\n        print(total_edges)\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979485273361206,
            0.9975246787071228,
            0.9978439807891846,
            0.9972733855247498,
            0.9976720213890076,
            0.9979362487792969,
            0.997420072555542,
            0.996454119682312,
            0.9973258972167969,
            0.9977068901062012,
            0.9978449940681458,
            0.997024416923523,
            0.9946290850639343,
            0.9961990714073181,
            0.9969470500946045,
            0.9977148175239563,
            0.997912585735321,
            0.9979364275932312,
            0.9978296160697937,
            0.9977163076400757
        ]
    },
    "2025": {
        "similarity": 0.9979953765869141,
        "body": "    if n < 4:\n        return -1\n    count = 0\n    while n >= 4:\n        if n % 2 == 0:\n            n -= 2\n        else:\n            n -= 3\n        count += 1\n    return count + (n > 0)\n\nq = int(input())\nresults = []\nfor _ in range(q):\n    n = int(input())\n    results.append(max_composite_summands(n))\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979953765869141,
            0.9979001879692078,
            0.9969460368156433,
            0.9971834421157837,
            0.9969636797904968,
            0.9968028664588928,
            0.9973998069763184,
            0.9959800243377686,
            0.9979709982872009,
            0.9977890849113464,
            0.9973348379135132,
            0.9979874491691589,
            0.997805655002594,
            0.996842622756958,
            0.996842622756958,
            0.9975534081459045,
            0.997440755367279,
            0.9973337054252625,
            0.9976256489753723,
            0.993644118309021
        ]
    },
    "1429": {
        "similarity": 0.9975062012672424,
        "body": "import sys\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            T = S[i:j]\n            perm_count = len(set(permutations(T)))\n            comp_perm_count = sum(1 for p in permutations(T) if is_complementary(p))\n            if perm_count == comp_perm_count:\n                count += 1\n    return count\n\n    complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return all(complement[a] == b for a, b in zip(t, t[::-1]))\n\nN = int(input().strip())\nS = input().strip()\nprint(count_complementary_substrings(N, S))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960645437240601,
            0.9963708519935608,
            0.9959471821784973,
            0.9975062012672424,
            0.9957060813903809,
            0.9938550591468811,
            0.9961681365966797,
            0.996745765209198,
            0.9969204664230347,
            0.9967281818389893,
            0.9969034790992737,
            0.9968222379684448,
            0.9966298341751099,
            0.9970980286598206,
            0.9960131645202637,
            0.9973869323730469,
            0.9973956942558289,
            0.9968904256820679,
            0.9971655607223511,
            0.9947947263717651
        ]
    },
    "1950": {
        "similarity": 0.9928416013717651,
        "body": "    a.sort()\n    return sum(a[:i] for i in range(1, n + 1))\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\nprint(min_penalty(n, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9921788573265076,
            0.986953616142273,
            0.9921181201934814,
            0.9924942851066589,
            0.9913308024406433,
            0.9915171265602112,
            0.9886856079101562,
            0.9928416013717651,
            0.9926721453666687,
            0.9915171265602112,
            0.9874384999275208,
            0.9874951243400574,
            0.9918497800827026,
            0.9890763163566589,
            0.9903091788291931,
            0.9926395416259766,
            0.9924743175506592,
            0.9918498992919922,
            0.9847908020019531,
            0.991068422794342
        ]
    },
    "631": {
        "similarity": 0.9973964691162109,
        "body": "import sys\n\n    n = len(a)\n    total_sum = 0\n    for i in range(n):\n        inner_sum = sum(a[j] / (j + 1) for j in range(i, n))\n        if inner_sum > m:\n            return \"NO\"\n        total_sum += inner_sum\n    return \"YES\" if total_sum == m else \"NO\"\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        results.append(can_reorder_to_sum(a, m))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996751070022583,
            0.9970214366912842,
            0.9946001768112183,
            0.9973658323287964,
            0.9969522356987,
            0.9973964691162109,
            0.9972440004348755,
            0.996995747089386,
            0.9966213703155518,
            0.9972344636917114,
            0.9960084557533264,
            0.9936017394065857,
            0.9968298077583313,
            0.9960910677909851,
            0.9950633645057678,
            0.9955413341522217,
            0.9956994652748108,
            0.9970040917396545,
            0.9944082498550415,
            0.9973772168159485
        ]
    },
    "2480": {
        "similarity": 0.9987531900405884,
        "body": "from collections import defaultdict\n\n    remainder_count = defaultdict(int)\n    remainder_count[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(N):\n        current_sum += A[i]\n        target_remainder = (current_sum - (i + 1)) % K\n        count += remainder_count[target_remainder]\n        remainder_count[current_sum % K] += 1\n    \n    return count\n\n# Read input from stdin\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_subsequences(N, K, A))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9979978203773499,
            0.9985401630401611,
            0.9981290102005005,
            0.9984838366508484,
            0.9980162382125854,
            0.9983556866645813,
            0.9975842833518982,
            0.9987531900405884,
            0.9982512593269348,
            0.9980762004852295,
            0.9978657960891724,
            0.9987442493438721,
            0.9984815716743469,
            0.9980924725532532,
            0.9978350400924683,
            0.9985829591751099,
            0.9973925352096558,
            0.9978668093681335,
            0.9984430074691772,
            0.9976166486740112
        ]
    },
    "2363": {
        "similarity": 0.9977951049804688,
        "body": "    results = []\n    for a, b in pairs:\n        count = 0\n        while a > 0 and b > 0:\n            if a < b:\n                b -= a\n            else:\n                a -= b\n            count += 1\n        results.append(count)\n    return results\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\nresults = count_operations(pairs)\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958142638206482,
            0.9972387552261353,
            0.9969191551208496,
            0.9971662163734436,
            0.9966211915016174,
            0.9963259696960449,
            0.9956972002983093,
            0.9973679780960083,
            0.9958763122558594,
            0.9967619180679321,
            0.9967314004898071,
            0.9974812865257263,
            0.9973775744438171,
            0.9966861605644226,
            0.9973323345184326,
            0.9966861605644226,
            0.9965914487838745,
            0.997043788433075,
            0.9977951049804688,
            0.9958798289299011
        ]
    },
    "909": {
        "similarity": 0.9978870749473572,
        "body": "a = int(input())\nb = int(input())\nc = int(input())\n\nmax_value = max(a + b * c, a * (b + c), a * b * c)\nprint(max_value)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977001547813416,
            0.9977001547813416,
            0.9977001547813416,
            0.9971967935562134,
            0.9978870749473572,
            0.9977001547813416,
            0.9978870749473572,
            0.9977001547813416,
            0.9862778186798096,
            0.9977001547813416,
            0.9938198924064636,
            0.9929870963096619,
            0.9977001547813416,
            0.9977001547813416,
            0.9972358345985413,
            0.9977001547813416,
            0.9977001547813416,
            0.9976194500923157,
            0.9978870749473572,
            0.9977001547813416
        ]
    },
    "154": {
        "similarity": 0.9969121217727661,
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 1\n    elif n % 2 != 0:\n        return 0\n    \n    half_n = n // 2\n    dp = [0] * (half_n + 1)\n    dp[0] = 1\n    for i in range(1, half_n + 1):\n        dp[i] = (dp[i - 1] * (i * (i - 1) // 2 + i)) % MOD\n    \n    return dp[half_n]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(count_perfectly_balanced_striped_binary_search_trees(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962899088859558,
            0.9945947527885437,
            0.9968519806861877,
            0.9961562156677246,
            0.9951834678649902,
            0.9932093620300293,
            0.9960325360298157,
            0.9945248961448669,
            0.993766188621521,
            0.9948660135269165,
            0.9954416155815125,
            0.9961980581283569,
            0.9959617257118225,
            0.9926602244377136,
            0.9959158897399902,
            0.9952433705329895,
            0.993265688419342,
            0.9969121217727661,
            0.9917237162590027,
            0.9895819425582886
        ]
    },
    "39": {
        "similarity": 0.9986845254898071,
        "body": "    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring != substring[::-1] and len(substring) > max_length:\n                max_length = len(substring)\n    \n    return max_length\n\n# Read input from stdin\ns = input().strip()\n# Print the result\nprint(longest_non_palindrome_substring(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99551922082901,
            0.9981500506401062,
            0.9986845254898071,
            0.9986676573753357,
            0.9982278943061829,
            0.9983030557632446,
            0.9975067973136902,
            0.998532772064209,
            0.9981256127357483,
            0.9985085725784302,
            0.9982540607452393,
            0.9973970055580139,
            0.9982641339302063,
            0.9986429810523987,
            0.9982861876487732,
            0.9981052875518799,
            0.9946776032447815,
            0.9974365234375,
            0.997639536857605,
            0.9980857372283936
        ]
    },
    "1885": {
        "similarity": 0.9949942231178284,
        "body": "from math import comb\n\nn = int(input())\ntotal = 0\nfor i in range(5, 8):\n    total += comb(n, i)\nprint(total)",
        "result": "passed",
        "similarities": [
            0.9929272532463074,
            0.9942174553871155,
            0.9949942231178284,
            0.9930965900421143,
            0.9941014051437378,
            0.9924870729446411,
            0.9939956665039062,
            0.9944987893104553,
            0.9941014051437378,
            0.9941138029098511,
            0.9924871325492859,
            0.9933470487594604,
            0.9924871325492859,
            0.9933475852012634,
            0.9918221235275269,
            0.9929291605949402,
            0.9933656454086304,
            0.9909735321998596,
            0.9854737520217896,
            0.9930201172828674
        ]
    },
    "1180": {
        "similarity": 0.9981979727745056,
        "body": "    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if digits[i-1] != '0':\n                dp[i][j] = dp[i-1][j]\n                if j > 0:\n                    dp[i][j] += dp[i-2][j-1] * int(digits[i-2:i])\n                    dp[i][j] %= MOD\n    \n    result = sum(dp[n]) % MOD\n    return result\n\n# Read input from stdin\nn, k = map(int, input().split())\ndigits = input().strip()\n\n# Calculate and print the result\nprint(calculate_sum(n, k, digits))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944925904273987,
            0.9956666231155396,
            0.9976949095726013,
            0.9972857236862183,
            0.9981979727745056,
            0.9962148070335388,
            0.9977534413337708,
            0.9964316487312317,
            0.9950802326202393,
            0.9977603554725647,
            0.9964587688446045,
            0.9974198937416077,
            0.9970592856407166,
            0.9976834058761597,
            0.9981211423873901,
            0.9977186918258667,
            0.9961014986038208,
            0.9970993399620056,
            0.9972752928733826,
            0.9977530241012573
        ]
    },
    "1856": {
        "similarity": 0.9958345293998718,
        "body": "from collections import defaultdict\n\n    graph = defaultdict(set)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            if set(passwords[i]) & set(passwords[j]):\n                graph[passwords[i]].add(passwords[j])\n                graph[passwords[j]].add(passwords[i])\n                \n    visited = set()\n    components = 0\n    \n        stack = [node]\n        while stack:\n            current = stack.pop()\n            if current not in visited:\n                visited.add(current)\n                stack.extend(graph[current] - visited)\n    \n    for password in passwords:\n        if password not in visited:\n            components += 1\n            dfs(password)\n            \n    return components\n\n# Read input\nn = int(input())\npasswords = [input().strip() for _ in range(n)]\n\n# Output the result\nprint(min_passwords(n, passwords))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9950720071792603,
            0.9948605895042419,
            0.9945198893547058,
            0.9951248168945312,
            0.9939399361610413,
            0.994968593120575,
            0.9933006167411804,
            0.9893961548805237,
            0.9940926432609558,
            0.9954135417938232,
            0.9949160218238831,
            0.9916960000991821,
            0.9950976967811584,
            0.9950990080833435,
            0.9947254657745361,
            0.994899332523346,
            0.9932538270950317,
            0.9947282075881958,
            0.9958345293998718,
            0.9938673973083496
        ]
    },
    "522": {
        "similarity": 0.9973124265670776,
        "body": "    result = 1\n    base = base % mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\n    MOD = 10**9 + 7\n    if n == 4:\n        return ((f1 * f2 * f3) ** 2 * c) % MOD\n    \n    dp = [0] * (n + 1)\n    dp[1], dp[2], dp[3] = f1, f2, f3\n    \n    for x in range(4, n + 1):\n        dp[x] = (dp[x - 1] * dp[x - 2] * dp[x - 3]) % MOD\n        dp[x] = (dp[x] ** 2) % MOD\n        dp[x] = (dp[x] * c) % MOD\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n, f1, f2, f3, c = map(int, input().split())\n    result = calculate_f(n, f1, f2, f3, c)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961644411087036,
            0.996881365776062,
            0.9967071413993835,
            0.9963418245315552,
            0.9970057606697083,
            0.9973124265670776,
            0.9966728687286377,
            0.996539294719696,
            0.9970829486846924,
            0.9972556233406067,
            0.9960930347442627,
            0.9960486888885498,
            0.9950959086418152,
            0.9960755705833435,
            0.9955673217773438,
            0.9971650838851929,
            0.9969918131828308,
            0.9972560405731201,
            0.9968022108078003,
            0.9949393272399902
        ]
    },
    "1719": {
        "similarity": 0.9946557879447937,
        "body": "MOD = 10**9 + 7\n\n    if N == 3:\n        return 61\n    \n    # dp[i][j][k] is the number of valid strings of length i ending with j and k\n    dp = [[[0]*4 for _ in range(4)] for _ in range(4)]\n    \n    # Initialize base case\n    dp[0][1][2] = 1  # \"ACG\" is not allowed, so we start with a different pattern\n    \n    for i in range(3, N):\n        new_dp = [[[0]*4 for _ in range(4)] for _ in range(4)]\n        for j in range(4):\n            for k in range(4):\n                for l in range(4):\n                    if (j == 1 and k == 2 and l == 3) or (k == 1 and l == 2 and j == 3):\n                        continue\n                    new_dp[j][k][l] = (new_dp[j][k][l] + dp[k][l][0]) % MOD\n                    new_dp[j][k][l] = (new_dp[j][k][l] + dp[k][l][1]) % MOD\n                    new_dp[j][k][l] = (new_dp[j][k][l] + dp[k][l][2]) % MOD\n                    new_dp[j][k][l] = (new_dp[j][k][l] + dp[k][l][3]) % MOD\n        dp = new_dp\n    \n    result = 0\n    for j in range(4):\n        for k in range(4):\n            for l in range(4):\n                if (j == 1 and k == 2 and l == 3) or (k == 1 and l == 2 and j == 3):\n                    continue\n                result = (result + dp[j][k][l]) % MOD\n    \n    return result\n\nN = int(input())\nprint(count_valid_strings(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9916917681694031,
            0.9920963644981384,
            0.9941755533218384,
            0.9945186972618103,
            0.9935295581817627,
            0.9932023882865906,
            0.983401358127594,
            0.992024302482605,
            0.9939333200454712,
            0.9927211403846741,
            0.9909589886665344,
            0.9923641681671143,
            0.9942597150802612,
            0.994064211845398,
            0.9907835125923157,
            0.9943833947181702,
            0.9943109154701233,
            0.9944286346435547,
            0.9912582039833069,
            0.9946557879447937
        ]
    },
    "1842": {
        "similarity": 0.996107280254364,
        "body": "import sys\nimport math\n\na, b, c = map(int, input().split())\n\ndiscriminant = b**2 - 4*a*c\n\nroot1 = (-b + math.sqrt(discriminant)) / (2*a)\nroot2 = (-b - math.sqrt(discriminant)) / (2*a)\n\nprint(root1)\nprint(root2)",
        "result": "passed",
        "similarities": [
            0.9953049421310425,
            0.9917461276054382,
            0.9958015084266663,
            0.9959198832511902,
            0.9953049421310425,
            0.996107280254364,
            0.9895800352096558,
            0.9943747520446777,
            0.9943747520446777,
            0.995487630367279,
            0.9953049421310425,
            0.9940251111984253,
            0.9952448606491089,
            0.9911398887634277,
            0.9953049421310425,
            0.9950278401374817,
            0.9953049421310425,
            0.9951677918434143,
            0.9943747520446777,
            0.9949479699134827
        ]
    },
    "806": {
        "similarity": 0.9975469708442688,
        "body": "MOD = 10**9 + 7\n\n    if n * l > r or n * r < l:\n        return 0\n    total_sum = (n * (l + r)) // 2\n    if total_sum % 3 != 0:\n        return 0\n    \n    dp = [0] * (total_sum // 3 + 1)\n    dp[0] = 1\n    \n    for _ in range(n):\n        new_dp = [0] * (total_sum // 3 + 1)\n        for s in range(total_sum // 3 + 1):\n            if dp[s] > 0:\n                new_dp[(s + l) % total_sum // 3] += dp[s]\n                new_dp[(s + r) % total_sum // 3] += dp[s]\n        dp = new_dp\n    \n    return dp[total_sum // 3] % MOD\n\n# Read input\nn, l, r = map(int, input().split())\n\n# Output the result\nprint(count_ways(n, l, r))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963929057121277,
            0.9959643483161926,
            0.9949439167976379,
            0.9965513348579407,
            0.9971249103546143,
            0.996870219707489,
            0.9966573119163513,
            0.9963768720626831,
            0.9975469708442688,
            0.9953545331954956,
            0.9971510171890259,
            0.9955464601516724,
            0.9962320923805237,
            0.9944190979003906,
            0.9962498545646667,
            0.996852695941925,
            0.9968829154968262,
            0.9943815469741821,
            0.9961684346199036,
            0.9972858428955078
        ]
    },
    "365": {
        "similarity": 0.9980506896972656,
        "body": "    total_length = sum(a)\n    if total_length != x:\n        return \"NO\"\n    if len(a) == 1 and a[0] == x:\n        return \"YES\"\n    if len(a) > 1:\n        max_segment = max(a)\n        min_segments = n - 1\n        if max_segment + min_segments * (max_segment - 1) >= x:\n            return \"NO\"\n    return \"YES\"\n\n# Read input from stdin\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(is_unique_crossword(n, x, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997857928276062,
            0.9972829222679138,
            0.9979794025421143,
            0.9964216351509094,
            0.9980097413063049,
            0.9971445202827454,
            0.9969439506530762,
            0.9976369142532349,
            0.9980178475379944,
            0.9927883148193359,
            0.9961040019989014,
            0.9975637197494507,
            0.9980171918869019,
            0.997312068939209,
            0.9960498809814453,
            0.9961967468261719,
            0.9980506896972656,
            0.9974473714828491,
            0.9976525902748108,
            0.997593104839325
        ]
    },
    "1158": {
        "similarity": 0.9973564147949219,
        "body": "    from collections import Counter\n    \n    # Count the frequency of each type of utensil\n    utensil_counts = Counter(utensils)\n    \n    # Calculate the minimum number of stolen utensils\n    stolen = sum(max(0, count - k) for count in utensil_counts.values())\n    \n    return stolen\n\n# Read input from stdin\nn, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\n# Print the result\nprint(min_stolen_utensils(n, k, utensils))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968651533126831,
            0.9961955547332764,
            0.9968293905258179,
            0.9946650266647339,
            0.9945807456970215,
            0.9962481260299683,
            0.9973564147949219,
            0.9969328045845032,
            0.9967736005783081,
            0.9970755577087402,
            0.997073233127594,
            0.9968543648719788,
            0.9964736104011536,
            0.994899570941925,
            0.9968851208686829,
            0.9956223368644714,
            0.9962750673294067,
            0.9970823526382446,
            0.9964215159416199,
            0.9972516894340515
        ]
    },
    "33": {
        "similarity": 0.9972285032272339,
        "body": "    if a1 == a2:\n        return max(0, min(R, b1) - max(L, b1) + 1)\n    \n    lcm = abs(a1 * a2) // gcd(a1, a2)\n    offset = (L - b1) % lcm\n    \n    count = 0\n    for k in range((offset + lcm - 1) // lcm, R // lcm + 1):\n        x = a1 * k + b1\n        if L <= x <= R:\n            if (x - b2) % lcm == 0:\n                count += 1\n                \n    return count\n\nfrom math import gcd\n\n# Read input from stdin\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954906105995178,
            0.9963768720626831,
            0.9933304190635681,
            0.9959654808044434,
            0.9961352944374084,
            0.9972285032272339,
            0.9965035319328308,
            0.9969627261161804,
            0.995631992816925,
            0.9938420057296753,
            0.9962409138679504,
            0.9971219897270203,
            0.9970287680625916,
            0.9957617521286011,
            0.9958624839782715,
            0.9963305592536926,
            0.9957227110862732,
            0.9967018961906433,
            0.9968738555908203,
            0.9944450259208679
        ]
    },
    "2498": {
        "similarity": 0.997664213180542,
        "body": "import sys\n\n    semi_common_multiples = set()\n    \n    for a in A:\n        p = 1 / a\n        while True:\n            X = a * (p + 0.5)\n            if X > M:\n                break\n            semi_common_multiples.add(int(X))\n            p += 2\n    \n    return len(semi_common_multiples)\n\n# Read input from stdin\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_semi_common_multiples(N, M, A)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973652362823486,
            0.9959568381309509,
            0.997664213180542,
            0.9965649843215942,
            0.9973781108856201,
            0.997465968132019,
            0.9973863363265991,
            0.9966474771499634,
            0.9966121315956116,
            0.9968593120574951,
            0.9950053691864014,
            0.9950934052467346,
            0.9964887499809265,
            0.9959057569503784,
            0.9969086050987244,
            0.9960347414016724,
            0.9967215657234192,
            0.996897280216217,
            0.9939247965812683,
            0.9951503276824951
        ]
    },
    "2309": {
        "similarity": 0.9979318380355835,
        "body": "from collections import Counter\n\n    vowels = 'aeiou'\n    return sum(1 for char in word if char in vowels)\n\n    n = len(words)\n    counts = [count_vowels(word) for word in words]\n    \n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if counts[i] == counts[j]:\n                last_vowel_i = next((char for char in reversed(words[i]) if char in 'aeiou'), None)\n                last_vowel_j = next((char for char in reversed(words[j]) if char in 'aeiou'), None)\n                if last_vowel_i == last_vowel_j:\n                    pairs.append((words[i], words[j]))\n    \n    return pairs\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    words = data[1:]\n    \n    beautiful_lyrics = find_beautiful_lyrics(words)\n    m = len(beautiful_lyrics)\n    \n    print(m)\n    for lyric in beautiful_lyrics:\n        print(f\"{lyric[0]} {lyric[1]}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975477457046509,
            0.9975665211677551,
            0.9975161552429199,
            0.9971810579299927,
            0.997852623462677,
            0.9970239400863647,
            0.9975013732910156,
            0.9977313876152039,
            0.9976937174797058,
            0.9976217150688171,
            0.9979318380355835,
            0.9964995980262756,
            0.9969512820243835,
            0.9978241324424744,
            0.9975953698158264,
            0.9973779916763306,
            0.9972283244132996,
            0.9976445436477661,
            0.9974973797798157,
            0.9970442056655884
        ]
    },
    "1326": {
        "similarity": 0.9971259236335754,
        "body": "import sys\n\n    total_sum = 0\n    for K in range(1, N + 1):\n        divisors_count = 0\n        for i in range(1, K + 1):\n            if K % i == 0:\n                divisors_count += 1\n        total_sum += K * divisors_count\n    return total_sum\n\nif __name__ == \"__main__\":\n    N = int(input())\n    print(sum_divisors(N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968355894088745,
            0.9968368411064148,
            0.9966245889663696,
            0.9960584044456482,
            0.9970614910125732,
            0.9938101768493652,
            0.9965978264808655,
            0.9958562254905701,
            0.9963464140892029,
            0.9969558715820312,
            0.9968329071998596,
            0.9971259236335754,
            0.9961488842964172,
            0.9963093996047974,
            0.9887896180152893,
            0.996995210647583,
            0.9964455366134644,
            0.9968101382255554,
            0.9962170124053955,
            0.990531325340271
        ]
    },
    "2950": {
        "similarity": 0.9976608753204346,
        "body": "    max_height = max(heights)\n    charges = 0\n    for i in range(max_height, 0, -1):\n        if any(h > i for h in heights):\n            charges += 1\n            for j in range(n):\n                if heights[j] > i:\n                    heights[j] -= 1\n    return charges\n\n# Read input from stdin\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Print the result\nprint(min_charges_to_tear_down_blocks(n, heights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996967613697052,
            0.9974097013473511,
            0.9971032738685608,
            0.9975188374519348,
            0.9969739317893982,
            0.9969580769538879,
            0.9966669678688049,
            0.9976608753204346,
            0.9966111779212952,
            0.9965545535087585,
            0.9966400861740112,
            0.9966229796409607,
            0.9906682372093201,
            0.9967837333679199,
            0.9971766471862793,
            0.9941474795341492,
            0.9969156980514526,
            0.9971175789833069,
            0.9972047209739685,
            0.9971386790275574
        ]
    },
    "1983": {
        "similarity": 0.9984101057052612,
        "body": "    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[-1]\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = longest_increasing_subsequence(n, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975491762161255,
            0.9973347187042236,
            0.99651038646698,
            0.9974216818809509,
            0.9983185529708862,
            0.9972789287567139,
            0.9972047209739685,
            0.9977129697799683,
            0.9980810284614563,
            0.9957993030548096,
            0.9982038736343384,
            0.998375654220581,
            0.9978625774383545,
            0.9982563853263855,
            0.9950008392333984,
            0.9978543519973755,
            0.9984101057052612,
            0.9971705079078674,
            0.9980933666229248,
            0.9977180361747742
        ]
    },
    "1767": {
        "similarity": 0.9985458254814148,
        "body": "    max_sum = 0\n    for l in range(n):\n        current_a_or = 0\n        current_b_or = 0\n        for r in range(l, n):\n            current_a_or |= a[r]\n            current_b_or |= b[r]\n            max_sum = max(max_sum, current_a_or + current_b_or)\n    return max_sum\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the result\nprint(max_bitwise_or_sum(n, a, b))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9985458254814148,
            0.9976678490638733,
            0.9984347820281982,
            0.9979131817817688,
            0.9984595775604248,
            0.9977673292160034,
            0.9975764751434326,
            0.9977311491966248,
            0.9981402158737183,
            0.9981762766838074,
            0.9979278445243835,
            0.9962489604949951,
            0.9985148906707764,
            0.9983241558074951,
            0.9972140789031982,
            0.9985148906707764,
            0.998482346534729,
            0.9985458254814148,
            0.997971773147583,
            0.9961261749267578
        ]
    },
    "2382": {
        "similarity": 0.9976850748062134,
        "body": "from collections import Counter\nimport sys\n\n    target = Counter(S)\n    queue = [(1, 0)]\n    \n    while queue:\n        current_time, health = queue.pop(0)\n        if current_time == N:\n            return True\n        \n        for new_health in range(health - 1, 0, -1):\n            if new_health not in target or target[new_health] <= 0:\n                continue\n            target[new_health] -= 1\n            queue.append((current_time + 1, new_health))\n            target[health] += 1\n    \n    return False\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = list(map(int, input().split()))\n    if can_reproduce(N, S):\n        print(\"Yes\")\n    else:\n        print(\"No\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975829124450684,
            0.9966123700141907,
            0.9970236420631409,
            0.9969958066940308,
            0.9972383379936218,
            0.9970867037773132,
            0.9968621134757996,
            0.9972453117370605,
            0.9974876046180725,
            0.9972900748252869,
            0.9957209229469299,
            0.9967938661575317,
            0.9970325827598572,
            0.9964979887008667,
            0.9964991211891174,
            0.9976752400398254,
            0.9972904920578003,
            0.9963611960411072,
            0.9976850748062134,
            0.9975852966308594
        ]
    },
    "3907": {
        "similarity": 0.9969655275344849,
        "body": "    # Count the frequency of each number in the coupons\n    coupon_count = {}\n    for q, w in coupons:\n        if q in coupon_count:\n            coupon_count[q] += w\n        else:\n            coupon_count[q] = w\n    \n    # Sort the keys of the coupon count dictionary\n    sorted_coupons = sorted(coupon_count.keys())\n    \n    # Initialize the maximum money Sereja can pay\n    max_money = 0\n    \n    # Iterate through the sorted coupons and calculate the maximum money\n    for i in range(len(sorted_coupons)):\n        q = sorted_coupons[i]\n        if i + 1 < len(sorted_coupons):\n            next_q = sorted_coupons[i + 1]\n            if next_q == q + 1:\n                continue\n        max_money += coupon_count[q]\n    \n    return max_money\n\n# Read input from stdin\nn, m = map(int, input().split())\ncoupons = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print the result\nprint(max_money_to_dima(n, m, coupons))",
        "result": "failed: testcase 0",
        "similarities": [
            0.996067464351654,
            0.9969655275344849,
            0.9969013929367065,
            0.9966844320297241,
            0.9965431094169617,
            0.9962190389633179,
            0.9959287047386169,
            0.9931104779243469,
            0.9939669370651245,
            0.9965012073516846,
            0.9960736632347107,
            0.9961224794387817,
            0.9966785907745361,
            0.9966596364974976,
            0.9958098530769348,
            0.9964687824249268,
            0.9969422221183777,
            0.9936506152153015,
            0.9968095421791077,
            0.9964258074760437
        ]
    },
    "3676": {
        "similarity": 0.9971580505371094,
        "body": "    if R == 1 and C == 1:\n        return 1\n    elif R == 1 or C == 1:\n        return R * C\n    else:\n        return (R - 2) * (C - 2)\n\n# Read input from stdin\nR, C = map(int, input().split())\n\n# Print the result\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965313673019409,
            0.9930033683776855,
            0.9971580505371094,
            0.9955171346664429,
            0.9956305623054504,
            0.9962608814239502,
            0.9966465830802917,
            0.9946748614311218,
            0.9955118894577026,
            0.9947688579559326,
            0.9959096312522888,
            0.9970025420188904,
            0.9949837923049927,
            0.9935025572776794,
            0.9968516826629639,
            0.9967851042747498,
            0.9964919090270996,
            0.995754063129425,
            0.9964973330497742,
            0.992214024066925
        ]
    },
    "3293": {
        "similarity": 0.9974164366722107,
        "body": "import sys\n\n    n = int(input())\n    snacks = []\n    \n    for _ in range(n):\n        f, p, m, s = map(int, input().split())\n        snacks.append((f - 1, p, m, s))\n    \n    snacks.sort()\n    profit = 0\n    min_buy_price = float('inf')\n    \n    for i in range(n):\n        if snacks[i][3] == 0:\n            continue\n        if snacks[i][1] < min_buy_price:\n            min_buy_price = snacks[i][1]\n        elif snacks[i][2] > snacks[i][1]:\n            profit += max(0, (snacks[i][2] - snacks[i][1]) * min(snacks[i][3], 1))\n    \n    print(profit)\n\nmax_profit()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957526326179504,
            0.9967061281204224,
            0.9953101277351379,
            0.9974164366722107,
            0.995805025100708,
            0.9967390298843384,
            0.9965453743934631,
            0.9970548748970032,
            0.99649578332901,
            0.9955586791038513,
            0.9950101971626282,
            0.9956002831459045,
            0.9935757517814636,
            0.9960539937019348,
            0.9956242442131042,
            0.9968811869621277,
            0.9937874674797058,
            0.9969197511672974,
            0.9955304861068726,
            0.996317446231842
        ]
    },
    "3587": {
        "similarity": 0.9966989755630493,
        "body": "    if N == 0:\n        return \"1\"\n    \n    # Check if we can construct a binary string that does not contain any of the taboo strings as a substring\n        for i in range(1 << 20):  # Arbitrarily large number to check combinations\n            binary_string = bin(i)[2:].zfill(20)  # Binary string of length at least 20\n            if all(taboo not in binary_string for taboo in taboo_strings):\n                return True\n        return False\n    \n    if can_construct():\n        return \"1\" * (N + 1)\n    \n    return -1\n\n# Read input\nN = int(input())\ntaboo_strings = [input().strip() for _ in range(N)]\n\n# Output the result\nprint(longest_clue(N, taboo_strings))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961289167404175,
            0.9961673617362976,
            0.9937322735786438,
            0.9962039589881897,
            0.9961952567100525,
            0.99395751953125,
            0.9949005842208862,
            0.9966989755630493,
            0.9951110482215881,
            0.9940982460975647,
            0.9955533742904663,
            0.9963167905807495,
            0.9952136874198914,
            0.9947842955589294,
            0.995921790599823,
            0.9927099347114563,
            0.9941366314888,
            0.9965490102767944,
            0.9954131245613098,
            0.9963314533233643
        ]
    },
    "3530": {
        "similarity": 0.9972321391105652,
        "body": "import sys\nfrom typing import List\n\n    results = []\n    for T in times:\n        total_fun = 0\n        used_time = 0\n        i = 0\n        while used_time < T and i < N:\n            a, b, t = coasters[i]\n            k = (used_time + t - 1) // t + 1\n            fun_value = a - (k - 1)**2 * b\n            if fun_value > 0:\n                total_fun += fun_value\n                used_time += t\n            else:\n                break\n            i += 1\n        results.append(total_fun)\n    return results\n\n# Read input from stdin\nN = int(input().strip())\ncoasters = []\nfor _ in range(N):\n    a, b, t = map(int, input().strip().split())\n    coasters.append([a, b, t])\nQ = int(input().strip())\ntimes = [int(input().strip()) for _ in range(Q)]\n\n# Calculate and print results\nresults = max_fun(N, coasters, Q, times)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955039620399475,
            0.9962800741195679,
            0.9956261515617371,
            0.996526837348938,
            0.9953096508979797,
            0.9954958558082581,
            0.9972321391105652,
            0.9970906972885132,
            0.9956730604171753,
            0.9968151450157166,
            0.9965497851371765,
            0.9968651533126831,
            0.9969992637634277,
            0.9951073527336121,
            0.9934337139129639,
            0.9970046877861023,
            0.9968599081039429,
            0.9960987567901611,
            0.9953580498695374,
            0.9960889220237732
        ]
    },
    "3900": {
        "similarity": 0.9967117309570312,
        "body": "from collections import defaultdict\nimport sys\n\n    suspects = set()\n    for x, y in opinions:\n        suspects.update([x, y])\n    \n    valid_sets = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if len(suspects.intersection({i, j})) >= p:\n                valid_sets += 1\n    \n    return valid_sets\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = int(data[1])\n    opinions = [(int(data[2 + 2 * i]) for _ in range(2)) for i in range(n)]\n    \n    result = count_ways(n, p, opinions)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963569641113281,
            0.9966966509819031,
            0.9953109622001648,
            0.9963996410369873,
            0.9956358075141907,
            0.9951463341712952,
            0.9943622946739197,
            0.9955028891563416,
            0.9951135516166687,
            0.995593249797821,
            0.9912495017051697,
            0.994718074798584,
            0.9967117309570312,
            0.996059000492096,
            0.9947242736816406,
            0.9953292012214661,
            0.9936051964759827,
            0.9956757426261902,
            0.9949629902839661,
            0.9957528710365295
        ]
    },
    "3996": {
        "similarity": 0.9956477284431458,
        "body": "from fractions import Fraction\nfrom math import gcd\n\nMOD = 10**9 + 7\n\n    k = int(input())\n    a = list(map(int, input().split()))\n    \n    n = 1\n    for x in a:\n        n *= x\n    \n    # Probability calculation\n    p = 1\n    q = 2 ** n\n    \n    # Simplify the fraction\n    common_divisor = gcd(p, q)\n    p //= common_divisor\n    q //= common_divisor\n    \n    # Get remainders\n    p_remainder = p % MOD\n    q_remainder = q % MOD\n    \n    print(f\"{p_remainder}/{q_remainder}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946752786636353,
            0.9956477284431458,
            0.9943231344223022,
            0.9956380128860474,
            0.9948143362998962,
            0.9948126077651978,
            0.9931782484054565,
            0.9941967725753784,
            0.9920715689659119,
            0.9956000447273254,
            0.9942361116409302,
            0.9943285584449768,
            0.9952296018600464,
            0.995314359664917,
            0.9950267672538757,
            0.9940075278282166,
            0.9947688579559326,
            0.9935139417648315,
            0.9947319030761719,
            0.9954304099082947
        ]
    },
    "3276": {
        "similarity": 0.99676913022995,
        "body": "    # Check if it's possible to reproduce the art piece\n    for i in range(N - 2):\n        for j in range(M - 2):\n            block = [art[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n            if len(set(block)) == 1:\n                continue\n            else:\n                return \"NO\"\n    return \"YES\"\n\n# Read input from stdin\nN, M = map(int, input().split())\nart = [input().strip() for _ in range(N)]\n\n# Output the result\nprint(can_reproduce_art(N, M, art))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960361123085022,
            0.9945902824401855,
            0.9960488677024841,
            0.9953911304473877,
            0.995164155960083,
            0.9960209727287292,
            0.9923524260520935,
            0.9936068654060364,
            0.9963240623474121,
            0.9933511018753052,
            0.9948290586471558,
            0.9963219165802002,
            0.9920154213905334,
            0.9951061606407166,
            0.9953688383102417,
            0.99676913022995,
            0.9951673150062561,
            0.9963212609291077,
            0.9951356649398804,
            0.9955438375473022
        ]
    },
    "3834": {
        "similarity": 0.9975295662879944,
        "body": "        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if (i != x1 and i != x2) and (j != y1 and j != y2):\n                    if grid[i][j] != grid[x1][y1]:\n                        return False\n        return True\n\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == value and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    stack.append((nx, ny))\n\n    changes = 0\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                component_value = grid[i][j]\n                dfs(i, j, component_value)\n                visited.add((i, j))\n                x1, y1, x2, y2 = min(x for x, y in visited), min(y for x, y in visited), max(x for x, y in visited), max(y for x, y in visited)\n                if not is_valid_rectangle(x1, y1, x2, y2):\n                    changes += 1\n\n    return -1 if changes > k else changes\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\ngrid = [[int(data[i * m + j + 3]) for j in range(m)] for i in range(n)]\n\nprint(min_changes_to_rectangle(n, m, k, grid))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9959152936935425,
            0.9972660541534424,
            0.9968424439430237,
            0.9975295662879944,
            0.9968808889389038,
            0.9970666766166687,
            0.9955689311027527,
            0.9959779381752014,
            0.995694637298584,
            0.9943464398384094,
            0.9953284859657288,
            0.997003972530365,
            0.9960943460464478,
            0.9973745942115784,
            0.9951818585395813,
            0.9974732995033264,
            0.9971683025360107,
            0.9970978498458862,
            0.9945371747016907,
            0.9949346780776978
        ]
    },
    "3012": {
        "similarity": 0.9976733326911926,
        "body": "MOD = 10**9 + 7\n\n    total = a11 + a12 + a21 + a22\n    if N == 0:\n        return 1\n    if N < 3 or total < 2:\n        return 0\n    \n    dp = [[[[0] * (total + 1) for _ in range(total + 1)] for _ in range(3)] for _ in range(2)]\n    \n        dp[a][b][c][d] += 1\n        dp[a][b][c][d] %= MOD\n    \n    update_dp(0, 0, a11, a12)\n    update_dp(1, 0, a21, a22)\n    \n    for _ in range(N - 1):\n        new_dp = [[[[0] * (total + 1) for _ in range(total + 1)] for _ in range(3)] for _ in range(2)]\n        for a in range(2):\n            for b in range(2):\n                for c in range(total + 1):\n                    for d in range(total + 1):\n                        if dp[a][b][c][d] == 0:\n                            continue\n                        if b == 0 and a == 0:\n                            for e in range(a11):\n                                update_dp(0, 1, c - 1, e)\n                            for e in range(a21):\n                                update_dp(1, 1, c - 1, e)\n                        elif b == 0 and a == 1:\n                            for e in range(a22):\n                                update_dp(1, 1, c - 1, e)\n                        else:\n                            if d > 0:\n                                update_dp(b, a, c + 1, d - 1)\n                            if d == 0:\n                                for e in range(total - c):\n                                    update_dp(b, a, c + 1, e)\n        dp = new_dp\n    \n    result = (dp[0][1][total][0] + dp[1][1][total][0]) % MOD\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\na11 = int(data[0])\na12 = int(data[1])\na21 = int(data[2])\na22 = int(data[3])\nN = int(data[4])\n\nprint(count_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968733787536621,
            0.9975009560585022,
            0.9975346922874451,
            0.9958115816116333,
            0.9974461793899536,
            0.9920441508293152,
            0.9944936633110046,
            0.9976733326911926,
            0.9976360201835632,
            0.9967948794364929,
            0.9974573850631714,
            0.9974925518035889,
            0.9970746636390686,
            0.9976125955581665,
            0.9972327351570129,
            0.9968339800834656,
            0.9970839619636536,
            0.9971243143081665,
            0.9971500039100647,
            0.9970136880874634
        ]
    },
    "3745": {
        "similarity": 0.9978474378585815,
        "body": "    if n == 1:\n        return \"Yes\\na\"\n    \n    graph = [[] for _ in range(n + 1)]\n    degree = [0] * (n + 1)\n    \n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    if any(d % 2 != 0 for d in degree):\n        return \"No\"\n    \n    colors = ['a', 'b', 'c']\n    color_map = {}\n    \n        for neighbor in graph[node]:\n            if neighbor not in color_map:\n                for color in colors:\n                    if color != prev_color and all(color_map.get(neighbor2) != color for neighbor2 in graph[neighbor]):\n                        color_map[neighbor] = color\n                        break\n                else:\n                    return False\n        return True\n    \n    if not dfs(1, None):\n        return \"No\"\n    \n    result = ''.join(color_map[i] for i in range(1, n + 1))\n    return f\"Yes\\n{result}\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nedges = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\nprint(can_form_string(n, m, edges))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955564737319946,
            0.9972437620162964,
            0.9976342916488647,
            0.9973453879356384,
            0.9969739317893982,
            0.9960931539535522,
            0.9948579668998718,
            0.9965844750404358,
            0.9967739582061768,
            0.9962945580482483,
            0.9961411356925964,
            0.9976451396942139,
            0.9978474378585815,
            0.9977208375930786,
            0.9971451163291931,
            0.9974769949913025,
            0.9977673888206482,
            0.9977065920829773,
            0.9973334074020386,
            0.9973328113555908
        ]
    },
    "3028": {
        "similarity": 0.9969817996025085,
        "body": "    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                for k in range(n):\n                    board[k][j] = (board[k][j] + 1) % p\n                for k in range(m):\n                    board[i][k] = (board[i][k] + 1) % p\n                moves.append(i * m + j + 1)\n    if all(board[i][j] == p for i in range(n) for j in range(m)):\n        return len(moves), moves\n    else:\n        return -1\n\n# Read input\nn, m, p = map(int, input().split())\nboard = [list(map(int, input().split())) for _ in range(n)]\n\n# Find and print the result\nresult = primonimo(n, m, p, board)\nif isinstance(result, tuple):\n    k, moves = result\n    print(k)\n    print(*moves)\nelse:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9963138103485107,
            0.9967589378356934,
            0.9969817996025085,
            0.994490385055542,
            0.9958044290542603,
            0.9938398003578186,
            0.9958533048629761,
            0.9960444569587708,
            0.9955507516860962,
            0.9969125390052795,
            0.9961724877357483,
            0.9949951171875,
            0.9968060851097107,
            0.9957672953605652,
            0.9966049194335938,
            0.9946361184120178,
            0.996498703956604,
            0.9949306845664978,
            0.9969156980514526,
            0.9965900778770447
        ]
    },
    "3196": {
        "similarity": 0.9977186918258667,
        "body": "from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for A, B in roads:\n        graph[A].append(B)\n\n    if 2 not in graph[1]:\n        return 0\n\n    queue = deque([1])\n    visited = [False] * (N + 1)\n    visited[1] = True\n    routes = 0\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                if neighbor == 2:\n                    routes += 1\n            elif neighbor == 1:\n                return \"inf\"\n\n    return routes % 1000000000\n\n# Read input\nN, M = map(int, input().split())\nroads = [tuple(map(int, input().split())) for _ in range(M)]\n\n# Print the result\nprint(count_routes(N, M, roads))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976558685302734,
            0.9970544576644897,
            0.997231662273407,
            0.9967896342277527,
            0.9967667460441589,
            0.9969428181648254,
            0.9971333742141724,
            0.9934206604957581,
            0.9975652098655701,
            0.996623694896698,
            0.9976551532745361,
            0.9950115084648132,
            0.9970110654830933,
            0.9958259463310242,
            0.9935701489448547,
            0.9977186918258667,
            0.9962539672851562,
            0.9973171949386597,
            0.9973154664039612,
            0.9962050914764404
        ]
    },
    "3405": {
        "similarity": 0.9976983666419983,
        "body": "    X_str = str(X)\n    digits = len(X_str) - 1\n    multiples = []\n    \n    for n in range(1, 10**digits):\n        num_str = str(n * (10 ** digits + int(X_str)))\n        if num_str.endswith(str(n)):\n            multiples.append(int(num_str))\n    \n    return sorted(multiples)\n\nif __name__ == \"__main__\":\n    X = float(input())\n    result = find_multiples(X)\n    if not result:\n        print(\"No solution\")\n    else:\n        for number in result:\n            print(number)",
        "result": "failed: testcase 0",
        "similarities": [
            0.996726393699646,
            0.9970155954360962,
            0.997165858745575,
            0.9951167106628418,
            0.9974677562713623,
            0.9972644448280334,
            0.9965474009513855,
            0.9969934225082397,
            0.9962507486343384,
            0.9958008527755737,
            0.9976485371589661,
            0.9967603087425232,
            0.9976983666419983,
            0.9957973957061768,
            0.9974942803382874,
            0.9936462044715881,
            0.9968472719192505,
            0.9956305623054504,
            0.9968801736831665,
            0.9972434043884277
        ]
    },
    "3126": {
        "similarity": 0.9968810081481934,
        "body": "    positions.sort()\n    n = len(positions)\n    total_jumps = 0\n\n    for i in range(n):\n        diff = abs(positions[i] - t)\n        if i % 2 == 0:\n            total_jumps += (i + 1) * diff\n        else:\n            total_jumps += (n - i) * diff\n\n    return total_jumps\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nt = int(data[1])\npositions = list(map(int, data[2:2+n]))\nC = int(data[2+n])\n\nresults = []\nfor i in range(2+n+C):\n    if i < 2 + n:\n        continue\n    command = data[2+n+i]\n    if command == 't':\n        t = int(data[3+n+i])\n    elif command.startswith('+'):\n        positions.append(int(command[1:]))\n        positions.sort()\n    elif command.startswith('-'):\n        positions.remove(int(command[1:]))\n\n    results.append(min_jumps(n, t, positions))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9945791363716125,
            0.9958612322807312,
            0.9964828491210938,
            0.9929309487342834,
            0.9932710528373718,
            0.9957031607627869,
            0.9961044192314148,
            0.9964433312416077,
            0.9965894818305969,
            0.996719241142273,
            0.9938207268714905,
            0.9962762594223022,
            0.9959790110588074,
            0.9963194131851196,
            0.9968795776367188,
            0.995408296585083,
            0.9965153932571411,
            0.9962561726570129,
            0.9963504672050476,
            0.9968810081481934
        ]
    },
    "3279": {
        "similarity": 0.9967082142829895,
        "body": "        bars = []\n        current_group_length = 0\n        for item in spec:\n            if item == 0:\n                if current_group_length > 0:\n                    bars.append((current_group_length, True))\n                    current_group_length = 0\n            else:\n                if current_group_length > 0:\n                    bars.append((current_group_length, False))\n                current_group_length = item\n        if current_group_length > 0:\n            bars.append((current_group_length, False))\n        return bars\n\n        vertical_grid = [[0] * (n + 1) for _ in range(n)]\n        for i in range(n):\n            vertical_bars = place_bars(vertical_spec[i], n)\n            pos = 0\n            for length, is_space in vertical_bars:\n                if not is_space:\n                    vertical_grid[i][pos + length] = 1\n                pos += length + (1 if is_space else 0)\n        return vertical_grid\n\n        horizontal_grid = [[0] * n for _ in range(n + 1)]\n        for j in range(n):\n            horizontal_bars = place_bars(horizontal_spec[j], n)\n            pos = 0\n            for length, is_space in horizontal_bars:\n                if not is_space:\n                    horizontal_grid[pos + length][j] = 1\n                pos += length + (1 if is_space else 0)\n        return horizontal_grid\n\n    vertical_grid = place_vertical_bars(n, vertical_spec)\n    horizontal_grid = place_horizontal_bars(n, horizontal_spec)\n\n    for i in range(n):\n        print(''.join(str(cell) for cell in vertical_grid[i]))\n    for j in range(n + 1):\n        print(''.join(str(cell) for cell in horizontal_grid[j]))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9961901307106018,
            0.9953601360321045,
            0.9951974749565125,
            0.9962461590766907,
            0.9958082437515259,
            0.9945704936981201,
            0.9952486753463745,
            0.9936094880104065,
            0.9965105652809143,
            0.9952763319015503,
            0.9931043386459351,
            0.9945662617683411,
            0.9957104921340942,
            0.9962401986122131,
            0.9967082142829895,
            0.9961608052253723,
            0.9956044554710388,
            0.9967067241668701,
            0.9961875081062317,
            0.9953880310058594
        ]
    },
    "3599": {
        "similarity": 0.9972416758537292,
        "body": "import sys\nfrom typing import List\n\n    result = []\n    current_time = 0\n    \n    for i in range(N):\n        break_duration = breaks[i]\n        if current_time + break_duration > T:\n            result.append(0)\n        else:\n            result.append(current_time)\n            current_time += break_duration - (current_time % (break_duration // 2))\n    \n    return result\n\n# Read input from stdin\nT, N = map(int, input().split())\nbreaks = list(map(int, input().split()))\n\n# Generate and print the output\noutput = schedule_breaks(T, N, breaks)\nprint(\" \".join(map(str, output)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968854188919067,
            0.9972416758537292,
            0.9959182739257812,
            0.9971891641616821,
            0.9961698651313782,
            0.9963072538375854,
            0.9953306913375854,
            0.9943483471870422,
            0.993902325630188,
            0.9954685568809509,
            0.9968252778053284,
            0.9949729442596436,
            0.9939173460006714,
            0.9966155886650085,
            0.9968613386154175,
            0.9962555766105652,
            0.9956494569778442,
            0.9952329397201538,
            0.9932742714881897,
            0.9962706565856934
        ]
    },
    "3687": {
        "similarity": 0.9975936412811279,
        "body": "    for _ in range(n):\n        d, *a = map(int, input().split())\n        data_to_transfer = [0] * (q + 1)\n        max_transfer = 0\n        \n        for i in range(s):\n            sensor_id = sensor_queues[i]\n            if a[i] > queue_sizes[sensor_id]:\n                return \"impossible\"\n            data_to_transfer[sensor_id] += a[i]\n        \n        for i in range(1, q + 1):\n            max_transfer += min(data_to_transfer[i], queue_sizes[i])\n        \n        if max_transfer < d:\n            return \"impossible\"\n    \n    return \"possible\"\n\n# Read input\nn, q, s = map(int, input().split())\nsensor_queues = list(map(int, input().split()))\nqueue_sizes = list(map(int, input().split()))\ndownlink_windows = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_transfer_data(n, q, s, sensor_queues, queue_sizes, downlink_windows))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966763854026794,
            0.9955556988716125,
            0.9972313642501831,
            0.9972532391548157,
            0.9974158406257629,
            0.9958296418190002,
            0.9958977103233337,
            0.9972572326660156,
            0.9939292073249817,
            0.9960652589797974,
            0.9965955018997192,
            0.9959176778793335,
            0.9957336783409119,
            0.9965838193893433,
            0.9968528747558594,
            0.9959584474563599,
            0.9971209168434143,
            0.9956390857696533,
            0.9961022138595581,
            0.9975936412811279
        ]
    },
    "3864": {
        "similarity": 0.9966797232627869,
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = ((i - 1) * dp[i - 1] + (i - 1)) % MOD\n    \n    total_boards = 2 ** n\n    result = sum(dp[i] * 2 for i in range(n + 1)) // total_boards\n    return result\n\nn = int(input())\nresults = [expected_black_stones(i) for i in range(1, n + 1)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958425760269165,
            0.9923437237739563,
            0.9958840608596802,
            0.9955748319625854,
            0.9888452291488647,
            0.9961387515068054,
            0.9963878989219666,
            0.988666832447052,
            0.9966797232627869,
            0.9932557344436646,
            0.9956895709037781,
            0.9963647723197937,
            0.9962652325630188,
            0.9965721964836121,
            0.9961311221122742,
            0.9963262677192688,
            0.994484543800354,
            0.9951501488685608,
            0.995493471622467,
            0.9946506023406982
        ]
    },
    "3504": {
        "similarity": 0.9974998831748962,
        "body": "    disintegration_y = [0] * len(droplets)\n    \n    for i, (x, y) in enumerate(droplets):\n        for sensor in sensors:\n            x1, x2, y_sensor = sensor\n            if x1 <= x <= x2 and y == y_sensor:\n                disintegration_y[i] = y_sensor\n                break\n    \n    return disintegration_y\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nD = int(data[0])\nS = int(data[1])\n\ndroplets = []\nindex = 2\nfor _ in range(D):\n    x = int(data[index])\n    y = int(data[index + 1])\n    droplets.append((x, y))\n    index += 2\n\nsensors = []\nfor _ in range(S):\n    x1 = int(data[index])\n    x2 = int(data[index + 1])\n    y_sensor = int(data[index + 2])\n    sensors.append((x1, x2, y_sensor))\n    index += 3\n\n# Find disintegration y-coordinates\nresult = find_disintegration_y(droplets, sensors)\n\n# Print results\nfor y in result:\n    print(y)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962617754936218,
            0.9974393248558044,
            0.9954940676689148,
            0.995841383934021,
            0.9970017671585083,
            0.9960445761680603,
            0.99628084897995,
            0.9961357116699219,
            0.9974998831748962,
            0.9967097043991089,
            0.9960964918136597,
            0.9920045137405396,
            0.997131884098053,
            0.9954866170883179,
            0.9958658814430237,
            0.9968163371086121,
            0.9959615468978882,
            0.9950900673866272,
            0.9953871369361877,
            0.9956232309341431
        ]
    },
    "3451": {
        "similarity": 0.9969592690467834,
        "body": "        stack = []\n        cost_used = 0\n        for i in range(n):\n            if sequence[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                elif cost_used + costs[i] <= max_cost:\n                    stack.append(-i)\n                    cost_used += costs[i]\n                else:\n                    return False\n        return len(stack) == 0\n\n    left, right = -1000 * n, 1000 * n\n    while left < right:\n        mid = (left + right) // 2\n        if can_balance(mid):\n            left = mid + 1\n        else:\n            right = mid\n    return '?' if right == 1000 * n else -right\n\n# Read input\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nk = int(data[1])\nsequence = data[2]\ncosts = [int(data[i]) for i in range(3, 3 + n)]\n\n# Output result\nresult = min_effort_to_impossible(n, k, sequence, costs)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9946492910385132,
            0.9964178204536438,
            0.993896484375,
            0.9959664940834045,
            0.996277391910553,
            0.9948939085006714,
            0.996672511100769,
            0.9966129660606384,
            0.9968946576118469,
            0.9969592690467834,
            0.9964109659194946,
            0.9962253570556641,
            0.9952210187911987,
            0.9962529540061951,
            0.9964542388916016,
            0.9962266683578491,
            0.9966793060302734,
            0.9929528832435608,
            0.9959616661071777,
            0.9962704181671143
        ]
    },
    "3156": {
        "similarity": 0.9978001117706299,
        "body": "from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    in_degree = [0] * N\n    \n    for i in range(K):\n        store, item = store_inventory[i]\n        graph[store].append(item)\n        in_degree[item] += 1\n    \n    queue = deque()\n    for item in set(purchased_items):\n        if in_degree[item] == 0:\n            queue.append((item, 0))\n    \n    path_count = 0\n    while queue:\n        current_item, store_index = queue.popleft()\n        if store_index >= N:\n            path_count += 1\n            continue\n        next_store = store_index + 1\n        if current_item in graph[next_store]:\n            for item in graph[next_store]:\n                if item == current_item:\n                    in_degree[item] -= 1\n                    queue.append((item, next_store))\n    \n    if path_count > 1:\n        return \"ambiguous\"\n    elif path_count == 1:\n        return \"unique\"\n    else:\n        return \"impossible\"\n\n# Read input from stdin\nN = int(input())\nK = int(input())\nstore_inventory = [tuple(map(str, input().split())) for _ in range(K)]\nM = int(input())\npurchased_items = [input() for _ in range(M)]\n\nresult = find_shopping_path(N, K, store_inventory, M, purchased_items)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974511861801147,
            0.9964174032211304,
            0.9972265958786011,
            0.9975220561027527,
            0.9967584013938904,
            0.9971883893013,
            0.9971857666969299,
            0.9972472190856934,
            0.9972472786903381,
            0.997242271900177,
            0.9970527291297913,
            0.9971088767051697,
            0.9970606565475464,
            0.9958506226539612,
            0.9974914193153381,
            0.996764063835144,
            0.9970927834510803,
            0.9978001117706299,
            0.9977290630340576,
            0.9956349730491638
        ]
    },
    "3697": {
        "similarity": 0.9974663257598877,
        "body": "import sys\n\n    votes = [0] * (n + 1)\n    last_votes = [-1] * (n + 1)\n    \n    for j in range(a):\n        candidate = int(input())\n        votes[candidate] += 1\n        if last_votes[candidate] == -1 or j > last_votes[candidate]:\n            last_votes[candidate] = j\n    \n    sorted_candidates = sorted(range(1, n + 1), key=lambda x: (-votes[x], -last_votes[x]))\n    \n    outcomes = [0] * (n + 1)\n    for i in range(n):\n        if i < k:\n            outcomes[sorted_candidates[i]] = 1\n        elif votes[sorted_candidates[i]] >= k - i:\n            outcomes[sorted_candidates[i]] = 2\n    \n    return outcomes\n\nif __name__ == \"__main__\":\n    n, k, m, a = map(int, input().split())\n    results = determine_outcomes(n, k, m, a)\n    for result in results[1:]:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965365529060364,
            0.9972180724143982,
            0.9966424703598022,
            0.9967749714851379,
            0.9964887499809265,
            0.9972047209739685,
            0.992257297039032,
            0.9957818388938904,
            0.9970842003822327,
            0.9960991740226746,
            0.9958744049072266,
            0.9964758157730103,
            0.9962126016616821,
            0.996848464012146,
            0.9974663257598877,
            0.9969626069068909,
            0.9974610209465027,
            0.9968827962875366,
            0.9963865876197815,
            0.9973992705345154
        ]
    },
    "3647": {
        "similarity": 0.9987819194793701,
        "body": "import sys\nfrom collections import deque\n\n    R, C = len(maze), len(maze[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < R and 0 <= y < C and maze[x][y] != '#'\n    \n    queue = deque()\n    distances = [[-1 for _ in range(C)] for _ in range(R)]\n    \n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'M':\n                queue.append((i, j))\n                distances[i][j] = 0\n    \n    while queue:\n        x, y = queue.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                new_dist = distances[x][y]\n                while is_valid(nx + dx, ny + dy) and maze[nx + dx][ny + dy] == '_':\n                    nx += dx\n                    ny += dy\n                    new_dist += 1\n                if distances[nx][ny] == -1 or distances[nx][ny] > new_dist:\n                    distances[nx][ny] = new_dist\n                    queue.append((nx, ny))\n    \n    return distances\n\ninput = sys.stdin.read\ndata = input().split()\nR, C = int(data[0]), int(data[1])\nmaze = [list(data[i + 2]) for i in range(R)]\n\nresult = shortest_path_to_goal(maze, 'M')\nfor row in result:\n    print(' '.join(map(str, row)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983896017074585,
            0.9971039295196533,
            0.9973663687705994,
            0.9987659454345703,
            0.9984117150306702,
            0.9985058307647705,
            0.9987819194793701,
            0.9985942840576172,
            0.9986043572425842,
            0.9982723593711853,
            0.9983816742897034,
            0.9987192749977112,
            0.9980414509773254,
            0.9978813529014587,
            0.9984064698219299,
            0.9986823201179504,
            0.9984455108642578,
            0.9986484050750732,
            0.9983159303665161,
            0.9986559152603149
        ]
    },
    "3699": {
        "similarity": 0.9971401691436768,
        "body": "import sys\nfrom typing import List, Tuple\nfrom math import sqrt\n\n    n = len(bottles)\n    \n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    \n        if index == n:\n            return 0\n        \n        adil_to_bottle = distance((ax, ay), bottles[index])\n        bera_to_bottle = distance((bx, by), bottles[index])\n        \n        adil_pick_and_go = adil_to_bottle + min_distance_recursive(index + 1)\n        bera_pick_and_go = bera_to_bottle + min_distance_recursive(index + 1)\n        \n        if adil_to_bottle < bera_to_bottle:\n            ax, ay = bottles[index]\n        else:\n            bx, by = bottles[index]\n        \n        return min(adil_pick_and_go, bera_pick_and_go)\n    \n    return min_distance_recursive(0)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    ax, ay = int(data[0]), int(data[1])\n    bx, by = int(data[2]), int(data[3])\n    tx, ty = int(data[4]), int(data[5])\n    \n    n = int(data[6])\n    bottles = [(int(data[7 + 2 * i]), int(data[8 + 2 * i])) for i in range(n)]\n    \n    result = min_distance_to_recycling_bin(ax, ay, bx, by, tx, ty, bottles)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953845143318176,
            0.9954556226730347,
            0.9951452016830444,
            0.9964973330497742,
            0.9953749775886536,
            0.9955376982688904,
            0.9968717694282532,
            0.9961556196212769,
            0.9964452385902405,
            0.9941511750221252,
            0.9964796304702759,
            0.9969395995140076,
            0.9971401691436768,
            0.995602548122406,
            0.9965552091598511,
            0.9944844841957092,
            0.9966754913330078,
            0.9939969778060913,
            0.9967061877250671,
            0.9959076642990112
        ]
    },
    "3145": {
        "similarity": 0.9978739023208618,
        "body": "    count = 0\n    for num in range(A, B + 1):\n        if num % X == 0:\n            if all(digit in allowed_digits for digit in str(num)):\n                count += 1\n    return count\n\n# Read input from stdin\nX, A, B = map(int, input().split())\nallowed_digits = set(input().strip())\n\n# Calculate and print the result\nresult = count_multiples(X, A, B, allowed_digits)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975875020027161,
            0.9978739023208618,
            0.9969878196716309,
            0.9952452778816223,
            0.9977865815162659,
            0.9969590902328491,
            0.9968076944351196,
            0.9967184662818909,
            0.997017502784729,
            0.9975035786628723,
            0.9967630505561829,
            0.9968711733818054,
            0.9945417642593384,
            0.9968553185462952,
            0.9975993633270264,
            0.9961146116256714,
            0.9966930747032166,
            0.9937607645988464,
            0.9966360330581665,
            0.9971060752868652
        ]
    },
    "3795": {
        "similarity": 0.9972062706947327,
        "body": "    # Calculate the number of euros Andrew can buy with his rubles\n    euros = n // e\n    remaining_rubles = n % e\n    \n    # Try to minimize the remaining rubles by buying dollar bills\n    for i in range(0, remaining_rubles + 1, d):\n        if (remaining_rubles - i) % e == 0:\n            dollars = (remaining_rubles - i) // e\n            total_bills = euros + dollars\n            return n - total_bills * min(d, e)\n    \n    # If no combination is found, return the initial amount of rubles\n    return n\n\n# Read input from stdin\nn = int(input())\nd = int(input())\ne = int(input())\n\n# Print the result\nprint(min_rubles(n, d, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964388012886047,
            0.9958248138427734,
            0.9952167868614197,
            0.9951287508010864,
            0.9964048266410828,
            0.996860921382904,
            0.9957168102264404,
            0.9956371784210205,
            0.9963555932044983,
            0.9939450025558472,
            0.9940725564956665,
            0.9964169859886169,
            0.9956576824188232,
            0.9968072175979614,
            0.9960246682167053,
            0.9968661069869995,
            0.9936010241508484,
            0.9966364502906799,
            0.996616542339325,
            0.9972062706947327
        ]
    },
    "3353": {
        "similarity": 0.9985474348068237,
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    graph = defaultdict(list)\n    for e1, e2 in logs:\n        graph[e1].append(e2)\n        graph[e2].append(e1)\n    \n        queue = deque([(start, 0)])\n        visited = set()\n        while queue:\n            current, time = queue.popleft()\n            if current == end:\n                return time\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, time + 1))\n        return float('inf')\n    \n    left_bank_to_boulder = bfs(-2, -1)\n    boulder_to_right_bank = [bfs(boulder, -1) for boulder in range(R)]\n    \n    if left_bank_to_boulder == float('inf'):\n        return P\n    \n    min_time = float('inf')\n    for i in range(P):\n        time = 0\n        for j in range(i + 1, P):\n            boulder = max(boulder_to_right_bank[b] for b in range(R) if (b - i + j) % 2 == 0)\n            time += min(left_bank_to_boulder, boulder)\n        min_time = min(min_time, time)\n    \n    return min_time\n\ninput = sys.stdin.read\ndata = input().split()\nP = int(data[0])\nR = int(data[1])\nL = int(data[2])\nlogs = [(int(data[3 + 2 * i]), int(data[4 + 2 * i])) for i in range(L)]\n\nresult = min_time_to_cross(P, R, L, logs)\nif result == float('inf'):\n    print(P - sum(1 for time in boulder_to_right_bank if time != float('inf')))\nelse:\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978421926498413,
            0.9980970621109009,
            0.9977673888206482,
            0.9974507689476013,
            0.9975670576095581,
            0.9977798461914062,
            0.9976778626441956,
            0.9984400868415833,
            0.9984948039054871,
            0.9976174235343933,
            0.9974655508995056,
            0.9973959922790527,
            0.9979271292686462,
            0.9978722333908081,
            0.9985474348068237,
            0.9981377124786377,
            0.9978260397911072,
            0.9977832436561584,
            0.9981281757354736,
            0.9975138306617737
        ]
    },
    "3065": {
        "similarity": 0.9976658225059509,
        "body": "from sys import stdin, stdout\nfrom fractions import Fraction\n\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        node, steps = queue.pop(0)\n        if node == target:\n            return True\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                queue.append((neighbor, steps + 1))\n    return False\n\n    N = int(input())\n    L = int(input())\n    walk = list(map(int, input().split()))\n    \n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        n = int(input())\n        neighbors = list(map(int, input().split()))\n        graph[i] = neighbors\n    \n    start = walk[0]\n    end = walk[-1]\n    \n    if not bfs(start, end, graph):\n        stdout.write(\"0.0\\n\")\n        return\n    \n    total_paths = 0\n    successful_paths = 0\n    \n    for i in range(1, L-1):\n        current_room = walk[i]\n        neighbors = graph[current_room]\n        neighbor_probs = [Fraction(1, len(neighbors)) for _ in neighbors]\n        \n        for next_room in neighbors:\n            if bfs(next_room, end, graph):\n                successful_paths += 1\n        \n        total_paths += len(neighbors)\n    \n    success_rate = Fraction(successful_paths, total_paths)\n    stdout.write(f\"{success_rate:.6f}\\n\")\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997263491153717,
            0.997031569480896,
            0.9966938495635986,
            0.9962579607963562,
            0.9971303343772888,
            0.9976658225059509,
            0.9970730543136597,
            0.9976388216018677,
            0.9969030022621155,
            0.9963647723197937,
            0.9968898296356201,
            0.9954986572265625,
            0.9973576068878174,
            0.993479311466217,
            0.9963716268539429,
            0.9973897337913513,
            0.9967271685600281,
            0.9968103170394897,
            0.9975296854972839,
            0.9967786073684692
        ]
    },
    "3250": {
        "similarity": 0.9956548810005188,
        "body": "    if b == d:\n        return \"no\"\n    m = 1\n    while True:\n        f_b_m_n = 0\n        negative = False\n        for i in range(m - 1, -1, -m):\n            term = sum(int(digit) * (b ** j) for j, digit in enumerate(reversed(str(n)[:i + 1])))\n            if negative:\n                f_b_m_n -= term\n            else:\n                f_b_m_n += term\n            negative = not negative\n        if f_b_m_n % d == 0:\n            return \"yes\"\n        m += 1\n\n# Read input from stdin\nb, d = map(int, input().split())\n\n# Print the result\nprint(is_valid_divisibility_hack(b, d))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9941574931144714,
            0.9909060597419739,
            0.9933274984359741,
            0.994798481464386,
            0.9942811727523804,
            0.9954115152359009,
            0.9944359660148621,
            0.9950025677680969,
            0.9921796917915344,
            0.9946475625038147,
            0.9933672547340393,
            0.9956548810005188,
            0.9953761696815491,
            0.9950599670410156,
            0.9823090434074402,
            0.9948756694793701,
            0.9941865801811218,
            0.9951090812683105,
            0.9940427541732788,
            0.9890761971473694
        ]
    },
    "3306": {
        "similarity": 0.9975335001945496,
        "body": "    calls = [0] * (M + 1)\n    for P, C in detectors:\n        calls[P] += C\n        calls[P + 1] -= C\n    total_calls = prev = 0\n    for i in range(1, M + 1):\n        if calls[i] != prev:\n            total_calls += max(calls[i], prev)\n        prev = max(calls[i], prev)\n    return total_calls\n\n# Read input from stdin\nN, M = map(int, input().split())\ndetectors = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Output the result\nprint(min_phone_calls(N, M, detectors))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9972752928733826,
            0.9968498945236206,
            0.9969522356987,
            0.9943633079528809,
            0.9957079887390137,
            0.9962965250015259,
            0.9966567158699036,
            0.9972060322761536,
            0.9975335001945496,
            0.9951199889183044,
            0.9967913627624512,
            0.9968879222869873,
            0.9941051006317139,
            0.9969554543495178,
            0.9973524212837219,
            0.9948049783706665,
            0.9973737001419067,
            0.9953761696815491,
            0.995896577835083,
            0.9954908490180969
        ]
    },
    "3970": {
        "similarity": 0.9983738660812378,
        "body": "    a.sort()\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0 and a[i] // a[j] == k:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(largest_k_multiple_free_subset(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9983354210853577,
            0.9951355457305908,
            0.9982848167419434,
            0.9972053170204163,
            0.9981975555419922,
            0.9983532428741455,
            0.9978589415550232,
            0.9969265460968018,
            0.9981507062911987,
            0.9980791807174683,
            0.9980792999267578,
            0.9978432059288025,
            0.9935952425003052,
            0.9973416924476624,
            0.9975829720497131,
            0.9974403381347656,
            0.9981338381767273,
            0.9983738660812378,
            0.9983738660812378,
            0.9976029992103577
        ]
    },
    "3655": {
        "similarity": 0.9981808066368103,
        "body": "import sys\n\n    robot_w, robot_h = len(robot_img[0]), len(robot_img)\n    floor_w, floor_h = len(floor_img[0]), len(floor_img)\n    max_matches = 0\n    candidates = []\n\n    for y in range(floor_h - robot_h + 1):\n        for x in range(floor_w - robot_w + 1):\n            matches = 0\n            for i in range(robot_h):\n                for j in range(robot_w):\n                    if robot_img[i][j] == floor_img[y+i][x+j]:\n                        matches += 1\n            if matches > max_matches:\n                max_matches = matches\n                candidates = [(x, y)]\n            elif matches == max_matches:\n                candidates.append((x, y))\n    \n    # Sort by x-coordinate, then by y-coordinate\n    candidates.sort(key=lambda p: (p[0], p[1]))\n    return candidates\n\n    # Read input\n    robot_w, robot_h = map(int, input().split())\n    robot_img = [list(map(int, input().split())) for _ in range(robot_h)]\n    floor_w, floor_h = map(int, input().split())\n    floor_img = [list(map(int, input().split())) for _ in range(floor_h)]\n\n    # Find candidates\n    candidates = find_candidates(robot_img, floor_img)\n\n    # Print results\n    for x, y in candidates:\n        print(x, y)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981109499931335,
            0.9979758858680725,
            0.9980754852294922,
            0.9972478151321411,
            0.9981327056884766,
            0.9976063966751099,
            0.9972224831581116,
            0.9976803660392761,
            0.9973028302192688,
            0.9981808066368103,
            0.9975535869598389,
            0.99798983335495,
            0.9978870749473572,
            0.9979197978973389,
            0.9977110624313354,
            0.9972943663597107,
            0.9966899752616882,
            0.997279703617096,
            0.997633695602417,
            0.9975544810295105
        ]
    },
    "3589": {
        "similarity": 0.9981802105903625,
        "body": "        while n >= 10:\n            product = 1\n            for digit in str(n):\n                if digit != '0':\n                    product *= int(digit)\n            n = product\n        return n\n\n    count = [0] * 9\n    for x in range(L, R + 1):\n        count[reduce_to_single_digit(x) - 1] += 1\n    return count\n\n# Read input\nL, R = map(int, input().split())\n\n# Calculate and print result\nresult = count_check_digits(L, R)\nprint(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981774687767029,
            0.9974039793014526,
            0.9976341724395752,
            0.9961256980895996,
            0.9960103631019592,
            0.9974256753921509,
            0.997370183467865,
            0.9980880618095398,
            0.9977403283119202,
            0.9974856376647949,
            0.9976130127906799,
            0.9963549375534058,
            0.9978878498077393,
            0.9981802105903625,
            0.9978313446044922,
            0.9974429607391357,
            0.9960684776306152,
            0.9976664185523987,
            0.9975220561027527,
            0.9981599450111389
        ]
    },
    "3257": {
        "similarity": 0.9968528747558594,
        "body": "import sys\nimport math\n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area\n\nif __name__ == \"__main__\":\n    line = input().strip()\n    a, b, c = map(float, line.split())\n    result = area_of_carpet(a, b, c)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9948135018348694,
            0.9952766299247742,
            0.9965014457702637,
            0.994681715965271,
            0.9962676167488098,
            0.9947339296340942,
            0.9968528747558594,
            0.9963662028312683,
            0.9961674213409424,
            0.9966217875480652,
            0.9929071068763733,
            0.9944390058517456,
            0.994806706905365,
            0.9953300356864929,
            0.9943804740905762,
            0.9959694743156433,
            0.9947353005409241,
            0.9959308505058289,
            0.9953765869140625,
            0.9965754151344299
        ]
    },
    "3927": {
        "similarity": 0.9974125623703003,
        "body": "from collections import Counter\n\n    count = Counter(weights)\n    total_masses = set(sum(pair) for pair in combinations(count.keys(), 2))\n    \n    max_revealed = 0\n    for mass in total_masses:\n        if mass * 2 <= sum(weights):\n            remaining_weight = sum(weights) - mass\n            if remaining_weight > 0 and remaining_weight in count:\n                max_revealed = max(max_revealed, 2)\n    \n    return max_revealed\n\n# Read input from stdin\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(max_weights_revealed(n, weights))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969935417175293,
            0.9968323111534119,
            0.9957460165023804,
            0.9966890215873718,
            0.9962182641029358,
            0.9974125623703003,
            0.996182918548584,
            0.996634840965271,
            0.996708333492279,
            0.9962446093559265,
            0.9962754845619202,
            0.993800938129425,
            0.9967241883277893,
            0.9965509176254272,
            0.9956267476081848,
            0.9961736798286438,
            0.9963990449905396,
            0.9965637922286987,
            0.9918389916419983,
            0.9968532919883728
        ]
    },
    "3319": {
        "similarity": 0.995816171169281,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nx, ny, nz = map(int, data[1:4])\n    \n    planetoids = []\n    index = 4\n    for i in range(n):\n        m = int(data[index])\n        x, y, z = map(int, data[index+1:index+4])\n        vx, vy, vz = map(int, data[index+4:index+7])\n        planetoids.append((m, (x, y, z), (vx, vy, vz)))\n        index += 7\n    \n    while True:\n        collisions = {}\n        for i in range(n):\n            for j in range(i + 1, n):\n                (mi, pos_i, vel_i) = planetoids[i]\n                (mj, pos_j, vel_j) = planetoids[j]\n                \n                dx = (pos_j[0] - pos_i[0] + nx) % nx\n                dy = (pos_j[1] - pos_i[1] + ny) % ny\n                dz = (pos_j[2] - pos_i[2] + nz) % nz\n                \n                dvx = abs(vel_i[0] - vel_j[0])\n                dvy = abs(vel_i[1] - vel_j[1])\n                dvz = abs(vel_i[2] - vel_j[2])\n                \n                if max(dx, dy, dz, dvx, dvy, dvz) == 1:\n                    coll_idx = (min(i, j), max(i, j))\n                    if coll_idx not in collisions:\n                        collisions[coll_idx] = []\n                    collisions[coll_idx].append((mi + mj, \n                                                  ((pos_i[0] + pos_j[0]) // 2) % nx, \n                                                  ((pos_i[1] + pos_j[1]) // 2) % ny, \n                                                  ((pos_i[2] + pos_j[2]) // 2) % nz,\n                                                  (vel_i[0] + vel_j[0]) // 2, \n                                                  (vel_i[1] + vel_j[1]) // 2, \n                                                  (vel_i[2] + vel_j[2]) // 2))\n        \n        if not collisions:\n            break\n        \n        new_planetoids = []\n        for i in range(n):\n            add = True\n            for coll in collisions.values():\n                if any(i == idx for idx, _ in coll):\n                    add = False\n                    break\n            if add:\n                new_planetoids.append(planetoids[i])\n        \n        for _, pos, vel in collisions.values():\n            new_planetoids.append((pos[2], pos, vel))\n        \n        planetoids = new_planetoids\n    \n    planetoids.sort(key=lambda x: (-x[0], x[1]))\n    \n    print(len(planetoids))\n    for i, (m, pos, vel) in enumerate(planetoids):\n        print(f\"P{i}: {m} {pos[0]} {pos[1]} {pos[2]} {vel[0]} {vel[1]} {vel[2]}\")\n\nsimulate_planet_collision()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9957934021949768,
            0.995816171169281,
            0.9945048093795776,
            0.9945760369300842,
            0.9940761923789978,
            0.9947142601013184,
            0.9954187273979187,
            0.9954572916030884,
            0.9938712120056152,
            0.9911278486251831,
            0.9914301633834839,
            0.995389461517334,
            0.9953835010528564,
            0.9939596056938171,
            0.9940137267112732,
            0.9934589862823486,
            0.9945995211601257,
            0.9930199384689331,
            0.9945895671844482,
            0.995192289352417
        ]
    },
    "3009": {
        "similarity": 0.9961652159690857,
        "body": "import sys\nfrom scipy.spatial import distance, ConvexHull\nfrom itertools import combinations\n\n    x = [l[0] for l in lamps]\n    y = [l[1] for l in lamps]\n    e = [l[2] for l in lamps]\n\n    hull = ConvexHull(list(zip(x, y)))\n    hull_points = list(zip(x, y))[hull.vertices]\n\n        inside_sum = 0\n        outside_sum = 0\n        for i in range(n):\n            dist_to_line = abs((line[1][1] - line[0][1]) * x[i] - (line[1][0] - line[0][0]) * y[i] + line[1][0] * line[0][1] - line[1][1] * line[0][0])\n            if dist_to_line < 2:\n                inside_sum += e[i]\n            else:\n                outside_sum += e[i]\n        return abs(inside_sum - outside_sum)\n\n    min_energy = float('inf')\n    for i, j in combinations(hull_points, 2):\n        line = (i, j)\n        energy = line_energy(line)\n        if energy == 0:\n            return distance.euclidean(i, j)\n        if energy < min_energy:\n            min_energy = energy\n\n    if min_energy == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    n = int(input())\n    lamps = [tuple(map(int, input().split())) for _ in range(n)]\n    result = shortest_dividing_line(n, lamps)\n    if result is not None:\n        print(\"{:.6f}\".format(result))\n    else:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954308271408081,
            0.9956977367401123,
            0.9950236082077026,
            0.9929618835449219,
            0.9946963787078857,
            0.9951428174972534,
            0.9943016767501831,
            0.9937475323677063,
            0.9901520609855652,
            0.9956079125404358,
            0.9944419860839844,
            0.9950077533721924,
            0.9959250092506409,
            0.9961652159690857,
            0.9919955730438232,
            0.99577796459198,
            0.9948834180831909,
            0.9949252605438232,
            0.9938112497329712,
            0.9956864714622498
        ]
    },
    "3896": {
        "similarity": 0.9979093670845032,
        "body": "    n = len(x)\n    count_ones = x.count('1')\n    count_zeros = n - count_ones\n    complexity = (count_ones * count_zeros) % 1000000007\n    return complexity\n\n# Read input from stdin\nx = input().strip()\n# Calculate and print the result\nprint(calculate_complexity(x))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969697594642639,
            0.9968850016593933,
            0.9979093670845032,
            0.9969528913497925,
            0.9977117776870728,
            0.9964721202850342,
            0.9970076680183411,
            0.9970076680183411,
            0.9972516894340515,
            0.9961122274398804,
            0.9957327842712402,
            0.9972293376922607,
            0.9941026568412781,
            0.9977547526359558,
            0.9975467324256897,
            0.9970825910568237,
            0.9976475238800049,
            0.9965109825134277,
            0.997676432132721,
            0.9975501894950867
        ]
    },
    "3509": {
        "similarity": 0.9986767172813416,
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            if distance < dist[v]:\n                dist[v] = distance\n                heappush(pq, (distance, v))\n    \n    return dist\n\n    graph = [[] for _ in range(n)]\n    for u, v, t in roads:\n        graph[u-1].append((v-1, t))\n    \n    dist_to_janet = dijkstra(graph, n-1)\n    min_wait = float('inf')\n    \n    for i in range(a, b + 1):\n        max_wait = float('-inf')\n        for j in range(n):\n            if dist_to_janet[j] <= i:\n                max_wait = max(max_wait, dist_to_janet[j])\n        min_wait = min(min_wait, max_wait)\n    \n    return min_wait\n\nif __name__ == \"__main__\":\n    a, b = map(int, input().split())\n    n, m = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    result = min_worst_case_wait(a, b, n, m, roads)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975286722183228,
            0.9981772899627686,
            0.9986767172813416,
            0.9983164072036743,
            0.9982559084892273,
            0.9981169700622559,
            0.9979850649833679,
            0.9981101155281067,
            0.9984472990036011,
            0.9986202120780945,
            0.9981011152267456,
            0.9983358979225159,
            0.9976229667663574,
            0.9984074831008911,
            0.9981006979942322,
            0.9983627796173096,
            0.9983335733413696,
            0.9977592825889587,
            0.99526447057724,
            0.9979239106178284
        ]
    },
    "3547": {
        "similarity": 0.9964240193367004,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    plots = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, data[4*i+1:4*i+5])\n        plots.append((x1, y1, x2, y2))\n    \n        from shapely.geometry import Polygon\n        total_area = 0.0\n        polygons = [Polygon([(x1, y1), (x2, y1), (x2, y2), (x1, y2)]) for x1, y1, x2, y2 in plots]\n        union = polygons[0]\n        for polygon in polygons[1:]:\n            union = union.union(polygon)\n        total_area = round(union.area, 2)\n        return total_area\n    \n    area = find_overlaps(plots)\n    print(f\"{area:.2f}\")\n\ncalculate_actual_area()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9925039410591125,
            0.9921914339065552,
            0.9910125732421875,
            0.9959070086479187,
            0.9953017234802246,
            0.9941121935844421,
            0.9952846169471741,
            0.9920439720153809,
            0.9944475293159485,
            0.9956241250038147,
            0.9927180409431458,
            0.9947351217269897,
            0.9938585162162781,
            0.9934515953063965,
            0.9964240193367004,
            0.9960167407989502,
            0.995560884475708,
            0.9954066872596741,
            0.9956984519958496,
            0.995530903339386
        ]
    },
    "3017": {
        "similarity": 0.9973962903022766,
        "body": "    power_of_two = 2 ** e\n    str_power_of_two = str(power_of_two)\n    count = 0\n\n    for i in range(n + 1):\n        if str_power_of_two in str(i):\n            count += 1\n\n    return count\n\n# Read input from stdin\nn, e = map(int, input().split())\n\n# Print the result\nprint(count_numbers_with_power_of_two(n, e))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964863657951355,
            0.9964788556098938,
            0.9962058067321777,
            0.9965456128120422,
            0.9960333108901978,
            0.9965106844902039,
            0.9969523549079895,
            0.9961694478988647,
            0.9863420128822327,
            0.9961473345756531,
            0.9965757131576538,
            0.9973962903022766,
            0.9973822236061096,
            0.9962003827095032,
            0.9959867596626282,
            0.9972273111343384,
            0.9966181516647339,
            0.9970796704292297,
            0.9970227479934692,
            0.9970227479934692
        ]
    },
    "3076": {
        "similarity": 0.9979555010795593,
        "body": "    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        size, value = jewels[i - 1]\n        for s in range(1, k + 1):\n            if size <= s:\n                dp[i][s] = max(dp[i - 1][s], dp[i - 1][s - size] + value)\n            else:\n                dp[i][s] = dp[i - 1][s]\n    \n    result = [0]\n    for s in range(1, k + 1):\n        result.append(max(dp[n][s], result[-1]))\n    \n    return result[1:]\n\n# Read input\nn, k = map(int, input().split())\njewels = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = max_jewel_value(n, k, jewels)\n\n# Print the result\nprint(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9978513121604919,
            0.9977769255638123,
            0.9959717988967896,
            0.9971711039543152,
            0.9948247671127319,
            0.9978824257850647,
            0.9955840110778809,
            0.9977609515190125,
            0.9946272969245911,
            0.9979114532470703,
            0.9973481893539429,
            0.9979555010795593,
            0.9978179931640625,
            0.99504554271698,
            0.9975826144218445,
            0.9972164630889893,
            0.9950734376907349,
            0.9974331259727478,
            0.9968988299369812,
            0.9970911145210266
        ]
    },
    "3923": {
        "similarity": 0.9979425072669983,
        "body": "    if N == 1:\n        return [1] if A == 1 else -1\n    \n    if A < B:\n        return [-1]\n    \n    permutation = []\n    remaining_numbers = list(range(1, N + 1))\n    \n    for i in range(1, N + 1):\n        if i <= A:\n            permutation.append(i)\n            remaining_numbers.remove(i)\n        else:\n            permutation.insert(0, remaining_numbers.pop())\n    \n    return permutation\n\n# Read input\nN, A, B = map(int, input().split())\n\n# Find and print the permutation\nresult = find_permutation(N, A, B)\nif result == -1:\n    print(-1)\nelse:\n    print(' '.join(map(str, result)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.997131884098053,
            0.9972835183143616,
            0.9976857900619507,
            0.9972354769706726,
            0.9955673217773438,
            0.9954652190208435,
            0.9973760843276978,
            0.9972644448280334,
            0.9979425072669983,
            0.9966328144073486,
            0.997532308101654,
            0.9975355267524719,
            0.9975937604904175,
            0.9974477887153625,
            0.9977286458015442,
            0.9962236285209656,
            0.9953488111495972,
            0.9952970743179321,
            0.9971098899841309,
            0.9971003532409668
        ]
    },
    "3332": {
        "similarity": 0.9978511333465576,
        "body": "import sys\nfrom collections import deque\n\n    n = int(input())\n    streams = []\n    \n    for _ in range(n):\n        s, d, p = map(int, input().split())\n        streams.append((s, s + d, p))\n    \n    streams.sort(key=lambda x: (x[0], -x[2]))\n    \n    processors = deque(range(1, n + 1))\n    max_priority = 0\n    current_time = 0\n    \n    for start, end, priority in streams:\n        while processors and processors[0] < current_time:\n            processors.popleft()\n        \n        if processors:\n            processors.append(start)\n            current_time = end\n            max_priority += priority\n    \n    print(max_priority)\n\nif __name__ == \"__main__\":\n    max_priority_subset()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9962986707687378,
            0.996964693069458,
            0.9973527789115906,
            0.9969552755355835,
            0.9972167015075684,
            0.9973668456077576,
            0.9961851239204407,
            0.9977738261222839,
            0.9978511333465576,
            0.9968743920326233,
            0.9972661733627319,
            0.9957650899887085,
            0.9967780113220215,
            0.9974658489227295,
            0.9971793293952942,
            0.9960387349128723,
            0.9974134564399719,
            0.9967453479766846,
            0.997543454170227,
            0.9965848326683044
        ]
    },
    "3240": {
        "similarity": 0.997342586517334,
        "body": "import sys\n\n    k, v = map(int, input().split())\n    p_b = [tuple(map(float, input().split())) for _ in range(v - 1)]\n    \n        total_prob = 0\n        for i in range(2 ** (v - 1)):\n            binary = bin(i)[2:].zfill(v - 1)\n            yraglac_wins = sum((p_b[j][0] if binary[j] == '1' else 1 - p_b[j][0]) * (p_b[j][1] if binary[j] == '1' else 1 - p_b[j][1]) for j in range(v - 1)) if b > 0 else 0\n            total_prob += yraglac_wins\n        return total_prob / 2 ** (v - 1)\n    \n    max_yraglac_wins = 0\n    optimal_b = 0\n    for b in range(2 ** k):\n        yraglac_wins = expected_yraglac_wins(b)\n        if yraglac_wins > max_yraglac_wins:\n            max_yraglac_wins = yraglac_wins\n            optimal_b = b\n    \n    print(optimal_b)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967105388641357,
            0.9969049096107483,
            0.997264564037323,
            0.9965322613716125,
            0.9963183403015137,
            0.995360255241394,
            0.9961503744125366,
            0.9965696930885315,
            0.997342586517334,
            0.9963876605033875,
            0.9968518614768982,
            0.9944089651107788,
            0.9968405365943909,
            0.9947050213813782,
            0.9971684813499451,
            0.9928971529006958,
            0.9963244199752808,
            0.9958374500274658,
            0.9961884021759033,
            0.9926049113273621
        ]
    },
    "3368": {
        "similarity": 0.9951266050338745,
        "body": "import sys\nfrom collections import defaultdict\n\n    target_enclosures = defaultdict(list)\n    current_enclosures = [set(enc) for enc in enclosures]\n    \n    # Create target enclosures based on animal types\n    for i in range(n):\n        animal_type, count, *animals = enclosures[i].split()\n        target_enclosures[animal_type] += animals\n    \n    # Check if we can move animals to their target enclosures\n    for current_animals in current_enclosures:\n        possible = False\n        for animal_type, target_animals in target_enclosures.items():\n            if all(animal in current_animals for animal in target_animals):\n                possible = True\n                break\n        if not possible:\n            return \"IMPOSSIBLE\"\n    \n    # Check if all animals are already in their proper enclosures\n    if all(len(enc) == 0 for enc in current_enclosures):\n        return \"FALSE ALARM\"\n    \n    return \"POSSIBLE\"\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\nenclosures = data[2:]\n\n# Get result and print it\nresult = can_relocate_animals(n, m, enclosures)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944767355918884,
            0.9931267499923706,
            0.9934781789779663,
            0.9935259819030762,
            0.9931148886680603,
            0.9923726916313171,
            0.9916585683822632,
            0.9941624999046326,
            0.9941006898880005,
            0.9949431419372559,
            0.9930630922317505,
            0.9903652667999268,
            0.9941185712814331,
            0.9942390322685242,
            0.9926782250404358,
            0.994421124458313,
            0.9951266050338745,
            0.9912030100822449,
            0.9946039319038391,
            0.9940625429153442
        ]
    },
    "3538": {
        "similarity": 0.9974068999290466,
        "body": "    # Sort frogs by their height in descending order\n    frogs.sort(key=lambda x: -x[2])\n    \n    total_weight = 0\n    escaped = 0\n    \n    for frog in frogs:\n        l, w, h = frog\n        if h + total_weight <= d:\n            total_weight += w\n            escaped += 1\n            while len(frogs) > 1 and frogs[1][2] + total_weight <= d:\n                next_frog = frogs.pop(1)\n                total_weight += next_frog[1]\n                escaped += 1\n    \n    return escaped\n\n# Read input\nn, d = map(int, input().split())\nfrogs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_frogs_to_escape(n, d, frogs))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968101382255554,
            0.9969499707221985,
            0.9954996705055237,
            0.9964086413383484,
            0.9957417249679565,
            0.9954215884208679,
            0.9953394532203674,
            0.9940055012702942,
            0.9971739053726196,
            0.9967607259750366,
            0.9969725608825684,
            0.9959210753440857,
            0.9961720705032349,
            0.9973096251487732,
            0.9968352317810059,
            0.9951698184013367,
            0.9965591430664062,
            0.9974068999290466,
            0.994873583316803,
            0.9947213530540466
        ]
    },
    "3183": {
        "similarity": 0.9986823201179504,
        "body": "import heapq\n\n    graph = [[] for _ in range(n)]\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))\n\n        dist = [float('inf')] * n\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, c, w in graph[u]:\n                cost = d + w - (dist[v] - dist[u])\n                if c > 0 and dist[v] > dist[u] + cost:\n                    dist[v] = dist[u] + cost\n                    heapq.heappush(pq, (dist[v], v))\n        return dist[t]\n\n    max_flow = 0\n    total_cost = 0\n    while True:\n        dist = dijkstra()\n        if dist == float('inf'):\n            break\n        flow = min(c for u, c, w in graph[s] if c > 0)\n        max_flow += flow\n        total_cost += dist * flow\n        v = t\n        while v != s:\n            u = None\n            for x, c, w in reversed(graph[v]):\n                if c >= flow:\n                    u = x\n                    break\n            for i in range(len(graph[u])):\n                if graph[u][i][0] == v:\n                    graph[u][i] = (v, graph[u][i][1] - flow, graph[u][i][2])\n                    break\n            for i in range(len(graph[v])):\n                if graph[v][i][0] == u:\n                    graph[v][i] = (u, graph[v][i][1] + flow, graph[v][i][2])\n                    break\n            v = u\n    return max_flow, total_cost\n\nif __name__ == \"__main__\":\n    n, m, s, t = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    result = min_cost_flow(n, m, s, t, edges)\n    print(result[0], result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9982603192329407,
            0.9979717135429382,
            0.9985333681106567,
            0.9985044598579407,
            0.9984809756278992,
            0.9985471963882446,
            0.9985384941101074,
            0.998310923576355,
            0.9983175992965698,
            0.9979575276374817,
            0.9982597231864929,
            0.9983071684837341,
            0.9973673820495605,
            0.9986787438392639,
            0.9985082745552063,
            0.997888445854187,
            0.9986823201179504,
            0.9983096718788147,
            0.9979497194290161,
            0.9985916018486023
        ]
    },
    "3916": {
        "similarity": 0.9974736571311951,
        "body": "from math import factorial\nfrom collections import defaultdict\n\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(x**0.5) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\n    graph = defaultdict(list)\n    visited = set()\n    \n        if node in visited:\n            return 0\n        visited.add(node)\n        for neighbor in graph[node]:\n            graph[neighbor].append(node)\n            dfs(neighbor)\n        \n        while len(graph[node]) > 1:\n            neighbor = graph[node].pop()\n            graph[neighbor].remove(node)\n            dfs(neighbor)\n        \n        if node not in graph or not graph[node]:\n            return 0\n        \n        distance = 1\n        for neighbor in graph[node]:\n            distance += dfs(neighbor)\n        \n        return distance\n    \n    for fragment in fragments:\n        current = factorial(fragment)\n        while current > 1:\n            graph[current].append(current // lowest_prime_divisor(current))\n            current //= lowest_prime_divisor(current)\n    \n    min_path_sum = float('inf')\n    for node in range(1, max(fragments) + 2):\n        visited.clear()\n        path_sum = dfs(node)\n        if path_sum < min_path_sum:\n            min_path_sum = path_sum\n    \n    return min_path_sum\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nfragments = list(map(int, data[1:]))\n\nprint(find_min_path_sum(n, fragments))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974639415740967,
            0.9957088828086853,
            0.9957765340805054,
            0.996311366558075,
            0.9963101744651794,
            0.9972132444381714,
            0.9966545104980469,
            0.9965059161186218,
            0.9968864917755127,
            0.9961581826210022,
            0.995503306388855,
            0.9967309832572937,
            0.9971223473548889,
            0.9964497089385986,
            0.9974736571311951,
            0.9967405200004578,
            0.9956958293914795,
            0.9956620931625366,
            0.9966414570808411,
            0.9973320364952087
        ]
    },
    "3195": {
        "similarity": 0.9965606331825256,
        "body": "from fractions import Fraction\n\n    total_time = T_g + T_y + T_r\n    cycle = [0] * (total_time + 1)\n    \n    for t, color in observations:\n        if color == 'green':\n            cycle[t % total_time] += 1\n        elif color == 'yellow':\n            cycle[(t + T_g) % total_time] += 1\n        else:\n            cycle[(t + T_g + T_y) % total_time] += 1\n    \n    total_observations = sum(cycle)\n    if c_q == 'green':\n        probability = Fraction(cycle[t_q % total_time], total_observations)\n    elif c_q == 'yellow':\n        probability = Fraction(cycle[(t_q + T_g) % total_time], total_observations)\n    else:\n        probability = Fraction(cycle[(t_q + T_g + T_y) % total_time], total_observations)\n    \n    return float(probability)\n\n# Read input\nT_g, T_y, T_r = map(int, input().split())\nn = int(input())\nobservations = [tuple(map(int, input().split())) for _ in range(n)]\nt_q, c_q = input().split()\nt_q = int(t_q)\n\n# Output result\nprint(traffic_light_probability(T_g, T_y, T_r, n, observations, t_q, c_q))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965606331825256,
            0.9961198568344116,
            0.9958387017250061,
            0.9960806965827942,
            0.9951460957527161,
            0.9932788014411926,
            0.9958287477493286,
            0.9955589175224304,
            0.9945024251937866,
            0.9963058829307556,
            0.9963776469230652,
            0.9960177540779114,
            0.9961386322975159,
            0.996320903301239,
            0.9961274862289429,
            0.9957291483879089,
            0.9953454732894897,
            0.9947085380554199,
            0.9960694909095764,
            0.9945957064628601
        ]
    },
    "3998": {
        "similarity": 0.9970613121986389,
        "body": "import sys\nfrom collections import Counter\n\n    n = len(ratings)\n    target_rating = max(ratings)\n    matches = []\n    \n        group.sort(reverse=True)\n        for i in range(1, len(group)):\n            if group[i] > group[0]:\n                for j in range(len(group)):\n                    if group[j] != group[0]:\n                        group[j] -= 1\n                        break\n                matches.append(\"\".join('1' if k in group else '0' for k in range(n)))\n    \n    ratings_counter = Counter(ratings)\n    while any(count > 1 for count in ratings_counter.values()):\n        max_rating = max(ratings_counter)\n        min_ratings = [r for r in ratings if r < max_rating]\n        remaining_count = n - len(min_ratings)\n        \n        for _ in range(remaining_count):\n            make_match(min_ratings[:2])\n            del min_ratings[0]\n        \n        if len(min_ratings) == 1:\n            make_match(min_ratings + [max_rating] * (5 - 1))\n    \n    final_rating = target_rating\n    return final_rating, matches\n\nif __name__ == \"__main__\":\n    n = int(input())\n    ratings = list(map(int, input().split()))\n    result_rating, result_matches = equalize_ratings(ratings)\n    print(result_rating)\n    print(len(result_matches))\n    for match in result_matches:\n        print(match)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9965145587921143,
            0.9931873679161072,
            0.9959492087364197,
            0.9965527057647705,
            0.9970511198043823,
            0.9967085123062134,
            0.9966057538986206,
            0.9965579509735107,
            0.993596613407135,
            0.9955259561538696,
            0.9957941174507141,
            0.9947623014450073,
            0.9962033629417419,
            0.9967202544212341,
            0.9949999451637268,
            0.9969984292984009,
            0.9970613121986389,
            0.9969497323036194,
            0.9966710805892944,
            0.9965869784355164
        ]
    },
    "3150": {
        "similarity": 0.9954490661621094,
        "body": "        while b != 0:\n            a, b = b, a % b\n        return a\n\n        dx1, dy1 = p1[0] - p2[0], p1[1] - p2[1]\n        dx2, dy2 = p1[0] - p3[0], p1[1] - p3[1]\n        return gcd(dx1 * dy2, dx2 * dy1) == abs(dx1 * dy2 - dx2 * dy1)\n\n    guards = []\n    for x1, y1, x2, y2 in trenches:\n        if (x1, y1) != (x2, y2):\n            guards.append(((x1 + x2) // 2, (y1 + y2) // 2))\n\n        n = len(lst)\n        return n * (n - 1) * (n - 2)\n\n    total_ways = 0\n    for i in range(len(guards)):\n        for j in range(i + 1, len(guards)):\n            for k in range(j + 1, len(guards)):\n                if is_collinear(guards[i], guards[j], guards[k]):\n                    total_ways += 6\n\n    return total_ways\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\ntrenches = [(int(data[4*i+1]), int(data[4*i+2]), int(data[4*i+3]), int(data[4*i+4])) for i in range(N)]\n\nprint(count_ways_to_place_guards(N, trenches))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9949858784675598,
            0.9943727254867554,
            0.9946930408477783,
            0.994382381439209,
            0.9954490661621094,
            0.9934071898460388,
            0.9945889711380005,
            0.9922913312911987,
            0.9948195219039917,
            0.9947363138198853,
            0.985339343547821,
            0.9932507872581482,
            0.9947144389152527,
            0.9907982349395752,
            0.9949412941932678,
            0.9940480589866638,
            0.9945154786109924,
            0.9951412677764893,
            0.9949553608894348,
            0.992728590965271
        ]
    },
    "3566": {
        "similarity": 0.9967312216758728,
        "body": "    for _ in range(q):\n        i, x = map(int, input().split())\n        huts[i] = x\n        left_sum = 0\n        right_sum = sum(huts)\n        min_diff = float('inf')\n        optimal_pos = -1\n        for j in range(n):\n            left_sum += huts[j]\n            right_sum -= huts[j]\n            diff = abs(left_sum - right_sum)\n            if diff < min_diff:\n                min_diff = diff\n                optimal_pos = j\n            elif diff == min_diff and j < optimal_pos:\n                optimal_pos = j\n        print(optimal_pos)\n\n# Read input\nn, q = map(int, input().split())\nhuts = list(map(int, input().split()))\n\n# Process each query\noptimal_food_truck_position(n, q, huts)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9960309267044067,
            0.9962629079818726,
            0.993078351020813,
            0.9962510466575623,
            0.9967312216758728,
            0.9962746500968933,
            0.9963018298149109,
            0.9930773377418518,
            0.9963822960853577,
            0.9935851097106934,
            0.9952502846717834,
            0.9939428567886353,
            0.9967085123062134,
            0.9947746992111206,
            0.9904347658157349,
            0.9964960813522339,
            0.9963833689689636,
            0.9946144819259644,
            0.9949461221694946,
            0.9954522848129272
        ]
    },
    "3401": {
        "similarity": 0.9978228211402893,
        "body": "import sys\nfrom heapq import heappush, heappop\n\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            \n            for v, height_diff in graph[u]:\n                length = abs(height_diff) * q / (height_diff ** 2 + max_length ** 2)\n                new_dist = current_dist + length\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heappush(pq, (new_dist, v))\n        \n        return dist\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            x_i, y_i, h_i = hills[i - 1]\n            x_j, y_j, h_j = hills[j - 1]\n            height_diff = h_j - h_i\n            length = ((x_j - x_i) ** 2 + (y_j - y_i) ** 2) ** 0.5\n            graph[i].append((j, height_diff))\n            graph[j].append((i, height_diff))\n    \n    min_length = float('inf')\n    for s_hill in springs:\n        dist_s = dijkstra(s_hill, q)\n        for t_hill in towns:\n            if dist_s[t_hill] < min_length:\n                min_length = dist_s[t_hill]\n    \n    if min_length == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return f\"{min_length:.6f}\"\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = int(data[1])\n    t = int(data[2])\n    q = int(data[3])\n    \n    hills = []\n    index = 4\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        h_i = int(data[index + 2])\n        hills.append((x_i, y_i, h_i))\n        index += 3\n    \n    springs = list(map(int, data[index:index + s]))\n    towns = list(map(int, data[index + s:]))\n    \n    result = find_minimal_aqueducts(n, s, t, q, hills, springs, towns)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974244832992554,
            0.9977597594261169,
            0.9961978793144226,
            0.9970155358314514,
            0.9974572062492371,
            0.9943178296089172,
            0.9970735311508179,
            0.9958726763725281,
            0.997195303440094,
            0.9976046681404114,
            0.9977936148643494,
            0.9977107644081116,
            0.9973325133323669,
            0.9971598386764526,
            0.9977218508720398,
            0.9976615905761719,
            0.9976391196250916,
            0.997211754322052,
            0.9942227602005005,
            0.9978228211402893
        ]
    },
    "3660": {
        "similarity": 0.9970517754554749,
        "body": "from collections import defaultdict\nimport sys\n\n    message = input().strip()\n    n = int(input().strip())\n    stickers = defaultdict(int)\n    \n    for _ in range(n):\n        word, price = input().strip().split()\n        stickers[word] = int(price)\n    \n    dp = [[float('inf')] * (len(message) + 1) for _ in range(3)]\n    dp[0][0] = 0\n    \n    for i in range(1, 3):\n        for j in range(len(message)):\n            for k in range(j + 1):\n                if message[k:j+1] in stickers:\n                    dp[i][j+1] = min(dp[i][j+1], dp[i-1][k] + stickers[message[k:j+1]])\n    \n    if dp[2][-1] == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        print(dp[2][-1])\n\nif __name__ == \"__main__\":\n    min_cost_message()",
        "result": "failed: testcase 0",
        "similarities": [
            0.996528148651123,
            0.9961329102516174,
            0.9959058165550232,
            0.9947749972343445,
            0.9961903095245361,
            0.9953689575195312,
            0.9963495135307312,
            0.9970517754554749,
            0.9962134957313538,
            0.9951078295707703,
            0.9968847036361694,
            0.9957588911056519,
            0.9958171844482422,
            0.9970124959945679,
            0.9965538382530212,
            0.9934676289558411,
            0.9968085289001465,
            0.9956982135772705,
            0.9959166646003723,
            0.9922036528587341
        ]
    },
    "3721": {
        "similarity": 0.9959067106246948,
        "body": "    total_elements = n * m\n    if len(elements) == total_elements:\n        return 0\n    \n    rows = [set() for _ in range(n)]\n    cols = [set() for _ in range(m)]\n    \n    for r, c in elements:\n        rows[r-1].add(c)\n        cols[c-1].add(r)\n    \n    missing_rows = n - len([row for row in rows if len(row) == m])\n    missing_cols = m - len([col for col in cols if len(col) == n])\n    \n    return max(missing_rows, missing_cols)\n\n# Read input\nn, m, q = map(int, input().split())\nelements = [tuple(map(int, input().split())) for _ in range(q)]\n\n# Output the result\nprint(min_purchases(n, m, q, elements))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9930538535118103,
            0.9874616861343384,
            0.9947088956832886,
            0.9959067106246948,
            0.9952922463417053,
            0.9949358105659485,
            0.9950583577156067,
            0.9936298727989197,
            0.9949676394462585,
            0.9938468933105469,
            0.9921579957008362,
            0.992745041847229,
            0.9934260845184326,
            0.9922878742218018,
            0.995039701461792,
            0.9934368133544922,
            0.9917687177658081,
            0.9953399300575256,
            0.994556725025177,
            0.9917349815368652
        ]
    },
    "3811": {
        "similarity": 0.9975932240486145,
        "body": "import sys\n\n    while b:\n        a, b = b, a % b\n    return a\n\n    if not pairs:\n        return -1\n    \n    current_wcd = pairs[0][0]\n    for pair in pairs:\n        current_wcd = gcd(current_wcd, gcd(pair[0], pair[1]))\n    \n    return current_wcd if current_wcd > 1 else -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    pairs = [tuple(map(int, input().split())) for _ in range(n)]\n    result = wcd(pairs)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966524243354797,
            0.9967652559280396,
            0.9968474507331848,
            0.9965415000915527,
            0.9970172047615051,
            0.9967077970504761,
            0.9969000816345215,
            0.9969245791435242,
            0.9968446493148804,
            0.9967171549797058,
            0.9963428378105164,
            0.9975932240486145,
            0.993827223777771,
            0.9963212609291077,
            0.9973788261413574,
            0.9965754151344299,
            0.9900686144828796,
            0.9974327087402344,
            0.9963828921318054,
            0.9970389008522034
        ]
    },
    "3528": {
        "similarity": 0.9979838132858276,
        "body": "import sys\n\n    n = len(points)\n    x = [p[0] for p in points]\n    y = [p[1] for p in points]\n    return 0.5 * abs(sum(x[i] * y[(i + 1) % n] - y[i] * x[(i + 1) % n] for i in range(n)))\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    nails = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(N)]\n    picks = [data[N*2 + i] for i in range(N-2)]\n    \n    areas = []\n    while len(nails) > 3:\n        area = calculate_area(nails)\n        areas.append(area)\n        \n        if picks.pop(0) == 'L':\n            nails.sort(key=lambda p: p[0])\n        elif picks.pop(0) == 'R':\n            nails.sort(key=lambda p: -p[0])\n        elif picks.pop(0) == 'U':\n            nails.sort(key=lambda p: -p[1])\n        else:\n            nails.sort(key=lambda p: p[1])\n        \n        nails = nails[1:-1]\n    \n    for area in areas:\n        print(f\"{area:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9977964162826538,
            0.9972365498542786,
            0.9965808391571045,
            0.9966098666191101,
            0.9969545006752014,
            0.9978244304656982,
            0.9976688027381897,
            0.9961970448493958,
            0.9960066080093384,
            0.9969223737716675,
            0.9971058368682861,
            0.9975044131278992,
            0.9971636533737183,
            0.997180163860321,
            0.9979838132858276,
            0.9936853051185608,
            0.9973568320274353,
            0.9976897239685059,
            0.9965534210205078,
            0.9976376295089722
        ]
    },
    "3890": {
        "similarity": 0.9976155161857605,
        "body": "    MOD = 1000000007\n    if n == 1:\n        return 1\n    if k == 1:\n        return (n * (n - 1)) % MOD\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        if i <= k:\n            dp[i] = (dp[i - 1] * (i - 1) + dp[i - 1]) % MOD\n        else:\n            dp[i] = (dp[i - 1] * (i - 1)) % MOD\n    return dp[n]\n\n# Read input from stdin\nn, k = map(int, input().split())\n# Print the result\nprint(count_plaque_numbers(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968850016593933,
            0.9966846108436584,
            0.9968364238739014,
            0.9968724846839905,
            0.9970482587814331,
            0.9967535138130188,
            0.9966691732406616,
            0.9971587657928467,
            0.9967833161354065,
            0.9976155161857605,
            0.9959965944290161,
            0.9915233254432678,
            0.9958711266517639,
            0.9945423007011414,
            0.9973174929618835,
            0.9969267845153809,
            0.9961423277854919,
            0.9966133832931519,
            0.9973248839378357,
            0.9975603818893433
        ]
    },
    "3534": {
        "similarity": 0.9986183643341064,
        "body": "    max_correct = 0\n    best_K = 0\n    \n    for K in range(2 * 10**9 + 1):\n        correct = 1\n        prev = a[0]\n        \n        for i in range(1, N):\n            if a[i] > prev:\n                next_key = prev + K\n            elif a[i] < prev:\n                next_key = prev - K\n            else:\n                next_key = prev\n            \n            if next_key == a[i]:\n                correct += 1\n            prev = next_key\n        \n        if correct > max_correct:\n            max_correct = correct\n            best_K = K\n    \n    return max_correct, best_K\n\n# Read input\nN = int(input())\na = list(map(int, input().split()))\n\n# Output result\nresult = max_correct_pitches(N, a)\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0",
        "similarities": [
            0.9986183643341064,
            0.9983498454093933,
            0.9955632090568542,
            0.9983779788017273,
            0.9983947277069092,
            0.9970114827156067,
            0.9978031516075134,
            0.9984482526779175,
            0.9974277019500732,
            0.9969786405563354,
            0.9936030507087708,
            0.9979585409164429,
            0.998550534248352,
            0.9985986351966858,
            0.9979570508003235,
            0.9984520673751831,
            0.998099684715271,
            0.9974683523178101,
            0.9982070922851562,
            0.9982289671897888
        ]
    },
    "3371": {
        "similarity": 0.9979081749916077,
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    if n <= 2 * n // 3:\n        return 'Impossible'\n    \n    graph = defaultdict(list)\n    for a, b, y in encounters:\n        graph[a].append((b, y))\n        graph[b].append((a, y))\n    \n        visited = [False] * (n + 1)\n        queue = deque([start])\n        year = [0] * (n + 1)\n        while queue:\n            node = queue.popleft()\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, y in graph[node]:\n                    if not visited[neighbor]:\n                        year[neighbor] = y\n                        queue.append(neighbor)\n        return year\n    \n    years = bfs(1)\n    \n    for i in range(1, n + 1):\n        if years[i] == 0:\n            years[i] = 2008\n    \n    max_year = max(years)\n    \n    for year in range(max_year, 1947, -1):\n        first_group = [i for i in range(1, n + 1) if years[i] < year]\n        second_group = [i for i in range(1, n + 1) if years[i] >= year]\n        \n        if len(first_group) <= 2 * n // 3 and len(second_group) <= 2 * n // 3:\n            return str(year)\n    \n    return 'Impossible'\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    index += 1\n    c = int(data[index])\n    index += 1\n    \n    encounters = []\n    for _ in range(c):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        y = int(data[index + 2])\n        index += 3\n        encounters.append((a, b, y))\n    \n    result = find_division(n, c, encounters)\n    print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967030882835388,
            0.9975484609603882,
            0.9977471232414246,
            0.9969536662101746,
            0.9978407025337219,
            0.9975650310516357,
            0.9979081749916077,
            0.9958899617195129,
            0.9974287748336792,
            0.9971357583999634,
            0.9971831440925598,
            0.9976816773414612,
            0.997435450553894,
            0.9974608421325684,
            0.9969285726547241,
            0.9971327781677246,
            0.9968022108078003,
            0.995652437210083,
            0.9968461394309998,
            0.9971022605895996
        ]
    },
    "3621": {
        "similarity": 0.9977808594703674,
        "body": "from sys import stdin, stdout\nfrom collections import defaultdict\n\nMOD = 10**9 + 7\n\n        size = 1\n        for neighbor in range(1, n+1):\n            if neighbor != node and neighbor != parent and edges[node][neighbor] == color:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    size += dfs(neighbor, node, color, visited)\n        return size\n\n    total_sum = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            color = edges[i][j]\n            if color > 0:\n                visited = {i}\n                size = dfs(i, -1, color, visited)\n                total_sum += size * (n - size + 1)\n                total_sum %= MOD\n    return total_sum\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    edges = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(1, n+1):\n        edge_colors = list(map(int, input().strip().split()))\n        for j in range(1, n+1):\n            edges[i][j] = edge_colors[j-1]\n    result = max_same_color_subset(n, edges)\n    stdout.write(str(result) + '\\n')",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969275593757629,
            0.9977808594703674,
            0.9962415099143982,
            0.9967899322509766,
            0.996396005153656,
            0.9971781373023987,
            0.997351884841919,
            0.997048020362854,
            0.9970526695251465,
            0.9971238970756531,
            0.9947091937065125,
            0.9975710511207581,
            0.9975492358207703,
            0.9974763989448547,
            0.9973307251930237,
            0.997076153755188,
            0.9969243407249451,
            0.9963846802711487,
            0.9971527457237244,
            0.9971947073936462
        ]
    },
    "3392": {
        "similarity": 0.997303307056427,
        "body": "import sys\nfrom collections import deque\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < N and 0 <= y < N\n    \n        for i in range(N):\n            for j in range(N):\n                heights[i][j] += growth_speeds[i][j] * years\n    \n        queue = deque([(x, y)])\n        visited = set()\n        visited.add((x, y))\n        size = 1\n        \n        while queue:\n            cx, cy = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited and heights[nx][ny] == target_height:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    size += 1\n        \n        return size\n    \n    max_size = 0\n    for years in range(1, N * N + 1):\n        grow_heights(heights, growth_speeds, years)\n        target_height = heights[0][0]\n        size = bfs(0, 0, target_height)\n        max_size = max(max_size, size)\n    \n    return max_size\n\n# Read input\nN = int(input())\nheights = [list(map(int, input().split())) for _ in range(N)]\ngrowth_speeds = [list(map(int, input().split())) for _ in range(N)]\n\n# Output the result\nprint(largest_group_of_trees(N, heights, growth_speeds))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951750040054321,
            0.9966455101966858,
            0.9970648884773254,
            0.9960728883743286,
            0.9962774515151978,
            0.9968693256378174,
            0.9968498945236206,
            0.997303307056427,
            0.9954425692558289,
            0.9965242147445679,
            0.9966704845428467,
            0.9960246682167053,
            0.9972223043441772,
            0.995580792427063,
            0.9970371723175049,
            0.9940766096115112,
            0.9960529804229736,
            0.9964605569839478,
            0.9924308657646179,
            0.9958630800247192
        ]
    },
    "3095": {
        "similarity": 0.9973998665809631,
        "body": "    return A[0][0] + A[r-1][s-1] <= A[0][s-1] + A[r-1][0]\n\n    for i in range(2, R+1):\n        for j in range(2, S+1):\n            if not is_cool(A, i, j):\n                return False\n    return True\n\n    max_size = 0\n    for i in range(R):\n        for j in range(S):\n            for r in range(i + 2, R + 1):\n                for s in range(j + 2, S + 1):\n                    submatrix = [row[j:s] for row in matrix[i:r]]\n                    if is_extremely_cool(submatrix, r - i, s - j):\n                        max_size = max(max_size, (r - i) * (s - j))\n    return max_size\n\n# Read input\nR, S = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(R)]\n\n# Output the result\nprint(largest_extremely_cool_submatrix(R, S, matrix))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973998665809631,
            0.9958604574203491,
            0.9966990947723389,
            0.9966592192649841,
            0.9969457387924194,
            0.9967743754386902,
            0.9964202046394348,
            0.9968928098678589,
            0.9957771301269531,
            0.9968538880348206,
            0.9971711039543152,
            0.9971094727516174,
            0.9967195391654968,
            0.9956035614013672,
            0.9898413419723511,
            0.9957290291786194,
            0.9969557523727417,
            0.9951404929161072,
            0.9968934655189514,
            0.9972401857376099
        ]
    },
    "3769": {
        "similarity": 0.9978426694869995,
        "body": "    MOD = 10**9 + 7\n    if k == 0:\n        return pow(p, p-1, MOD)\n    else:\n        return pow(p, p//2, MOD)\n\n# Read input from stdin\np, k = map(int, input().split())\n\n# Print the result modulo 10^9 + 7\nprint(count_functions(p, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967894554138184,
            0.9955652952194214,
            0.9956386089324951,
            0.9978426694869995,
            0.9960131645202637,
            0.9978232383728027,
            0.9975924491882324,
            0.9976438283920288,
            0.9974722862243652,
            0.996596097946167,
            0.9969518780708313,
            0.9971616864204407,
            0.9954241514205933,
            0.997319757938385,
            0.9974768757820129,
            0.9974850416183472,
            0.9958377480506897,
            0.9976640343666077,
            0.9960750937461853,
            0.9970500469207764
        ]
    },
    "3563": {
        "similarity": 0.997175931930542,
        "body": "    # Sort holes by x-coordinate\n    holes.sort()\n    \n    # Initialize line count\n    lines = 0\n    \n    # Iterate through holes to determine the minimum number of lines needed\n    i = 0\n    while i < n:\n        x1, y1 = holes[i]\n        x2, y2 = holes[(i + 1) % n]\n        \n        if y1 != y2:\n            lines += 1\n        \n        # Skip consecutive points with the same y-coordinate\n        while i < n - 1 and holes[i][1] == holes[i + 1][1]:\n            i += 1\n        \n        i += 1\n    \n    return lines\n\n# Read input\nn = int(input())\nholes = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_lines_to_cover_holes(n, holes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964417219161987,
            0.9968934655189514,
            0.9966011047363281,
            0.995011568069458,
            0.9951362609863281,
            0.997175931930542,
            0.996453046798706,
            0.9963583946228027,
            0.9941090941429138,
            0.9968936443328857,
            0.9958364367485046,
            0.99679034948349,
            0.9938145875930786,
            0.9957671165466309,
            0.9964109063148499,
            0.9964503049850464,
            0.9969020485877991,
            0.9966073632240295,
            0.9963322877883911,
            0.9958568215370178
        ]
    },
    "3618": {
        "similarity": 0.9967511892318726,
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 10\n    \n    # Initialize DP table\n    dp = [0] * (n + 1)\n    dp[1] = 10\n    for i in range(2, n + 1):\n        dp[i] = ((dp[i - 1] * 9) % MOD) * 2 % MOD\n    \n    return dp[n]\n\n# Read input\nn = int(input())\n\n# Print result\nprint(count_best_friend_pairs(n))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9967173337936401,
            0.9957478046417236,
            0.9959859251976013,
            0.9836453199386597,
            0.9947530031204224,
            0.994388997554779,
            0.9946542382240295,
            0.9967508912086487,
            0.9952716827392578,
            0.9962627291679382,
            0.9960033893585205,
            0.9959957599639893,
            0.9951541423797607,
            0.9965459108352661,
            0.9967511892318726,
            0.9962900876998901,
            0.9953818321228027,
            0.9951100945472717,
            0.9940648674964905,
            0.9961568117141724
        ]
    },
    "3830": {
        "similarity": 0.9959756135940552,
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    results = []\n    index = 0\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        belts = data[index]\n        index += 1\n        \n        returnable = 0\n        \n        for i in range(n):\n            if belts[i] == '-' or (i > 0 and belts[(i-1) % n] != '<') or (i < n-1 and belts[(i+1) % n] != '>'):\n                returnable += 1\n                \n        results.append(returnable)\n    \n    for result in results:\n        print(result)\n\n# Call the function with the number of test cases\ncount_returnable_rooms(int(input()))",
        "result": "failed: testcase 0",
        "similarities": [
            0.995940089225769,
            0.995705783367157,
            0.9878022074699402,
            0.9940022826194763,
            0.9938374757766724,
            0.9939404726028442,
            0.9951875805854797,
            0.9955134391784668,
            0.9952996969223022,
            0.9933885335922241,
            0.9940083026885986,
            0.9950564503669739,
            0.9946473836898804,
            0.9951704144477844,
            0.9949294924736023,
            0.9951324462890625,
            0.9954244494438171,
            0.9956597685813904,
            0.9959756135940552,
            0.9950191974639893
        ]
    },
    "3912": {
        "similarity": 0.9969657063484192,
        "body": "from collections import Counter\nimport sys\n\n    n = len(s)\n    count = Counter(s)\n    \n    # Calculate the minimum number of palindromes\n    k = 0\n    for char, freq in count.items():\n        if freq % 2 == 1:\n            k += 1\n    \n    # Create a palindrome by rearranging characters\n        return s == s[::-1]\n    \n    result = []\n    i = 0\n    while i < n:\n        palindrome = \"\"\n        for char, freq in count.items():\n            if freq % 2 == 1 and char not in palindrome:\n                palindrome += char * (freq // 2)\n            else:\n                palindrome += char * (freq // 2) * 2\n        result.append(palindrome)\n        i += len(palindrome)\n    \n    return k, \" \".join(result)\n\n# Read input\nn = int(input())\ns = input()\n\n# Get the minimum number of palindromes and the palindromes themselves\nk, palindromes = min_palindromes(s)\n\n# Print the result\nprint(k)\nprint(palindromes)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9940149188041687,
            0.9965673685073853,
            0.9935535788536072,
            0.994803786277771,
            0.996301531791687,
            0.9962437152862549,
            0.9945963621139526,
            0.9966830015182495,
            0.9959826469421387,
            0.9965922832489014,
            0.9959713816642761,
            0.9949769377708435,
            0.9957131147384644,
            0.9938706159591675,
            0.9960578083992004,
            0.9969657063484192,
            0.9965465068817139,
            0.995512843132019,
            0.9951015114784241,
            0.9957662224769592
        ]
    },
    "3878": {
        "similarity": 0.9976449608802795,
        "body": "import sys\n\n    graph = [[] for _ in range(n)]\n    for u, v in friendships:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    visited = [False] * n\n    steps = 0\n    selected_guests = []\n\n        stack = [node]\n        while stack:\n            current = stack.pop()\n            if not visited[current]:\n                visited[current] = True\n                for neighbor in graph[current]:\n                    if not visited[neighbor]:\n                        stack.append(neighbor)\n\n    # Find a starting node that can connect all guests\n    start_node = -1\n    for i in range(n):\n        if len(graph[i]) > 0:\n            start_node = i\n            break\n\n    dfs(start_node)\n    if all(visited):\n        return 1, [start_node + 1]\n\n    # If not all guests are connected, find the second guest to introduce them\n    visited = [False] * n\n    selected_guests.append(start_node + 1)\n    for i in range(n):\n        if not visited[i]:\n            selected_guests.append(i + 1)\n            dfs(i)\n            break\n\n    return len(selected_guests), selected_guests\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    friendships = [(int(data[i*2+2]) - 1, int(data[i*2+3]) - 1) for i in range(m)]\n    \n    steps, guests = min_steps_to_make_all_friends(n, m, friendships)\n    \n    print(steps)\n    print(\" \".join(map(str, guests)))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9970689415931702,
            0.9970704913139343,
            0.9973738789558411,
            0.9972940683364868,
            0.9976206421852112,
            0.9971995949745178,
            0.9976449608802795,
            0.9971794486045837,
            0.9972596764564514,
            0.9968000650405884,
            0.9969156384468079,
            0.9968603849411011,
            0.9967061281204224,
            0.9969131350517273,
            0.9973114728927612,
            0.9975262880325317,
            0.9976078867912292,
            0.9974619150161743,
            0.9962776899337769,
            0.9968988299369812
        ]
    },
    "3010": {
        "similarity": 0.9958376884460449,
        "body": "    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        if x0 == x1:\n            min_y = min(y0, y1)\n            max_y = max(y0, y1)\n            for j in range(min_y, max_y + 1):\n                points.add((x0, j))\n        elif y0 == y1:\n            min_x = min(x0, x1)\n            max_x = max(x0, x1)\n            for j in range(min_x, max_x + 1):\n                points.add((j, y0))\n    return len(points) if -1 not in points else -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nlines = [(int(data[i*4+1]), int(data[i*4+2]), int(data[i*4+3]), int(data[i*4+4])) for i in range(n)]\nprint(count_intersection_points(n, lines))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9944714307785034,
            0.9941390156745911,
            0.9949185252189636,
            0.9949295520782471,
            0.9941937327384949,
            0.9908849000930786,
            0.9957613945007324,
            0.9945513010025024,
            0.9926633238792419,
            0.9931331276893616,
            0.9958128929138184,
            0.995758056640625,
            0.9933273196220398,
            0.9941846132278442,
            0.9958376884460449,
            0.9933098554611206,
            0.9946649670600891,
            0.993200421333313,
            0.9946181774139404,
            0.9940391182899475
        ]
    },
    "3068": {
        "similarity": 0.9973297119140625,
        "body": "from itertools import combinations, product\n\n    N = int(input())\n    investigations = [input().split() for _ in range(N)]\n    \n    suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    admissible_solutions = set()\n    \n    for black_vienna in combinations(suspects, 3):\n        valid = True\n        for investigation in investigations:\n            pair, player, reply = investigation[0], int(investigation[1]), int(investigation[2])\n            count_in_hand = sum(1 for suspect in black_vienna if suspect in set(pair))\n            if count_in_hand != reply:\n                valid = False\n                break\n        if valid:\n            admissible_solutions.add(black_vienna)\n    \n    print(len(admissible_solutions))\n\ncount_admissible_solutions()",
        "result": "failed: testcase 0",
        "similarities": [
            0.997262179851532,
            0.9952951669692993,
            0.996924877166748,
            0.9956245422363281,
            0.9965726137161255,
            0.9965746998786926,
            0.9966820478439331,
            0.9952648878097534,
            0.994912326335907,
            0.9946128726005554,
            0.9945075511932373,
            0.9950559735298157,
            0.9973297119140625,
            0.9968069195747375,
            0.9945175051689148,
            0.9955978393554688,
            0.9960151314735413,
            0.9959292411804199,
            0.9951778054237366,
            0.9932544231414795
        ]
    },
    "3030": {
        "similarity": 0.9970207214355469,
        "body": "import sys\n\n    parent = [-1] * n\n    for i in range(1, n):\n        parent[nodes[i][1]] = i\n    \n        max_size = 0\n        for child in range(node, n):\n            if parent[child] == node:\n                size = dfs(child)\n                if nodes[node][0] > nodes[child][0]:\n                    max_size = max(max_size, size + 1)\n        return max_size\n    \n    result = 0\n    for i in range(n):\n        if parent[i] == -1 or nodes[parent[i]][0] < nodes[i][0]:\n            result = max(result, dfs(i) + 1)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    nodes = []\n    index = 1\n    for i in range(n):\n        value = int(data[index])\n        parent_index = int(data[index + 1])\n        nodes.append((value, parent_index))\n        index += 2\n    \n    print(max_heap_subset(n, nodes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9955740571022034,
            0.9965855479240417,
            0.9967510104179382,
            0.9953047037124634,
            0.9957279562950134,
            0.9964202046394348,
            0.9970207214355469,
            0.996897280216217,
            0.9966820478439331,
            0.9952067136764526,
            0.9961336851119995,
            0.9967422485351562,
            0.9969891905784607,
            0.9941567182540894,
            0.9952579140663147,
            0.9944431781768799,
            0.9965329766273499,
            0.9943225383758545,
            0.9968635439872742,
            0.9964138865470886
        ]
    },
    "3630": {
        "similarity": 0.9986286163330078,
        "body": "    moves = 0\n    n = len(s1)\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            diff = ord(s2[i]) - ord(s1[i])\n            if diff < 0:\n                diff += 26\n            moves += diff\n    \n    return moves\n\n# Read input from stdin\ns1, s2 = input().split()\n# Print the result\nprint(min_moves_to_modify(s1, s2))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9981407523155212,
            0.9982044100761414,
            0.9979848265647888,
            0.9981352090835571,
            0.9977701306343079,
            0.9983780384063721,
            0.9979724884033203,
            0.9967525005340576,
            0.9979031085968018,
            0.9966320395469666,
            0.9985136985778809,
            0.9981400370597839,
            0.9980984926223755,
            0.9983998537063599,
            0.997379720211029,
            0.9979128837585449,
            0.9986286163330078,
            0.9971717000007629,
            0.9980093240737915,
            0.9978367686271667
        ]
    },
    "3133": {
        "similarity": 0.9976925253868103,
        "body": "        queue = [start]\n        visited = set()\n        while queue:\n            current = queue.pop(0)\n            if (current, 1) in visited or (current, -1) in visited:\n                continue\n            visited.add((current, 1))\n            visited.add((current, -1))\n            if intersections[current][2] == 1:\n                return True\n            left = intersections[current][0]\n            right = intersections[current][1]\n            if left != current and (left, 1) not in visited:\n                queue.append(left)\n            if right != current and (right, -1) not in visited:\n                queue.append(right)\n        return False\n\n    alice_can_see = can_see_tower(A)\n    bob_can_see = can_see_tower(B)\n\n    if alice_can_see and not bob_can_see:\n        return 0\n    elif bob_can_see and not alice_can_see:\n        return 0\n    else:\n        return \"indistinguishable\"\n\n# Read input from stdin\nn, A, B = map(int, input().split())\nintersections = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(min_turns_to_distinguish(n, A, B, intersections))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9976925253868103,
            0.9972626566886902,
            0.9973540306091309,
            0.9968065023422241,
            0.9964078664779663,
            0.9973112344741821,
            0.9966944456100464,
            0.9961760640144348,
            0.9960609078407288,
            0.9961040019989014,
            0.9967878460884094,
            0.9972091317176819,
            0.9972924590110779,
            0.9962966442108154,
            0.9973923563957214,
            0.997157871723175,
            0.996535062789917,
            0.9975079894065857,
            0.9970352053642273,
            0.9961525797843933
        ]
    },
    "3480": {
        "similarity": 0.9964882731437683,
        "body": "import sys\n\n    L, D = map(int, input().split())\n    for _ in range(L):\n        first_voice, second_voice_times = input(), list(map(int, input().split()))\n        first_voice_parts = first_voice.split()\n        second_voice_output = [''] * len(first_voice_parts)\n        \n        current_time = 0\n        second_voice_index = 0\n        \n        for i in range(len(first_voice_parts)):\n            syllable = first_voice_parts[i]\n            time_units = second_voice_times[i]\n            start_time = current_time + D\n            \n            if start_time < time_units:\n                second_voice_output[i] += '_' * (start_time - current_time)\n            \n            second_voice_output[i] += syllable\n            second_voice_output[i] += '_' * max(0, time_units - len(second_voice_output[i]))\n            \n            current_time += time_units\n        \n        for line in second_voice_output:\n            if not line:\n                print('/')\n            else:\n                print(line)\n\nif __name__ == \"__main__\":\n    generate_round()",
        "result": "failed: testcase 0",
        "similarities": [
            0.995708167552948,
            0.9958497285842896,
            0.9959751963615417,
            0.9961515069007874,
            0.9947783946990967,
            0.9955052733421326,
            0.9955775737762451,
            0.9958739876747131,
            0.9951105713844299,
            0.9961845278739929,
            0.995694100856781,
            0.9937549233436584,
            0.9956130981445312,
            0.9878843426704407,
            0.9960694909095764,
            0.9962347149848938,
            0.9964882731437683,
            0.9893360137939453,
            0.9948630332946777,
            0.9953954815864563
        ]
    },
    "3389": {
        "similarity": 0.9975346922874451,
        "body": "    current_type = None\n    clicks = 0\n    \n    for i in range(n):\n        if video_list[i] != current_type:\n            clicks += 1\n            current_type = video_list[i]\n    \n    return clicks\n\n# Read input\nn, k = map(int, input().split())\nvideo_list = input()\n\n# Output the result\nprint(min_clicks_to_watch_all_videos(n, k, video_list))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973816275596619,
            0.9960925579071045,
            0.9975346922874451,
            0.997324526309967,
            0.9907965660095215,
            0.9970512390136719,
            0.9962339997291565,
            0.9970948100090027,
            0.9969719648361206,
            0.9948086142539978,
            0.9967041015625,
            0.9968135356903076,
            0.9968680143356323,
            0.9957432150840759,
            0.9973008036613464,
            0.9963108897209167,
            0.9945502281188965,
            0.9971616864204407,
            0.9936704039573669,
            0.9949322938919067
        ]
    },
    "3925": {
        "similarity": 0.997347891330719,
        "body": "    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        length = 1\n        for j in range(i + 1, n):\n            if s[j] == s[j - 1]:\n                break\n            length += 1\n        max_length = max(max_length, length)\n    \n    return max_length\n\n# Read input from stdin\ns = input().strip()\nprint(max_zebra_length(s))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947741627693176,
            0.9950341582298279,
            0.9964081645011902,
            0.9970776438713074,
            0.9963063597679138,
            0.9962987303733826,
            0.9970253705978394,
            0.9971305727958679,
            0.9954605102539062,
            0.9968482851982117,
            0.9931985139846802,
            0.9973365664482117,
            0.9963110089302063,
            0.9919732809066772,
            0.9972488284111023,
            0.9934943318367004,
            0.997347891330719,
            0.9970727562904358,
            0.9972962737083435,
            0.9971862435340881
        ]
    },
    "3700": {
        "similarity": 0.9969004392623901,
        "body": "    count = 0\n    for i in range(1, n + 1):\n        if k - i > i and k - i <= n:\n            count += 1\n    return count\n\nn, k = map(int, input().split())\nprint(count_pairs(n, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947393536567688,
            0.9959213733673096,
            0.9954374432563782,
            0.9960152506828308,
            0.9916026592254639,
            0.9954374432563782,
            0.9926950335502625,
            0.9958815574645996,
            0.9960646629333496,
            0.9956504702568054,
            0.9969004392623901,
            0.9935104250907898,
            0.9953532814979553,
            0.9954374432563782,
            0.9965624809265137,
            0.996545672416687,
            0.9954189658164978,
            0.9960345029830933,
            0.9960615038871765,
            0.9959352612495422
        ]
    },
    "3944": {
        "similarity": 0.9951384663581848,
        "body": "import sys\n\nMOD = 10**9 + 7\n\n    if N == 0:\n        return (3**M * 3**K) % MOD\n    elif M == 0:\n        return (3**N * 3**K) % MOD\n    elif K == 0:\n        return (3**N * 3**M) % MOD\n    \n    # Calculate the number of ways to win for each player's turn\n    a_wins = (3**(M+K-1)) % MOD\n    b_wins = (2 * 3**(N-1) * 3**(K-1)) % MOD\n    c_wins = (2 * 3**(N-1) * 3**(M-1)) % MOD\n    \n    # Total number of winning patterns for Alice\n    total_wins = (a_wins + b_wins + c_wins) % MOD\n    \n    return total_wins\n\n# Read input from stdin\nN, M, K = map(int, input().split())\n\n# Calculate and print the result\nprint(count_winning_patterns(N, M, K))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9942768812179565,
            0.9940233826637268,
            0.9934004545211792,
            0.9899936318397522,
            0.9883919954299927,
            0.9951384663581848,
            0.9923444986343384,
            0.9947569966316223,
            0.9937995076179504,
            0.9927789568901062,
            0.9937289357185364,
            0.9940502643585205,
            0.9935215711593628,
            0.9917162656784058,
            0.9898677468299866,
            0.9938876628875732,
            0.9897920489311218,
            0.9908450245857239,
            0.9936712980270386,
            0.9890460968017578
        ]
    },
    "3821": {
        "similarity": 0.9966354370117188,
        "body": "import sys\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for p in probabilities:\n        for i in range(n, 0, -1):\n            dp[i] += dp[i-1] * (1 - p)\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    probabilities = list(map(float, input().strip().split()))\n    result = max_probability(n, probabilities)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952053427696228,
            0.9948439598083496,
            0.9924162030220032,
            0.9961330890655518,
            0.9957303404808044,
            0.9942147135734558,
            0.9960027933120728,
            0.9961934685707092,
            0.9963000416755676,
            0.9948610067367554,
            0.9954926371574402,
            0.9928151369094849,
            0.996423602104187,
            0.9958080649375916,
            0.9913789629936218,
            0.996592104434967,
            0.9949153065681458,
            0.9965359568595886,
            0.9963691234588623,
            0.9966354370117188
        ]
    },
    "3667": {
        "similarity": 0.9962947368621826,
        "body": "from collections import defaultdict\nimport sys\n\n    graph = defaultdict(list)\n    intersections = set()\n    \n    # Build the graph and find intersections\n    for s, x1, y1 in pipes:\n        for e, x2, y2 in pipes:\n            if s != e and (x1 == x2 or y1 == y2) and (s, x1, y1) < (e, x2, y2):\n                intersections.add((min(x1, x2), min(y1, y2)))\n    \n    # Check each well to see if it is reachable from any other well\n    for i in range(w):\n        stack = [i]\n        visited = set()\n        while stack:\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        stack.append(neighbor)\n        \n        # Check if all intersections can be reached from the current well\n        unreachable_intersections = set(intersections) - visited\n        if reachable_intersections:\n            return \"impossible\"\n    \n    return \"possible\"\n\n# Read input\nw, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for _ in range(w)]\npipes = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output result\nprint(can_clean_all_intersections(w, p, wells, pipes))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953303933143616,
            0.9962224364280701,
            0.9957209229469299,
            0.9952750205993652,
            0.9952637553215027,
            0.9942300915718079,
            0.9959903359413147,
            0.9953456521034241,
            0.9944237470626831,
            0.992401123046875,
            0.9949780702590942,
            0.995200514793396,
            0.9955941438674927,
            0.9941319227218628,
            0.9946402311325073,
            0.9929445385932922,
            0.994354248046875,
            0.9954478740692139,
            0.9962947368621826,
            0.9953370690345764
        ]
    },
    "3959": {
        "similarity": 0.9977981448173523,
        "body": "from collections import Counter\n\n    MOD = 10**9 + 7\n    \n    # Calculate the frequency of each Pokemon type in all gyms\n    type_count = Counter()\n    for gym in gyms:\n        for type_ in gym[1:]:\n            type_count[type_] += 1\n    \n    # Check if it's possible to have the same number of each type after evolving\n    for count in type_count.values():\n        if count % n != 0:\n            return 0\n    \n    # Calculate the number of valid evolution plans\n    result = 1\n    for count in type_count.values():\n        result *= pow(m, count // n, MOD)\n        m -= 1\n        result %= MOD\n    \n    return result\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\n\ngyms = []\nindex = 2\nfor i in range(n):\n    g_i = int(data[index])\n    gym = [g_i]\n    index += 1\n    for _ in range(g_i):\n        type_ = int(data[index])\n        index += 1\n        gym.append(type_)\n    gyms.append(gym)\n\n# Output the result\nprint(count_evolution_plans(n, m, gyms))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9975777864456177,
            0.9971124529838562,
            0.996813952922821,
            0.9960931539535522,
            0.9964025616645813,
            0.9976007342338562,
            0.997600257396698,
            0.9968535900115967,
            0.9954614043235779,
            0.9961361289024353,
            0.9962638020515442,
            0.9977981448173523,
            0.9967302083969116,
            0.9963812828063965,
            0.9974707365036011,
            0.9970272779464722,
            0.9971988201141357,
            0.996512770652771,
            0.9976770281791687,
            0.9953683614730835
        ]
    },
    "3692": {
        "similarity": 0.994840145111084,
        "body": "import sys\n\n        return (x - cx) ** 2 + (y - cy) ** 2 <= r ** 2\n    \n    regions = 1\n    for i in range(n):\n        x1, y1, r1 = circles[i]\n        for j in range(i + 1, n):\n            x2, y2, r2 = circles[j]\n            if in_circle(x1, y1, x2, y2, r2) and in_circle(x2, y2, x1, y1, r1):\n                regions += 1\n    return regions\n\nif __name__ == \"__main__\":\n    n = int(input())\n    circles = [tuple(map(int, input().split())) for _ in range(n)]\n    print(count_regions(n, circles))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9947875142097473,
            0.9928805828094482,
            0.9942725300788879,
            0.994840145111084,
            0.9877022504806519,
            0.9936991333961487,
            0.9909244179725647,
            0.9935262799263,
            0.9904472827911377,
            0.9859713315963745,
            0.9924413561820984,
            0.9905602335929871,
            0.9933283925056458,
            0.988673985004425,
            0.9942570924758911,
            0.9923573732376099,
            0.9919969439506531,
            0.9859046936035156,
            0.994587242603302,
            0.9947397112846375
        ]
    },
    "3894": {
        "similarity": 0.9972016215324402,
        "body": "    even_piles = sum(1 for x in a if x % 2 == 0)\n    odd_cows = sum(x % 2 for x in a)\n\n    if even_piles > 0:\n        return \"Kevin\"\n    elif odd_cows % 2 == 1:\n        return \"Kevin\"\n    else:\n        return \"Nicky\"\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(lieges_of_legendre(n, k, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.99654620885849,
            0.9965786337852478,
            0.9958943128585815,
            0.9949244260787964,
            0.9965139031410217,
            0.9951801300048828,
            0.9948335289955139,
            0.9972016215324402,
            0.9965139627456665,
            0.9959142804145813,
            0.987107515335083,
            0.9967483878135681,
            0.9962577819824219,
            0.9955272674560547,
            0.9967097043991089,
            0.996535062789917,
            0.9964068531990051,
            0.9955272674560547,
            0.996600329875946,
            0.99615877866745
        ]
    },
    "3856": {
        "similarity": 0.9971765279769897,
        "body": "import sys\nfrom itertools import combinations\n\n    max_height = max(f[1] for f in friends)\n    areas = [f[0] * f[1] for f in friends]\n    \n    if n <= 2:\n        return sum(areas) + (max_height - 1) * (sum(max(f[0], f[1]) for f in friends))\n    \n    min_area = float('inf')\n    half_n = n // 2\n    \n    for comb in combinations(range(n), half_n):\n        standing_area = sum(areas[i] if i not in comb else max(friends[i][0], friends[i][1]) * max_height for i in range(n))\n        min_area = min(min_area, standing_area)\n    \n    return min_area\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nfriends = [(int(data[2*i+1]), int(data[2*i+2])) for i in range(n)]\n\nprint(min_photo_area(n, friends))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968571066856384,
            0.9959046244621277,
            0.9968629479408264,
            0.9971765279769897,
            0.996931254863739,
            0.9966747164726257,
            0.9968346357345581,
            0.9936083555221558,
            0.994746744632721,
            0.9956371188163757,
            0.9945398569107056,
            0.9962158203125,
            0.997023344039917,
            0.9958782196044922,
            0.9952486753463745,
            0.9935120344161987,
            0.9966567158699036,
            0.996997058391571,
            0.9968599081039429,
            0.9969245791435242
        ]
    },
    "3282": {
        "similarity": 0.9972692728042603,
        "body": "    count = 0\n    bills = []\n    for b in range(1, P//2):\n        m = P - b\n        if m <= b:\n            continue\n        digits = set()\n        digits.update(str(b))\n        digits.update(str(m))\n        if len(digits) == len(str(b)) + len(str(m)):\n            count += 1\n            bills.append((b, m))\n    return count, bills[:5000]\n\nif __name__ == \"__main__\":\n    P = int(input().strip())\n    result_count, result_bills = count_free_desserts(P)\n    print(result_count)\n    for bill in result_bills:\n        print(*bill)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9968383312225342,
            0.9923089742660522,
            0.9972692728042603,
            0.9969404339790344,
            0.9961317181587219,
            0.9958494901657104,
            0.9961578249931335,
            0.9957448244094849,
            0.995552659034729,
            0.994225263595581,
            0.9964714050292969,
            0.9963232278823853,
            0.9968845248222351,
            0.9961443543434143,
            0.9971154928207397,
            0.9921374917030334,
            0.9963573813438416,
            0.9969179034233093,
            0.9970932006835938,
            0.9967734813690186
        ]
    },
    "3596": {
        "similarity": 0.9978328347206116,
        "body": "import math\nfrom scipy.special import erf, gamma, jn\n\n    return c * integral(lambda x: t1 * gamma(x) + (math.log(erf(t3 * x)) ** (1 / t2)) - (jn(t4, x) ** t4), a, b)\n\n    n = 1000\n    h = (b - a) / n\n    return sum(func(a + i * h) for i in range(n + 1)) * h\n\n    coeffs = [f(i, a, b, c, t1, t2, t3, t4) / math.factorial(i) for i in range(r + 1)]\n    return sum(coeffs[i] * x**i for i in range(r + 1))\n\n    if n == 0:\n        return P(x)\n    else:\n        return sum(P(j, n - 1) * x**j for j in range(n + 1))\n\n    p_s = P_n(x, s)\n    degree = len(p_s.__str__().split()) - 1\n    return [coeff * i for i, coeff in enumerate(p_s.coeffs)][degree] if hasattr(p_s, 'coeffs') else [p_s(degree)]\n\n    x = P_n(n, r)\n    g_x = g(x, s)\n    return ((g_x[0] + l)**2 / (math.pi * math.e)) + (1 / (l + 1))\n\n# Read input from stdin\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\nn, k, r, s, l = map(int, input().split())\n\n# Calculate and print the result\nresult = location(a, b, c, t1, t2, t3, t4, n, k, r, s, l)\nprint(f\"{result:.6f}\")",
        "result": "failed: testcase 0",
        "similarities": [
            0.9974222779273987,
            0.9974831342697144,
            0.9974592328071594,
            0.9968808889389038,
            0.9958327412605286,
            0.9978328347206116,
            0.996985912322998,
            0.9975993633270264,
            0.9972058534622192,
            0.994171679019928,
            0.9967983961105347,
            0.9969139099121094,
            0.997572660446167,
            0.9975513815879822,
            0.9963157176971436,
            0.9977830648422241,
            0.9973000288009644,
            0.9971426129341125,
            0.9952672719955444,
            0.997327983379364
        ]
    },
    "3540": {
        "similarity": 0.9963796734809875,
        "body": "    # Read the input grid\n    grid = [list(input().strip()) for _ in range(4)]\n    \n    # Define the target state\n    target_state = [['R', 'G', 'B', 'Y']] + [['G', 'B', 'Y', 'R']] + [['B', 'Y', 'R', 'G']] + [['Y', 'R', 'G', 'B']]\n    \n    min_moves = float('inf')\n    \n    # Check all possible starting positions\n    for i in range(4):\n        for j in range(4):\n            current_state = [grid[(i + k) % 4][j] for k in range(4)]\n            moves = 0\n            \n            # Calculate the number of moves to align with the target state\n            for k in range(4):\n                if current_state[k] != target_state[0][k]:\n                    moves += abs((target_state[0].index(current_state[k]) - k + 4) % 4)\n            \n            min_moves = min(min_moves, moves)\n    \n    # Output the minimum number of moves\n    print(min_moves)\n\nmin_moves_to_solve()",
        "result": "failed: testcase 0",
        "similarities": [
            0.9923166036605835,
            0.9958046674728394,
            0.9963796734809875,
            0.9951131939888,
            0.9956843852996826,
            0.9947358965873718,
            0.9959650635719299,
            0.9946514964103699,
            0.9952217936515808,
            0.9939401745796204,
            0.9960128664970398,
            0.9955925345420837,
            0.993923008441925,
            0.9963493347167969,
            0.9961149096488953,
            0.9949579834938049,
            0.9928166270256042,
            0.9961819052696228,
            0.9938696026802063,
            0.9938237071037292
        ]
    },
    "3354": {
        "similarity": 0.9971126914024353,
        "body": "import math\n\n    area_sandwich = math.pi * s**2\n    max_area_covered = area_sandwich * z / 100\n    num_fit = 0\n    \n    if r > s - r:\n        return 0\n    \n    radius_ratio = r / s\n    effective_radius = radius_ratio * (s - r)\n    \n    while n >= 1 and (num_fit + 1) * math.pi * effective_radius**2 <= max_area_covered:\n        num_fit += 1\n        n -= 1\n    \n    return num_fit\n\n# Read input\ns, r, n, z = map(float, input().split())\nn = int(n)\nz = int(z)\n\n# Output the result\nprint(max_pickles(s, r, n, z))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9951838254928589,
            0.9959546327590942,
            0.9962174296379089,
            0.9961087107658386,
            0.9962120056152344,
            0.9969711303710938,
            0.9959718585014343,
            0.9959229230880737,
            0.9948722720146179,
            0.9971126914024353,
            0.9946125745773315,
            0.9966261982917786,
            0.9969397187232971,
            0.9969924092292786,
            0.9957516193389893,
            0.9957907795906067,
            0.9965246319770813,
            0.9959302544593811,
            0.9958457946777344,
            0.9970667958259583
        ]
    },
    "3217": {
        "similarity": 0.9964998960494995,
        "body": "    if not defective_cells:\n        return 0\n    \n    min_x = min(cell[0] for cell in defective_cells)\n    max_x = max(cell[0] for cell in defective_cells)\n    min_y = min(cell[1] for cell in defective_cells)\n    max_y = max(cell[1] for cell in defective_cells)\n    min_z = min(cell[2] for cell in defective_cells)\n    max_z = max(cell[2] for cell in defective_cells)\n    \n    width = max_x - min_x + 1\n    height = max_y - min_y + 1\n    depth = max_z - min_z + 1\n    \n    return (width * 2) + (height * 2) + (depth * 2)\n\n# Read input from stdin\nn = int(input())\n\n# Print the result\nprint(min_panels(defective_cells))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9952060580253601,
            0.9952760338783264,
            0.9961572289466858,
            0.9948212504386902,
            0.9958564639091492,
            0.9957178831100464,
            0.9949985146522522,
            0.9962900876998901,
            0.9952304363250732,
            0.9947822093963623,
            0.9914939403533936,
            0.9936709403991699,
            0.9956082105636597,
            0.9964998960494995,
            0.9912275075912476,
            0.9946114420890808,
            0.9962737560272217,
            0.9951224327087402,
            0.9957873821258545,
            0.9944965243339539
        ]
    },
    "3520": {
        "similarity": 0.9972735047340393,
        "body": "import sys\n\n    # Sort pills by their introduction time\n    pills.sort()\n    \n    # Initialize variables\n    max_age = n\n    current_age = 0\n    last_pill_index = -1\n    \n    for i in range(p):\n        t_i, x_i, y_i = pills[i]\n        \n        if t_i > 0:\n            # Age due to time passing without a pill\n            current_age += max(0, t_i - current_age)\n        \n        if last_pill_index >= 0 and last_pill_index != i:\n            # Age due to switching pills\n            current_age += c\n        \n        # Calculate the maximum age you can achieve with this pill\n        max_age = max(max_age, current_age + (x_i - y_i))\n        \n        # Update the last pill index\n        last_pill_index = i\n    \n    return max_age\n\n# Read input\nn, p, c = map(int, input().split())\npills = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output the result\nprint(max_life(n, p, c, pills))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9969520568847656,
            0.9948172569274902,
            0.9969936013221741,
            0.9958134889602661,
            0.9959477782249451,
            0.9967281222343445,
            0.9964923858642578,
            0.9966228008270264,
            0.9966477751731873,
            0.9969817996025085,
            0.9966100454330444,
            0.9944953918457031,
            0.9962961077690125,
            0.996002733707428,
            0.9964128136634827,
            0.99309903383255,
            0.9965243935585022,
            0.9972735047340393,
            0.9958811402320862,
            0.9950252175331116
        ]
    },
    "3475": {
        "similarity": 0.9971181154251099,
        "body": "import sys\nfrom typing import List, Tuple\n\n    min_switches = float('inf')\n    \n        nonlocal min_switches\n        if current_index == n - 1:\n            min_switches = min(min_switches, current_type)\n            return\n        \n        for next_type in range(t):\n            next_min_distance, next_max_heading_range = transportation_types[next_type]\n            next_distance, next_angle = distances_and_angles[current_index]\n            \n            if current_distance + next_distance >= next_min_distance and abs(current_angle - next_angle) <= next_max_heading_range:\n                backtrack(current_index + 1, next_type, current_distance + next_distance, next_angle)\n    \n    for i in range(t):\n        backtrack(0, i, 0, distances_and_angles[0][1])\n    \n    return min_switches if min_switches != float('inf') else -1\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    n = int(data[index + 1])\n    transportation_types = []\n    distances_and_angles = []\n    \n    for _ in range(t):\n        d_min = int(data[index + 2])\n        a_max = int(data[index + 3])\n        transportation_types.append((d_min, a_max))\n        index += 4\n    \n    for _ in range(n - 1):\n        d_i = int(data[index])\n        h_i = int(data[index + 1])\n        distances_and_angles.append((d_i, h_i))\n        index += 2\n    \n    result = can_visit_all_points(t, n, transportation_types, distances_and_angles)\n    \n    if result == -1:\n        print(\"IMPOSSIBLE\")\n    else:\n        print(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9966115355491638,
            0.9965852499008179,
            0.9965949654579163,
            0.996772050857544,
            0.9957042336463928,
            0.9971181154251099,
            0.9952480792999268,
            0.9966537356376648,
            0.9959922432899475,
            0.9963566660881042,
            0.9963010549545288,
            0.9963236451148987,
            0.994171679019928,
            0.9963119029998779,
            0.9948998689651489,
            0.9964207410812378,
            0.9967977404594421,
            0.9963710308074951,
            0.99676114320755,
            0.9964011311531067
        ]
    },
    "3977": {
        "similarity": 0.9976372122764587,
        "body": "import sys\n\n    # Create a set of government nodes for quick lookup\n    government_set = set(governments)\n    \n    # Count the number of edges that connect non-government nodes\n    valid_edges = 0\n    for u, v in edges:\n        if u not in government_set and v not in government_set:\n            valid_edges += 1\n    \n    # Calculate the maximum number of edges that can be added\n    max_possible_edges = (n - k) * (n - k - 1) // 2\n    additional_edges = max(0, max_possible_edges - valid_edges)\n    \n    return additional_edges\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ngovernments = list(map(int, data[3:3+k]))\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\n# Calculate and print the result\nresult = max_edges(n, m, k, governments, edges)\nprint(result)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9958472847938538,
            0.9954639077186584,
            0.996720552444458,
            0.9968777894973755,
            0.9969881772994995,
            0.9970784783363342,
            0.9971662163734436,
            0.9976372122764587,
            0.9970287680625916,
            0.9971988201141357,
            0.9968351125717163,
            0.9972406625747681,
            0.9971399903297424,
            0.9971460103988647,
            0.9965404868125916,
            0.9975254535675049,
            0.9974542856216431,
            0.9967764019966125,
            0.9940699338912964,
            0.9963270425796509
        ]
    },
    "3626": {
        "similarity": 0.9980687499046326,
        "body": "    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, x2, y2 = rectangles[i]\n            x3, y3, x4, y4 = rectangles[j]\n            if not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1):\n                return 1\n    return 0\n\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\nprint(check_intersections(n, rectangles))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9973531365394592,
            0.9971728324890137,
            0.9980260133743286,
            0.9969907999038696,
            0.9970977306365967,
            0.9974919557571411,
            0.997894823551178,
            0.9954182505607605,
            0.9975335001945496,
            0.9973596334457397,
            0.9969010949134827,
            0.9980687499046326,
            0.9967597126960754,
            0.9978705048561096,
            0.9971054792404175,
            0.9972772002220154,
            0.9977967143058777,
            0.9980311989784241,
            0.9970018267631531,
            0.9973849058151245
        ]
    },
    "3584": {
        "similarity": 0.9961158633232117,
        "body": "import sys\nfrom itertools import combinations\nfrom scipy.spatial import ConvexHull\n\n    hull = ConvexHull(posts)\n    selected_posts = set(hull.vertices)\n\n        return any(\n            (point[0] - v1[0]) * (v2[1] - v1[1]) + \n            (v1[0] - point[0]) * (v2[1] - v1[1]) >= 0\n            for v1, v2 in zip(vertices, vertices[1:] + [vertices[0]])\n        )\n\n    max_protected = 0\n    for k in range(K + 1):\n        for additional_posts in combinations(hull.vertices, k):\n            protected_onions = sum(\n                is_within_convex_hull(onion, selected_posts | set(additional_posts))\n                for onion in onions\n            )\n            if protected_onions > max_protected:\n                max_protected = protected_onions\n\n    print(max_protected)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    M = int(data[index])\n    index += 1\n    K = int(data[index])\n    index += 1\n    \n    onions = []\n    for _ in range(N):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        onions.append((X, Y))\n        index += 2\n    \n    posts = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        posts.append((A, B))\n        index += 2\n    \n    max_onions_protected(N, M, K, onions, posts)",
        "result": "failed: testcase 0",
        "similarities": [
            0.9918501973152161,
            0.9947662353515625,
            0.9945427775382996,
            0.9953870177268982,
            0.9954460859298706,
            0.9959896802902222,
            0.9932736754417419,
            0.995863676071167,
            0.9952043294906616,
            0.9952784180641174,
            0.9951249957084656,
            0.9961158633232117,
            0.9955941438674927,
            0.9937242269515991,
            0.9958515167236328,
            0.9941805601119995,
            0.9960594177246094,
            0.9936188459396362,
            0.9942540526390076,
            0.9960740804672241
        ]
    },
    "3950": {
        "similarity": 0.9974424242973328,
        "body": "    if any(x > q or x == 0 for x in a):\n        return \"NO\"\n    \n        count = [0] * (q + 1)\n        for i in range(n):\n            if a[i] != 0:\n                count[a[i]] += 1\n        return all(x > 0 for x in count[1:])\n    \n    if not can_restore():\n        return \"NO\"\n    \n    result = [0] * n\n    for i in range(q, 0, -1):\n        if any(a[j] == 0 for j in range(n)):\n            pos = next(j for j in range(n) if a[j] == 0)\n            result[pos] = i\n            a[pos] = i\n    \n    return \"YES\\n\" + ' '.join(map(str, result))\n\n# Read input from stdin\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(restore_array(n, q, a))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9954450726509094,
            0.997056245803833,
            0.9955875277519226,
            0.9971438050270081,
            0.9970236420631409,
            0.9966120719909668,
            0.9965943098068237,
            0.9949527382850647,
            0.9965013265609741,
            0.9963678121566772,
            0.9971480965614319,
            0.997267484664917,
            0.9974424242973328,
            0.9964911937713623,
            0.9959873557090759,
            0.9940813779830933,
            0.9970223307609558,
            0.9966926574707031,
            0.9971242547035217,
            0.9971850514411926
        ]
    },
    "3075": {
        "similarity": 0.9972004294395447,
        "body": "import sys\nfrom typing import List\n\n    if n == 1:\n        return \"cancel road trip\"\n    \n    stations.sort()\n    total_cost = 0\n    current_fuel = g\n    \n    for i in range(n - 1):\n        distance_to_next = stations[i + 1][0] - stations[i][0]\n        if current_fuel < distance_to_next:\n            return \"cancel road trip\"\n        \n        fuel_needed = distance_to_next\n        if fuel_needed > current_fuel:\n            cost_per_gallon = stations[i][1]\n            additional_fuel_cost = (fuel_needed - current_fuel) * cost_per_gallon\n            total_cost += additional_fuel_cost\n            current_fuel = g\n        \n        current_fuel -= fuel_needed\n    \n    return str(total_cost)\n\n# Read input from stdin\nn, g = map(int, input().split())\nstations = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(min_cost_to_travel(n, g, stations))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9964051842689514,
            0.9949301481246948,
            0.9962747693061829,
            0.9950954914093018,
            0.9966382384300232,
            0.9943410158157349,
            0.9953505992889404,
            0.9970464110374451,
            0.9952053427696228,
            0.9958837628364563,
            0.9971086382865906,
            0.9966641664505005,
            0.9950305819511414,
            0.9965952634811401,
            0.9959560036659241,
            0.9963806867599487,
            0.9941090941429138,
            0.9946837425231934,
            0.9972004294395447,
            0.9944524168968201
        ]
    },
    "3711": {
        "similarity": 0.9962148070335388,
        "body": "    if n * m <= k + 1:\n        return -1\n    total_cuts = min(k, n - 1) + min(k, m - 1)\n    if total_cuts < k:\n        return -1\n    pieces = n * m - k\n    smallest_piece_area = (n * m - pieces) // pieces\n    return smallest_piece_area\n\n# Read input from stdin\nn, m, k = map(int, input().split())\n\n# Print the result\nprint(max_smallest_piece_area(n, m, k))",
        "result": "failed: testcase 0",
        "similarities": [
            0.9953661561012268,
            0.9931977987289429,
            0.9960464835166931,
            0.9929835796356201,
            0.9945263266563416,
            0.9962148070335388,
            0.9961731433868408,
            0.995390772819519,
            0.9942477345466614,
            0.9907917380332947,
            0.9934511780738831,
            0.9942999482154846,
            0.9956018328666687,
            0.9947680234909058,
            0.9952413439750671,
            0.9956761598587036,
            0.995186984539032,
            0.993432879447937,
            0.9954584836959839,
            0.9951745271682739
        ]
    }
}