{
    "4693": {
        "body": "a = int(input().split()[0])\nb = int(input().split()[1])\nprint(\"error\" if a + b >= 10 else str(a + b))",
        "result": "failed: testcase 0"
    },
    "4077": {
        "body": "    n = len(a)\n    ans = 0\n    for i in range(n):\n        if a[i] > m: break\n        l = i\n        while l < n-1 and a[l+1] <= m:\n            l += 1\n        r = l\n        while r < n-1 and a[r+1] == m:\n            r += 1\n        ans += (r-l+1)*(r-i+1)\n    return ans",
        "result": "failed: testcase 0"
    },
    "4006": {
        "body": "    while x > 9 and x % 10 == 0:\n        x //= 10\n    return x + 1\n\nn = int(input())\ns = set()\nwhile n not in s:\n    s.add(n)\n    n = f(n)\n\nprint(len(s))",
        "result": "failed: testcase 0"
    },
    "4556": {
        "body": "    return s[0] + 'C'",
        "result": "failed: testcase 0"
    },
    "4571": {
        "body": "    return sum(i * 1900 / (2 ** i) for i in range(1, min(m + 1, n + 1)))",
        "result": "failed: testcase 0"
    },
    "4019": {
        "body": "    n, m, D = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v - 1, u - 1))\n    edges.sort(key=lambda x: x[0])\n    adj = [[] for _ in range(n)]\n    degrees = [0] * n\n    for v, u in edges:\n        adj[v].append(u)\n        adj[u].append(v)\n        degrees[v] += 1\n        degrees[u] += 1\n\n    parent = list(range(n))\n    rank = [0] * n\n\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                parent[rooty] = rootx\n            else:\n                parent[rootx] = rooty\n                if rank[rootx] == rank[rooty]:\n                    rank[rooty] += 1\n\n    for v, u in edges:\n        if find(v) != find(u):\n            union(v, u)\n\n    count = [0] * n\n    degree1 = degrees[0]\n    for i in range(1, n):\n        root = find(i)\n        if parent[root] == root and degrees[root] >= D and rank[root] + 1 < n:\n            count[root] += 1\n\n    if degrees[0] > D or (degrees[0] == D and any(count[i] == 0 for i in range(1, n) if find(i) != find(0))):\n        print(\"NO\")\n        return\n    else:\n        print(\"YES\")\n\n    parent = list(range(n))\n    rank = [0] * n\n\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n        rootx = find(x)\n        rooty = find(y)\n        if rootx != rooty:\n            if rank[rootx] > rank[rooty]:\n                parent[rooty] = rootx\n            else:\n                parent[rootx] = rooty\n                if rank[rootx] == rank[rooty]:\n                    rank[rooty] += 1\n\n    for v, u in edges:\n        if find(v) != find(u):\n            union(v, u)\n            if degrees[v] > D or degrees[u] > D:\n                continue\n            if degree1 < D and find(0) == find(v):\n                print(u + 1, \" \", 1)\n                degree1 += 1\n                count[find(v)] -= 1\n            elif count[find(v)] == 0:\n                print(v + 1, \" \", u + 1)\n                count[find(v)] = 2\n\n    for i in range(1, n):\n        if degrees[i] > D or (degrees[i] == D and find(i) != find(0)):\n            continue\n        root = find(i)\n        for x in adj[i]:\n            if parent[x] == x:\n                print(x + 1, \" \", i + 1)\n\nfind_spanning_tree()",
        "result": "failed: testcase 0"
    },
    "4265": {
        "body": "    counter_S = [0] * 26\n    counter_T = [0] * 26\n    for i in range(len(S)):\n        counter_S[ord(S[i]) - ord('a')] += 1\n        counter_T[ord(T[i]) - ord('a')] += 1\n\n    operations = 0\n    for i in range(26):\n        operations += abs(counter_S[i] - counter_T[i])\n\n    return operations - len(set(S))\n\nprint(min_operations(input(), input()))",
        "result": "failed: testcase 0"
    },
    "4657": {
        "body": "    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if a[i - 1] % 2 == 1:\n            dp[i] = 1\n        else:\n            dp[i] = dp[i - 1]\n\n    pre_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        pre_sum[i] = pre_sum[i - 1] ^ dp[i]\n\n    if (pre_sum[n] >> k) & 1:\n        return \"NO\"\n\n    ans = []\n    left = n\n    for _ in range(k):\n        while not ((pre_sum[left] >> _) & 1):\n            left -= 1\n\n        ans.append(left + 1)\n        new_left = left - 1\n        while new_left >= 0 and (dp[new_left] == 0 or pre_sum[new_left] != pre_sum[left]):\n            new_left -= 1\n\n        if new_left < 0:\n            return \"NO\"\n\n        left = new_left\n\n    ans.append(n + 1)\n    return \"YES\\n\" + ' '.join(map(str, reversed(ans)))\n\nq = int(input())\nfor _ in range(q):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(solve(n, k, a))",
        "result": "failed: testcase 0"
    },
    "4599": {
        "body": "n = int(input())\na = sorted(map(int, input().split()))\nprint(sum(a[::2]) - sum(a[1::2]))",
        "result": "failed: testcase 0"
    },
    "4774": {
        "body": "a, b, c, d = map(int, input().split())\nops = ['+', '-', '*', '/']\nvalid_exprs = []\n\nfor op1 in ops:\n    for op2 in ops:\n        try:\n            if eval(f'{a} {op1} {b} = {c} {op2} {d}') or eval(f'{c} {op2} {d} = {a} {op1} {b}'):\n                valid_exprs.append(f'{a} {op1} {b} = {c} {op2} {d}')\n        except ZeroDivisionError:\n            pass\n\nif not valid_exprs:\n    print('problems ahead')\nelse:\n    valid_exprs.sort()\n    for expr in valid_exprs:\n        print(expr)",
        "result": "failed: testcase 0"
    },
    "4851": {
        "body": "    while True:\n        d = sum(int(c) for c in str(n))\n        if n % d == 0:\n            return n\n        n += 1",
        "result": "failed: testcase 0"
    },
    "4655": {
        "body": "    t = a + b + c\n    return min((c - 1) // 2, max(a, b), (a + b + min(c, 1)) // 2)",
        "result": "failed: testcase 0"
    },
    "4132": {
        "body": "import sys\nimport random\n\nN = int(input())\nA = list(map(int, input().split()))\n\nA.sort()\nif N == 2:\n    print(min(A[0], A[1]))\nelse:\n    s = sum(A[:-1])\n    if s < A[-1]:\n        print(0)\n    else:\n        a = (s - A[-1] + A[-1] % 2) // (N - 1)\n        for _ in range(N-1):\n            idx = random.randint(0, N-2)\n            while A[idx] == a: idx = random.randint(0, N-2)\n            if A[idx] < a:\n                print(A[-1])\n                break\n            A[idx] -= a\n            s -= a\n        else:\n            print(a)",
        "result": "failed: testcase 0"
    },
    "4085": {
        "body": "    for _ in range(t):\n        n = int(input())\n        d = list(map(int, input().split()))\n        x = 1\n        for y in d:\n            if y != 1 and x % y:\n                x *= y\n        if len(d) < x:\n            print(-1)\n        else:\n            ans = 1\n            for i in range(len(d)):\n                if d[i] == x:\n                    ans = max(ans, x * d[(i+1)%len(d)])\n            print(min(ans,x))\n\n    return",
        "result": "failed: testcase 0"
    },
    "4399": {
        "body": "    return 'Yes' if 'A' in S and 'B' in S else 'No'",
        "result": "failed: testcase 0"
    },
    "4999": {
        "body": "    steps = 0\n    while a != b:\n        if a % 2 == 0:\n            a //= 2\n        else:\n            a += 1\n        steps += 1\n        if a > b:\n            break\n    return steps\n\na, b = map(int, input().split())\nprint(min_operations(a, b))",
        "result": "failed: testcase 0"
    },
    "4727": {
        "body": "grid = [list(map(int, input().split())) for _ in range(4)]\nmove = int(input())\n\nfor _ in range(move):\n    new_grid = [[0]*4 for _ in range(4)]\n\n    for i in range(4):\n        left = 0\n        for j in range(4):\n            if grid[i][j] != 0:\n                left += 1\n                new_grid[i][left-1] = grid[i][j]\n        right = len(grid[0]) - 1\n        for j in range(len(grid[0])-1, -1, -1):\n            if grid[i][j] != 0:\n                right -= 1\n                new_grid[i][right+1] = grid[i][j]\n\n    for i in range(4):\n        top = 0\n        for j in range(4):\n            if new_grid[j][i] != 0:\n                top += 1\n                new_grid[top-1][i] = new_grid[j][i]\n        bottom = len(new_grid) - 1\n        for j in range(len(new_grid)-1, -1, -1):\n            if new_grid[j][i] != 0:\n                bottom -= 1\n                new_grid[bottom+1][i] = new_grid[j][i]\n\n    new_grid = merge_rows(new_grid)\n    new_grid = merge_cols(new_grid)\n\n    grid = new_grid\n\n    for i in range(4):\n        left = 0\n        while left < len(grid[i]):\n            if grid[i][left] == 0:\n                del grid[i][left]\n                grid[i].insert(left, 0)\n            elif left + 1 < len(grid[i]) and grid[i][left] == grid[i][left+1]:\n                grid[i][left] *= 2\n                del grid[i][left+1]\n                grid[i].insert(left+1, 0)\n                left -= 1\n            left += 1\n\n    return grid\n\n    for i in range(4):\n        top = 0\n        while top < len(grid):\n            if grid[top][i] == 0:\n                del grid[top][i]\n                grid.insert(top, [0])\n            elif top + 1 < len(grid) and grid[top][i] == grid[top+1][i]:\n                grid[top][i] *= 2\n                del grid[top+1][i]\n                grid[top].insert(i, 0)\n                top -= 1\n            top += 1\n\n    return grid\n\nfor row in new_grid:\n    print(*row)",
        "result": "failed: testcase 0"
    },
    "4906": {
        "body": "    encoded = ''\n    i = 0\n    while i < len(input_str):\n        char_count = 1\n        while i + 1 < len(input_str) and input_str[i] == input_str[i+1]:\n            i += 1\n            char_count += 1\n        encoded += input_str[i] + str(char_count)\n        i += 1\n    return encoded\n\n    decoded = ''\n    i = 0\n    while i < len(encoded_str):\n        char = encoded_str[i]\n        count = int(encoded_str[i+1])\n        for _ in range(count):\n            decoded += char\n        i += 2\n    return decoded\n\ninput_str = input()\nmode, message = input_str[0], input_str[2:]\nif mode == 'E':\n    result = run_length_encoding(message)\nelif mode == 'D':\n    result = run_length_decoding(message)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4011": {
        "body": "    n = int(input())\n    a = list(map(int, input()))\n    b = list(map(int, input().split()))\n\n    if len(set(a)) == 1:\n        return ''.join(map(str, a))\n\n    sa = sorted(a)\n    sb = sorted(b)\n\n    k = -1\n    for i in range(n):\n        if a[i] < sb[k]:\n            k = n-1-i\n\n    ma = 0\n    c = [[i]*n for i in range(10)]\n    s = [0]\n    for i in range(n):\n        s.append(s[-1]+a[i])\n\n    d = dict()\n    for i in range(k+1, -1, -1):\n        d[a[i]] = a[i]\n\n    mx = ''.join(map(str, a))\n    for i in range(9):\n        for j in range(c[i][k], c[i][k]-1, -1):\n            if (s[k] <= s[j] and s[n-1] >= s[j+k-c[i][k]]) or d.get(i+1) == None:\n                cur = a[:c[i][k]]+['*']*j\n                for p in range(j, n-j+k+1):\n                    cur[p] = b[i]\n                for p in range(j+k, n):\n                    cur[p] = b[a[p]]\n                cur += [0]*(n-k)\n                mx = max(mx, ''.join(map(str, cur)))\n\n    return mx",
        "result": "failed: testcase 0"
    },
    "4099": {
        "body": "    N, K, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    total = sum(A)\n    avg = (total + M) / (N+1)\n    if avg > K:\n        return -1\n    needed = int(avg * (N+1)) - total\n    return needed",
        "result": "failed: testcase 0"
    },
    "4465": {
        "body": "    A, B = map(int, input().split())\n    return A * B - 2 - 2\n\nprint(calculate_area())",
        "result": "failed: testcase 0"
    },
    "4315": {
        "body": "import math\nR = float(input())\nprint(2 * math.pi * R)",
        "result": "passed"
    },
    "4633": {
        "body": "    while sum(int(d) for d in str(n)) > s:\n        n += 1\n    return n",
        "result": "failed: testcase 0"
    },
    "4734": {
        "body": "    if y[-1] == 'e':\n        return y + 'x' + p\n    elif y[-1] in 'aiou':\n        return y[:-1] + 'ex' + p\n    elif y.endswith('ex'):\n        return y + p\n    else:\n        return y + 'ex' + p",
        "result": "failed: testcase 0"
    },
    "4229": {
        "body": "    s = 0\n    for i in range(1, n+1):\n        if i % 3 == 0 and i % 5 == 0:\n            s += \"FizzBuzz\"\n        elif i % 3 == 0:\n            s += \"Fizz\"\n        elif i % 5 == 0:\n            s += \"Buzz\"\n        else:\n            s += str(i)\n    numbers = [int(i) for i in s.split() if not (i.startswith(\"Fizz\") or i == \"Buzz\")]\n    return sum(numbers)",
        "result": "failed: testcase 0"
    },
    "4321": {
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n",
        "result": "failed: testcase 0"
    },
    "4503": {
        "body": "    A.sort()\n    if len(A) != len(set(A)):\n        return \"No\"\n    for i in range(N-1, -1, -1):\n        H -= A[i]\n        if H <= 0:\n            break\n    return \"Yes\" if H <= 0 else \"No\"\n\nH, N = map(int, input().split())\nA = list(map(int, input().split()))\nprint(f(H, N, A))",
        "result": "failed: testcase 0"
    },
    "4855": {
        "body": "    return -(-a // b)\n\nA, I = map(int, input().split())\nprint(ceil_div(I * A, 1) - A)",
        "result": "failed: testcase 0"
    },
    "4704": {
        "body": "n = int(input())\na = list(map(int, input().split()))\nmin_diff = float('inf')\nfor i in range(1, n):\n    x = sum(a[:i])\n    y = sum(a[i:])\n    min_diff = min(min_diff, abs(x - y))\nprint(min_diff)",
        "result": "passed"
    },
    "4829": {
        "body": "a, b = map(int, input().split())\nif a == 0 and b == 0:\n    print(\"Not a moose\")\nelif a == b:\n    print(f\"Even {2 * a}\")\nelse:\n    print(f\"Odd {(max(a, b) << 1)}\")",
        "result": "passed"
    },
    "4730": {
        "body": "op = {'(': ')', '[': ']', '{': '}'}\nl = 0\nprev = None\nfor i, c in enumerate(input()):\n    if l > 0 and c != op[prev]:\n        print(c, i)\n        break\n    elif l > 0 and c == prev:\n        l -= 1\n    elif c not in op.keys() and c != ' ':\n        continue\n    elif c in op.keys():\n        l += 1\n        prev = c\nelse:\n    if l == 0:\n        print('ok so far')",
        "result": "failed: testcase 0"
    },
    "4729": {
        "body": "p = input().strip()\nm = input().strip()\n\ni, j = 0, 0\nwhile i < len(p) and j < len(m):\n    if p[i] == m[j]:\n        j += 1\n        c = ord(p[i]) + 1\n        while i < len(p) and ord(p[i]) != c:\n            i += 1\n    else:\n        i += 1\n\nprint(\"PASS\" if j == len(m) else \"FAIL\")",
        "result": "failed: testcase 0"
    },
    "4582": {
        "body": "a = input()\nb = input()\n\nif a == 'H':\n    if b == 'D':\n        print('D')\n    else:\n        print('H')\nelse:\n    if b == 'H':\n        print('D')\n    else:\n        print('H')",
        "result": "failed: testcase 0"
    },
    "4910": {
        "body": "from collections import defaultdict\nimport sys\n\nn = int(input())\ncounts = defaultdict(int)\nfor _ in range(n):\n    costume = input()\n    counts[costume] += 1\n\nmax_count = max(counts.values())\ncategories = [costume for costume, count in counts.items() if count == max_count]\nprint(' '.join(sorted(categories)))",
        "result": "failed: testcase 0"
    },
    "4323": {
        "body": "    a.sort(key=lambda x: (x[0] - x[1], x[0]))\n    for i in range(1, n):\n        if a[i-1][0] + a[i][0] > m:\n            break\n    else:\n        return 0\n\n    ans = 0\n    s = 0\n    for i, (ai, bi) in enumerate(a):\n        if s + ai <= m:\n            s += ai\n        elif s + ai - bi <= m:\n            s += ai - bi\n            ans += 1\n        else:\n            break\n\n    return len(a) - n if s > m else ans",
        "result": "failed: testcase 0"
    },
    "4626": {
        "body": "    return abs(a-b) + abs(a-c) + abs(b-c)\n\nq = int(input())\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    print(min(f(a,b,c), min(max(a,b)+min(c-a,c-b), max(a,c)+min(b-a,b-c))))",
        "result": "failed: testcase 0"
    },
    "4400": {
        "body": "    S = input()\n    return str(S.count('R'))",
        "result": "failed: testcase 0"
    },
    "4794": {
        "body": "    R, C = map(int, input().split())\n    grid = [list(input()) for _ in range(R)]\n    counts = [0] * 5\n    for i in range(0, R - 2):\n        for j in range(0, C - 2):\n            if grid[i][j] == '.' and grid[i][j + 1] == '.' and grid[i][j + 2] == '.' and \\\n               grid[i + 1][j] == '.' and grid[i + 1][j + 1] == '.' and grid[i + 1][j + 2] == '.':\n                if (grid[i][j + 3] != '#' and\n                    grid[i + 1][j + 3] != '#' and\n                    grid[i + 2][j + 3] != '#' and\n                    grid[i + 3][j + 3] != '#'):\n                    counts[4] += 1\n                elif (grid[i][j + 3] == '.' or grid[i][j + 3] == 'X') and \\\n                     (grid[i + 1][j + 3] == '.' or grid[i + 1][j + 3] == 'X') and \\\n                     (grid[i + 2][j + 3] == '.' or grid[i + 2][j + 3] == 'X'):\n                    counts[3] += 1\n                elif ((grid[i][j + 3] == '.' or grid[i][j + 3] == 'X') and \\\n                      (grid[i + 2][j + 3] == '.' or grid[i + 2][j + 3] == 'X')) or \\\n                     ((grid[i + 1][j + 3] == '.' or grid[i + 1][j + 3] == 'X') and \\\n                      (grid[i + 2][j + 3] == '.' or grid[i + 2][j + 3] == 'X')):\n                    counts[2] += 1\n                elif ((grid[i][j + 3] == '.' or grid[i][j + 3] == 'X') and \\\n                      (grid[i + 1][j + 3] == '.' or grid[i + 1][j + 3] == 'X')) or \\\n                     ((grid[i + 1][j + 3] == '.' or grid[i + 1][j + 3] == 'X') and \\\n                      (grid[i + 2][j + 3] == '.' or grid[i + 2][j + 3] == 'X')):\n                    counts[1] += 1\n                else:\n                    counts[0] += 1\n    for count in counts[:-1]:\n        print(count)\n    print(counts[-1])\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "4096": {
        "body": "    s = sum(a)\n    if s < m: return -1\n    a.sort(reverse=True)\n    res = 0\n    while True:\n        r = 0\n        for i in range(len(a)):\n            r += max(0, a[i] - (i + 1))\n            if r >= m:\n                break\n        else:\n            if len(a) == 0: return -1\n            res += 1\n            m -= r\n            a = [a[i] - i for i in range(len(a)) if a[i] > i]\n    return res + 1",
        "result": "failed: testcase 0"
    },
    "4530": {
        "body": "    s = set()\n    t = {}\n    for i in a:\n        if i not in s:\n            t[i] = 1\n        else:\n            s.add(i)\n    u = len(s)\n    v = sum(1 for i in a if i in t and t[i] < 2)\n    return min(u, (len(a) - v + 1) // 2)",
        "result": "failed: testcase 0"
    },
    "4724": {
        "body": "    return 2*G - R",
        "result": "failed: testcase 0"
    },
    "4276": {
        "body": "N, T = map(int, input().split())\nroutes = [list(map(int, input().split())) for _ in range(N)]\nroutes.sort(key=lambda x: x[1])\nfor c, t in routes:\n    if t <= T:\n        print(c)\n        break\nelse:\n    print('TLE')",
        "result": "failed: testcase 2"
    },
    "4708": {
        "body": "N = int(input())\nK = int(input())\nX = int(input())\nY = int(input())\n\nprint(N * X - K * X + (N - K) * Y)",
        "result": "failed: testcase 0"
    },
    "4396": {
        "body": "N = int(input())\ntotal = 0.0\nfor _ in range(N):\n    x, u = input().split()\n    if u == 'JPY':\n        total += float(x)\n    else:\n        total += float(x) * 380000.0\nprint(total)",
        "result": "passed"
    },
    "4155": {
        "body": "N = int(input())\nh = list(map(int, input().split()))\nans = 0\nprev = 0\nfor i in h:\n    if prev != i:\n        ans += 1\n        prev = i\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "4557": {
        "body": "    return \"YES\" if A <= X <= A + B else \"NO\"",
        "result": "failed: testcase 0"
    },
    "4930": {
        "body": "    vowels = 'aeiou'\n    words = sentence.split()\n    decoded_words = []\n    for word in words:\n        decoded_word = ''\n        i = 0\n        while i < len(word):\n            if word[i] in vowels:\n                decoded_word += word[i] + 'p' + word[i]\n                i += 2\n            else:\n                decoded_word += word[i]\n                i += 1\n        decoded_words.append(decoded_word)\n    return ' '.join(decoded_words)",
        "result": "failed: testcase 0"
    },
    "4715": {
        "body": "    a, b, c = map(int, input().split())\n    return len(set([a, b, c]))\n\nprint(count_colors())",
        "result": "failed: testcase 0"
    },
    "4008": {
        "body": "    while b:\n        a, b = b, a % b\n    return a\n\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    cnt = [0] * (k + 1)\n    vis = [False] * (n + 1)\n\n    for i in range(n):\n        cnt[a[i]] += 1\n\n    ans = [[i+1] * k for i in range(n)]\n\n    for i in range(1, k+1):\n        if cnt[i] > n-k+i:\n            print(\"NO\")\n            return\n        elif cnt[i] <= n-k+i:\n            for j in range(cnt[i], n):\n                ans[j][i-1] = a[j]\n                vis[a[j]] = True\n\n    b = sorted(a)\n    b = [x for x in b if not vis[x]]\n\n    p = 0\n    for i in range(k, 0, -1):\n        l = []\n        while p < n and (b[p] == i or a[p] in l):\n            l.append(a[p])\n            p += 1\n\n        for j, x in enumerate(l):\n            ans[a.index(x)][i-1] = j+1\n\n    print(\"YES\")\n    for line in ans:\n        print(*line)\n\nmain()",
        "result": "failed: testcase 0"
    },
    "4257": {
        "body": "    A, B = map(int, input().split())\n    return A * B",
        "result": "failed: testcase 0"
    },
    "4584": {
        "body": "    D = [0] * N\n    for i in range(1, N):\n        D[A[i-1]-1] += 1\n        D[i-1] += D[A[i-1]-1]\n    return '\\n'.join(map(str, D))",
        "result": "failed: testcase 0"
    },
    "4195": {
        "body": "    if D == 0:\n        return N\n    elif D == 1:\n        return 100 * (N + 1)\n    else:\n        return 10 * (100 * (N // 25) + (N % 25) + 1)\n\nD, N = map(int, input().split())\nprint(solve(D, N))",
        "result": "failed: testcase 0"
    },
    "4176": {
        "body": "    return max((A - 1) // A * A + 1, (B - 1) // B * B + 1)\n\nA = int(input().split()[0])\nB = int(input().split()[1])\n\nprint(f(min(A, B), max(A, B)))",
        "result": "failed: testcase 0"
    },
    "4166": {
        "body": "    N, M = map(int, input().split())\n    s_c = [list(map(int, input().split())) for _ in range(M)]\n    ans = '0' * N\n    for i, (s, c) in enumerate(s_c):\n        ans = ans[:s-1] + str(c) + ans[s:]\n    if int(ans) >= 0:\n        print(ans)\n    else:\n        print(-1)\n\n    f()\n\nfor _ in range(10000): \n    g()",
        "result": "failed: testcase 0"
    },
    "4827": {
        "body": "    if n < 10:\n        return [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"][n - 1]\n    elif n < 20:\n        return [\"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"][n - 11]\n    else:\n        return num_to_words(n // 10) + (\"zero\" if n % 10 == 0 else num_to_words(n % 10))\n\n    d = {\"one\": 1, \"two\": 2, \"three\": 3, \"four\": 4, \"five\": 5, \"six\": 6, \"seven\": 7, \"eight\": 8, \"nine\": 9,\n        \"eleven\": 11, \"twelve\": 12, \"thirteen\": 13, \"fourteen\": 14, \"fifteen\": 15, \"sixteen\": 16, \"seventeen\": 17,\n        \"eighteen\": 18, \"nineteen\": 19, \"twenty\": 20, \"thirty\": 30, \"forty\": 40, \"fifty\": 50, \"sixty\": 60, \"seventy\": 70,\n        \"eighty\": 80, \"ninety\": 90}\n    if s in d:\n        return d[s]\n    else:\n        x = int(s[:-1])\n        if s[-1] == \"zero\":\n            return x\n        else:\n            return x + words_to_num(s[-1])\n\n    if n < 20:\n        return num_to_words(n)\n    elif n < 100:\n        return num_to_words(n // 10) + (\"zero\" if n % 10 == 0 else num_to_words(n % 10))\n    else:\n        return num_to_words(n // 100) + \"hundred\" + (\"zero\" if n % 100 == 0 else num_words(n % 100))\n\n    i = words.index(\"$\")\n    count = sum(len(word) for word in words[:i])\n    words[i] = str(count)\n    return \" \".join(words)\n\nn = int(input())\nwords = [input() for _ in range(n)]\nprint(solve(words))",
        "result": "failed: testcase 0"
    },
    "4871": {
        "body": "    group_score = 0\n    for i in range(n):\n        group_score += scores[i] * ((4/5)**i)\n    return group_score / 5\n\n    total_sum = 0\n    for i in range(n):\n        new_group_score = f(n-1, scores[:i] + scores[i+1:])\n        total_sum += new_group_score\n    return total_sum / n",
        "result": "failed: testcase 0"
    },
    "4148": {
        "body": "    n = int(input())\n    s = input()\n    result = \"\"\n    for char in s:\n        if 'A' <= char <= 'Z':\n            result += chr((ord(char) - ord('A') + n) % 26 + ord('A'))\n        else:\n            result += char\n    print(result)",
        "result": "passed"
    },
    "4316": {
        "body": "    c = {}\n    for s in S:\n        c[s] = c.get(s, 0) + 1\n    return len(c) == 2 and all(v == 2 for v in c.values())",
        "result": "failed: testcase 0"
    },
    "4397": {
        "body": "N, i = map(int, input().split())\nprint(N - i + 1)",
        "result": "passed"
    },
    "4180": {
        "body": "    return N % 1000",
        "result": "failed: testcase 0"
    },
    "4907": {
        "body": "n = int(input())\nif n % 2 == 0:\n    print(\"Bob\")\nelse:\n    print(\"Alice\")\n    print(1)",
        "result": "failed: testcase 0"
    },
    "4839": {
        "body": "    n = int(input())\n    c = sorted(map(int, input().split()), reverse=True)\n    if sum(c) < sum(range(1, n+1)):\n        return 'impossible'\n    minfrac = 0.0\n    remain = 0\n    for i in range(n):\n        if c[i] == i + 1:\n            continue\n        elif c[i] > i + 1:\n            minfrac += (c[i] - i - 1) / (i + 1)\n            c[i] -= c[i] - i - 1\n        remain += c[i]\n    if n == 0:\n        return '1.000000'\n    minfrac += remain / n\n    print(f'{minfrac:.6f}')",
        "result": "failed: testcase 0"
    },
    "4665": {
        "body": "from collections import namedtuple\n\n    n = int(input())\n    columns = tuple(input().split())\n\n    Student = namedtuple('Student', columns)\n    students = []\n    \n    for _ in range(n):\n        line = input()\n        student = Student(*line.split())\n        students.append(student)\n\n    total_marks = sum(getattr(student, 'MARKS') for student in students)\n    average_mark = round(total_marks / n, 2)\n\n    return average_mark\n\nprint(calculate_average_marks())",
        "result": "failed: testcase 0"
    },
    "4785": {
        "body": "s = input()\nprint('hiss' if 'ss' in s else 'no hiss')",
        "result": "passed"
    },
    "4272": {
        "body": "    n = len(S)\n    count = 0\n    for i in range(n - 2):\n        if S[i:i+3] == 'ABC':\n            count += 1\n    return count",
        "result": "failed: testcase 0"
    },
    "4092": {
        "body": "    n = len(a)\n    p = [a[0]]\n    for i in range(1, n):\n        p.append(p[-1] + a[i])\n    m = max(p)\n    ans = 0\n    if abs(m) < abs(p[-1]):\n        ans += 1\n    for i in range(n-1):\n        if p[i+1] == 0:\n            ans += 1\n    return ans",
        "result": "failed: testcase 0"
    },
    "4023": {
        "body": "    n = len(a)\n    m = max(a)\n    if min(a) == m:\n        return 'YES'\n    for i in range(n-1):\n        if a[i] != a[i+1]:\n            return 'NO'\n    return 'YES'",
        "result": "failed: testcase 0"
    },
    "4160": {
        "body": "    y = 100\n    t = 0\n    while y < X:\n        t += 1\n        y *= 101 / 100\n    return t",
        "result": "failed: testcase 0"
    },
    "4815": {
        "body": "n, p, m = map(int, input().split())\nname_to_points = {}\nfor _ in range(n):\n    name = input()\n    if name not in name_to_points:\n        name_to_points[name] = 0\n\nfor _ in range(m - n):\n    name, points = input().split()\n    if name in name_to_points:\n        name_to_points[name] += int(points)\n\nwinner_names = []\nfor name, points in name_to_points.items():\n    if points >= p and (not winner_names or winner_names[-1][1] < points):\n        print(f\"{name} wins!\")\n        winner_names.append((name, points))\n\nif not winner_names:\n    print(\"No winner!\")\n",
        "result": "failed: testcase 0"
    },
    "4514": {
        "body": "    res = []\n    stack = [(u, 0)]\n    while stack:\n        a, b = stack.pop()\n        if a not in visited:\n            visited.add(a)\n            res.append(a)\n            for i in adj[a]:\n                if i[0] not in visited:\n                    stack.append((i[0], len(res)))\n    return res\n\n    v = dfs(u, set())\n    if k > len(v): return -1\n    else: return v[k-1]\n\nadj = {}\nn, q = map(int, input().split())\np = list(map(int, input().split()))\nfor i in range(n-1):\n    adj[p[i]] = [(i+2, 0)]\nfor i in range(1, n+1):\n    if i not in adj: adj[i] = []\n\nfor _ in range(q):\n    u, k = map(int, input().split())\n    print(query(u, k))",
        "result": "failed: testcase 0"
    },
    "4585": {
        "body": "    t = 1\n    while True:\n        if abs(X - t) % t == 0:\n            return t\n        t += 1",
        "result": "failed: testcase 0"
    },
    "4781": {
        "body": "k = int(input())\nn = int(input())\n\nbox_holder = k - 1\nfor _ in range(n):\n    t, z = input().split()\n    t = int(t)\n    if z == \"N\" or (z == \"P\" and box_holder == 0):\n        box_holder = (box_holder + 1) % 8\n\nprint(box_holder + 1)",
        "result": "failed: testcase 0"
    },
    "4551": {
        "body": "A,B,C,D = map(int,input().split())\nprint('Left' if A+B>C+D else 'Right' if A+B==C+D else 'Balanced')",
        "result": "failed: testcase 1"
    },
    "4345": {
        "body": "import sys\n\nn = int(input())\na = list(map(int, input().split()))\n\nb = [[], []]\nfor i in range(n):\n    if b[1] and a[i] < b[1][-1]:\n        b[0].append(a[i])\n        for j in b[1]:\n            b[0].append(j)\n        break\n    elif not b[0] or a[i] > b[0][-1]:\n        b[1].append(a[i])\n    else:\n        if b[1] and b[0] and b[1][-1] == b[0][-1]:\n            print('NO')\n            sys.exit(0)\n        for j in range(i, -1, -1):\n            if a[j] > b[1][-1]:\n                break\n            else:\n                b[1].pop()\n                i = j\n        b[0].append(a[i])\n        for j in range(i + 1, n):\n            b[0].append(a[j])\n\nif len(b[0]) != len(set(b[0])):\n    print('NO')\nelif len(b[1]) != len(set(b[1])):\n    print('NO')\nelse:\n    print('YES')\n    res = [0] * n\n    for i in range(n):\n        if a[i] in b[0]:\n            res[i] = 0\n    for i in range(n):\n        if a[i] in b[1]:\n            res[i] = 1\n    print(*res)",
        "result": "failed: testcase 1"
    },
    "4075": {
        "body": "from collections import defaultdict\n\nn, m = map(int, input().split())\nbulb_switches = defaultdict(list)\nfor i in range(m):\n    k, *switches = map(int, input().split())\n    for s in switches:\n        bulb_switches[i].append(s)\n\np = [int(x) for x in input().split()]\nresult = 0\n\n    for i in range(m):\n        count = sum(1 for s in bulb_switches[i] if combination[s-1])\n        if (count % 2) != p[i]:\n            return False\n    return True\n\nfor mask in range(2**n):\n    combination = [bool(mask >> i & 1) for i in range(n)]\n    result += is_lighted(combination)\n\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4408": {
        "body": "    c.sort()\n    h = h[::-1]\n    max_joy = 0\n    for i in range(1, len(h)):\n        if c[i-1][1] > 0:\n            t = min(c[i-1][1], c[i][1])\n            j = 0\n            while j < t:\n                max_joy += h[i]\n                c[i-1][1] -= 1\n                c[i][1] -= 1\n                for l in range(len(f)):\n                    if f[l] == c[i-1][0]:\n                        f[l][2] += 1\n                        if f[l][2] <= c[i-1][1]:\n                            j += 1\n            i = len(h) - 1\n    max_joy = sum([h[0]*x for x in f])\n    return max_joy\n\nn, k = map(int, input().split())\nc = list(map(int, input().split()))\nf = [[x, 0, 0] for x in map(int, input().split())]\nh = list(map(int, input().split()))\nprint(f(c, h, f))",
        "result": "failed: testcase 0"
    },
    "4282": {
        "body": "    n = int(input())\n    a = []\n    for i in range(n):\n        x, y = map(int, input().split())\n        a.append((x, y))\n    e = [[] for _ in range(n+1)]\n    for x, y in a:\n        if x != y:\n            e[x].append(y)\n            e[y].append(x)\n    v = [-1] * (n + 1)\n    s = []\n        v[u] = len(s)\n        s.append(u)\n        for p in e[u]:\n            if v[p] == -1:\n                dfs(p)\n    dfs(a[0][0])\n    ans = [0] * n\n    for i, (x, y) in enumerate(a):\n        u = v[x]\n        v2 = v[y]\n        if v2 < u:\n            ans[i] = a[u-1][y==a[u-1][0]]\n    return ' '.join(map(str, ans))",
        "result": "failed: testcase 0"
    },
    "4331": {
        "body": "    return 'Yes' if '7' in str(N) else 'No'\n\nN = int(input())\nprint(f(N))",
        "result": "failed: testcase 0"
    },
    "4550": {
        "body": "    s = a + b + c\n    return 'Yes' if s % 2 == 0 else 'No'\n\na, b, c = map(int, input().split())\nprint(f(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4271": {
        "body": "N = int(input())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nresult = B[0]\nfor i in range(1, N):\n    result += B[i] + C[i-1]\n\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4848": {
        "body": "    while b: a, b = b, a % b\n    return a\n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % (i * i) == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(2, n):\n    if is_square_free(m * n):\n        print(m)\n        break",
        "result": "failed: testcase 0"
    },
    "4694": {
        "body": "    n = len(arr)\n    arr.sort()\n    dist = float('inf')\n    for i in range(n):\n        dist = min(dist, max(0, 2 * arr[i] - (arr[-1] + arr[0])) + sum(abs(a - b) for a, b in zip(arr[:i], arr[i+1:])))\n    return dist",
        "result": "failed: testcase 0"
    },
    "4213": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    return max(abs(a[i] - a[j]) for i in range(n) for j in range(i + 1, n))",
        "result": "failed: testcase 0"
    },
    "4471": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    mx = max(a)\n    if sum((mx-1)//2 + 1 for _ in range(n)) >= mx:\n        return \"YES\"\n    else: \n        return \"NO\"\n\nt = int(input())\nfor i in range(t):\n    print(solve())",
        "result": "failed: testcase 0"
    },
    "4802": {
        "body": "h, m = map(int, input().split())\nnew_m = (m - 45) % 60\nnew_h = (h - 1 + (m - 45) // 60) % 24\nprint(new_h, new_m)",
        "result": "failed: testcase 0"
    },
    "4890": {
        "body": "n, m, s, d = map(int, input().split())\nc = list(map(int, input().split()))\np = [0] * s\nfor i in range(s):\n    p[i] = (d - c[i]) + 1\nopt = sum(p) < n\nif opt:\n    print(\"impossible\")\nelse:\n    for i in sorted(range(s), key=lambda i: p[i], reverse=True):\n        p[i] += min(n, d - c[i])\n        n -= p[i]\nprint(*p)",
        "result": "failed: testcase 0"
    },
    "4286": {
        "body": "    if parent[x] != x:\n        parent[x] = find(parent, parent[x])\n    return parent[x]\n\n    rootx = find(parent, x)\n    rooty = find(parent, y)\n\n    if rootx == rooty:\n        return\n\n    if rank[rootx] > rank[rooty]:\n        parent[rooty] = rootx\n    elif rank[rootx] < rank[rooty]:\n        parent[rootx] = rooty\n    else:\n        parent[rooty] = rootx\n        rank[rootx] += 1\n\n    stack = [s]\n    while stack:\n        node = stack.pop()\n        if not visited[node]:\n            visited[node] = True\n            for neighbor in graph[node]:\n                stack.append(neighbor)\n\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    edges = []\n    parent = [i for i in range(n+1)]\n    rank = [0]*(n+1)\n    total = 0\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        if find(parent, x) != find(parent, y):\n            union(parent, rank, x, y)\n            edges.append((w, max(a[x-1], a[y-1])))\n        else:\n            total += min(a[x-1] + a[y-1], w)\n\n    for i in range(n):\n        if parent[i+1] == i+1:\n            total += a[i]\n\n    visited = [False]*(n+1)\n    visited[find(parent, 1)] = True\n    dfs(edges, visited, find(parent, 1))\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            total += sum(a[:i])\n\n    print(total)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "4713": {
        "body": "x = 0\nN = int(input())\nS = input()\nfor c in S:\n    if c == 'I':\n        x += 1\n    else:\n        x -= 1\nprint(max(x, 0))",
        "result": "failed: testcase 0"
    },
    "4698": {
        "body": "    n = int(input())\n    t = list(map(int, input().split()))\n    m = int(input())\n    p = [0] * 101\n    x = []\n    for _ in range(m):\n        pi, xi = map(int, input().split())\n        p[pi] = xi\n        x.append(xi)\n    ans = [(sum(t) + sum(p[i] - t[i-1] for i in range(1, n+1))) for y in x]\n    print(*ans, sep='\\n')",
        "result": "failed: testcase 0"
    },
    "4841": {
        "body": "n = int(input())\na = list(map(str, input().split()))\ncnt = 0\nprev = -1\nfor x in a:\n    if x == \"mumble\":\n        cnt += 1\n    elif x.isdigit():\n        y = int(x)\n        if prev != -1 and prev + 1 < y:\n            print(\"something is fishy\")\n            break\n        prev = y\nelse:\n    print(\"makes sense\")",
        "result": "failed: testcase 0"
    },
    "4865": {
        "body": "N = int(input())\nfor _ in range(N):\n    d, h, m = [int(x) for x in input().split()[1:]]\n    if input().startswith('F'):\n        new_m = (m + d) % 60\n        new_h = (h + (m + d) // 60) % 24\n    else:\n        new_m = (m - d + 60) % 60\n        new_h = (h + (m - d) // 60) % 24\n    print(f'{new_h} {new_m}')",
        "result": "failed: testcase 0"
    },
    "4957": {
        "body": "import sys\n\nn, m = map(int, input().split())\ngrid = [list(input()) for _ in range(n)]\n\n    if 0 <= i < n and 0 <= j < m and grid[i][j] == '.':\n        grid[i][j] = 'E'\n        dfs(i - 1, j)\n        dfs(i + 1, j)\n        dfs(i, j - 1)\n        dfs(i, j + 1)\n\nfor i in range(n):\n    for j in range(m):\n        if grid[i][j] == '.':\n            dfs(i, j)\n\nfor row in grid:\n    print(''.join(row))",
        "result": "failed: testcase 0"
    },
    "4382": {
        "body": "N = int(input())\nprint(N ** 3)",
        "result": "passed"
    },
    "4456": {
        "body": "    c = [0] * 26\n    s = [''] * n\n    for i in range(n):\n        c[ord(p[i]) - ord('a')] += 1\n        c[ord(q[n-i-1]) - ord('a')] += 1\n    if min(c) < k:\n        return 'NO'\n    for i in range(k, n):\n        j = p[i-k]\n        s[j] = chr((i-k)+97)\n    for i in range(n):\n        x = max(0, p[i]-k)\n        y = q[n-i-1]-x\n        if 0 <= x < k and 0 <= y:\n            s[p[x]] = min(s[p[x]], chr(y+97))\n    return 'YES\\n' + ''.join(s)",
        "result": "failed: testcase 0"
    },
    "4594": {
        "body": "N = int(input())\ndiameters = [int(x) for x in input().split()]\ncount = 0\nmax_diameter = max(diameters)\nfor diameter in sorted(diameters, reverse=True):\n    if diameter <= max_diameter:\n        count += 1\n        max_diameter = diameter\nprint(count - 1)",
        "result": "failed: testcase 0"
    },
    "4560": {
        "body": "    if N < A:\n        return \"No\"\n    for i in range(A // 500 + 1):\n        if (N - i * 500) % 1 == 0:\n            return \"Yes\"\n    return \"No\"\n\nN = int(input())\nA = int(input())\nprint(can_pay(N, A))",
        "result": "failed: testcase 0"
    },
    "4320": {
        "body": "    return n // 2 if n % 2 == 0 else n",
        "result": "failed: testcase 0"
    },
    "4500": {
        "body": "A, B, C = map(int, input().split())\nprint('Yes' if A + B >= C else 'No')",
        "result": "passed"
    },
    "4739": {
        "body": "import sys\n\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\ndists = set()\nfor i in range(M):\n    for j in range(i + 1, M):\n        time_diff = T[j] - T[i]\n        if time_diff != 0:\n            dist = X[j] - X[i]\n            speed = (dist * 1503) // time_diff\n            dists.add(speed)\n\nprint(len(dists))\nprint(*sorted([x for x in dists if x <= X[N-1] - X[0]]))",
        "result": "failed: testcase 0"
    },
    "4410": {
        "body": "    one = []\n    for i in range(n):\n        if s[i] == '1':\n            one.append(i)\n    m = len(one)\n    ans = 0\n    if m == 0:\n        return 0\n    for i in range(2 * k + 1):\n        j = 0\n        while j < m and one[j] < one[i - (2 * k + 1)] + k:\n            j += 1\n        ans = max(ans, j)\n    return ans",
        "result": "failed: testcase 0"
    },
    "2441": {
        "body": "import sys\nfrom collections import deque, defaultdict\n\nmod = int(1e9) + 7\nn = int(input())\ncosts = list(map(int, input().split()))\nm = int(input())\n\nroads = [[] for _ in range(n)]\nfor i in range(m):\n    u, v = map(int, input().split())\n    roads[u-1].append(v-1)\n\n    vis[start] = True\n    dist[start] = 0\n    q.append(start)\n    while q:\n        node = q.popleft()\n        for neighbor in roads[node]:\n            if not vis[neighbor]:\n                vis[neighbor] = True\n                dist[neighbor] = dist[node] + 1\n                q.append(neighbor)\n\n    global ans, ways\n\n    dp = [0]*n\n    vis = [False]*n\n    dist = [float('inf')]*n\n    q = deque()\n    dfs(0)\n    for i in range(n):\n        if not vis[i]:\n            dfs(i)\n    for i in range(n):\n        dp[i] = costs[i]\n        for neighbor in roads[i]:\n            if dist[neighbor] % 2 == 0:\n                dp[i] = min(dp[i], costs[i])\n    ans = sum(dp)\n    ways = 1\n    dp[:n] = [0]*n\n\n    vis = [False]*n\n    q = deque()\n    for i in range(n):\n        if not vis[i]:\n            dfs(i)\n            dp[i] = costs[i]\n            for neighbor in roads[i]:\n                if dist[neighbor] % 2 == 0:\n                    dp[i] = min(dp[i], costs[i])\n                    ways = (ways * 2) % mod\n    print(ans, ways)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "276": {
        "body": "    n = int(input())\n    colors = []\n    for _ in range(n):\n        colors.append(input())\n\n    absent_names = ['Time', 'Mind', 'Soul', 'Power', 'Reality', 'Space']\n    present_names = [name for name, color in zip(absent_names, ['purple', 'green', 'blue', 'orange', 'red', 'yellow']) if color in colors]\n\n    print(len([name for name in absent_names if name not in present_names]))\n    print(*[name for name in absent_names if name not in present_names], sep='\\n')\n\nfind_absent_gems()",
        "result": "failed: testcase 0"
    },
    "2635": {
        "body": "m = int(input())\nn = int(input().split()[0])\nmatrix = []\nfor i in range(m):\n    row = list(map(int, input().split()))\n    matrix.append(row)\n\ntop = 0\nbottom = m - 1\nleft = 0\nright = n - 1\nresult = []\n\nwhile top <= bottom and left <= right:\n    for j in range(left, right + 1):\n        result.append(matrix[top][j])\n    top += 1\n\n    for i in range(top, bottom + 1):\n        result.append(matrix[i][right])\n    right -= 1\n\n    if top <= bottom:\n        for j in range(right, left - 1, -1):\n            result.append(matrix[bottom][j])\n        bottom -= 1\n\n    if left <= right:\n        for i in range(bottom, top - 1, -1):\n            result.append(matrix[i][left])\n        left += 1\n\nprint(*result)",
        "result": "timed out"
    },
    "281": {
        "body": "    res = 1\n    for i in range(2, n+1):\n        res *= i\n        res %= 10\n    return res\n\na, b = map(int, input().split())\nprint(factorial(b) // factorial(a))",
        "result": "failed: testcase 0"
    },
    "2300": {
        "body": "n, m = map(int, input().split())\na = [0] + list(map(int, input().split()))\nops = []\nfor _ in range(m):\n    op = list(map(int, input().split()))\n    ops.append(op)\n\nf = [[0]*2 for _ in range(200005)]\nfor i in range(1, 200001):\n    f[i][0] = 1\n    if i >= 2:\n        f[i][1] = f[i-2][0]+f[i-1][0]-1\n\n    l, r = ops[i][-2], ops[i][-1]\n    s = [0]*200005\n    for x in range(l, r+1):\n        c = 1 if x-l >= 3 else (x-l)\n        s[x] = f[c][r-l-x+l]\n    ans = 0\n    for i in range(1, n+1):\n        ans += s[i]*a[i]\n        ans %= 1000000000\n    print(ans)\n\nfor i in range(m):\n    op = ops[i]\n    if op[0] == 1:\n        a[op[1]] = op[2]\n    elif op[0] == 2:\n        solve()\n    else:\n        for x in range(op[-2], op[-1]+1):\n            a[x] += op[-3]\n\nfor i in range(m):\n    op = ops[i]\n    if op[0] == 1:\n        continue\n    elif op[0] == 2:\n        solve()",
        "result": "failed: testcase 0"
    },
    "2104": {
        "body": "l, r = map(int, input().split())\nif (r - l + 1) % 2 == 0: \n    print('NO')\nelse:\n    c = 1 if (r - l + 1) < 3e5 else ((r - l + 1) >> 1)\n    print('YES')\n    for i in range(0, r - l + 1, 2):\n        if i % c == 0: \n            print(l + i, l + i + 1)\n        else:\n            print(l + i + 1, l + i)",
        "result": "failed: testcase 0"
    },
    "1995": {
        "body": "    for l_i, r_i, k_i in queries:\n        substring = s[l_i - 1:r_i]\n        s = s[:l_i - 1] + substring[-k_i % len(substring):] + substring[:-k_i % len(substring)] + s[r_i:]\n    return s\n\ns = input()\nm = int(input())\nqueries = []\nfor _ in range(m):\n    l, r, k = map(int, input().split())\n    queries.append((l, r, k))\nprint(process_string(s, m, queries))",
        "result": "failed: testcase 0"
    },
    "2064": {
        "body": "    max_num = 0\n    for i in range(10, -1, -1):\n        if sum(int(digit) for digit in str(i)) <= n:\n            max_num = i\n        else:\n            break\n    return max_num",
        "result": "failed: testcase 0"
    },
    "1715": {
        "body": "    A, B, Q = map(int, input().split())\n    S = list(map(int, input().split())) + [float('inf')]\n    T = list(map(int, input().split())) + [float('inf')]\n    X = list(map(int, input().split()))\n    for i in range(1, A+1):\n        S[i] = min(S[i], S[i-1])\n    for i in range(1, B+1):\n        T[B-i] = min(T[B-i], T[B-i+1])\n    ans = []\n    for x in X:\n        lo, hi = 0, A+B\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if S[mid-1] - x <= x - T[mid]:\n                hi = mid\n            else:\n                lo = mid + 1\n        best = min(S[lo-1] - x, x - T[lo])\n        for d in range(1, B):\n            dist = abs(x-T[d]) + abs(T[d]-T[B-d]) + abs(x-S[lo-B+d])\n            if dist < best:\n                best = dist\n        ans.append(best)\n    print(*ans, sep='\\n')",
        "result": "failed: testcase 0"
    },
    "2074": {
        "body": "    n, m = map(int, input().split())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(int, input().split())))\n    mx = 0\n    mini = float('inf')\n    for i in range(n):\n        maxi = max(grid[i])\n        if maxi > mx:\n            mx = maxi\n            mini = min(mini, min(grid[i]))\n    print(min(max(mx, mini), max(max(j) for j in grid)))",
        "result": "failed: testcase 0"
    },
    "2921": {
        "body": "    return input().split()\n\nm, u, d = map(float, readline())\ndrinks = []\nfor _ in range(d):\n    name, strength, size, cost = readline()\n    strength, price = float(strength), float(cost)\n    drinks.append((name, int(strength), size, price))\n\ndrinks.sort(key=lambda x: (x[2], -1 * x[3]))\n\ndp = [[float('inf')] * 11 for _ in range(41)]\nfor name, strength, size, cost in drinks:\n    for j in range(len(dp)):\n        if dp[j][0] == float('inf'):\n            continue\n        k = int(j / len(drinks)) + 1\n        if k <= u:\n            val = (strength * cost) / 100.0\n            if size == '1/3':\n                val /= 3.0\n            elif size == '1/2':\n                val /= 2.0\n            dp[k][int(j % len(drinks))] = min(dp[k][int(j % len(drinks))], dp[j][0] + val)\n\nif u > m:\n    print('IMPOSSIBLE')\nelse:\n    ans = [[[], 0]]\n    for i in range(len(drinks)):\n        k, j = u, i\n        while k >= len(drinks):\n            if k != dp[k][j]:\n                continue\n            name, strength, size, _ = drinks[j]\n            count = int(dp[k][j] - dp[k - 1][j])\n            ans.append([name, count])\n            k -= len(drinks)\n        i += 1\n\n    for name, _ in reversed(ans):\n        print(f'{name} {_}')",
        "result": "failed: testcase 0"
    },
    "1642": {
        "body": "    return p[0] * q[0] + p[1] * q[1]\n\n    return p[0] * q[1] - p[1] * q[0]\n\n    return ((p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2) ** .5\n\n    val = cross(q, r)\n    if not val:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\nn = int(input())\np = []\nfor i in range(n):\n    x, y = map(int, input().split())\n    p.append((x, y))\n\n    n = len(points)\n    if n < 3:\n        raise ValueError(\"Convex Hull not possible with less than 3 points\")\n    hull = []\n    leftmost = min(points, key=lambda p: (p[0], p[1]))\n    p = [leftmost]\n    while True:\n        q = None\n        for r in points:\n            if r == p[-1]: continue\n            if q is None or orientation(p[-1], r, q) != 2:\n                q = r\n        p.append(q)\n        if q == leftmost: break\n    hull.extend(reversed(p))\n    return hull\n\n    return max(abs(x[0]), abs(x[1]))\n\nhull = convex_hull(p)\n\nans = 10000000000.0\nfor i in range(n - 2, 0, -1):\n    d = 0\n    for j in range(i + 1, n):\n        c = distance(hull[j], hull[i])\n        if c > ans:\n            break\n        p1 = (hull[j][0] * c**2 + hull[j][1], hull[j][1] * c**2 - hull[j][0])\n        p2 = (hull[i][0] * c**2 + hull[i][1], hull[i][1] * c**2 - hull[i][0])\n        d = max(d, dist((p1[0] - hull[j][0]) / c), dist((p2[0] - hull[i][0]) / c))\n    ans = min(ans, d)\n\nprint(10 ** 6 * (ans + 10000000000.0) / 10000000000.0)",
        "result": "failed: testcase 0"
    },
    "947": {
        "body": "        while b:\n            a, b = b, a % b\n        return a\n    return a * b // gcd(a, b)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    if n % 2 == 0:\n        print(n//2, n//2)\n    else:\n        print(1, n-1)",
        "result": "failed: testcase 0"
    },
    "743": {
        "body": "    while b != 0:\n        a, b = b, a % b\n    return a\n\nn = int(input())\nnumbers = list(map(int, input().split()))\ngcd_result = numbers[0]\nfor num in numbers[1:]:\n    gcd_result = gcd(gcd_result, num)\nresult = sum(num // gcd_result for num in numbers)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1397": {
        "body": "    n, m = map(int, input().split())\n    adj = {i: set() for i in range(1, n + 1)}\n    bad_edges = set()\n    for _ in range(m):\n        u, v = map(int, input().split())\n        bad_edges.add((u, v))\n        bad_edges.add((v, u))\n    q = []\n    vis = [False] * (n + 1)\n    ans = []\n    for i in range(1, n + 1):\n        if not vis[i]:\n            vis[i] = True\n            q.append(i)\n            while q:\n                x = q.pop()\n                for y in adj[x]:\n                    if not vis[y]:\n                        vis[y] = True\n                        q.append(y)\n                        bad_edges.discard((x, y))\n    ans.extend([(u, v) for u in range(1, n + 1) for v in adj[u]\n                if (v, u) not in bad_edges])\n    print(len(ans))\n    for u, v in sorted(ans):\n        print(u, v)",
        "result": "failed: testcase 0"
    },
    "1144": {
        "body": "    t = ''.join('a' if i % 2 else 'b' for i in range(m))\n    dp0 = [0] * (n + 1)\n    dp1 = [float('inf')] * (n + 1)\n    for i in range(1, n + 1):\n        c = s[i - 1]\n        if c == t[i % m]:\n            dp0[i] = max(dp0[i], dp0[i - 1])\n            dp1[i] = min(dp1[i], dp1[i - 1])\n            if i >= m and t[:m - (i % m)] + s[i - m:i] == t:\n                dp1[i] = min(dp1[i], dp0[i - m])\n        else:\n            c = '?' if c in '?ab' else 'a' if i % 2 else 'b'\n            if i >= m and t[:m - (i % m)] + s[i - m:i] == t:\n                dp0[i] = max(dp0[i], dp0[i - m])\n                dp1[i] = min(dp1[i], dp0[i - m] + 1)\n    return dp1[n]\n\nn = int(input())\ns = input()\nm = int(input())\nprint(maxBeauty(s, n, m))",
        "result": "failed: testcase 0"
    },
    "890": {
        "body": "    n, l, r, x = map(int, input().split())\n    c = list(map(int, input().split()))\n    if max(c) - min(c) < x:\n        return 0\n    dp = [[0] * (r + 1) for _ in range(2)]\n    for i in sorted(c):\n        for j in range(n + 1):\n            for k in range(l, r + 1):\n                if k >= i and dp[j & 1][k - i]:\n                    dp[(j + 1) & 1][k] += dp[j & 1][k - i]\n    return sum(dp[n & 1])\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "2410": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    prefix_sum = [0]\n    for x in a:\n        prefix_sum.append(prefix_sum[-1] + x)\n    suffix_sum = [0]\n    for i in range(n - 1, -1, -1):\n        suffix_sum.append(suffix_sum[-1] + a[i])\n    max_suffix_sum = max(suffix_sum[1:])\n    if max_suffix_sum <= prefix_sum[-1]:\n        return \"YES\"\n    else:\n        s_prefix_sum = list(reversed(prefix_sum))\n        for i in range(n - 1, 0, -1):\n            if s_prefix_sum[i] > suffix_sum[i + 1]:\n                return \"NO\"\n        return \"YES\"\n\nt = int(input())\nfor _ in range(t):\n    print(solve())",
        "result": "failed: testcase 0"
    },
    "1004": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    mp = {}\n    st = []\n    cnt = 1\n    ans = []\n    for i in range(n):\n        if not a[i] < 0:\n            if a[i] in mp and mp[a[i]]:\n                print(-1)\n                return\n            elif a[i] not in mp:\n                mp[a[i]] = True\n                st.append(a[i])\n        else:\n            a[i] = -a[i]\n            if st and st[-1] == a[i]:\n                ans.append(len(st))\n                del mp[st.pop()]\n            elif not st or (len(st) > 1 and st[-2] != a[i]):\n                print(-1)\n                return\n            else:\n                ans.append(1 + len(st))\n                del mp[st.pop()]\n        cnt += 1\n    print(len(ans))\n    if ans:\n        print(' '.join(map(str, ans)))\nsolve()",
        "result": "failed: testcase 0"
    },
    "531": {
        "body": "from collections import defaultdict\n\nn = int(input())\nx = list(map(int, input().split()))\n\nmin_x = min(x)\nmax_x = max(x)\n\ncounts = defaultdict(lambda: 0)\nfor xi in x:\n    counts[xi] += 1\n\nequal_counts = sum(1 for count in counts.values() if count > 1)\n\nif equal_counts == n:\n    print(n)\n    print(' '.join(str(min_x) * n))\nelse:\n    min_count = float('inf')\n    for max_y, min_y in [(max_x - 2, min_x), (max_x - 1, min_x), (max_x, min_x)]:\n        counts = defaultdict(lambda: 0)\n        i = 0\n        y = []\n        for xi in x:\n            if counts[xi] > 0 and len(y) < n // 2 and i < n - equal_counts:\n                yi = min_y + (max_y - min_y) * counts[xi]\n                counts[xi] -= 1\n                i += 1\n                y.append(yi)\n            else:\n                yi = xi\n                y.append(yi)\n        curr_min_count = sum(1 for count in counts.values() if count > 0)\n        min_count = min(min_count, curr_min_count)\n\n    print(n - min_count)\n    print(' '.join(map(str, x[:n // 2])))",
        "result": "failed: testcase 0"
    },
    "510": {
        "body": "    a, b, c = min(a, b, c), max(a, b, c)\n    if a > b + c - d:\n        return a - b - c + 2*d\n    elif abs(b-c) < d:\n        p = (b+c-d-abs(b-c))//2\n        return max(abs(p-a), max(abs(c-p-d), abs(p-b)))\n    else:\n        return 0",
        "result": "failed: testcase 0"
    },
    "2555": {
        "body": "    n = len(a)\n    s1 = [0] * (n + 1)\n    s2 = [0] * (n + 1)\n    for i in range(n):\n        if i & 1:\n            s2[i + 1] = max(s2[i], a[i] - s1[i])\n        else:\n            s1[i + 1] = max(s1[i], a[i] - s2[i])\n    return max(s2[n])\n\nt = int(input())\nfor _ in range(t):\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    l = [0] * (q + 1)\n    r = [0] * (q + 1)\n    for i in range(1, q + 1):\n        l[i], r[i] = map(int, input().split())\n    a = [-a[i - 1] if (i & 1) else a[i - 1] for i in range(n)]\n    print(f(a, 0, n), end=' ')\n    for i in range(1, q + 1):\n        ai, bi = l[i], r[i]\n        ai -= 1\n        if (ai & 1) == (bi & 1):\n            a[ai], a[bi] = a[bi], a[ai]\n            print(f(a, 0, n), end=' ')\n            a[ai], a[bi] = a[bi], a[ai]\n        else:\n            print(f(a, ai, bi) if (ai & 1) else f(a, bi, ai), end=' ')\n    print()",
        "result": "failed: testcase 0"
    },
    "324": {
        "body": "    i = 2\n    while True:\n        a = 2 * i + n\n        b = i\n        if a >= 2 and any(a % j != 0 for j in range(2, int(a ** 0.5) + 1)):\n            return a, b\n        i += 1",
        "result": "failed: testcase 0"
    },
    "2912": {
        "body": "from collections import deque\n\nn = int(input())\nstrings = [input() for _ in range(n)]\noperations = [[int(x) - 1 for x in input().split()] for _ in range(n - 1)]\n\nq = deque()\nfor a, b in operations:\n    strings[a] += strings[b]\n    q.append(b)\nwhile q:\n    i = q.popleft()\n    del strings[i]\n\nprint(strings[0])",
        "result": "failed: testcase 0"
    },
    "9": {
        "body": "    n = int(input())\n    _, h, w = map(int, input().split())\n    sofas = [[] for _ in range(n)]\n    cnt = list(map(int, input().split()))\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        if abs(x1 - x2) + abs(y1 - y2) == 1:\n            sofas[i] = [(x1, y1), (x2, y2)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if set(sofas[i]) & set(sofas[j]):\n                return -1\n    for i in range(n):\n        s = sofas[i]\n        if len(set([c[0] for c in s])) != 2 or len(set([c[1] for c in s])) != 2:\n            continue\n        x, y = s[0][:]\n        if (cnt[0] == -1) ^ (len([c for c in sofas if c and c[0][0] < x]) == cnt[0]):\n            continue\n        if (cnt[1] == -1) ^ (len([c for c in sofas if c and c[0][0] > x and c[0][1] == y]) == cnt[1]):\n            continue\n        if (cnt[2] == -1) ^ (len([c for c in sofas if c and c[0][1] < y]) == cnt[2]):\n            continue\n        if (cnt[3] == -1) ^ (len([c for c in sofas if c and c[0][1] > y and c[0][0] == x]) == cnt[3]):\n            continue\n        return i + 1\n    return -1",
        "result": "failed: testcase 0"
    },
    "249": {
        "body": "    p = []\n    d = [0]\n    for i in range(1, n + 1):\n        d.append(a[i] - a[i - 1])\n    c = [d[i] for i in range(len(d)) if d[i] == x or d[i] == y]\n\n        j = len(c) - 1\n        while j > i and c[j] - c[i] >= y: j -= 1\n        return max(j, 0)\n\n    for i in range(len(d)):\n        if d[i] not in c:\n            p.append(a[i])\n            g(i)\n            break\n\n    q = [a[-1]]\n    while len(q) < 2:\n        r = []\n        for w in p:\n            if a[-1] - w >= x and a[-1] - w <= y: r.append(w)\n        q += sorted(r)[:2]\n    return len(p), *q",
        "result": "failed: testcase 0"
    },
    "2999": {
        "body": "    n, s = map(int, input().split())\n    participants = []\n    for _ in range(n):\n        name, b = input().split()\n        participants.append((name, int(b)))\n    participants.sort(key=lambda x: x[1])\n    groups = {}\n    current_sum = 0\n    current_bid = -1\n    for name, bid in participants:\n        if bid > current_bid or (bid < current_bid and current_sum != s):\n            current_sum += bid\n            current_bid = bid\n            groups[current_sum] = [name]\n        elif bid == current_bid:\n            current_sum += bid\n            groups[current_sum].append(name)\n    result = 0\n    for sum_val, names in groups.items():\n        if sum_val == s:\n            result += len(names)\n            for name in names:\n                print(name)\n    print(result)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "2239": {
        "body": "    a = [2, 3, 4, 5, 6, 7]\n    n = len(a)\n    for i in range(n ** x + 1):\n        s = sum([a[j] for j in a[i % n:i + x > n and n]])\n        if s == x:\n            return i + 1\n    return ''",
        "result": "failed: testcase 0"
    },
    "2615": {
        "body": "    factors = {}\n    i = 2\n    while n > 1:\n        if n % i == 0:\n            factors[i] = factors.get(i, 0) + 1\n            n //= i\n        else:\n            i += 1\n    return factors\n\n    while(y):\n        x, y = y, x % y\n    return x\n\n    p = 2\n    e = [0]*p\n    cnt = 0\n    for d in range(2, int(n**0.5) + 1):\n        if n % d == 0:\n            k = 0\n            while n % d == 0:\n                k += 1\n                n //= d\n            e[d] = max(e[d], k)\n    if n > 1: e[n] = max(e[n], 1)\n    for i in range(2, p):\n        if e[i] and gcd(e[i-1], e[i]) == e[i]:\n            return cnt\n        cnt += e[i]\n    return cnt + (n - e[p-1])\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(count_elegant(n))",
        "result": "failed: testcase 0"
    },
    "2542": {
        "body": "    n = len(s)\n    cnt = [0] * 10\n    for c in s:\n        cnt[int(c)] += 1\n\n    ans = n\n    for i in range(10):\n        l = (i * n) % 10\n        r = ((i + 1) * n - 1) % 10\n        if cnt[l] and cnt[r]:\n            ans = min(ans, max(cnt[(l + j) % 10] for j in range(n)) - min(cnt[(r + j) % 10] for j in range(n)))\n    return ans\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    print(solve(s))",
        "result": "failed: testcase 0"
    },
    "511": {
        "body": "    while b != 0:\n        a, b = b, a % b\n    return a\n\n    if y == 0:\n        return 0\n    return 1 + f(x, y - gcd(x, y))",
        "result": "failed: testcase 0"
    },
    "1409": {
        "body": "n, k = map(int, input().split())\na = sorted(map(int, input().split()), reverse=True)\n\nres = 0\ni = 0\nwhile i < n:\n    if a[i] >= k * 3:\n        res += (a[i] - 1) // (k * 2)\n        i += 1\n    else:\n        c = sum(1 for j in range(i, n) if a[j] >= k)\n        if c < 3:\n            break\n        i += c\n\nprint(res)",
        "result": "failed: testcase 0"
    },
    "2274": {
        "body": "    n, m = len(matrix), len(matrix[0])\n    visited = [[False]*m for _ in range(n)]\n    directions = [(0, 1), (1, 0)]\n    to_change = set()\n\n        if not (0 <= i < n and 0 <= j < m) or matrix[i][j] == 'C' or visited[i][j]:\n            return\n        visited[i][j] = True\n\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < n and 0 <= nj < m) or matrix[ni][nj] == 'C':\n                to_change.add((ni, nj))\n                continue\n            dfs(ni, nj)\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] != 'D' or (i == n-1 and j == m-1):\n                dfs(i, j)\n            elif (i, j) not in to_change:\n                to_change.add((i, j))\n\n    return len(to_change)\n\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    matrix = [input() for _ in range(n)]\n    print(min_changes(matrix))",
        "result": "failed: testcase 0"
    },
    "2420": {
        "body": "    points = [list(map(int, input().split())) for _ in range(n)]\n    max_covered = 0\n    for i in range(n):\n        x, y = points[i]\n        covered = 0\n        for j in range(n):\n            if i == j:\n                continue\n            dx, dy = abs(x - points[j][0]), abs(y - points[j][1])\n            if dx + dy <= r:\n                covered += 1\n        max_covered = max(max_covered, covered + 1)\n    return max_covered",
        "result": "failed: testcase 0"
    },
    "1267": {
        "body": "n = int(input())\na = sorted(map(int, input().split()))\nans = 1 if any(x != 0 for x in a) else 0\nfor i in range(n - 1):\n    if a[i] == a[i + 1]:\n        ans *= (i + 2)\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "2356": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    d = dict()\n    b = []\n    for i in range(n):\n        if a[i] not in d:\n            d[a[i]] = 0\n        x = (i - a[i]) % n\n        while x in d and d[x] < len(b):\n            x += 1\n        d[x] = len(b)\n        b.append(a[i])\n    print(*b)\n\nfor _ in range(int(input())):\n    f()",
        "result": "failed: testcase 0"
    },
    "108": {
        "body": "import sys\n\n    s = input().strip()\n    ans = ''\n    i = 0\n    for c in 'abcdefghijklmnopqrstuvwxyz':\n        while i < len(s) and s[i] != c:\n            j = ord(s[i]) - ord('a')\n            if j >= ord(c) - ord('a'):\n                ans += c\n                i += 1\n            else:\n                s = s[:i] + c + s[i:]\n        if i < len(s):\n            ans += s[i]\n            i += 1\n    print(ans if len(ans) == 26 else '-1')\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "1833": {
        "body": "import sys\n\nN = 1000000 + 10\nmod = int(1e9) + 7\n\nn = int(input())\na = list(map(int, input().split()))\n\ndp = [[0] * N for _ in range(n + 1)]\nfor i in range(n):\n    dp[i][0] = 1\n    for j in range(1, a[i] + 1):\n        if j % (i + 1) == 0:\n            dp[i + 1][j] += dp[i][j]\n            dp[i + 1][j] %= mod\n\nans = 0\nfor i in range(n):\n    for j in range(a[i] + 1):\n        ans += dp[n][j]\n\nprint(ans % mod)",
        "result": "timed out"
    },
    "2324": {
        "body": "    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                if j > i:\n                    dp[i][j] = dp[i + 1][j - 1]\n                dp[i][j] += 1\n    result = [0] * (n + 1)\n    for k in range(1, n + 1):\n        count = 0\n        for i in range(n):\n            j = n - 1 - i\n            if i <= j and s[i] == s[j]:\n                count += dp[i][j]\n        result[k] = count\n    return ' '.join(map(str, result[:-1]))",
        "result": "failed: testcase 0"
    },
    "2372": {
        "body": "import sys\nfrom collections import deque\n\nH, W = map(int, sys.stdin.readline().split())\nC_h, C_w = map(int, sys.stdin.readline().split())\nD_h, D_w = map(int, sys.stdin.readline().split())\n\nS = [list(sys.stdin.readline().strip()) for _ in range(H)]\n\n    return 0 <= i < H and 0 <= j < W\n\nBFS_queue = deque([(C_h, C_w, -1)])\n\nvisited = {(C_h, C_w)}\n\nwhile BFS_queue:\n    x, y, step = BFS_queue.popleft()\n    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        nx, ny = x + dx, y + dy\n        if is_valid(nx, ny) and S[nx][ny] == '.' and (nx, ny) not in visited:\n            visited.add((nx, ny))\n            BFS_queue.append((nx, ny, step))\n\n    for i in range(max(0, C_h-2), min(H, C_h+3)):\n        for j in range(max(0, C_w-2), min(W, C_w+3)):\n            if (i, j) == (D_h, D_w):\n                print(step + 1)\n                exit()\n            elif S[i][j] == '.' and is_valid(i, j) and (i, j) not in visited:\n                visited.add((i, j))\n                BFS_queue.append(((i, j), step + 1))\n\nprint(-1)",
        "result": "failed: testcase 0"
    },
    "1984": {
        "body": "n, m, k, w = map(int, input().split())\nlevels = []\nfor _ in range(k):\n    levels.append(input())\n\ncost = [[0 for _ in range(m)] for _ in range(n)]\nfor i in range(1, k):\n    diff = [[0 for _ in range(m)] for _ in range(n)]\n    for j in range(n):\n        for l in range(m):\n            if levels[i][j * m + l] != levels[0][j * m + l]:\n                diff[j][l] = 1\n    for j in range(1, i):\n        for l in range(n):\n            for o in range(m):\n                if diff[l][o] == 1 and levels[i][n * m + l + o] != levels[j][n * m + l + o]:\n                    diff[l][o] += 1\n    for j in range(n):\n        for l in range(m):\n            cost[i][l] = (diff[j][l] if diff[j][l] > 0 else 1) * w\n\norder = [i for i in range(1, k)]\nwhile len(order) > 1:\n    idx = order.index(min(order))\n    level_idx = order.pop(idx)\n    print(level_idx + 1, int(cost[level_idx].count(1) == n * m), end=' ')\n    if cost[level_idx].count(1) != n * m:\n        order.remove(0)\n\nprint()",
        "result": "failed: testcase 0"
    },
    "1253": {
        "body": "    a = list(map(int, input().split()))\n    s = sum(a)\n    for i in range(n - 1, n - k - 1, -1):\n        if a[i] < 0:\n            a[i] *= -1\n            s += 2\n    return s",
        "result": "failed: testcase 0"
    },
    "523": {
        "body": "    s.sort(key=len)\n    s = [i[::-1] for i in s]\n    left, right = 0, n - 1\n    ans = []\n    while left < right:\n        if len(s[left]) > len(s[right]):\n            ans.append(s[left])\n            left += 1\n        else:\n            ans.append(s[right])\n            right -= 1\n    if left == right:\n        ans.append(s[left])\n    return \"\".join(ans[::-1]), len(\"\".join(ans))",
        "result": "failed: testcase 0"
    },
    "2934": {
        "body": "    if not b: return a\n    return gcd(b, a % b)\n\nmod = 10**9\n\nN = int(input())\nM = int(input())\n\nif N == 1:\n    print(M)\nelif N >= 3:\n    print(0)\nelse:\n    c1, c2, c3 = [0] * (N+1), [0] * (N+1), [0] * (N+1)\n    c1[0], c1[1], c2[0] = 1, 1, 1\n    for n in range(2, N+1):\n        c3[n-1] = c1[n-1]\n        c1[n] = sum(c2[:n])\n        for m in range(n, 0, -1):\n            c3[m-1] += (c1[m-1] * c2[n-m] + c2[m-1] * c1[n-m]) % mod\n    print(sum(c3) % mod)",
        "result": "failed: testcase 0"
    },
    "1745": {
        "body": "    if n < 5 or m < 5:\n        return 0\n    \n    ways = [[0] * m for _ in range(n)]\n    \n        return 0 <= x < n and 0 <= y < m and field[x][y] == '.'\n    \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        neighbors = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and field[nx][ny] == '*':\n                neighbors.append((nx, ny))\n        return neighbors\n    \n        ways[x][y] += 1\n        neighbors = get_neighbors(x, y)\n        for nx, ny in neighbors:\n            if not ways[nx][ny]:\n                dfs(nx, ny)\n    \n        n_pipe, m_pipe = len(pipe), len(pipe[0])\n        for i in range(n_pipe - 1):\n            for j in range(m_pipe):\n                if pipe[i][j] == '*' and (pipe[i + 1][j] != '*' or not is_valid(i + 2, j)):\n                    return False\n                elif pipe[i][j] != '*' and (pipe[i + 1][j] == '*'):\n                    return False\n        \n        for i in range(n_pipe):\n            for j in range(m_pipe - 1):\n                if pipe[i][j] == '*' and (pipe[i][j + 1] != '*' or not is_valid(i, j + 2)):\n                    return False\n                elif pipe[i][j] != '*' and (pipe[i][j + 1] == '*'):\n                    return False\n        \n        # check border squares\n        for i in range(n_pipe):\n            if pipe[i][0] == '*':\n                if not is_valid(i, -1) or not is_valid(i, 1):\n                    return False\n            if pipe[i][-1] == '*':\n                if not is_valid(i, m_pipe - 2) or not is_valid(i, m_pipe):\n                    return False\n        \n        for j in range(m_pipe):\n            if pipe[0][j] == '*':\n                if not is_valid(-1, j) or not is_valid(1, j):\n                    return False\n            if pipe[-1][j] == '*':\n                if not is_valid(n_pipe - 2, j) or not is_valid(n_pipe, j):\n                    return False\n        \n        # check non-border squares\n        for i in range(1, n_pipe - 1):\n            for j in range(1, m_pipe - 1):\n                if pipe[i][j] == '*':\n                    if (not is_valid(i + 1, j) or not is_valid(i - 1, j)) and \\\n                       (not is_valid(i, j + 1) or not is_valid(i, j - 1)):\n                        return False\n        \n        return True\n    \n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*' and is_valid_pipe([[i], [j]]):\n                dfs(i, j)\n    \n    max_ways = 0\n    for row in ways:\n        max_ways = max(max_ways, max(row))\n    \n    return max_ways\n\n    n, m = map(int, input().split())\n    field = []\n    for _ in range(n):\n        field.append(list(input()))\n    print(count_ways(n, m, field))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "1422": {
        "body": "import sys\n\ns = list(input())\nm = int(input())\n\nif '1' not in s:\n    if m % 2 == 0:\n        print('YES')\n        for i in range(m // 2):\n            print(0, end=' ')\n        print()\n    else:\n        print('NO')\nelse:\n        if i >= m and j >= m:\n            return True\n        if i < m and rec(i + 1, j, weights):\n            return True\n        if j < m and (rec(i, j + 1, weights) or \n                      (i != m // 2 and s[i] == '0' and weights[j] <= weights[m // 2])):\n            return True\n        return False\n\n        if i >= m and j >= m:\n            return []\n        res = []\n        if i < m:\n            res.extend(get_result(i + 1, j))\n        if j < m and (rec(i, j + 1, res) or \n                      (i != m // 2 and s[i] == '0' and len(res) <= len(weights) - 1)):\n            res.append(weights[j])\n            res.extend(get_result(i, j + 1))\n        return res\n\n    weights = [int(x) for x in s]\n    if rec(0, 0, []):\n        print('YES')\n        print(*get_result(0, 0))\n    else:\n        print('NO')",
        "result": "failed: testcase 0"
    },
    "1763": {
        "body": "import sys\nimport heapq\nN, A, R, M = map(int, input().split())\nh = list(map(int, input().split()))\nQ = [0] + sorted([x - sum(h) // N for x in h])\ncost = 0\nfor i in range(1, len(Q)):\n    if Q[i] > 0:\n        cost += M * (Q[i] - 1)\n        heapq.heappush(Q, Q[i] - 1)\nprint(cost + A * sum(h) + R * (sum(h) % N))",
        "result": "failed: testcase 0"
    },
    "974": {
        "body": "    n = int(input())\n    m = [0] * (n + 1)\n    p = []\n    q = []\n    for _ in range(2 * n):\n        t, x = input().split()\n        if t == 'add':\n            i = int(x)\n            p.append(i)\n            m[i] += 1\n        else:\n            i = int(x)\n            q.append(i)\n    l, r = 0, 0\n    ans = 0\n    for i in range(n):\n        while l < n and m[p[l]] == 0:\n            l += 1\n        while r < n and p[r] <= q[i]:\n            r += 1\n        if p[l] != q[i]:\n            ans += 1\n            while l < r:\n                m[p[l]] -= 1\n                l += 1\n    print(ans)",
        "result": "failed: testcase 0"
    },
    "2343": {
        "body": "    m = 2 ** n\n    if m == 1 or (m > 1 and k < n * 2 - 2):\n        return \"YES \" + str(n)\n    else:\n        return \"NO\"",
        "result": "failed: testcase 0"
    },
    "627": {
        "body": "n = int(input())\ns = input()\nif n == 2 or s[1:n] == sorted(s[1:n]):\n    print(s[:-1])\nelse:\n    idx = -1\n    for i in range(n-1):\n        if s[i+1] < s[idx]:\n            idx = i+1\n    print(s[:idx]+s[idx+1:])",
        "result": "failed: testcase 0"
    },
    "1655": {
        "body": "    killed = [0] * n\n    for i in range(n-1, -1, -1):\n        if i + L[i] >= n:\n            continue\n        for j in range(max(0, i-L[i]+1), i):\n            killed[j] = 1\n    return sum(1 for x in killed if not x)",
        "result": "failed: testcase 0"
    },
    "2124": {
        "body": "    n = int(input())\n    users = input().split()\n    m = int(input())\n\n    chat = []\n    for i in range(m):\n        message = input()\n        if ':' not in message:\n            message = '?' + message\n        sender, text = message.split(':', 1)\n        chat.append((sender, text))\n\n    possible_senders = users[:]\n    result = []\n\n        return len(possible_senders) == len(set([msg[0] for msg in result])) and all(msg[0] != msg[1].split()[0] for msg in result)\n\n    for sender, _ in chat:\n        if sender == '?' and not possible_senders:\n            return 'Impossible'\n        if sender != '?':\n            possible_senders.remove(sender)\n        result.append((sender, chat[-1][1]))\n        while len(possible_senders) > 0 and result[-2][0] == result[-1][0]:\n            possible_senders.pop()\n        if not is_valid():\n            return 'Impossible'\n\n    print('\\n'.join(f'{msg[0]}:{msg[1]}' for msg in result))\n\nt = int(input())\nfor _ in range(t):\n    recover_senders()",
        "result": "failed: testcase 0"
    },
    "1093": {
        "body": "n, m = map(int, input().split())\na = [list(input()) for _ in range(n)]\nmx_down = 0\nmx_up = 0\nfor j in range(m):\n    mx_height = 0\n    down = 0\n    up = 0\n    for i in range(n - 1, -1, -1):\n        if a[i][j] == '*':\n            mx_height = max(mx_height + (n - i), mx_height)\n            down = max(down, mx_height - (n - i))\n            up = max(up, mx_height - (n - i - 1) or 0)\n    mx_down = max(mx_down, down)\n    mx_up = max(mx_up, up)\nprint(mx_up, mx_down)",
        "result": "failed: testcase 0"
    },
    "899": {
        "body": "    import sys\n    input = sys.stdin.readline\n    N,M = map(int,input().split())\n    edges = []\n    for _ in range(M):\n        a,b,c = map(int,input().split())\n        if (a,b) not in edges:\n            edges.append((a,b))\n        else:\n            continue\n    INF = int(1e9)\n    dist = [[INF]*(N+1) for i in range(N+1)]\n    for i in range(1,N+1):\n        dist[i][i] = 0\n    for a,b,c in edges:\n        dist[a][b] = c\n        dist[b][a] = c\n\n    for k in range(1,N+1):\n        for i in range(1,N+1):\n            for j in range(1,N+1):\n                if (dist[i][k]+dist[k][j]) < dist[i][j]:\n                    dist[i][j] = dist[i][k]+dist[k][j]\n    ans = 0\n    for a,b,c in edges:\n        if c==dist[a][b]:continue\n        else:ans+=1\n    print(ans)",
        "result": "failed: testcase 0"
    },
    "551": {
        "body": "    y.sort()\n    for i in range(1, n):\n        if y[i-1] != y[i]:\n            return 'Yes'\n    return 'No'\n\nn = int(input())\ny = list(map(int, input().split()))\nprint(f(n, y))",
        "result": "failed: testcase 0"
    },
    "1772": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    o = sum(1 for x in a if x % 2)\n    e = n - o\n    return min(o, (e + 1) // 2)",
        "result": "failed: testcase 0"
    },
    "1339": {
        "body": "    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r, i + 1))\n    segments.sort(key=lambda x: (x[0], -x[1]))\n    max_covered = -1\n    for i in range(len(segments) - 1):\n        if segments[i][1] >= segments[-1][0]:\n            return str(segments[i][2])\n    return '-1'",
        "result": "failed: testcase 0"
    },
    "440": {
        "body": "    vowels = 'aeiouy'\n    i = 0\n    while True:\n        if i < len(s) - 1 and s[i] in vowels and s[i + 1] in vowels:\n            j = i\n            while j > 0 and s[j - 1] not in vowels:\n                j -= 1\n            if j == 0 or s[j - 1] not in vowels:\n                break\n            del s[j]\n            n -= 1\n        else:\n            break\n        i += 1\n    return ''.join(s)[:n]",
        "result": "failed: testcase 0"
    },
    "2801": {
        "body": "import sys\nfrom collections import deque\n\nn, m = map(int, input().split())\nc = list(map(float, input().split()))\n\ng = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v = map(lambda x: int(x) - 1, input().split())\n    g[u].append(v)\n\n    q = deque()\n    inf = float('-inf')\n    dist = [0] * n\n    vis = [False] * n\n    f = [-inf] * n\n\n    for i in range(n):\n        if not vis[i]:\n            vis[i] = True\n            d = 0\n            q.append(i)\n            while q:\n                u = q.popleft()\n                for v in g[u]:\n                    if not vis[v]:\n                        vis[v] = True\n                        dist[v] = max(dist[u], c[v])\n                        f[v] = max(f[u], d + c[v])\n                        d += 1 / (2 ** d)\n                        q.append(v)\n\n    return max(f)\n\nprint(bfs())",
        "result": "failed: testcase 0"
    },
    "2749": {
        "body": "from collections import deque\n\nH, W = map(int, input().split())\nN = int(input())\na = list(map(int, input().split()))\n\ndx = [0, 1, 0, -1]\ndy = [1, 0, -1, 0]\n\ns = []\nfor i in range(H):\n    s.append(list(map(lambda x: None, range(W))))\n\n    if not (0 <= x < H and 0 <= y < W): return\n    if s[x][y] is not None: return\n    s[x][y] = c\n    for i in range(4):\n        nx, ny = x + dx[i], y + dy[i]\n        paint(nx, ny, c)\n\nfor i in range(N):\n    for j in range(a[i]):\n        r = 0\n        while True:\n            h = (r // W) % H\n            w = r % W\n            if s[h][w] is None:\n                paint(h, w, i + 1)\n                break\n            r += 1\n\nfor row in s:\n    print(*[x for x in row])",
        "result": "failed: testcase 0"
    },
    "2319": {
        "body": "    if s == t: return 0\n    for i in range(len(s)):\n        if s[i:] + s[:i] == t:\n            return len(s) - i\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    t = input()\n    print(f(s, t))",
        "result": "failed: testcase 0"
    },
    "2121": {
        "body": "    global ans\n    vis[node] = True\n    for nei in adj[node]:\n        if not vis[nei]:\n            v = a[nei]\n            a[nei], a[node] = a[node], a[nei]\n            dfs(nei)\n            ans = min(ans, a[node])\n\nn, k = map(int, input().split())\na = [0] + list(map(int, input().split()))\nfor i in range(n - 1):\n    u, v = map(int, input().split())\n    if a[u] > a[v]:\n        a[u], a[v] = a[v], a[u]\n    adj[v].append(u)\nans = float('inf')\nvis = [False] * (n + 1)\nfor i in range(1, n + 1):\n    ans = min(ans, a[i])\n    vis = [False] * (n + 1)\n    dfs(i)\nprint(min(ans, min(a[nei] for nei in adj[i] if len(adj[nei]) > 0) for i in range(1, n + 1)))",
        "result": "failed: testcase 0"
    },
    "2617": {
        "body": "import sys\n\n    if n == 2:\n        return [0]\n    elif not n % 2 or n <= 3:\n        return [-1]\n\n    res = []\n    nights = (n - 2) // 2 + 1\n    k = n // (1 << nights)\n    for _ in range(nights):\n        if k > 1:\n            res.append(k - 1)\n            k -= 1\n        else:\n            res.append(0)\n\n    return [nights] + res\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(*f(n))",
        "result": "failed: testcase 0"
    },
    "175": {
        "body": "    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    return a, b\n\nn, m = map(int, input().split())\nprint(*f(n, m))",
        "result": "failed: testcase 0"
    },
    "995": {
        "body": "from collections import defaultdict\nimport math\nimport sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    ans = [0] * (n + 1)\n    f = defaultdict(int)\n\n    for i in range(n):\n        d = set()\n        c = {}\n        x = abs(a[i])\n        while x % 2 == 0:\n            x //= 2\n            if x not in c:\n                c[x] = 1\n            else:\n                d.add(x)\n        y = math.isqrt(x)\n        if y * y != x:\n            ans[1] += f[i]\n            for j in range(i + 1, n):\n                if abs(a[j]) % y == 0:\n                    ans[1] += 1\n            f[i] += 1\n\n        for z in d | set(c.keys()):\n            while x % (z * z) == 0:\n                x //= (z * z)\n        if x <= n:\n            ans[x] += f[i]\n    print(*ans[1:])\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "582": {
        "body": "import sys\nfrom collections import defaultdict\n\nn = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\ncnt = defaultdict(list)\nfor i in range(n):\n    cnt[a[i]].append(t[i])\n\nans = 0\nsorted_a = sorted(set(a))\nfor c in sorted_a:\n    if len(cnt[c]) == 1:\n        continue\n    else:\n        b = max(c for c in cnt[c] if cnt[c].count(c) < cnt[c].count(b))\n        ans += b * (cnt[c].count(b) - cnt[c].count(c))\n\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "1402": {
        "body": "    n = int(input())\n    s1 = input()\n    s2 = input()\n    mod = 10**9 + 7\n    ans = 0\n    for i in range(n):\n        if s1[i] != '?' and s2[i] != '?':\n            if s1[i] > s2[i]:\n                for j in range(i+1, n):\n                    if s1[j] < s2[j]:\n                        return 0\n            elif s1[i] < s2[i]:\n                for j in range(i+1, n):\n                    if s1[j] > s2[j]:\n                        return 0\n        else:\n            l = len(str(s1))\n            r = len(str(s2))\n            c1 = [s1.count('?',j,l) for j in range(n)]\n            c2 = [s2.count('?',j,r) for j in range(n)]\n            if i < l and s1[i] != '?':\n                c1[i] += 1\n            elif i == l:\n                c1.append(0)\n            if i < r and s2[i] != '?':\n                c2[i] += 1\n            elif i == r:\n                c2.append(0)\n            for j in range(n):\n                if c1[j] > 0 and (s1[j]!='?' or c2[j]==0):\n                    c1[c1.index(max(c1))]+=c1[j]\n                    c1[j]=0\n                elif c2[j]>0:\n                    c2[c2.index(max(c2))]+=c2[j]\n                    c2[j]=0\n            for j in range(n):\n                if s1[j] != '?' and s2[j] != '?':\n                    if s1[j] > s2[j]:\n                        ans += c1[j]*c2[n-j-1]\n                        ans %= mod\n                    elif s1[j] < s2[j]:\n                        ans += (mod-c2[j]*c1[n-j-1]) % mod\n    return str(ans % mod)",
        "result": "failed: testcase 0"
    },
    "1141": {
        "body": "n, m = map(int, input().split())\ns = list(input())\n\nfor _ in range(m):\n    l, r, c1, c2 = input().split()\n    l, r = int(l) - 1, int(r)\n    for i in range(l, r + 1):\n        if s[i] == c1:\n            s[i] = c2\n\nprint(''.join(s))",
        "result": "failed: testcase 1"
    },
    "2836": {
        "body": "    P.sort()\n    m = N // 2\n    if N % 2 == 0: m += 1\n    X_min = min(abs(A - P[0]), abs(B - P[-1]))\n    ans = A - X_min + (A + B) % 2\n    for i in range(N):\n        x = (P[i] + A + 1) // 2\n        if i < m: x += (B - A) // (N * 2) + 1\n        else: x -= (B - A) // (N * 2)\n        X = max(x, abs(A - P[i]))\n        Y = max(X, abs(B - P[i]))\n        if X_min < X <= B:\n            ans = max(ans, min(X, Y))\n    return ans",
        "result": "failed: testcase 0"
    },
    "1109": {
        "body": "n, k = map(int, input().split())\na = list(map(int, input().split()))\nb = [0]*(k+1)\nfor i in range(k):\n    b[a[i]] += 1\nans = sum(b[j] % (n//k) for j in range(2))\nif ans == n:\n    ans = max(a[:k])\nprint(ans - k)",
        "result": "failed: testcase 0"
    },
    "2125": {
        "body": "    cnt = 0\n    for i in range(1, n):\n        c = set()\n        for j in range(m):\n            if len(c) == 3:\n                break\n            u = [a[i-1][j], a[i][j]]\n            if '' not in u or (u[0] != u[1]):\n                c.add(u[0])\n                c.add(u[1])\n        else:\n            continue\n        for j in range(i+1, n):\n            c2 = set()\n            for k in range(m):\n                if a[j][k] not in c:\n                    break\n                u = [a[i-1][k], a[i][k], a[j][k]]\n                if '' not in u or (u[0] != u[1]) and (u[1] != u[2]):\n                    c2.add(u[0])\n                    c2.add(u[1])\n                    c2.add(u[2])\n            else:\n                cnt += 1\n    return cnt\n\nn, m = map(int, input().split())\na = [input() for _ in range(n)]\nprint(f(n, m, a))",
        "result": "failed: testcase 0"
    },
    "1746": {
        "body": "    if len(tree[parent]) < 3:\n        return False\n    for child in tree[parent]:\n        if not (child != 1 or all(child2 != 1 for child2 in tree[child])):\n            continue\n        if not count_children(child, parent, tree):\n            return False\n    return True\n\n    tree = [[] for _ in range(n + 1)]\n    for p, c in edges:\n        tree[p].append(c)\n    if count_children(1, -1, tree):\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\nedges = []\nfor i in range(n - 1):\n    p = int(input()) - 1\n    edges.append((p, i + 2))\nprint(is_spruce(n, edges))",
        "result": "failed: testcase 0"
    },
    "1294": {
        "body": "    d = {}\n    for c in s:\n        if c not in d or 2 < d[c] + 1 <= len(s) - len(s.replace(c, '')):\n            d[c] = d.get(c, 0) + 1\n    return ''.join(sorted(d.keys()))",
        "result": "failed: testcase 0"
    },
    "1159": {
        "body": "    if n < 2:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nimport sys\nn = int(input())\nfor edges in range(2, (n*(n-1))//2+1):\n    if is_prime(edges):\n        adj = [[] for _ in range(n)]\n        deg = [0]*n\n        added_edges = 0\n        for u in range(n):\n            for v in range(u+1, n):\n                if is_prime(deg[u]+1) and is_prime(deg[v]+1):\n                    adj[u].append(v)\n                    adj[v].append(u)\n                    deg[u] += 1\n                    deg[v] += 1\n                    added_edges += 1\n        if added_edges == edges:\n            print(edges)\n            for u in range(n):\n                for v in adj[u]:\n                    if is_prime(deg[u]) and is_prime(deg[v]):\n                        print(u+1, v+1)\n            sys.exit(0)",
        "result": "failed: testcase 0"
    },
    "2025": {
        "body": "    if n < 4: return -1\n    c = 0\n    while n > 3:\n        c += n // 4\n        n %= 4\n    return c + n",
        "result": "failed: testcase 0"
    },
    "1429": {
        "body": "from collections import defaultdict\nimport sys\n\nN = int(input().split()[0])\nS = input()\ndp = [[0]*4 for _ in range(N+1)]\ncnt = [defaultdict(int) for _ in range(4)]\n\nfor i, c in enumerate(S):\n    if c == 'A': c = 0\n    elif c == 'T': c = 1\n    elif c == 'C': c = 2\n    else: c = 3\n\n    for j in range(4):\n        dp[i+1][j] += cnt[j][c ^ j]\n        cnt[j][c ^ j] += 1\n\nans = 0\nfor i in range(N):\n    for j in range(4):\n        ans += dp[i+1][j]\n\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "1950": {
        "body": "    dp = [[0] * 200001 for _ in range(4)]\n    for i in sorted(range(n), key=lambda x: -a[x]):\n        cur_max = 1\n        for k in range(2, 5):\n            if n < k:\n                continue\n            for j in range(k + 1):\n                dp[k][j] = max(dp[k][j], dp[k-1][j-1] + a[i])\n                if i == 0 or j < cur_max:\n                    dp[k][cur_max] = max(dp[k][cur_max], dp[k-1][cur_max-1] + a[i])\n            cur_max += 1\n    return min(dp[3])",
        "result": "failed: testcase 0"
    },
    "631": {
        "body": "    s = 0\n    for i in range(n-1, -1, -1):\n        for j in range(i, n):\n            s += a[j] / (j+1)\n        if s == m:\n            return 'YES'\n        elif s > m:\n            return 'NO'\n    return 'NO'",
        "result": "failed: testcase 0"
    },
    "2480": {
        "body": "    seen = {}\n    res = 0\n    for i in range(N):\n        cur = 0\n        for j in range(i, N):\n            cur += A[j]\n            if cur % K == j - i + 1:\n                res += 1\n            v = (i * N + j) % K\n            seen[v] = seen.get(v, 0) + 1\n    return res",
        "result": "failed: testcase 0"
    },
    "2363": {
        "body": "    if a == b: return 0\n    ans = 0\n    while b > a:\n        b -= max(b - a, 1)\n        ans += 1\n    return ans\n\nn = int(input())\nfor _ in range(n):\n    x, y = map(int, input().split())\n    print(f(x, y))",
        "result": "failed: testcase 0"
    },
    "909": {
        "body": "    return max((a+b)*c, a*(b+c), a*b*c, a+(b*c))",
        "result": "failed: testcase 0"
    },
    "154": {
        "body": "    MOD = 998244353\n    if n % 2 == 1:\n        return 0\n    dp = [[0] * (n + 1) for _ in range(31)]\n    dp[0][0] = 1\n    for i in range(31):\n        for j in range(n + 1):\n            if j > 0:\n                dp[i][j] += dp[i][j - 1]\n                dp[i][j] %= MOD\n            k = (n - j) // 2\n            if k >= 0 and i < 30:\n                dp[i + 1][k] += dp[i][j] * ((-1) ** k)\n                dp[i + 1][k] %= MOD\n    return dp[30][n // 2]",
        "result": "failed: testcase 0"
    },
    "39": {
        "body": "    n = len(s)\n    max_len = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if substr == substr[::-1]:\n                continue\n            max_len = max(max_len, j - i)\n    return max_len",
        "result": "failed: testcase 0"
    },
    "1885": {
        "body": "    if r > n - r: \n        r = n - r \n    res = 1\n    for i in range(r): \n        res = res * (n - i) / (i + 1)\n    return res\n\nn = int(input())\nans = sum(nCr(n, k) * nCr(6, k) for k in range(5, min(7, n+1)))\nprint(int(ans))",
        "result": "failed: testcase 0"
    },
    "1180": {
        "body": "    m = int(1e9 + 7)\n    a = [int(x) for x in s]\n    if k > n - k:\n        return sum(a[:k]) % m\n    ways = [[0] * (n + 1) for _ in range(k + 1)]\n    ways[0][0] = 1\n    for i in range(1, len(s) + 1):\n        for j in range(min(i, k), 0, -1):\n            ways[j][i] += ways[j][i - 1]\n            ways[j][i] %= m\n            ways[j][i] *= a[i - 1]\n            ways[j][i] %= m\n    ans = sum([ways[k][i] * (sum(a[i + 1:i + k + 1]) % m) for i in range(n - k)]) % m\n    return ans",
        "result": "failed: testcase 0"
    },
    "1856": {
        "body": "    d = {}\n    for p in ps:\n        if p not in d:\n            d[p] = set(p)\n    r = 0\n    for x in d.values():\n        c = set()\n        for y in d.values():\n            c |= x & y\n        if c != x and len(x) == len(c):\n            r += 1\n            del d[p for p in d if d[p] == c]\n    return n - len(d)\n\nn = int(input())\nps = []\nfor _ in range(n): ps.append(input()) \nprint(f(n, *ps))",
        "result": "failed: testcase 0"
    },
    "522": {
        "body": "\nM = (1 << 30)\nN, f0, f1, f2, c = map(int, input().split())\nfc = [f1, f2, f3] + [0] * (N-3)\nfor i in range(4, N+1):\n    fc[i] = mod((c*c)%M*fc[i-1]%M*fc[i-2]%M*fc[i-3]%M)\nprint(fc[N])",
        "result": "failed: testcase 0"
    },
    "1719": {
        "body": "    MOD = 10**9+7\n    dp0, dp1, dp2 = [0]*101, [0]*101, [0]*101\n    dp0[1] = 4; dp1[1] = 3; dp2[1] = 3\n    for n in range(2, N+1):\n        dp0[n] = (dp0[n-1]+4*dp2[n-1]) % MOD\n        if n>1:\n            dp0[n] += dp2[n-2]\n        dp1[n] = (dp1[n-1]+3*dp2[n-1]) % MOD\n        if n>1: dp1[n] += 2*dp2[n-2]\n        dp2[n] = (dp2[n-1]+2*dp2[n-1]) % MOD\n        if n>2: dp2[n] += dp2[n-3]\n    return dp0[N]",
        "result": "failed: testcase 0"
    },
    "1842": {
        "body": "import math\n\na, b, c = map(float, input().split())\nd = b**2 - 4*a*c\nx1 = (-b + math.sqrt(d)) / (2 * a)\nx2 = (-b - math.sqrt(d)) / (2 * a)\n\nprint(max(x1, x2))\nprint(min(x1, x2))",
        "result": "passed"
    },
    "806": {
        "body": "    n, l, r = map(int, input().split())\n    M = 10**9 + 7\n    if (r - l + 1) % 3 == 0:\n        return str((r-l+1)//3 * ((r-l+1)//3 + 1)*(r-l+2)//3)\n\n    s = [0, 0, 0]\n    for x in range(l, r + 1):\n        s[x % 3] += 1\n    f = [[0] * (s[2] + 1) for _ in range(n + 1)]\n    f[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(s[2] - i//3 * 3, s[2] + 1):\n            if j >= 0:\n                f[i][j] += f[i-1][j]\n                f[i][j] %= M\n    ans = 0\n    for i in range(1, n + 1):\n        t = (n - i) // 3 * s[2]\n        ans += ((t <= r-l+1) and (i % 3 == n % 3)) and f[i][t] or 0\n        ans %= M\n\n    return str(ans)\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "365": {
        "body": "    segments = []\n    prev_i = -1\n    for i in range(len(a)):\n        if a[i] != 0:\n            segments.append((a[i], i + 1))\n            prev_i = i + 1\n    if len(segments) == 0 or sum([s[0] for s in segments]) != x:\n        return 'NO'\n    if len(segments) > 1:\n        return 'NO'\n    return 'YES'",
        "result": "failed: testcase 0"
    },
    "1158": {
        "body": "    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    counts = {}\n    for x in a:\n        if x not in counts:\n            counts[x] = 1\n        else:\n            counts[x] += 1\n\n    max_count = max(counts.values())\n\n    dishes_per_guest = (max_count + k - 1) // k\n\n    return n - len(set(a)) * dishes_per_guest",
        "result": "failed: testcase 0"
    },
    "33": {
        "body": "    if abs(b1 - b2) > max(abs(R - L), abs(a1 - a2)):\n        return 0\n    c = abs(b1 - b2)\n    d = abs(a1 - a2)\n    if c == 0:\n        return (R // d + 1) * (L >= 0 and L % d == 0 or 1)\n    elif max(abs(R - L), abs(a1 - a2)) == c:\n        return min((R // d + 1), (R - L) // c + 1)\n    else:\n        u = d * (L // d)\n        v = d * ((L + c - 1) // d)\n        w = max(u, v)\n        x = min(R // d * d, R)\n        return x - w + 1",
        "result": "failed: testcase 0"
    },
    "2498": {
        "body": "        while b: a, b = b, a % b\n        return a\n    return a * b // gcd(a, b)\n\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nm = 1\nfor i in A:\n    m = lcm(m, i)\ncnt = 0\nfor i in range(1, M + 1):\n    for j in A:\n        if not (i % j == 0 and 2 * i // j <= M):\n            break\n    else: cnt += 1\nprint(cnt)",
        "result": "failed: testcase 0"
    },
    "2309": {
        "body": "    return sum(1 for char in word if char in 'aeiou')\n\n    return (count_vowels(w1) == count_vowels(v1)) and \\\n           (count_vowels(w2) == count_vowels(v2)) and \\\n           (l1[-1] == l2[-1])\n\n    n = int(input())\n    words = [input() for _ in range(n)]\n    vovels = ['a', 'e', 'i', 'o', 'u']\n    last_vowel = {}\n    for w in words:\n        for c in reversed(w):\n            if c in vovels:\n                last_vowel[w] = c\n                break\n\n    pairs = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if last_vowel[words[i]] == last_vowel[words[j]]:\n                w1 = words[i]\n                w2 = words[j]\n                v1 = next(w for w in words if last_vowel[w] == last_vowel[w1])\n                v2 = next(w for w in words if last_vowel[w] == last_vowel[w2])\n                if count_vowels(w1) >= count_vowels(v1) and \\\n                   count_vowels(w2) >= count_vowels(v2):\n                    pairs.append((w1, v1, w2, v2))\n\n    ans = []\n    for pair in pairs:\n        w1, v1, w2, v2 = pair\n        if is_beautiful_lyric(w1, w2, v1, v2,\n                              last_vowel[w1], last_vowel[w2]):\n            c1 = 0\n            c2 = 0\n            while (count_vowels(w1) >= count_vowels(v1)) and \\\n                  (c1 < words.count(w1)):\n                while (count_vowels(w2) >= count_vowels(v2)) and \\\n                      (c2 < words.count(w2)):\n                    ans.append((w1, v1))\n                    ans.append((w2, v2))\n                    c1 += 1\n                    c2 += 1\n\n    return ans",
        "result": "failed: testcase 0"
    },
    "1326": {
        "body": "    count = 0\n    for i in range(1, int(x**0.5) + 1):\n        if x % i == 0:\n            count += 2\n        if i * i == x:\n            count -= 1\n    return count\n\nN = int(input())\nans = 0\nfor k in range(1, N+1):\n    ans += k * f(k)\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "2950": {
        "body": "    l = len(h)\n    s = sum(h)\n    a = [0] * (s + 1)\n    for i in range(l):\n        a[h[i]] += 1\n    for i in range(1, s + 1):\n        if a[i]:\n            j = i\n            while j <= s:\n                a[j] += a[j - i]\n                j += i\n    ans = 0\n    for i in range(s, 0, -1):\n        if a[i] == l:\n            ans += (s + i - 1) // i\n            s -= i * (s // i)\n        else:\n            return ans + 1\n    return ans",
        "result": "failed: testcase 0"
    },
    "1983": {
        "body": "    n = len(a)\n    dp = [0] * 100001\n    for i in range(n*2-1, -1, -1):\n        dp[i] = max(dp[i+2], 1 + (i == 0 or a[i] > a[i-1]) and dp[i-1])\n    return max(dp)",
        "result": "failed: testcase 0"
    },
    "1767": {
        "body": "n = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n    ans = 0\n    for i in range(l - 1, r):\n        ans |= x[i]\n    return ans\n\npref_a = [0] * (n + 1)\nfor i in range(n):\n    pref_a[i + 1] = pref_a[i] | a[i]\n\npref_b = [0] * (n + 1)\nfor i in range(n):\n    pref_b[i + 1] = pref_b[i] | b[i]\n\nans = float('-inf')\nfor l in range(1, n + 1):\n    for r in range(l, n + 1):\n        ans = max(ans, f(pref_a, l, r) + f(pref_b, l, r))\n\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "2382": {
        "body": "    s = set(S)\n    if len(s) > N or min(s) <= 0 or max(s) >= 10**9:\n        return 'No'\n    elif N == 1:\n        return 'Yes' if set(S) == {S[0]} else 'No'\n    else:\n        S.sort(reverse = True)\n        for i in range(2**N):\n            s.add(max(S))\n            S.append(min(S)-1)\n        return 'Yes' if set(S) == s else 'No'\n\nN = int(input())\nS = list(map(int, input().split()))\nprint(f(N, S))",
        "result": "failed: testcase 0"
    },
    "3907": {
        "body": "    a = {}\n    for _ in range(m):\n        q, w = map(int, input().split())\n        if q not in a:\n            a[q] = 0\n        a[q] += w\n    b = list(a.keys())\n    b.sort()\n    ans = 0\n    cur = 0\n    for x in b:\n        y = (x + 1) * (n - cur)\n        if y >= x:\n            ans += min(y, x) * a[x]\n        else:\n            ans += y * a[x]\n        cur += n\n    return ans",
        "result": "failed: testcase 0"
    },
    "3676": {
        "body": "    if R == 1 or C == 1:\n        return 1 + C * R - 1\n    elif R == 2 and C == 2:\n        return 13\n    else:\n        return (C + 1) * (R + 1) ** 2 - 4 * ((R - 2) * (C - 2) + max(R, C) + 1)\n\n    R, C = map(int, input().split())\n    print(f(R, C))\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3293": {
        "body": "n = int(input())\nprofits = [0] * n\nfor _ in range(n):\n    f, p, m, s = map(int, input().split())\n    profits[f - 1] += max(s * (m - p), 0)\nprint(max(profits))",
        "result": "failed: testcase 0"
    },
    "3587": {
        "body": "    max_length = 0\n    best_clue = ''\n    for i in range(2**50): # arbitrary large limit, assuming taboo strings can fit\n        clue = bin(i)[2:].zfill(max_length+1)\n        is_valid = True\n        for s in taboo:\n            if s in clue:\n                is_valid = False\n                break\n        if is_valid and len(clue) > max_length:\n            max_length = len(clue)\n            best_clue = clue\n    return -1 if not best_clue else best_clue\n\nn = int(input())\ntaboo = [input().strip() for _ in range(n)]\nprint(longest_clue(taboo))",
        "result": "failed: testcase 0"
    },
    "3530": {
        "body": "import sys\n\nN = int(input())\na, b, t = [], [], []\nfor _ in range(N):\n    ai, bi, ti = map(int, input().split())\n    a.append(ai)\n    b.append(bi)\n    t.append(ti)\n\nQ = int(input())\nT = [int(input()) for _ in range(Q)]\n\nresult = []\nfor q in T:\n    i, j = 0, N - 1\n    ans = 0\n    while i <= j:\n        mid = (i + j) // 2\n        if t[mid] * q < a[mid]:\n            ans += a[mid]\n            i = mid + 1\n        elif b[mid] == 0 or q <= (a[mid] - b[mid]) / b[mid]:\n            ans += a[mid] - (q - 1) ** 2 * b[mid]\n            break\n        else:\n            j = mid - 1\n    result.append(ans)\n\nprint('\\n'.join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3900": {
        "body": "    s = set()\n    for i in range(1, n + 1):\n        x, y = map(int, input().split())\n        s.add((x, i))\n        s.add((y, i))\n    m = max(n - p + 1, 0)\n    ans = 0\n    for i in range(m, min(n, p) + 1):\n        v = [0] * (n + 1)\n        for j in s:\n            if v[j[0]] < i:\n                v[j[0]] += 1\n        c = 0\n        for j in s:\n            if v[j[0]] > 0 and v[j[1]] > 0:\n                c += 1\n        ans += (c + 2) * c // 2 - i\n    return ans",
        "result": "failed: testcase 0"
    },
    "3996": {
        "body": "    p = p % q\n    if p == 0: return 0\n    u1, v1 = egcd(p, q)\n    return (u1 + q) % q\n\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b // a) * y, y)\n\nk = int(input())\na = list(map(int, input().split()))\nn = 1\nfor i in range(k):\n    n *= a[i]\n\nmod = 10**9 + 7\n\np = modinv(n, mod)\nq = pow(n, mod - 2, mod)\n\nprint(p, '/', q)",
        "result": "failed: testcase 0"
    },
    "3276": {
        "body": "    N, M = map(int, input().split())\n    grid = [list(input()) for _ in range(N)]\n    stamp = [['W'] * 3 for _ in range(3)]\n\n        return i >= 0 and i < N and j >= 0 and j < M\n\n        for i in range(max(0, x - 1), min(N, x + 2)):\n            for j in range(max(0, y - 1), min(M, y + 2)):\n                if is_valid(i, j) and grid[i][j] == 'W':\n                    stamp[(i - x + 1) % 3][(j - y + 1) % 3] = c\n\n    for i in range(N):\n        for j in range(M):\n            paint(i, j, grid[i][j])\n\n    for i in range(2, N-1):\n        for j in range(2, M-1):\n            if stamp[0][0] == 'W' and \\\n               (grid[i - 1][j] != grid[i + 1][j] or grid[i][j - 1] != grid[i][j + 1]):\n                return \"NO\"\n    return \"YES\"",
        "result": "failed: testcase 0"
    },
    "3834": {
        "body": "from collections import deque\n\nn, m, k = map(int, input().split())\na = [list(map(int, input().split())) for _ in range(n)]\n\n    queue = deque([(i, j)])\n    a[i][j] = 0\n    count = 1\n\n    while queue:\n        x, y = queue.popleft()\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and a[nx][ny] == a[x][y]:\n                queue.append((nx, ny))\n                count += 1\n                a[nx][ny] = 0\n\n    return count\n\n    ans = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                cnt = bfs(i, j)\n                if cnt != (i + 1) * (m - (j + 1 + m % m)):\n                    return -1\n                ans += n * m - cnt\n\n    return ans\n\nprint(check())",
        "result": "failed: testcase 0"
    },
    "3012": {
        "body": "MOD = 1000000007\n\n    a11, a12, a21, a22, N = map(int, input().split())\n    dp = [[0] * 4 for _ in range(2)]\n    sum_dp = [0] * 2\n\n        if n < 5:\n            return n + 1\n        res = (n - 3) % 2 * 9 + 6\n        res %= MOD\n        return res\n\n    for _ in range(N):\n        dp_new = [[0] * 4 for _ in range(2)]\n        sum_dp_new = [0] * 2\n\n        if a11:\n            dp_new[0][0] += get_sum(a11 - 1)\n            sum_dp_new[0] += dp_new[0][0]\n            dp_new[1][0] += a12\n            sum_dp_new[1] += dp_new[1][0]\n\n        if a21:\n            dp_new[1][2] += get_sum(a21 - 1) * a11\n            sum_dp_new[1] += dp_new[1][2]\n            dp_new[0][3] += a22 * (a12 + a21)\n            sum_dp_new[0] += dp_new[0][3]\n\n        if _ % 2 == 1:\n            for i in range(2):\n                for j in range(4):\n                    if not i or not j & 2:\n                        continue\n                    dp_new[i ^ (j >> 2)][j & 1 | 2] += dp[i][j]\n\n        else:\n            for i in range(2):\n                for j in range(4):\n                    if not i or not j & 3:\n                        continue\n                    dp_new[i ^ (j >> 3)][j & 1 | 3] += a21 * dp[i][j]\n\n        sum_dp = sum_dp_new\n\n    print(sum(dp[0]) % MOD)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3745": {
        "body": "    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    color = [-1]*n\n    stack = [(0, -1)]\n\n    while stack:\n        u, p = stack.pop()\n        if color[u] != -1: continue\n\n        c = 0 if p == -1 else ('a' if chr(ord('a') + (ord(graph[p][0]) < u)) == graph[p][0] else 'b')\n        for v in graph[u]:\n            if v != p:\n                stack.append((v, u))\n                color[v] = 3 - c\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if (graph[i][j] == j or\n                not ((color[i] == -1 and color[j] == -1) or \n                     (color[i] != -1 and color[i] != color[j]))):\n                return \"No\"\n\n    s = \"\"\n    for c in color:\n        if c < 0: s += 'a'\n        elif c == 2: s += 'c'\n        else: s += 'b'\n\n    return \"Yes\\n\" + s",
        "result": "failed: testcase 0"
    },
    "3028": {
        "body": "    board = [list(map(int, input().split())) for _ in range(n)]\n    moves = []\n\n        if board[row][col] == p:\n            return 1\n        return (p - board[row][col]) % p + 1\n\n        v = board[row][col]\n        for i in range(n):\n            board[i][col] += 1\n            if board[i][col] > p:\n                board[i][col] %= p\n        for j in range(m):\n            board[row][j] += 1\n            if board[row][j] > p:\n                board[row][j] %= p\n\n        return all(board[i][j] == p for i in range(n) for j in range(m))\n\n    q = []\n    visited = set()\n    moves = []\n\n    for i in range(n):\n        for j in range(m):\n            if (i, j) not in visited:\n                q.append((i, j))\n                visited.add((i, j))\n\n    while q:\n        row, col = q.pop(0)\n        move = get_moves(row, col)\n\n        if check_win():\n            return len(moves) + 1\n\n        for i in range(n):\n            if (i, col) not in visited:\n                make_move(i, col)\n                moves.append((i * m + col))\n                visited.add((i, col))\n                q.append((i, col))\n\n        for j in range(m):\n            if (row, j) not in visited:\n                make_move(row, j)\n                moves.append((row * m + j))\n                visited.add((row, j))\n                q.append((row, j))\n\n    return -1\n\nn, m, p = map(int, input().split())\nprint(solve(n, m, p))",
        "result": "failed: testcase 0"
    },
    "3196": {
        "body": "from collections import defaultdict, deque\nimport sys\nimport math\n\nN = int(input())\nM = int(input())\n\ngraph = [[] for _ in range(N)]\nfor _ in range(M):\n    a, b = map(int, input().split())\n    graph[a-1].append(b-1)\n\n    n = len(graph)\n    queue = deque([(0, 1)])\n    dp = [[0] * (n + 1) for _ in range(n)]\n    dp[0][1] = 1\n    visited = [False] * (n + 1)\n    while queue:\n        node, parent = queue.popleft()\n        if not visited[node]:\n            visited[node] = True\n            for nei in graph[node]:\n                if nei != parent:\n                    dp[nei][node] = 0\n                    queue.append((nei, node))\n    result = []\n    n2 = int(math.pow(10, 9) + 7)\n    for i in range(n):\n        s = sum(dp[i])\n        s %= n2\n        if s != dp[1][i]:\n            result.append(i+1)\n    return len(result)\n\nif bfs(graph) == 1:\n    print(\"inf\")\nelse:\n    print(bfs(graph))",
        "result": "failed: testcase 0"
    },
    "3405": {
        "body": "    X = str(X)\n    digit = int(X[0])\n    multiples = []\n    i = 1\n    while True:\n        s = str(i)\n        if len(s) > 8 or int(s) * float('1.' + X[:3]) != float(int(digit) * '1.' + s[1:]):\n            break\n        multiples.append(int(s))\n        i += 1\n    if not multiples:\n        print(\"No solution\")\n    else:\n        for n in sorted(multiples):\n            print(n)\n\nget_multiples(float(input()))",
        "result": "failed: testcase 0"
    },
    "3126": {
        "body": "n, t = map(int, input().split())\np = list(map(int, input().split()))\nc = int(input())\n\nans = []\n\nfor _ in range(c):\n    line = input()\n    if line.startswith('+'):\n        a = int(line[2:])\n        p.append(a)\n        n += 1\n    elif line.startswith('-'):\n        a = int(line[2:])\n        p.remove(a)\n        n -= 1\n    else:\n        a = int(line[3:])\n\n    s = set(p)\n\n    jumps = 0\n    for i in range(len(s)):\n        v = min(s)\n        jumps += (v + i) * (v + i + 1) // 2 - t * t\n        s.remove(v)\n        t = v\n\n    ans.append(jumps)\n\nprint('\\n'.join(map(str, ans)))",
        "result": "failed: testcase 0"
    },
    "3279": {
        "body": "import sys\n    ans = [['0'] * (n + 1) for _ in range(n)]\n    pos = [[False] * n for _ in range(n)]\n    for i in range(n):\n        cur = -1\n        for v in arr[i]:\n            cur += 1\n            tmp = ['0'] * (v - 1)\n            if cur < len(arr[i]):\n                tmp.append('1')\n            ans[i][cur + 1] = '1'\n            for k in range(cur, min(n, cur + v)):\n                pos[i][k] = True\n                pos[k][i] = True\n    for i in range(0, n):\n        for j in range(i, n):\n            if pos[i][j]:\n                ans[j][i] = '1'\n    return '\\n'.join([''.join(x) for x in ans])\n\n    n = int(input())\n    arr = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        arr.append(row)\n    brr = [x[:] for x in arr]\n    for i in range(n):\n        for j in range(n):\n            row = list(map(int, input().split()))\n            for k in range(len(row)):\n                brr[j][k] = row[k]\n    print(solve(n, arr))\n    print(solve(n, brr))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3599": {
        "body": "from sys import stdin, stdout\n\n    T, N = map(int, stdin.readline().split())\n    break_times = sorted(map(int, stdin.readline().split()))\n\n    stage_times = [0] * N\n    free_members = 0\n    next_free_member = 1\n    t = 0\n\n    for b in range(N):\n        while next_free_member < N and (break_times[next_free_member - 1] <= break_times[b] or next_free_member - free_members > 2):\n            stage_times[next_free_member - 1] = t + break_times[next_free_member - 1]\n            t += break_times[next_free_member - 1]\n            free_members += 1\n            next_free_member += 1\n\n        if next_free_member < N:\n            if break_times[b] <= break_times[next_free_member - 1]:\n                stage_times[b] = t + (break_times[b] - break_times[free_members])\n                t += (break_times[b] - break_times[free_members])\n            else:\n                stage_times[b] = t\n                t += break_times[b]\n\n    stdout.write(' '.join(map(str, stage_times)))\n\nf()",
        "result": "failed: testcase 0"
    },
    "3687": {
        "body": "n, q, s = map(int, input().split())\nq_ids = list(map(int, input().split()))\nc = [0] + list(map(int, input().split()))\nwindows = []\nfor _ in range(n):\n    windows.append(list(map(int, input().split())))\n\nf = [[float('inf')] * (n + 1) for _ in range(q + 1)]\nf[0][0] = 0\n\nfor i in range(1, n + 1):\n    d, *a = windows[i - 1]\n    for j, q_id in enumerate(q_ids):\n        c[q_id] -= a[j]\n\n    for k in range(1, q + 1):\n        f[k][i] = min(f[k][i], f[k][i - 1])\n\n        if c[k] >= d:\n            f[k][i] = min(f[k][i], f[k - 1][i - 1] + c[k] - d)\n\nfor k in range(1, q + 1):\n    if f[k][-1] > c[k]:\n        print('impossible')\n        exit()\n\nprint('possible')",
        "result": "failed: testcase 0"
    },
    "3864": {
        "body": "    MOD = 998244353\n    dp = [[0] * n for _ in range(2)]\n    for c in range(8):\n        b, w = bin(c)[2:].zfill(n).count('1'), n - (bin(c)[2:].zfill(n).count('1'))\n        if b == 3:\n            dp[0][w] += 3\n        elif b == 2 or b == 3:\n            dp[0][w] += 2\n        elif b == 1 or b == 3:\n            dp[0][w] += 1\n        elif b == 0:\n            dp[0][w] += 0\n\n    for i in range(1, n):\n        for j in range(n + 5):\n            dp[i & 1][j] = (dp[(i & 1) ^ 1][max(j - 3, 0)] + dp[i & 1][max(j - 2, 0)]) % MOD\n    return sum(dp[n & 1]) % MOD",
        "result": "failed: testcase 0"
    },
    "3504": {
        "body": "N, M = map(int, input().split())\ndrops = [list(map(int, input().split())) for _ in range(N)]\nsensors = [list(map(int, input().split())) for _ in range(M)]\n\n    global drops, sensors\n    N, M = len(drops), len(sensors)\n    events = []\n    for i in range(N):\n        x, y = drops[i]\n        events.append([x, 0, i])\n        events.append([x + 1, 1, i])\n    for j in range(M):\n        x1, x2, y = sensors[j]\n        events.append([x1, -1, N + j])\n        events.append([x2 + 1, -1, N + j])\n    events.sort()\n    active = []\n    for _, type, i in events:\n        if type == 0:\n            k = bisect.bisect_left(active, drops[i][0], hi=len(active))\n            if k < len(active) and (active[k] <= drops[i][1]):\n                print(sensors[active[k]-N][2])\n                active.pop(k)\n        elif type == 1:\n            k = bisect.bisect_right(active, drops[i][0]) - 1\n            if k >= 0 and (active[k] <= drops[i][1]):\n                active.insert(k+1, i+N)\n        else:\n            if len(active) > 0 and active[-1] < sensors[i-N][1]:\n                active.append(i+N)\n\nfrom bisect import bisect_left, bisect_right\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3451": {
        "body": "import sys\n\nn, k = map(int, input().split())\ns = list(input())\n\ncost = [0] * n\nfor i in range(n):\n    cost[i] = int(input())\n\nopening = 0\nclosing = 0\nmin_change = float('inf')\n\n    if opening <= k + abs(opening - closing) and closing <= k:\n        min_change = min(min_change, s[opening] * cost[opening] + s[n - closing - 1] * cost[n - closing - 1])\n    else:\n        min_change = float('inf')\n\nfor i in range(n):\n    if s[i] == '(':\n        opening += 1\n    else:\n        closing += 1\n\n    update(min_change, opening, closing)\n\nif k == 0 and (opening != closing or (opening - closing) % 2 == 1):\n    print('?')\nelse:\n    print(min_change)",
        "result": "failed: testcase 0"
    },
    "3156": {
        "body": "from collections import defaultdict, deque\nimport sys\n\nn = int(input())\nk = int(input())\n\ngraph = [[] for _ in range(n)]\ninventory = [defaultdict(int) for _ in range(n)]\n\nfor i in range(k):\n    idx, item = input().split()\n    idx = int(idx)\n    graph[idx].append((item, n))\n    inventory[idx][item] += 1\n\nm = int(input())\nbought_items = set()\n\nfor i in range(m):\n    item = input()\n    bought_items.add(item)\n\n    for i, (item, store) in enumerate(path):\n        if graph[store][i][0] != item:\n            return False\n    return True\n\n    q = deque([(start_store, 0)])\n    visited = set([start_store])\n    path = [[] for _ in range(n)]\n\n    while q:\n        store, idx = q.popleft()\n        if graph[store][idx][1] not in visited:\n            next_store = graph[store][idx][1]\n            visited.add(next_store)\n            q.append((next_store, 0))\n\n            path[next_store].append(graph[store][idx])\n            if is_possible(path[start_store] + path[next_store]):\n                return True\n\n    return False\n\nfor i in range(n):\n    if not bfs(i):\n        print('impossible')\n        sys.exit()\n\nseen = set()\nfound_unique_path = False\nfor i in range(n):\n    for j, (item, store) in enumerate(graph[i]):\n        if item in bought_items:\n            seen.add(store)\n        else:\n            path = []\n            q = deque([(store, j)])\n            visited = {store}\n\n            while q:\n                curr_store, idx = q.popleft()\n                path.append((graph[curr_store][idx]))\n\n                next_store = graph[curr_store][idx][1]\n                if next_store not in visited:\n                    visited.add(next_store)\n                    q.append((next_store, 0))\n\n            found_unique_path |= (len(visited) == len(seen))\n\nif found_unique_path:\n    print('unique')\nelse:\n    print('ambiguous')",
        "result": "failed: testcase 0"
    },
    "3697": {
        "body": "    n, k, m, a = map(int, input().split())\n    g = list(map(int, input().split()))\n    votes_counted = [[] for _ in range(n)]\n    for i, v in enumerate(g):\n        votes_counted[v-1].append((i+1, len(votes_counted[v-1])))\n    for i in range(n):\n        votes_counted[i].sort(key=lambda x: (-x[0], -x[1]))\n    result = [3]*n\n    for i in range(k):\n        if len(votes_counted[g[i]-1]) >= k:\n            result[g[i]-1] = 1\n        else:\n            break\n    for i, (votes, last_voted) in enumerate(votes_counted):\n        if votes < k and votes != 0 and last_voted <= a:\n            result[i] = 2\n    return ' '.join(map(str, result))",
        "result": "failed: testcase 0"
    },
    "3647": {
        "body": "from collections import deque\nR, C = map(int, input().split())\ngrid = [list(input()) for _ in range(R)]\ngoal_row, goal_col = None, None\nfor r in range(R):\n    for c in range(C):\n        if grid[r][c] == 'M':\n            goal_row, goal_col = r, c\n\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    for dr, dc in directions:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < R and 0 <= nc < C:\n            yield nr, nc\n\n    visited = [[False]*C for _ in range(R)]\n    dist = [[float('inf')]*C for _ in range(R)]\n    queue = deque([(r, c)])\n    visited[r][c] = True\n    while queue:\n        r, c = queue.popleft()\n        if (r, c) == (goal_row, goal_col):\n            return True\n        dist[r][c] = 1\n        for nr, nc in get_neighbors(r, c):\n            if grid[nr][nc] != '#' and not visited[nr][nc]:\n                char = grid[nr][nc]\n                if char == '.':\n                    queue.append((nr, nc))\n                    visited[nr][nc] = True\n                elif char == '_':\n                    if (nr, nc) in get_neighbors(r, c):\n                        queue.append((nr, nc))\n                        visited[nr][nc] = True\n                else:\n                    queue.append((nr, nc))\n                    visited[nr][nc] = True\n    return False\n\nfor r in range(R):\n    row = []\n    for c in range(C):\n        if grid[r][c] == 'M':\n            row.append(0)\n        elif bfs(r, c):\n            row.append(1 + max(dist[goal_row][goal_col], [dist[nr][nc] for nr, nc in get_neighbors(goal_row, goal_col)]))\n        else:\n            row.append(-1)\n    print(*row)",
        "result": "failed: testcase 0"
    },
    "3699": {
        "body": "import sys\nimport math\nfrom typing import List, Tuple\n\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n\n    ax, ay, bx, by, tx, ty = map(float, input().split())\n    n = int(input())\n    bottles: List[Tuple[float, float]] = []\n    for _ in range(n):\n        x, y = map(float, input().split())\n        bottles.append((x, y))\n    bottles.sort()\n    min_dist = 0.0\n    adil_path = [ax, ay]\n    bera_path = [bx, by]\n    for i in range(len(bottles)):\n        adil_bottle = bottles[i]\n        adil_dist = dist(adil_path[-1], adil_path[-2], adil_bottle[0], adil_bottle[1])\n        min_dist += adil_dist\n        adil_path.append(adil_bottle[0])\n        adil_path.append(adil_bottle[1])\n\n        bera_bottle = bottles[i + 1] if i + 1 < len(bottles) else (tx, ty)\n        bera_dist = dist(bera_path[-2], bera_path[-1], bera_bottle[0], bera_bottle[1])\n        min_dist += bera_dist\n        bera_path.append(bera_bottle[0])\n        bera_path.append(bera_bottle[1])\n\n    return f\"{min_dist:.10f}\"\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "3145": {
        "body": "import sys\n\nx, a, b = map(int, input().split())\nallowed = set(input())\n\n    if n == 0:\n        return ['']\n    res = []\n    for digit in allowed:\n        res.extend(c + str(digit) for c in generate_numbers(n - 1))\n    return res\n\n    res = sum(1 for num in numbers if (a <= int(num) <= b) and ((int(num) % x) == 0))\n    return res\n\nnumbers = generate_numbers(10)\nprint(count_multiples(numbers, x, a, b))",
        "result": "failed: testcase 0"
    },
    "3795": {
        "body": "    if n <= 0: return 0\n    euro = [200, 100, 50, 20, 10, 5]\n    dollar = [100, 50, 20, 10, 5, 2, 1]\n    maxEuro = float('inf')\n    for i in range(6):\n        numEuros = n // (euro[i] * e)\n        if numEuros > 0:\n            remain = n - numEuros * euro[i] * e\n            for j in range(7):\n                x = min(remain // d, numEuros)\n                maxEuro = min(maxEuro, numEuros * euro[i] + x * dollar[j])\n                remain -= x * d\n    return maxEuro",
        "result": "failed: testcase 0"
    },
    "3353": {
        "body": "    P, R, L = map(int, input().split())\n    g = [[] for _ in range(R + 2)]\n    for _ in range(L):\n        a, b = map(lambda x: int(x) - 2 if x != '-1' else -1, input().split())\n        g[a].append(b)\n        g[b].append(a)\n\n    visited = [0] * (R + 2)\n    times = [float('inf')] * (R + 2)\n    for i in range(R + 2):\n        if not visited[i]:\n            time, cnt = 0, P\n            q = [(i, 0)]\n            while q:\n                v, t = q.pop()\n                if t == time:\n                    continue\n                time += 1\n                times[v] = min(times[v], time)\n                for u in g[v]:\n                    if not visited[u]:\n                        cnt -= 1\n                        q.append((u, time))\n                        visited[u] = 1\n            if cnt != 0:\n                return str(cnt)\n\n    res = sum(times[2:])\n    print(res)",
        "result": "failed: testcase 0"
    },
    "3065": {
        "body": "import sys\nfrom collections import deque\nfrom random import randint\n\nN = int(input())\nL = int(input())\nwalk = list(map(int, input().split()))\n\nadj = [[] for _ in range(N)]\nfor i in range(N):\n    temp = list(map(int, input().split()))\n    n = temp[0]\n    adj[i] = [x - 1 for x in temp[1:]]\n\n    dist = [-1] * N\n    dist[walk[0]] = 0\n    q = deque([walk[0]])\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if dist[v] == -1:\n                dist[v] = dist[u] + 1\n                q.append(v)\n    return dist\n\n    dp = [[0.0, 0.0] for _ in range(N)]\n    dp[walk[-1]][0] = 1.0\n    for i in range(L - 2, -1, -1):\n        u = walk[i]\n        v = walk[i + 1]\n        if dist[v] == dist[u] + 1:\n            for j in adj[u]:\n                dp[j][0] += dp[u][randint(0, 1)]\n            dp[u][0] *= (len(adj[u]) - 2) / len(adj[u])\n        else:\n            dp[walk[i]][0] = 0.5\n    return dp[walk[0]][0]\n\ndist = bfs()\nprint(prob(L))",
        "result": "failed: testcase 0"
    },
    "3250": {
        "body": "    while b != 0:\n        a, b = b, a % b\n    return a\n\n    for m in range(1, b + 2):\n        c = 0\n        for i in range(m):\n            c += pow(b, i) * (pow(b, -i) % d)\n        if c % d == 0:\n            return True\n    return False\n\nb, d = map(int, input().split())\nif is_valid_hack(b, d):\n    print(\"yes\")\nelse:\n    print(\"no\")",
        "result": "failed: testcase 0"
    },
    "3306": {
        "body": "M, N = map(int, input().split())\ndetectors = []\nfor _ in range(N):\n    p, c = map(int, input().split())\n    detectors.append((p, c))\ndetectors.sort()\ncalls = [0]\nfor i in range(N):\n    calls.append(calls[-1] + detectors[i][1])\nresult = 0\nfor i in range(1, N):\n    a = detectors[i-1][0] + 1\n    b = detectors[i][0]\n    c = min(detectors[i][0] - detectors[i-1][0], M - (detectors[i][0] + 1))\n    result += max(calls[b+1] - calls[a], 0)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3970": {
        "body": "n, k = map(int, input().split())\na = sorted(map(int, input().split()))\n\nf = [0] * n\ni = 0\nwhile i < n:\n    if a[i] % k != 0 or f[(a[i] // k) - 1] == 0:\n        f[i] = 1\n        j = (a[i] // k)\n        while j < n and f[j] == 0:\n            f[j] = 1\n            j += a[j] * k <= a[i]\n    i += 1\n\nprint(sum(f))",
        "result": "failed: testcase 0"
    },
    "3655": {
        "body": "W, H = map(int, input().split())\nimage = []\nfor _ in range(H):\n    image.append(list(map(int, input().split())))\n\nrobot_w, robot_h = W, H\nfloor_w, floor_h = 0, 0\nmatches = []\n\nfor i in range(W - robot_w + 1):\n    for j in range(H - robot_h + 1):\n        score = sum(image[x][y] == image[x + robot_h][y + robot_w][x - i][y - j] and 1 or 0\n                    for x in range(robot_h) for y in range(robot_w))\n\n        if score > floor_w:\n            matches.clear()\n            matches.append((i, j))\n            floor_w = score\n\n        elif score == floor_w:\n            matches.append((i, j))\n\nprint('\\n'.join(f'{x} {y}' for x, y in sorted(matches)))",
        "result": "failed: testcase 0"
    },
    "3589": {
        "body": "    while x >= 10:\n        d = 0\n        for c in str(x):\n            if int(c) != 0: \n                d *= int(c)\n        x = d\n    return x\n\nL, R = map(int, input().split())\ncnt = [0] * 10\nfor i in range(L, R+1):\n    cnt[f(i)] += 1\nprint(*cnt[1:])",
        "result": "failed: testcase 0"
    },
    "3257": {
        "body": "import math\n\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area if math.isclose(area, round(area, 3)) else -1\n\na, b, c = map(float, input().split())\nprint(carpet_area(a, b, c))",
        "result": "failed: testcase 0"
    },
    "3927": {
        "body": "import sys\n\nn = int(input())\na = sorted(map(int, input().split()))\n\nfor k in range(n - 1, 0, -1):\n    for m in range(sum(a) + 1):\n        possible = False\n        for i in range(2**k):\n            mask = bin(i)[2:].zfill(k)\n            s = sum([a[j] * int(mask[j]) for j in range(k)])\n            if s == m:\n                possible = True\n                break\n        if not possible: continue\n\n        max_mass = 0\n        max_count = 0\n        counts = [0] * (m + 1)\n        for i in range(2**n):\n            mask = bin(i)[2:].zfill(n)\n            s = sum([a[j] * int(mask[j]) for j in range(n)])\n            if s <= m:\n                max_mass += a[n - k]\n                counts[s] += 1\n                if s > max_mass: max_mass, max_count = s, 1\n                elif s == max_mass: max_count += 1\n\n        if max_count == n:\n            print(k)\n            sys.exit()\n\nprint(0)",
        "result": "timed out"
    },
    "3319": {
        "body": "import sys\nfrom collections import deque\nimport math\n\n    while a > 0 and b > 0:\n        if a > b:\n            a %= b\n        else:\n            b %= a\n    return a | b\n\nn = int(input().split()[0])\nnx, ny, nz = map(int, input().split()[1:])\nplanetoids = []\nfor i in range(n):\n    mass, x, y, z, vx, vy, vz = map(int, input().split())\n    planetoids.append((mass, (x, y, z), (vx, vy, vz)))\n\n    return ((loc[0] + vel[0]) % nx,\n            (loc[1] + vel[1]) % ny,\n            (loc[2] + vel[2]) % nz)\n\n    mass1, loc1, vel1 = planetoid1\n    mass2, loc2, vel2 = planetoid2\n    new_mass = mass1 + mass2\n    new_vel = ((mass1 * vel1[0] + mass2 * vel2[0]) // (new_mass),\n               (mass1 * vel1[1] + mass2 * vel2[1]) // (new_mass),\n               (mass1 * vel1[2] + mass2 * vel2[2]) // (new_mass))\n    return ((new_mass, update_location(loc1, new_vel), new_vel), None)\n\n    collisions = deque()\n    for i in range(len(planetoids)):\n        for j in range(i + 1, len(planetoids)):\n            if planetoids[i][2] == planetoids[j][2]:\n                collisions.append((i, j))\n    while collisions:\n        index1, index2 = collisions.popleft()\n        if index1 > index2:\n            index1, index2 = index2, index1\n        new_planetoid, _ = collide(planetoids[index1], planetoids[index2])\n        del planetoids[index1]\n        del planetoids[index2 - 1]\n        planetoids.insert(index2 - 1, new_planetoid)\n        for i in range(len(planetoids)):\n            for j in range(i + 1, len(planetoids)):\n                if planetoids[i][2] == planetoids[j][2]:\n                    collisions.append((i, j))\n    return planetoids\n\n    planetoids.sort(key=lambda x: (-x[0], -x[1][0], -x[1][1], -x[1][2]))\n    result = []\n    for i in range(len(planetoids)):\n        result.append((f\"P{i}\", *planetoids[i]))\n    return result\n\nfinal_planets = resolve_collisions(planetoids)\noutput = [f\"{len(final_planets)}\\n\"] + [\n    f\"{mass} {x+1} {y+1} {z+1} {vx} {vy} {vz}\\n\"\n    for mass, (x, y, z), vx in final_planets\n]\nprint(\"\".join(output))",
        "result": "failed: testcase 0"
    },
    "3009": {
        "body": "import sys\nimport math\n\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\nN = int(input())\nlamps = []\nfor _ in range(N):\n    x, y, e = map(int, input().split())\n    lamps.append((x, y, e))\n\n    s1 = 0\n    s2 = 0\n    visited = [False] * len(lamps)\n    visited[i] = True\n\n    stack = [(i, 0)]\n    while stack:\n        u, si = stack.pop()\n        if lamps[u][2] > 0 and si < -1e-6:\n            return False, s1 + s2\n        for v in range(len(lamps)):\n            if not visited[v]:\n                x1, y1, e1 = lamps[u]\n                x2, y2, e2 = lamps[v]\n                d = distance((x1, y1), (x2, y2))\n                if d < 2 and si + s2 <= -2000:\n                    return False, s1 + s2\n                elif d == 2:\n                    stack.append((v, si - e1 + e2 if e1 > 0 else si + e2))\n        for v in range(len(lamps)):\n            if not visited[v]:\n                x1, y1, e1 = lamps[u]\n                x2, y2, e2 = lamps[v]\n                d = distance((x1, y1), (x2, y2))\n                if d < 2 and si + s2 <= -2000:\n                    return False, s1 + s2\n        visited[j] = True\n        stack.append((j, si - lamps[i][2] + lamps[j][2]))\n    return True, s1 + s2\n\nfor i in range(len(lamps)):\n    for j in range(i+1, len(lamps)):\n        b, s = check_line(lamps, i, j)\n        if b:\n            print(distance(lamps[i][:2], lamps[j][:2]))\n            sys.exit(0)\n\nprint('IMPOSSIBLE')",
        "result": "failed: testcase 0"
    },
    "3896": {
        "body": "    x = int(input(), 2)\n    MOD = 10**9 + 7\n    ret = 0\n    for i in range(30):\n        if (x >> i) & 1:\n            ret += (1 << i)\n            ret %= MOD\n    return sum((ret - n*(n-1)//2)*n//2 for n in range(ret+1))[::-1] % MOD",
        "result": "timed out"
    },
    "3509": {
        "body": "from collections import deque, defaultdict\nimport sys\n\nsys.setrecursionlimit(10**5)\n\n    dist = [float('inf')] * n\n    dist[0] = 0\n    q = [(0, 0)]\n    while q:\n        d, u = min(q)\n        q.remove((d, u))\n        for v, w in adj[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                q.append((dist[v], v))\n    return dist\n\n    visited = [False] * n\n    res = 0\n        nonlocal res\n        if u == n-1: return True\n        for v, w in adj[u]:\n            if not visited[v] and d + w <= b:\n                visited[v] = True\n                if dfs2(v, d+w): return True\n                visited[v] = False\n        return False\n    for i in range(a, b+1):\n        res = max(res, min(b-i, dijkstra(dist)[n-1]))\n        visited[0] = True\n        dfs2(0, 0)\n    return res\n\na, b = map(int, input().split())\nn, m = map(int, input().split())\nadj = [[] for _ in range(n)]\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    adj[u-1].append((v-1, w))\ndist = dijkstra(adj)\nprint(dfs(adj, dist))",
        "result": "failed: testcase 0"
    },
    "3547": {
        "body": "    n = int(input())\n    areas = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        areas.append((x1, y1, x2, y2))\n    total_area = 0\n    for i in range(n):\n        max_x1, min_y1, max_x2, min_y2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n        for j in range(i+1, n):\n            x1, y1, x2, y2 = areas[j]\n            max_x1 = max(max_x1, x1)\n            min_y1 = min(min_y1, y1)\n            max_x2 = min(max_x2, x2)\n            min_y2 = max(min_y2, y2)\n            if (max_x1 <= min_x2) and (min_y1 <= min_y2):\n                area = abs((max_x2 - max_x1) * (min_y2 - min_y1))\n                total_area += area\n        x1, y1, x2, y2 = areas[i]\n        if max_x1 > x1 or min_y1 < y1:\n            area = abs((x2-x1) * (y2-y1))\n            total_area += area\n    return \"{:.2f}\".format(total_area)",
        "result": "failed: testcase 0"
    },
    "3017": {
        "body": "    p = 2 ** e\n    x = str(p)\n    c = [0] * 64\n    m = 10 ** len(x)\n    for i in range(1, m + 1):\n        if str(i).find(x) != -1:\n            c[e] += 1\n    ans = 0\n    for i in range(e, -1, -1):\n        c[i + 1] -= c[i]\n        ans += c[i] * (n // m)\n        n %= m\n        if not n: break\n        m //= 10\n    return ans",
        "result": "failed: testcase 0"
    },
    "3076": {
        "body": "from collections import defaultdict\nimport sys\n\nn, k = map(int, input().split())\njewels = [tuple(map(int, input().split())) for _ in range(n)]\nvalues_by_size = defaultdict(list)\n\nfor s, v in jewels:\n    values_by_size[s].append(v)\n\ndp = [[0] * (k + 1) for _ in range(len(jewels) + 1)]\n\nfor i in range(1, len(jewels) + 1):\n    for j in range(1, k + 1):\n        if jewels[i - 1][0] <= j:\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - jewels[i - 1][0]] + jewels[i - 1][1])\n        else:\n            dp[i][j] = dp[i - 1][j]\n\nresult = [str(max([dp[i][k] for i in range(1, len(jewels) + 1)])) for _ in range(k)]\nprint(' '.join(result))",
        "result": "failed: testcase 0"
    },
    "3923": {
        "body": "    if j == 1: return P[i]\n    return f(P, i, j-1)\n\n    for j in range(1, len(P)+1):\n        if f(P, i, j) == i: return j\n\nN, A, B = map(int, input().split())\nif max(A,B)*2 > N:\n    print(-1)\nelse:\n    P = []\n    left = 0\n    right = N+1\n    while True:\n        if left <= A and right >= B:\n            for i in range(left, min(A+1,right-1)):\n                P.append(i)\n            for i in range(min(A+1,right-1), max(A,B) + 1):\n                P.append(i)\n            for i in range(max(A,B)+1, right):\n                P.append(i)\n            break\n        elif left > A or right < B:\n            break\n        mid = (left+right)//2\n        if g(P+[mid], len(P)) == A:\n            right = mid\n        else:\n            left = mid + 1\n    print(*P)",
        "result": "failed: testcase 0"
    },
    "3332": {
        "body": "import sys\nfrom operator import itemgetter\n\nn = int(input())\nstreams = []\nfor _ in range(n):\n    s, d, p = map(int, input().split())\n    streams.append((s, d, p))\n\nstreams.sort(key=itemgetter(0))\nmax_total_priority = 0\nstack = [0] * (n + 1)\n\ni = 0\nwhile i < n:\n    end_time = -1\n    total_priority = 0\n    while i < n and streams[i][0] <= end_time:\n        s, d, p = streams[i]\n        if s + d > end_time:\n            end_time = s + d\n            stack.pop()\n            max_total_priority = max(max_total_priority, total_priority)\n        else:\n            stack.append(i)\n            total_priority += p\n            i += 1\n\nprint(max_total_priority)",
        "result": "timed out"
    },
    "3240": {
        "body": "k, v = map(int, input().split())\nb = [list(map(int, input().split())) for _ in range(v - 1)]\np = [row[0] for row in b]\nb = [[row[1] >> i & 1 for i in range(k - 1, -1, -1)] for row in b]\n\n    prob = 1\n    bits = [0] * k\n    for i in range(v - 1):\n        if p[i]:\n            prob *= p[i]\n            for j in range(k):\n                bits[j] += mask[i][j] * b[i][j]\n    return sum([bits[i] & (not mask[v-1][i]) == v - 1 and 2**i for i in range(k)])\n\nbest = 0\nfor i in range(2**k):\n    if f(i) > f(best):\n        best = i\n\nprint(sum([(best >> j & 1) * (2**j) for j in range(k)]))",
        "result": "failed: testcase 0"
    },
    "3368": {
        "body": "from collections import defaultdict, deque\n\n    q = deque()\n    for u in adj['monkey']:\n        if u == 'monkey':\n            return \"POSSIBLE\"\n    seen = [False] * len(adj)\n    for i in range(len(adj)):\n        if not seen[i]:\n            q.append(i)\n            while q:\n                v = q.popleft()\n                seen[v] = True\n                for u, e in adj[v].items():\n                    if not seen[adj[u][v]]:\n                        q.append(adj[u][v])\n    return \"IMPOSSIBLE\" if any(e > 1 for e in adj.values()) else \"FALSE ALARM\"\n\nn, m = map(int, input().split())\nadj = defaultdict(lambda: defaultdict(int))\nanimal_count = {}\nfor i in range(n):\n    animals = list(map(str, input().split()))[1:]\n    animal_count[list(map(str, input().split()))[0]] += len(animals)\n    for j, v in enumerate(animals):\n        adj[v][animals[j]] += 1\nprint(bfs(adj))",
        "result": "failed: testcase 0"
    },
    "3538": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    dp = [-1] * len(frogs)\n    for i in range(len(frogs)):\n        if frogs[i][0] > d:\n            dp[i] = 1\n        for j in range(i):\n            if frogs[j][1] + frogs[i][1] <= frogs[j][2]:\n                max_height = max(frogs[j][2], frogs[j][2] + frogs[i][0])\n                new_escape = max(0, max_height > d)\n                dp[i] = max(dp[i], (dp[j] if j != i else 0) + new_escape)\n    return sum(1 for x in dp if x >= 1)\n\nn, d = map(int, input().split())\nfrogs = []\nfor _ in range(n):\n    l, w, h = map(int, input().split())\n    frogs.append([l, w, h])\nprint(can_escape(frogs))",
        "result": "failed: testcase 0"
    },
    "3183": {
        "body": "from collections import defaultdict\nimport sys\n\nclass Edge:\n        self.u = u\n        self.v = v\n        self.c = c\n        self.w = w\n\nN = 256\nINF = 10**9\n\n    n, m, s, t = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v, c, w = map(int, input().split())\n        edges.append(Edge(u, v, c, w))\n    return n, m, s, t, edges\n\n    for e in edges:\n        adj[e.u].append((e.v, cap(e.c), cost(e.w)))\n        adj[e.v].append((e.u, 0, -cost(e.w)))\n\n    dist = [INF] * N\n    dist[s] = 0\n    for _ in range(N-1):\n        for u in range(N):\n            for v, capv, costv in adj[u]:\n                if dist[u] + costv < dist[v]:\n                    dist[v] = dist[u] + costv\n    return dist\n\n    augmenting_path = []\n    dist = bellman_ford(adj, s, t)\n    while True:\n        min_cap = INF\n        for u in range(N):\n            for v, capv, _ in adj[u]:\n                if dist[v] == dist[u] + 1 and capv > 0:\n                    augmenting_path.append((u, v))\n                    min_cap = min(min_cap, capv)\n        if not augmenting_path:\n            break\n        v = augmenting_path[-1][1]\n        for u in reversed(augmenting_path):\n            flow[u] += 1\n            cost[u] -= 1\n            adj[u[0]][adj[u[0]].index((u[1], 0, -cost[u]))][2] += 1\n            adj[v[0]][adj[v[0]].index((v[1], 0, -cost[v]))][2] -= 1\n        flow[t] += min_cap\n        cost[t] += min_cap * dist[t]\n    return flow[s], cost[s]\n\n    n, m, s, t, edges = read_input()\n    adj = defaultdict(list)\n    add_edge(adj, edges, lambda x: x, lambda x: x)\n    flow = [0] * N\n    cost = [0] * N\n    ans_flow, ans_cost = edmonds_karp(adj, s, t, flow, cost)\n    print(ans_flow, ans_cost)\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3916": {
        "body": "    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\n    f = []\n    k = 2\n    while k * k <= n:\n        while n % k == 0:\n            f.append(k)\n            n //= k\n        k += 1\n    if n > 1:\n        f.append(n)\n    return f\n\nn = int(input())\na = list(map(int, input().split()))\nb = [a[i] for i in range(n) if a[i] not in b]\np = {1: 0}\n\nfor x in b[::-1]:\n    f = factor(x)\n    p[x * x] = min(p.get(x * y, float('inf')) + (x // y - y) for y in f)\n\nprint(sum(p[k] * (a.count(k) or 1) for k in a))",
        "result": "failed: testcase 0"
    },
    "3195": {
        "body": "import sys\nfrom math import gcd\n\nT_g, T_y, T_r = map(int, input().split())\nn = int(input())\n\nobserved_Ts = []\nfor _ in range(n):\n    t, c = input().split()\n    t = int(t)\n    if c == 'green':\n        observed_Ts.append((t % (T_g + T_y + T_r), 0))\n    elif c == 'yellow':\n        observed_Ts.append((t % (T_g + T_y + T_r), 1))\n    else:\n        observed_Ts.append((t % (T_g + T_y + T_r), 2))\n\nt_q, cq = input().split()\nt_q = int(t_q)\n\nk = len(observed_Ts)\nobserved_Ts.sort(key=lambda x: x[0])\n\nGCD = gcd(T_g, T_y, T_r)\nfor i in range(k):\n    observed_Ts[i] = ((observed_Ts[i][0] % GCD, observed_Ts[i][1]), i)\n\nans = 0\nfor g, j in [(T_g, 0), (T_y, 1), (T_r, 2)]:\n    for p in range(k):\n        if t_q < observed_Ts[p][0][0] + g:\n            break\n        elif observed_Ts[p][0][0] <= t_q < observed_Ts[(p+1)%k][0][0]:\n            ans += (observed_Ts[p][0][0] - 1) * j\n    for p in range(k):\n        if t_q < observed_Ts[p][0][0] + g:\n            break\n        elif observed_Ts[p][0][0] <= t_q < observed_Ts[(p+1)%k][0][0]:\n            ans += (observed_Ts[p+1][0][0] - 1 - observed_Ts[p][0][0]) * j\n\nfor i in range(k):\n    if observed_Ts[i][0][0] == t_q % GCD and observed_Ts[i][1] == cq:\n        ans += 1\n\nprint(ans / k)",
        "result": "failed: testcase 0"
    },
    "3998": {
        "body": "from itertools import combinations_with_replacement, permutations\nimport sys\n\nn = int(input())\nr = list(map(int, input().split()))\n\nmax_r = max(r)\nwhile True:\n    if all(r_i >= 0 for r_i in r):\n        break\n    r_diff = [abs(r[i] - r[j]) for i in range(n) for j in range(i + 1, n)]\n    max_r_diff = max(r_diff)\n\n    p = []\n    for c in combinations_with_replacement(range(2, min(max_r_diff + 1, n + 1)), len(set(r))):\n        s = set(c)\n        t = tuple(sorted(s))\n        if t not in p:\n            p.append(t)\n\n    moves = [0] * n\n    i = 0\n    while True:\n        for c in p[i % len(p)]:\n            r[c[0]] -= 1\n            r[c[1]] -= 1\n            moves[c[0]] += 1\n            moves[c[1]] += 1\n\n        if all(r_i >= 0 for r_i in r):\n            break\n        i += 1\n\n    max_r = min(max_r, min(r))\n    sys.stdout.write(f'{max_r}\\n')\n\n    count = sum(moves)\n    t = ''\n    for c in moves:\n        t += '01'[c % 2]\n\n    l = [t]\n    while len(t) < n * (count - 1):\n        s = t + '0' * (len(t) % n)\n        if s[:n] not in l and s[:n]:\n            l.append(s[:n])\n            t += s[n:]\n\n    for s in l:\n        sys.stdout.write(f'{s}\\n')\n\nsys.stdout.flush()",
        "result": "failed: testcase 0"
    },
    "3150": {
        "body": "from collections import defaultdict, deque\nimport sys\ninput = lambda: sys.stdin.readline().rstrip()\n\n    n = int(input())\n    graph = [[] for _ in range(1001)]\n    seen = [[False] * 1001 for _ in range(1001)]\n    dist = [[float('inf')] * 1001 for _ in range(1001)]\n\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        x1, y1, x2, y2 = min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)\n        if x1 == x2:\n            continue\n        for i in range(x1 + 1, x2):\n            graph[i].append((x1, y1))\n            graph[i].append((x2, y2))\n\n    q = deque()\n    for node in range(1001):\n        if len(graph[node]) == 0:\n            continue\n        dist[0][node] = 0\n        q.append(node)\n\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            x, y = v\n            if seen[x][y]:\n                continue\n            seen[x][y] = True\n            if dist[x][y] == float('inf'):\n                q.append((x, y))\n            dist[x][y] = 1 + min(dist[u][0], dist[0][v])\n\n    cnt = [0] * 1002\n    for i in range(1, 1002):\n        if seen[i][i]:\n            continue\n        for j in range(i + 1, 1002):\n            if not seen[j][j]:\n                continue\n            cnt[dist[i][j]] += 1\n\n    ans = 0\n    for i in range(3, len(cnt)):\n        if i >= 4 and cnt[i] == 0:\n            continue\n        x, y = divmod(i - 2, 2)\n        z = max(x + 1, y)\n        c = (cnt[x] * cnt[y]) % (1_000_000_007)\n        ans += (c * cnt[z])\n    print(ans)\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3566": {
        "body": "    diffs = [abs(a[i] - a[(i + 1) % n]) for i in range(n)]\n    for i in range(q):\n        i, x = map(int, input().split())\n        diff = abs(x - a[i])\n        a[i] = x\n        if i > 0:\n            diffs[i], diffs[i-1] = min(diffs[i], diffs[i-1]), max(diffs[i], diffs[i-1])\n        for j in range(i + 2, n):\n            diffs[j-1] += diff - abs(x - a[(j - 1) % n])\n            diffs[j] -= diff\n        diffs.sort()\n        print((i + diffs.index(min(diffs))) % n)\n\nn, q = map(int, input().split())\na = list(map(int, input().split()))\nfor _ in range(q):\n    food_truck(n, q, a)",
        "result": "failed: testcase 0"
    },
    "3401": {
        "body": "import sys\nimport math\n\nn, s, t, q = map(int, input().split())\nhills = [tuple(map(int, input().split())) for _ in range(n)]\nsprings = list(map(int, input().split()))\ntowns = list(map(int, input().split()))\n\nedges = [[] for _ in range(n + 1)]\n\nfor i in range(n):\n    x0, y0, h0 = hills[i]\n    for j in range(i + 1, n):\n        x1, y1, h1 = hills[j]\n        dx = x1 - x0\n        dy = y1 - y0\n        dh = h1 - h0\n        if 2 * abs(dh) <= min(dx, dy):\n            weight = math.sqrt((dx ** 2 + dy ** 2) / (dh ** 2))\n            edges[i].append((j, weight))\n            edges[j].append((i, weight))\n\n    dist = [float('inf')] * (n + 1)\n    prev = [-1] * (n + 1)\n\n    dist[start] = 0\n    queue = [(start, 0)]\n\n    while queue:\n        u, d = queue.pop(0)\n\n        for v, w in edges[u]:\n            if dist[v] > d + w:\n                dist[v] = d + w\n                prev[v] = u\n\n                queue.append((v, dist[v]))\n\n    return dist, prev\n\ntotal_dist = 0\nfor i in range(t):\n    s_i = springs[i - 1]\n    t_j = towns[i - 1]\n\n    dist_spring_town = [float('inf')] * (n + 1)\n    prev_spring_town = [-1] * (n + 1)\n\n    for h in range(n):\n        if hills[h][2] == springs[i - 1]:\n            spring_dist, _ = dijkstra(h)\n            break\n    else:\n        print('IMPOSSIBLE')\n        sys.exit(0)\n\n    for h in range(n):\n        if hills[h][2] == towns[i - 1]:\n            town_dist, prev = dijkstra(h)\n            break\n\n    for k in range(s + n):\n        dist_spring_town[k] = min(dist_spring_town[k], spring_dist[k] + town_dist[k])\n\n    for h in range(n):\n        if hills[h][2] == springs[i - 1]:\n            prev_h = prev_spring_town[h]\n            break\n    else:\n        continue\n\n    total_dist += dist_spring_town[t_j]\n\n    while t_j != -1 and dist_spring_town[t_j] < float('inf'):\n        total_dist -= edges[prev_spring_town[t_j]][0][1]\n        t_j = prev_spring_town[t_j]\n\nif total_dist <= q:\n    print(format(total_dist, '.6f'))\nelse:\n    print('IMPOSSIBLE')",
        "result": "failed: testcase 0"
    },
    "3660": {
        "body": "    n = int(input())\n    cost_dict = {}\n    for _ in range(n):\n        w, p = input().split()\n        cost_dict[w] = int(p)\n    \n    dp = [[float('inf')] * (len(s) + 1) for _ in range(2)]\n    dp[0][0] = 0\n    for i in range(len(s)):\n        if s[i] == ' ':\n            continue\n        j = 1 - (i % 2)\n        for k, w in cost_dict.items():\n            l = i + len(k) - 1\n            if l <= len(s):\n                dp[j][l] = min(dp[j][l], dp[j ^ 1][i] + w)\n\n        for k, w in cost_dict.items():\n            l = i + len(k)\n            if s[l:] == k and l <= len(s) - 2:\n                r = l + len(k) - 1\n                dp[j][r] = min(dp[j][r], dp[j ^ 1][i] + w)\n\n    return 'IMPOSSIBLE' if dp[1][-1] == float('inf') else str(dp[1][-1])\n\ns = input()\nprint(min_cost(s, [input().split() for _ in range(int(input()))]))",
        "result": "failed: testcase 0"
    },
    "3721": {
        "body": "from collections import defaultdict\nimport sys\n\nn, m, q = map(int, input().split())\ngraph = defaultdict(set)\nsamples = set()\n\nfor _ in range(q):\n    r, c = map(int, input().split())\n    graph[(r, c)].add((r, c))\n    samples.add((r, c))\n\n    for r in range(1, n + 1):\n        if (r, col) not in graph:\n            return [(r, col)]\n    for c in range(1, m + 1):\n        if (row, c) not in graph and (row, c) not in samples:\n            return [(row, c)]\n\ncount = q\nfor row in range(1, n + 1):\n    for col in range(1, m + 1):\n        if (row, col) not in samples:\n            count += 1\n            neighbors = get_neighbors(row, col)\n            for neighbor in neighbors:\n                graph[neighbor].add((row, col))\n                graph[(row, col)].add(neighbor)\n\nqueue = list(graph.keys())\nwhile queue and count < n * m:\n    u = queue.pop()\n    if len(graph[u]) == 0:\n        continue\n    v = None\n    for neighbor in graph[u]:\n        if neighbor not in samples and (v is None or graph[neighbor] >= graph[v]):\n            v = neighbor\n    if v is not None:\n        count -= 1\n        graph[v].add(u)\n        graph[u].add(v)\n        queue.extend(graph[u])\nprint(count)",
        "result": "failed: testcase 0"
    },
    "3811": {
        "body": "    while b != 0:\n        a, b = b, a % b\n    return a\n\nn = int(input())\na = []\nb = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    a.append(x)\n    b.append(y)\n\n    for i in range(2, min(a[0], b[0]) + 1):\n        if all(i % xx == 0 or ii % i == 0 for xx, ii in zip(a, b)):\n            return i\n    return -1\n\nprint(f(a, b))",
        "result": "failed: testcase 0"
    },
    "3528": {
        "body": "n = int(input())\nx = []\ny = []\nfor i in range(n):\n    xi, yi = map(int, input().split())\n    x.append(xi)\n    y.append(yi)\nops = list(input())\n\n    return abs((x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)) / 2\n\narea = []\nfor i in range(n-2):\n    if ops[i] == 'L':\n        idx = next(j for j, v in enumerate(x) if v == min([v for k, v in enumerate(x) if k != i]))\n        area.append(str(calc_area(min(x), min(y), max(x), max(y), x[idx], y[idx])))\n    elif ops[i] == 'R':\n        idx = next(j for j, v in enumerate(x) if v == max([v for k, v in enumerate(x) if k != i]))\n        area.append(str(calc_area(min(x), min(y), max(x), max(y), x[idx], y[idx])))\n    elif ops[i] == 'U':\n        idx = next(j for j, v in enumerate(y) if v == max([v for k, v in enumerate(y) if k != i]))\n        area.append(str(calc_area(min(x), min(y), max(x), max(y), x[i], y[idx])))\n    else:\n        idx = next(j for j, v in enumerate(y) if v == min([v for k, v in enumerate(y) if k != i]))\n        area.append(str(calc_area(min(x), min(y), max(x), max(y), x[i], y[idx])))\n\nprint('\\n'.join(area))",
        "result": "failed: testcase 0"
    },
    "3890": {
        "body": "    res = 1\n    while b > 0:\n        if b & 1:\n            res = (res * a) % m\n        a = (a * a) % m\n        b >>= 1\n    return res\n\nn, k = map(int, input().split())\nif n == k:\n    print(1)\nelif n == 1:\n    print(1)\nelse:\n    ans = modpow(k, n - 2, 1000000007) * pow(n - k, (k + 1) // 2, 1000000007) % 1000000007\n    ans *= modpow(k - 1, (n - k - 1) * (k - 1) // 2, 1000000007)\n    ans %= 1000000007\n    for i in range(1, n + 1):\n        if i not in [j for j in range(1, min(k, n))]:\n            ans *= pow(n, (n - i) * (n - k), 1000000007)\n            ans %= 1000000007\n    print(ans)",
        "result": "failed: testcase 0"
    },
    "3534": {
        "body": "    best_k = -1\n    best_count = 0\n    for k in range(1, 2*n+1):\n        count = 1\n        prev = a[0]\n        ok = True\n        for i in range(1, n):\n            if a[i] > prev:\n                new_key = min(prev + k, a[i])\n            elif a[i] < prev:\n                new_key = max(prev - k, a[i])\n            else:\n                new_key = prev\n            count += (new_key == a[i])\n            if not (a[i] >= new_key and a[i] <= new_key+1):\n                ok = False\n                break\n            prev = new_key\n        if ok and count > best_count:\n            best_k = k\n            best_count = count\n    return [best_count, best_k]",
        "result": "failed: testcase 0"
    },
    "3371": {
        "body": "    n, c = map(int, input().split())\n    e = [[] for _ in range(n+1)]\n    for _ in range(c):\n        a, b, y = map(int, input().split())\n        e[a].append(y)\n        e[b].append(y)\n    e = [[y[0] for y in sorted(e[i])] for i in range(1, n+1)]\n        v = [False] * (n + 1)\n        s = set()\n        ans = 0\n        for i in range(1, n+1):\n            if e[i]:\n                mi = min(y for y in e[i] if y >= Y)\n                v[i] = True\n                ans += 1\n                for j in range(i + 1, n + 1):\n                    if e[j]:\n                        mx = max(y for y in e[j] if y < Y)\n                        if not v[j]:\n                            s.add((mi, mx))\n        return len(s) <= (n * 2 // 3 - ans), ans\n    lo, hi = 1948, 2007\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        p1, _ = go(mid)\n        if not p1: lo = mid + 1\n        else:\n            p2, s2 = go(mid + 1)\n            if p2 and s2 <= (n * 2 // 3):\n                print(mid + 1)\n                return\n            hi = mid - 1\n    if lo == 2007: print('Impossible')\nf()",
        "result": "failed: testcase 0"
    },
    "3621": {
        "body": "    if not S: return 0\n    a = 1 << len(S)\n    c = [0] * a\n    for i in range(a):\n        if bin(i).count('1') % 2:\n            continue\n        u = i\n        while True:\n            v = u & -u\n            c[i | v] = max(c[i | v], c[u ^ v])\n            if not u: break\n            u ^= v\n    return sum((1 << len(S)) * (c[a-1-j] + 1) for j in range(a)) % (10**9 + 7)\n\nn = int(input())\ng = [list(map(int, input().split())) for _ in range(n)]\na = [0] * n\nfor c in g:\n    for i in range(1, n):\n        a[i] |= 1 << (c[i-1] - 1)\nans = 0\nfor i in range(2**(n-1)):\n    ans += f([j+1 for j in range(n) if (i >> j) & 1])\nprint(ans % (10**9 + 7))",
        "result": "failed: testcase 0"
    },
    "3392": {
        "body": "from collections import deque\n\nN = int(input())\ngridH = [[0] * N for _ in range(N)]\ngridV = [[0] * N for _ in range(N)]\n\nfor i in range(N):\n    gridH[i] = list(map(int, input().split()))\n\nfor i in range(N):\n    gridV[i] = list(map(int, input().split()))\n\nans = 0\n\n    global ans\n    visited.add((x, y))\n    queue.append((x, y))\n\n    while len(queue) > 0:\n        x, y = queue.popleft()\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and gridH[nx][ny] == h and gridV[nx][ny] == gridV[x][y] and (nx, ny) not in visited:\n                queue.append((nx, ny))\n                visited.add((nx, ny))\n\n    ans = max(ans, len(visited))\n\nfor i in range(N):\n    for j in range(N):\n        h = int(gridH[i][j] + gridV[i][j] * (N - 1))\n        visited = set()\n        queue = deque()\n        dfs(i, j, h)\n\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "3095": {
        "body": "    return list(map(int, input().split()))[:S]\n\nR, S = map(int, input().split())\nA = [get_row(i, R, S) for i in range(R)]\n\nmax_elements = 0\nfor r1 in range(2, R+1):\n    if max_elements >= R * (R - 1) // 2:\n        break\n    for s1 in range(2, S+1):\n        if max_elements >= R * (S - 1) // 2:\n            break\n\n        for r2 in range(r1-1, R):\n            if max_elements >= r2 * (r2 + 1) // 2:\n                break\n            for s2 in range(s1-1, S):\n\n                valid = True\n                for i in range(1, r1):\n                    if A[i][s2] > A[r1][s2] + A[i][s1] - A[r1][s1]:\n                        valid = False\n                        break\n\n                if not valid:\n                    continue\n\n                count_elements = (r2 - r1 + 1) * (s2 - s1 + 1)\n                max_elements = max(max_elements, count_elements)\n\nprint(max_elements)",
        "result": "failed: testcase 0"
    },
    "3769": {
        "body": "    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = res * a % mod\n        a = a * a % mod\n        b //= 2\n    return res\n\np, k = map(int, input().split())\nif p == k:\n    print(powmod(p, p - 1, 10**9 + 7))\nelse:\n    ans = powmod(k, (p - 1) // gcd(p - 1, k), 10**9 + 7)\n    for g in range(1, min(k, p - 1) + 1):\n        if (k * powmod(g, p - 2, p)) % p == 1:\n            ans = (ans + powmod(powmod(p, p // g, 10**9 + 7), p - 1, 10**9 + 7) - 1) % (10**9 + 7)\n    print(ans)",
        "result": "failed: testcase 0"
    },
    "3563": {
        "body": "    return (q[1] - p[1]) * (r[0] - q[0]) > (r[1] - q[1]) * (q[0] - p[0])\n\n    n = len(points)\n    if n < 3:\n        return points\n    hull = []\n    l = 0\n    for i in range(1, n):\n        if points[i][0] < points[l][0]:\n            l = i\n    p = l\n    q = 0\n    while True:\n        hull.append(points[p])\n        q = (p + 1) % n\n        for i in range(n):\n            if orientation(points[p], points[i], points[q]) == 0:\n                q = i\n        p = q\n        if p == l:\n            break\n    return hull\n\n    hull = convex_hull(points)\n    lines = set()\n    for i in range(1, len(hull)):\n        lines.add((hull[i - 1][0], hull[i - 1][1], hull[i][0], hull[i][1]))\n    return lines\n\n    n = int(input().split()[0])\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    lines = find_lines(points)\n    print(len(lines))\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3618": {
        "body": "    res = 1\n    while b > 0:\n        if b % 2 == 1:\n            res = (res * a) % 998244353\n        a = (a * a) % 998244353\n        b //= 2\n    return res\n\n    mod = 998244353\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        if i == 1:\n            dp[i] = fastpow(i + 9, n - 1) % mod\n        else:\n            for j in range(i - 1, 0, -1):\n                if j > 1 and (i - j) // 2 < i - 1:\n                    continue\n                dp[i] += dp[j]\n            dp[i] %= mod\n    return dp[n]\n\nn = int(input())\nprint(count_pairs(n))",
        "result": "failed: testcase 0"
    },
    "3830": {
        "body": "    i = 0\n    while i < n and s[i] != '-':\n        i += 1\n    j = i - 1\n    while j >= 0 and s[j] != '-':\n        j -= 1\n    k = n + i - 1\n    while k < n and s[k] != '-':\n        k += 1\n    l = k + 1\n    while l < n and s[l] != '-':\n        l += 1\n    m = [False] * (n + 1)\n    for x in range(i, j + 1):\n        m[x] = True\n    if i <= j:\n        return sum(m)\n    else:\n        c = 0\n        for x in range(k + 1, n + 1):\n            if s[(x - k) % n] == '>':\n                c += not m[x]\n        return (n - c)",
        "result": "failed: testcase 0"
    },
    "3912": {
        "body": "    n = int(input())\n    s = input()\n    a = [0] * 58\n    for c in s:\n        a[ord(c) - ord('a')] += 1\n    a[26:32] = a[:6][::-1]\n    k, m = 1, 0\n    while True:\n        if all(a[i] == 0 or i // 6 * 2 <= a[i] for i in range(58)):\n            break\n        if max(a) % 2 > 0 and (a[26:32] + [max(a) % 2])[:27] != a[26:32][::-1]:\n            k += 1\n            m = max(m, a.index(max(a)) // 6 * 2)\n        else:\n            for i in range(58):\n                a[i] -= (a[i] >= m and a[i] % 2 > 0) or (a[i] >= m + 1)\n    c = 0\n    ans = []\n    for _ in range(k):\n        ans.append(''.join(c ^= 32 & ord(c) < 97 for c in s[m:]))\n        m += k * (max(a) - 2 * a.count(max(a)) // 2 + 1)\n    print(k)\n    print(*ans, sep=' ')",
        "result": "failed: testcase 0"
    },
    "3878": {
        "body": "    n, m = map(int, input().split())\n    graph = {}\n    for _ in range(m):\n        u, v = map(int, input().split())\n        if u not in graph:\n            graph[u] = set()\n        if v not in graph:\n            graph[v] = set()\n        graph[u].add(v)\n        graph[v].add(u)\n\n    degrees = {i: len(graph[i]) for i in range(1, n + 1)}\n    queue = [max(degrees, key=degrees.get)]\n    steps = []\n    while queue:\n        current_node = queue.pop(0)\n        steps.append(current_node)\n        for neighbor in graph[current_node]:\n            degrees[neighbor] -= 1\n            if degrees[neighbor] == 0:\n                queue.append(neighbor)\n\n    print(len(steps) - 1)\n    print(*steps[-2::-1])\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3010": {
        "body": "from collections import defaultdict\n\n    x0, y0 = p1\n    x1, y1 = p2\n    if x0 == x1:\n        return (x0, float('inf'))\n    m = (y0 - y1) / (x0 - x1)\n    b = y0 - m * x0\n    return (m, b)\n\n    n = int(input())\n    points = []\n    edges = defaultdict(int)\n    for _ in range(n):\n        p1 = tuple(map(int, input().split()))\n        p2 = tuple(map(int, input().split()))\n        if p1 == p2:\n            continue\n        line = intersect(p1, p2)\n        x, y = intersect(p2, p1)\n        edges[line] += 1\n        edges[x] += 1\n    edges2 = {}\n    for key, value in edges.items():\n        if type(key) != tuple or len(key) > 2:\n            continue\n        if key not in edges2:\n            edges2[key] = set()\n        edges2[key].add(value)\n    ans = 0\n    for values in edges2.values():\n        if any(v >= 2 for v in values):\n            ans += 1\n    if len(edges2) > 1000:\n        print(-1)\n    else:\n        print(len(edges2))\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3068": {
        "body": "from itertools import combinations\n\nn = int(input())\ninvestigations = [tuple(map(str, input().split())) for _ in range(n)]\n\nsuspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\nblack_vienna = suspects.copy()\n\nfor investigation in investigations:\n    a, b, player, result = investigation\n    if result == 1 and (player == '1' and a not in black_vienna or player == '2' and a in black_vienna):\n        black_vienna.remove(a)\n    elif result == 1 and (player == '1' and b not in black_vienna or player == '2' and b in black_vienna):\n        black_vienna.remove(b)\n    elif result == 2:\n        if player == '1':\n            black_vienna.remove(a)\n            black_vienna.remove(b)\n        else:\n            black_vienna.discard(a)\n            black_vienna.discard(b)\n\nadmissible_solutions = 0\nfor combination in combinations(black_vienna, 3):\n    admissible_solutions += 1\n\nprint(admissible_solutions)",
        "result": "failed: testcase 1"
    },
    "3030": {
        "body": "import sys\nsys.stdin = open(0)\nn = int(input())\nadj = [[] for _ in range(n+1)]\nfor i in range(n):\n    v, p = map(int, input().split())\n    adj[p].append(i)\n\n    ans = 0\n    stack = [(0, -1)]\n    while stack:\n        node, parent = stack.pop()\n        if node == parent:\n            ans += 1\n        for child in adj[node]:\n            if child != parent:\n                stack.append((child, node))\n    return ans\n\nprint(max_subset(adj))",
        "result": "failed: testcase 0"
    },
    "3630": {
        "body": "    n = len(s1)\n    dp = [[0] * 26 for _ in range(n)]\n    dp[0][ord(s1[0]) - ord('a')] = 0\n\n    for i in range(1, n):\n        for j in range(26):\n            if s1[i] == chr(j + ord('a')):\n                dp[i][j] = dp[i-1][j]\n            elif 'a' <= s2[i] <='z':\n                prev = (ord(s2[i]) - ord('a')) % 26\n                if j != prev and not ('z' in s1[i-(prev-j):i]):\n                    dp[i][j] = min(dp[i-1][j], dp[i-1][prev]+1)\n\n    ans = float('inf')\n    for k in range(26):\n        for l in range(k, -1, -1):\n            if not ('a' <= s2[-1] <='z'):\n                continue\n            if ord(s2[n-1]) - ord('a') == k or ord(s2[n-1]) - ord('a') == (k-l) % 26:\n                ans = min(ans, dp[-1][k] + dp[-1][(k-l)%26]+1)\n    return str(ans)\n\ns = input().split()\nprint(solve(*s))",
        "result": "failed: testcase 0"
    },
    "3133": {
        "body": "    visited = set()\n    tower_a = {u for u in adj[a] if adj[u][2]}\n    tower_b = {u for u in adj[b] if adj[u][2]}\n    \n        if u == a or u == b:\n            return not (see_tower and (tower_a ^ tower_b))\n        \n        if u in visited:\n            return False\n        \n        visited.add(u)\n        for v in [adj[u][0], adj[u][1]]:\n            if v not in visited:\n                yield from dfs(v, turns + 1, see_tower | (v in tower_a))\n    \n    for u in adj[a]:\n        if u == b:\n            continue\n        see_tower = adj[u][2]\n        if list(dfs(u, 0, see_tower)):\n            return 0\n    \n    for u in adj[b]:\n        if u == a:\n            continue\n        see_tower = adj[u][2]\n        if list(dfs(u, 0, see_tower)):\n            return 1\n    \n    return -1\n\nn, a, b = map(int, input().split())\nadj = [[] for _ in range(n)]\nfor i in range(n):\n    l, r, t = map(int, input().split())\n    adj[i] = [l, r, t]\n\nprint(f(n, a, b, adj))",
        "result": "failed: testcase 0"
    },
    "3480": {
        "body": "L, D = map(int, input().split())\nsyllables = [input().split()]\ntimes = [[int(t) for t in input().split()]]\n\nfor i in range(L-1):\n    syllables.append(input().split())\n    times.append([int(t) for t in input().split()])\n\n    lines = []\n    current_line = \"\"\n    max_time = 0\n    for (i, s), time in zip(enumerate(syllable_times), syllable_times):\n        if i > 0:\n            prev_syllable = syllables[i-1][s]\n            prev_time = times[i-1][s]\n            current_line += \"_____\"\n            max_time = max(max_time, delay + prev_time)\n        time += delay\n        max_time = max(max_time, time)\n        if time > max_time:\n            lines.append(current_line)\n            current_line = \"\"\n        current_line += s + \"_\"\n    lines.append(current_line)\n    return lines\n\nprint(\"\\n\".join(align(times[0])))\nfor i in range(L):\n    print(\"____________________\")\nfor i in range(L):\n    times_i = align([t for t in zip(syllables[i], times[i]) if t[1] > D])\n    print(\"\\n\".join(times_i))",
        "result": "failed: testcase 0"
    },
    "3389": {
        "body": "from collections import defaultdict\nimport sys\n\nn, k = map(int, input().split())\ns = input()\ncnt = defaultdict(int)\nlast = {}\nfor i in range(n):\n    cnt[s[i]] += 1\n    last[s[i]] = s[i] if i == n - 1 else s[i + 1]\n\nans = 0\np = 'A'\nwhile True:\n    if p not in last or not cnt[last[p]]:\n        ans += 1\n        p = 'A'\n        continue\n    for c in set(s):\n        if c != p and cnt[c]:\n            p = c\n            break\n    else:\n        p = last[p]\n    ans += 1\n    cnt[last[p]] -= 1\nprint(ans - 1)",
        "result": "timed out"
    },
    "3925": {
        "body": "    c = s.count('b')\n    l = 0\n    d = {'bb':-1, 'bw':1, 'wb':1, 'ww':-1}\n    for i in range(len(s)):\n        if c == len(s) // 2:\n            break\n        v = s[i:i+2]\n        if v not in d:\n            continue\n        l += (i > 0 and s[i-1] != v[0])\n        l += d[v]\n    return max(0, len(s)-l)",
        "result": "failed: testcase 0"
    },
    "3700": {
        "body": "    if k <= 1 + n // 2 or k > n: return 0\n    left = k - n\n    right = n - k\n    for i in range(1, n+1):\n        if i + (left or right) > n or i + (left or right) < 1: continue\n        ans += max(left, right)\n        break\n    return ans",
        "result": "failed: testcase 0"
    },
    "3944": {
        "body": "    ans = 1\n    while n > 0:\n        if n % 2 == 1: \n            ans = (ans * a) % MOD\n        a = (a * a) % MOD\n        n //= 2\n    return ans\n\nN, M, K = map(int, input().split())\nMOD = 10**9 + 7\nans = pwr(3, N+M+K, MOD)\nfor i in range(N):\n    for j in range(M+1):\n        if (i != N-1 or j != M) and (j == M or (j < M and ord('a' + chr(j)) > ord('b'))):\n            ans = (ans - pwr(3, i+j, MOD), MOD)\nfor i in range(K+1):\n    for j in range(M):\n        if (i != K-1 or j != M) and (j == M or (j < M and ord('a' + chr(j)) > ord('c'))):\n            ans = (ans - pwr(3, i+j, MOD), MOD)\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "3821": {
        "body": "import sys\n\nn = float(input())\np = sorted([float(x) for x in input().split()], reverse=True)\n\nresult = 0.0\nfor i in range(1, min(n + 1, 100)):\n    prob = sum(p[j] * (1 - p[j]) ** (i - j - 1) * (p[j] ** i) for j in range(i))\n    result = max(result, prob)\n\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3667": {
        "body": "    w, p = map(int, input().split())\n    wells = {}\n    pipes = []\n    for i in range(w):\n        x, y = map(int, input().split())\n        wells[i] = (x, y)\n    for i in range(p):\n        s, x, y = map(int, input().split())\n        pipes.append((s-1, x-y, i))\n    pipes.sort()\n    graph = {}\n    for pipe in pipes:\n        x, y, i = pipe\n        if x not in graph: graph[x] = []\n        graph[x].append(i)\n    used_pipes = [False]*p\n    intersections = 0\n    for node, edges in graph.items():\n        if len(edges) > 2:\n            print(\"impossible\")\n            return\n        for edge in edges:\n            used_pipes[edge] = True\n            intersections += 1\n    for i in range(p):\n        if used_pipes[i]: continue\n        s, x, y = pipes[i]\n        count = sum(1 for j in graph[x] if pipes[j][0] == s)\n        if count % 2 != 0:\n            print(\"impossible\")\n            return\n    print(\"possible\" if intersections == len(graph) else \"impossible\")",
        "result": "failed: testcase 0"
    },
    "3959": {
        "body": "    m = int(input())\n    n = int(input())\n    v = []\n    for _ in range(m):\n        a = [int(x) - 1 for x in input().split()[1:]]\n        v.append(a)\n    cnt = [[0] * n for _ in range(n)]\n    for i in v:\n        for j in i:\n            cnt[j][j] += 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cnt[i][j]:\n                print(0)\n                return\n    c = [sum(x) % (10 ** 9 + 7) for x in cnt]\n    d = []\n    for i in v:\n        s = set()\n        t = []\n        for j in i:\n            k = j if j not in s else -1\n            s.add(j)\n            t.append(k)\n        d.append(t)\n    mod = 10 ** 9 + 7\n    dp = [[0] * (mod + 5) for _ in range(m + 1)]\n    dp[0][c[0]] += 1\n        c = [0] * len(a)\n        for i in range(len(c)):\n            c[i] = a[i] * b % mod\n        return c\n    inv2 = pow(2, -1, mod)\n    for i in range(m):\n        t = d[i]\n        n = sum(x != -1 for x in t) + 1\n        r = [0] * (n + 5)\n        s = [[0] * (mod + 5) for _ in range(n)]\n        for j in range(1, n):\n            p = 0\n            for k in range(len(t)):\n                if t[k] != -1 and t[k] == j - 1:\n                    r[j] += 1\n                    p ^= 1\n                    s[j][c[t[k]]] += dp[i][p]\n        for j in range(1, n):\n            s[j] = mul(s[j], inv2)\n        if not p:\n            dp[i + 1] = [0] * (mod + 5)\n        else:\n            dp[i + 1] = [0] * len(r)\n            for i in r[1:]:\n                j = c[t[r.index(i)]]\n                for k in s[i]:\n                    dp[i + 1][k ^ i] += k\n    print(sum(dp[m]) % (10 ** 9 + 7))",
        "result": "failed: testcase 0"
    },
    "3692": {
        "body": "    return (x2 - x1)**2 + (y2 - y1)**2\n\n    dx = abs(c1[0] - c2[0])\n    dy = abs(c1[1] - c2[1])\n    d = dist(c1[0], c1[1], c2[0], c2[1])\n    if d == 0:\n        return True\n    r_sum = c1[2] + c2[2]\n    if dx * dx + dy * dy <= (d - r_sum)**2 or \\\n       (dx * dx == d * d and abs(dy) <= d):\n         return True\n    return False\n\n    return dist(c[0], c[1], x, y) <= c[2]**2\n\nn = int(input())\ncircles = []\nfor i in range(n):\n    circles.append([int(t) for t in input().split()])\n\ninf = float('inf')\nregions = 1\nfor i in range(n):\n    for j in range(i + 1, n):\n        if intersect(circles[i], circles[j]):\n            regions += 2\n\nfor i in range(n):\n    x, y, r = circles[i]\n    if inside(x, y, (10, 0, inf)) or inside(x, y, (-10, 0, inf)):\n        regions -= 1\nprint(regions)",
        "result": "failed: testcase 0"
    },
    "3894": {
        "body": "    even = []\n    odd = []\n    for x in a: \n        if x%2 == 0: even.append(x)\n        else: odd.append(x)\n    if len(odd) % 2 != 0:\n        return \"Kevin\"\n    even.sort()\n    while max(even)>=1 and min(even)%k==0:\n        even.remove(max(even))\n        for _ in range(k-1): \n            even.append(min(even)//k)\n    return \"Nicky\" if min(odd)>0 or (max(even)==0 and len(even)>0) else \"Kevin\"\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(f(n, k, a))",
        "result": "failed: testcase 0"
    },
    "3856": {
        "body": "    return w * h\n\nn = int(input())\nw = []\nh = []\n\nfor _ in range(n):\n    wi, hi = map(int, input().split())\n    w.append(wi)\n    h.append(hi)\n\nw.sort()\nh.sort(reverse=True)\n\nans = float('inf')\nfor i in range(1 << n):\n    a = 0\n    b = sum(f(h[j], w[j]) if (i >> j) & 1 else f(w[j], h[j]) for j in range(n))\n    c = max(sum(w[j] for j in range(n) if not ((i >> j) & 1)), sum(h[j] for j in range(n) if (i >> j) & 1))\n    ans = min(ans, c * b)\n\nprint(ans)",
        "result": "failed: testcase 0"
    },
    "3282": {
        "body": "import sys\n    P = int(input())\n        return len(set(str(a)) & set(str(b))) == 0\n    res = []\n    for i in range(1, P+1):\n        for j in range(i+1, P+1):\n            total = i + j\n            if not (is_same_digit(i, j) or is_same_digit(i, total) or is_same_digit(j, total)):\n                if len(res) < 5000 and [i, j] not in res:\n                    res.append([i, j])\n    print(len(res))\n    for x in sorted(res):\n        print(*x)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3596": {
        "body": "    import math\n\n        return math.gamma(z)\n\n        return 0.5 + 0.5 * math.erf(x / math.sqrt(2))\n\n        import scipy.special as ss\n        return ss.jn(k, x) / math.pi\n\n    return c * (t1 * Gamma(x) + \n                (erf(t3 * x))**(1/t2) - \n                J(k, x)**t4)\n\n    result = 0\n    for i in range(r+1):\n        result += f(i, t1, t2, t3, t4) / math.factorial(i) * x**i\n    return result\n\n    result = 0\n    for i in range(r+n+1):\n        result += P(n-1, i) * x**i\n    return result\n\n    s = deg(Ps(x))\n    result = 0\n    for i in range(s+1):\n        result += math.factorial(i) * Pn(s-i, r+s, Ps_prime(x)) / math.factorial(i)\n    return result\n\nimport sys\n\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\n_, _, r, s, l = map(int, input().split())\n\nPs = lambda x: Pn(s, r+s, x)\nPs_prime = lambda x: Ps(x).derivative(n=deg(Ps(x))+1)\n\n    import sympy as sp\n    return sp.degree(f(sp.symbols('x')))\n\nprint(((g(a) + l)**2 / (math.pi * math.e) + 1/(l+1))[0:5])",
        "result": "failed: testcase 0"
    },
    "3540": {
        "body": "    goal = [\"RRRR\", \"GGGG\", \"BBBB\", \"YYYY\"]\n    moves = 0\n    for i in range(4):\n        row_moves = 0\n        if input_str[i] != goal[i]:\n            # find the position of the first mismatched character\n            pos = next((j for j, c in enumerate(input_str[i]) if c != goal[i][j]), -1)\n            # calculate the moves needed to move it to its correct position\n            row_moves = max(pos - 0, 3 - pos) + \\\n                        max(i - (goal[i].index(goal[i][pos])) % 4, 3 - i + (goal[i].index(goal[i][pos])) % 4)\n        moves += min(row_moves, 6 - min(row_moves, 1))\n    return moves\n\ninput_str = input()\nprint(min_moves(input_str))",
        "result": "failed: testcase 0"
    },
    "3354": {
        "body": "import math\nimport sys\n\ns, r = map(float, input().split())\nn, z = map(int, input().split())\n\nmax_area = (z / 100) * math.pi * s ** 2\n\npickles_per_circle = math.floor(math.pi * r ** 2 / math.pi * r ** 2)\navailable_space = n * pickles_per_circle\nallowed_pickles = min(n, available_space)\n\nfor i in range(n):\n    if math.pi * (s - r) ** 2 <= max_area:\n        allowed_pickles -= 1\n\nprint(min(allowed_pickles + 1, n))",
        "result": "failed: testcase 0"
    },
    "3217": {
        "body": "    return [[x - 1, y, z], [x + 1, y, z],\n            [x, y - 1, z], [x, y + 1, z],\n            [x, y, z - 1], [x, y, z + 1]]\n\n    return 0 <= x1 < 10 and 0 <= y1 < 10 and 0 <= z1 < 10 and \\\n           0 <= x2 < 10 and 0 <= y2 < 10 and 0 <= z2 < 10\n\n    return max(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\nn = int(input())\np = set()\nfor _ in range(n):\n    a, b, c = map(int, input().split())\n    p.add((a, b, c))\ns = 0\nwhile len(p) > 0:\n    newp = set()\n    for x1 in p:\n        for q in f(*x1):\n            if isvalid(*q):\n                s += 1\n                for y in p.copy():\n                    if dist(q, y) == 1 or dist(q, y) == dist(x1, y):\n                        newp.add(y)\n    p = newp\nprint(s)",
        "result": "failed: testcase 0"
    },
    "3520": {
        "body": "import sys\n\nn, p, c = map(int, input().split())\nt = [0]\nfor _ in range(p):\n    t.append(int(input()))\nx, y = [], []\nfor _ in range(p):\n    x1, y1, x2, y2 = map(int, input().split())\n    x.append(x1 - y1)\n    y.append(y2 - y1)\n\ndp = [0] * (n + 1)\nfor i in range(1, p + 1):\n    dp[0], ans = max(dp[0], t[i] + c), float('inf')\n    for j in range(n + 1):\n        if j < len(t) and t[j] <= dp[j - 1]:\n            dp[j] = max(dp[j], min((dp[j - 1] - t[j]) // (x[j - i] - y[i - 1]) + t[j] + c, ans))\n        elif j > 0:\n            dp[j] = max(dp[j], dp[j - 1])\n\nprint(\"%.6f\" % (dp[n] / (x[p] - y[p - 1])))",
        "result": "failed: testcase 0"
    },
    "3475": {
        "body": "import sys\n\n    t, n = map(int, sys.stdin.readline().split())\n    d_min = [0] * t\n    heading_range = [0] * t\n    for i in range(t):\n        d_min[i], heading_range[i] = map(int, sys.stdin.readline().split())\n\n    distances = []\n    headings = []\n    for i in range(n - 1):\n        distance, heading = map(int, sys.stdin.readline().split())\n        distances.append(distance)\n        headings.append(heading)\n\n    dp = [[float('inf')] * (n + t) for _ in range(n)]\n    dp[0][0] = 0\n    for i in range(n - 1):\n        for j in range(t):\n            if dp[i][j] == float('inf'):\n                continue\n            min_distance = d_min[j]\n            max_heading_range = heading_range[j]\n            new_dp = []\n            for k in range(min(i + t, n) + 1):\n                if dp[i][j] + distances[i] >= min_distance:\n                    direction_change = False\n                    if i < n - 1 and abs(headings[i] - headings[i + 1]) > max_heading_range * (10 ** 3):\n                        direction_change = True\n\n                    new_dp.append(dp[i][j] + distances[i])\n                else:\n                    new_dp.append(float('inf'))\n            for k in range(t):\n                if dp[i][k] == float('inf'):\n                    continue\n                min_distance = d_min[k]\n                max_heading_range = heading_range[k]\n\n                change_type_cost = 1\n                direction_change = False\n\n                if i < n - 1 and abs(headings[i] - headings[i + 1]) > max_heading_range * (10 ** 3):\n                    direction_change = True\n\n                new_dp.append(min(dp[i][k] + change_type_cost, dp[i][j] + distances[i]))\n\n            dp[i + 1] = new_dp\n\n    ans = float('inf')\n    for j in range(t + n):\n        ans = min(ans, dp[n - 1][j])\n    if ans == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return str(ans)\n\nprint(transportation_switching_scheme())",
        "result": "failed: testcase 0"
    },
    "3977": {
        "body": "    n, m, k = map(int, input().split())\n    home_nodes = set(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    ans = 0\n    for i in home_nodes:\n        node_count = sum(1 for j in home_nodes if i != j and not any(k in graph[j] for k in graph[i]))\n        ans += max(0, node_count - 1)\n    return ans",
        "result": "failed: testcase 0"
    },
    "3626": {
        "body": "    for i in range(4):\n        if intersect_with_rectangle(x1, y1, x2, y2, rectangles[i]):\n            return 1\n    return 0\n\nimport sys\n\nn = int(input())\nrectangles = []\nfor _ in range(n):\n    x1, y1, x2, y2 = map(int, input().split())\n    rectangles.append((x1, y1, x2, y2))\n\n    ax, ay, bx, by = other\n    return max(ax, x1) <= min(bx, x2) and max(ay, y1) <= min(by, y2)\n\nfor _ in range(n - 1):\n    rectangles.sort(key=lambda r: r[0])\n    for i in range(n):\n        if intersect(*rectangles[i]):\n            print(1)\n            break\n    else:\n        continue\n    break",
        "result": "failed: testcase 0"
    },
    "3584": {
        "body": "    while a >= 1 and b >= 1:\n        if a > b:\n            a = a % b\n        else:\n            b = b % a\n    return max(a, b)\n\n    x1, y1 = p1\n    x2, y2 = p2\n    return abs((x2 - x1) * y1 - (y2 - y1) * x1) / ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n\n    n = len(points)\n    if n <= 3:\n        return points\n    hull = []\n    p = max(points, key=lambda p: p[0])\n    while True:\n        hull.append(p)\n        next_p = None\n        for q in points:\n            if q == p:\n                continue\n            if next_p is None or (q[1] - p[1]) * (next_p[0] - p[0]) > (p[1] - next_p[1]) * (q[0] - p[0]):\n                next_p = q\n        if next_p == p:\n            break\n        p = next_p\n    return hull\n\n    n = len(points)\n    convex = convex_hull(points)\n    dists = []\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = ((convex[i][0] - convex[j][0])**2 + (convex[i][1] - convex[j][1])**2)**0.5\n            dists.append((dist, convex[i], convex[j]))\n    dists.sort()\n    res = 0\n    selected = []\n    for dist, p1, p2 in dists:\n        if len(selected) < K:\n            selected.append((p1, p2))\n        else:\n            d = point_line_distance(p1, p2)\n            if d > dists[-1][0]:\n                break\n    hull = convex_hull([p for p in points if (p[0] - points[0][0])**2 + (p[1] - points[0][1])**2 < 10000000])\n    onions_in_hull = sum(1 for p in points if ((convex[0][0] - convex[-1][0])**2 + (convex[0][1] - convex[-1][1])**2 == 0 or (p[0] - convex[0][0]) * (convex[-1][0] - convex[0][0]) + (p[1] - convex[0][1]) * (convex[-1][1] - convex[0][1]) <= 0) and any(((p[0] - q[0])**2 + (p[1] - q[1])**2)**0.5 < dist for q in hull))\n    return max(onions_in_hull, sum(1 for p in points if (point_line_distance(p, selected[i][0]) < point_line_distance(p, selected[i+1][0])) == ((i % 2) == 0) and any(((p[0] - q[0])**2 + (p[1] - q[1])**2)**0.5 < dist for q in hull)) for i in range(K))",
        "result": "failed: testcase 0"
    },
    "3950": {
        "body": "    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    s = [0] * (q + 1)\n    l = [[0] * (n + 1) for _ in range(q + 1)]\n    r = [[0] * (n + 1) for _ in range(q + 1)]\n\n        if a[x - 1]:\n            y = min(s[a[x - 1]], q)\n            s[a[x - 1]] -= 1\n            l[a[x - 1]][y] += 1\n            r[a[x - 1]][y] += 1\n            for i in range(a[x - 1], q + 1):\n                dfs(i)\n\n    for x in range(1, n + 1):\n        if a[x - 1]:\n            dfs(a[x - 1])\n        else:\n            for i in range(1, q + 1):\n                if s[i] < n - x + 1:\n                    l[i][x], r[i][x] = 1, 1\n                    break\n\n    for i in range(q, 0, -1):\n        if not all(l[i][j] == r[i][j] for j in range(1, n + 1)):\n            print('NO')\n            return\n        else:\n            for j in range(1, n + 1):\n                l[i][j], r[i][j] = l[i][j - l[i][j]] + 1, l[i][j]\n\n    c = [0] * (n + 1)\n    for i in range(q, 0, -1):\n        if l[i][n]:\n            k = n\n            while not r[i][k] and k >= l[i][k]:\n                c[k] += 1\n                k -= 1\n\n            for j in range(l[i][n], n + 1):\n                if r[i][j]:\n                    k = j - 1\n                    while not c[k] and k >= l[i][n] and (not r[i][k] or r[i][k] != i):\n                        c[k] += 1\n                        k -= 1\n\n            for j in range(l[i][n], n + 1):\n                if r[i][j]:\n                    a[j - 1] = i\n                    break\n        else:\n            print('NO')\n            return\n\n    print('YES')\n    print(*a)",
        "result": "failed: testcase 0"
    },
    "3075": {
        "body": "    n, g = map(int, input().split())\n    stations = []\n    for _ in range(n):\n        d, c = map(int, input().split())\n        stations.append((d, c))\n    stations.sort()\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    tank = g\n    for i in range(1, n + 1):\n        d, c = stations[i - 1]\n        while i > 0 and stations[i - 1][0] == stations[i - 2][0]:\n            i -= 1\n            d, c = stations[i]\n        tank = g if dp[i - 1] <= tank else tank + (d - stations[i - 1][0]) // g * c\n        dp[i] = min(dp[i], dp[i - 1] + (d - stations[i - 1][0]) * c)\n    ans = 'cancel road trip'\n    for i in range(n):\n        if i > 0 and stations[i][0] == stations[i - 1][0]:\n            continue\n        tank = g if dp[i] <= tank else tank + (stations[i][0] - stations[i - 1][0]) // g * stations[i - 1][1]\n        if tank >= stations[n - 1][0]:\n            ans = str(dp[-1])\n    print(ans)",
        "result": "failed: testcase 0"
    },
    "3711": {
        "body": "n, m, k = map(int, input().split())\nif min(n, m) <= k or max(n, m) < k + 1:\n    print(-1)\nelse:\n    if k % 2 == 0:\n        print(min(n, m) * min(n, m))\n    else:\n        print(min(min(n, m), (k + 1) // 2 * min(n, m)))",
        "result": "failed: testcase 0"
    }
}