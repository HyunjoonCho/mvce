{
    "4693": {
        "body": "A, B = map(int, input().split())\nresult = A + B\nif result >= 10:\n    print(\"error\")\nelse:\n    print(result)",
        "result": "passed"
    },
    "4077": {
        "body": "from collections import Counter\n\n    left = [0] * (n + 1)\n    right = [0] * (n + 1)\n    current = []\n    \n    for i in range(n - 1, -1, -1):\n        current.append(a[i])\n        current.sort()\n        if len(current) % 2 == 1:\n            mid = len(current) // 2\n            right[i] = current[mid]\n        else:\n            left[i] = current[len(current) // 2 - 1]\n    \n    result = 0\n    count = Counter()\n    \n    for i in range(n):\n        count[a[i]] += 1\n        if len(count) % 2 == 1:\n            mid = len(count) // 2\n            key = sorted(count.keys())[mid]\n            if left[i] <= key <= right[i]:\n                result += 1\n        else:\n            keys = sorted(list(count.keys()))\n            mid1, mid2 = keys[len(keys) // 2 - 1], keys[len(keys) // 2]\n            if left[i] <= mid1 <= right[i] or left[i] <= mid2 <= right[i]:\n                result += 1\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_median_pairs(n, m, a))",
        "result": "failed: testcase 0"
    },
    "4006": {
        "body": "    reachable = set()\n    current = n\n    while current not in reachable:\n        reachable.add(current)\n        current += 1\n        while current % 10 == 0:\n            current //= 10\n    return len(reachable)\n\n# Read input from stdin\nn = int(input().strip())\n\n# Print the result\nprint(count_reachable_numbers(n))",
        "result": "failed: testcase 0"
    },
    "4556": {
        "body": "print(input().split()[1][0] + input().split()[2][:3])",
        "result": "failed: testcase 0"
    },
    "4571": {
        "body": "import sys\n\n    total_time = 0\n    for i in range(1, N + 1):\n        if i <= M:\n            probability = 1 / (2 ** i)\n            time = i * 1900\n        else:\n            probability = 1\n            time = 100\n        total_time += probability * time\n    return int(total_time)\n\n# Read input from stdin\nN, M = map(int, input().split())\n\n# Print the expected value of the total execution time\nprint(expected_execution_time(N, M))",
        "result": "failed: testcase 0"
    },
    "4019": {
        "body": "import sys\n\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n    \n    from collections import defaultdict, deque\n    \n        visited = [False] * (n + 1)\n        queue = deque([start])\n        visited[start] = True\n        degree = defaultdict(int)\n        \n        while queue:\n            node = queue.popleft()\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    degree[node] += 1\n                    degree[neighbor] += 1\n        \n        return degree\n    \n    graph = defaultdict(list)\n    for v, u in edges:\n        graph[v].append(u)\n        graph[u].append(v)\n    \n    degree = bfs(graph, 1)\n    \n    if degree[1] == D:\n        print(\"YES\")\n        for v, u in edges:\n            if u == degree[v]:\n                print(f\"{v} {u}\")\n                break\n    else:\n        print(\"NO\")\n\nif __name__ == \"__main__\":\n    n, m, D = map(int, input().split())\n    find_spanning_tree(n, m, D)",
        "result": "failed: testcase 0"
    },
    "4265": {
        "body": "    return sum(1 for s, t in zip(S, T) if s != t)\n\n# Read input from stdin\nS = input().strip()\nT = input().strip()\n\n# Print the result\nprint(min_operations_to_transform(S, T))",
        "result": "failed: testcase 0"
    },
    "4657": {
        "body": "    odd_count = sum(1 for x in a if x % 2 != 0)\n    if odd_count < k or odd_count % 2 != k % 2:\n        return \"NO\"\n    \n    result = []\n    current_sum = 0\n    count = 0\n    i = 0\n    \n    while i < n:\n        while i < n and (current_sum + a[i]) % 2 == 0:\n            current_sum += a[i]\n            i += 1\n        if i >= n:\n            break\n        result.append(i)\n        current_sum = a[i]\n        i += 1\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_divide_into_odd_sum_subsegments(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4599": {
        "body": "    # Sort the list to maximize the difference by alternating choices\n    a.sort()\n    alice_score = 0\n    bob_score = 0\n    \n    for i in range(N):\n        if i % 2 == 0:\n            alice_score += a[N - 1 - i]\n        else:\n            bob_score += a[i]\n    \n    return alice_score - bob_score\n\n# Read input from stdin\nN = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = max_score_difference(N, a)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4774": {
        "body": "    operators = ['+', '-', '*', '/']\n    valid_expressions = []\n\n    for op1 in operators:\n        for op2 in operators:\n            try:\n                if eval(f\"{a} {op1} {b} == {c} {op2} {d}\"):\n                    expression = f\"{a} {op1} {b} = {c} {op2} {d}\"\n                    valid_expressions.append(expression)\n            except ZeroDivisionError:\n                pass\n\n    if not valid_expressions:\n        print(\"problems ahead\")\n    else:\n        for expr in sorted(valid_expressions):\n            print(expr)\n\n# Read input\na, b, c, d = map(int, input().split())\n\n# Find and print valid expressions\nfind_valid_expressions(a, b, c, d)",
        "result": "failed: testcase 0"
    },
    "4851": {
        "body": "    digit_sum = sum(int(digit) for digit in str(num))\n    return num % digit_sum == 0\n\nn = int(input())\nwhile not is_harshad_number(n):\n    n += 1\nprint(n)",
        "result": "failed: testcase 0"
    },
    "4655": {
        "body": "    piles = sorted([a, b, c])\n    if piles[2] - piles[1] >= piles[0]:\n        return piles[1]\n    else:\n        return (piles[0] + piles[1]) // 2\n\nq = int(input())\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    print(max_candies(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4132": {
        "body": "import sys\nfrom heapq import heapify, heappop, heappush\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    # Convert health values to negative for max-heap behavior using min-heap\n    A = [-x for x in A]\n    heapify(A)\n    \n    while len(A) > 1:\n        # Pop the two largest (smallest negative) elements\n        a = -heappop(A)\n        b = -heappop(A)\n        \n        # Calculate the health of the remaining monster after the attack\n        if a > b:\n            heappush(A, -(a - b))\n    \n    # The last remaining monster's health (negative value)\n    print(-A[0])\n\nmin_final_health()",
        "result": "failed: testcase 0"
    },
    "4085": {
        "body": "import sys\nfrom math import sqrt\n\n    divisors = set(divisors)\n    if len(divisors) < 2:\n        return -1\n    \n    x = max(divisors)\n    for i in range(2, int(sqrt(x)) + 1):\n        if x % i == 0 and i not in divisors or (x // i != i and x // i not in divisors):\n            return -1\n    return x\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        divisors = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = find_minimum_x(divisors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4399": {
        "body": "    if 'A' in S and 'B' in S:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input from standard input\nS = input().strip()\n\n# Print the result\nprint(check_bus_service(S))",
        "result": "failed: testcase 0"
    },
    "4999": {
        "body": "    operations = 0\n    while a < b:\n        if b % 2 == 1:\n            b += 1\n        else:\n            b //= 2\n        operations += 1\n    return operations + (a - b)\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations(a, b))",
        "result": "failed: testcase 0"
    },
    "4727": {
        "body": "    for row in grid:\n        non_zeros = [x for x in row if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(non_zeros[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        row[:len(merged)] = merged\n        row[len(merged):] = [0] * (4 - len(merged))\n    return grid\n\n    for row in grid:\n        non_zeros = [x for x in row if x != 0]\n        merged = []\n        i = len(non_zeros) - 1\n        while i >= 0:\n            if i > 0 and non_zeros[i] == non_zeros[i - 1]:\n                merged.insert(0, non_zeros[i] * 2)\n                i -= 2\n            else:\n                merged.insert(0, non_zeros[i])\n                i -= 1\n        row[:len(merged)] = merged\n        row[len(merged):] = [0] * (4 - len(merged))\n    return grid\n\n    for col in range(4):\n        column = [grid[row][col] for row in range(4)]\n        non_zeros = [x for x in column if x != 0]\n        merged = []\n        i = 0\n        while i < len(non_zeros):\n            if i + 1 < len(non_zeros) and non_zeros[i] == non_zeros[i + 1]:\n                merged.append(non_zeros[i] * 2)\n                i += 2\n            else:\n                merged.append(non_zeros[i])\n                i += 1\n        for row in range(4):\n            grid[row][col] = merged.pop(0) if merged else 0\n    return grid\n\n    for col in range(4):\n        column = [grid[row][col] for row in range(3, -1, -1)]\n        non_zeros = [x for x in column if x != 0]\n        merged = []\n        i = len(non_zeros) - 1\n        while i >= 0:\n            if i > 0 and non_zeros[i] == non_zeros[i - 1]:\n                merged.insert(0, non_zeros[i] * 2)\n                i -= 2\n            else:\n                merged.insert(0, non_zeros[i])\n                i -= 1\n        for row in range(3, -1, -1):\n            grid[row][col] = merged.pop(0) if merged else 0\n    return grid\n\n    grid = [list(map(int, input().split())) for _ in range(4)]\n    direction = int(input())\n    \n    if direction == 0:\n        new_grid = move_left(grid)\n    elif direction == 1:\n        new_grid = move_up(grid)\n    elif direction == 2:\n        new_grid = move_right(grid)\n    elif direction == 3:\n        new_grid = move_down(grid)\n    \n    for row in new_grid:\n        print(' '.join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4906": {
        "body": "import sys\n\n    encoded = []\n    count = 1\n    for i in range(1, len(s)):\n        if s[i] == s[i-1]:\n            count += 1\n        else:\n            encoded.append(f\"{s[i-1]}{count}\")\n            count = 1\n    encoded.append(f\"{s[-1]}{count}\")\n    return ''.join(encoded)\n\n    decoded = []\n    i = 0\n    while i < len(s):\n        char = s[i]\n        i += 1\n        num = ''\n        while i < len(s) and s[i].isdigit():\n            num += s[i]\n            i += 1\n        decoded.append(char * int(num))\n    return ''.join(decoded)\n\n    command, message = input().split(' ', 1)\n    if command == 'E':\n        print(run_length_encode(message))\n    elif command == 'D':\n        print(run_length_decode(message))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4011": {
        "body": "    max_num = int(a)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            segment = a[i:j]\n            new_segment = ''.join(str(f[int(digit) - 1]) for digit in segment)\n            new_number = a[:i] + new_segment + a[j:]\n            max_num = max(max_num, int(new_number))\n    return max_num\n\n# Read input\nn = int(input())\na = input()\nf = list(map(int, input().split()))\n\n# Print the result\nprint(max_number(n, a, f))",
        "result": "failed: testcase 0"
    },
    "4099": {
        "body": "import sys\n\n    total_needed = N * M\n    current_total = sum(A)\n    needed_on_final = total_needed - current_total\n    \n    if needed_on_final <= 0 or needed_on_final > K:\n        return -1\n    else:\n        return needed_on_final\n\n# Read input from stdin\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_points_to_achieve_average(N, K, M, A))",
        "result": "failed: testcase 0"
    },
    "4465": {
        "body": "A = int(input())\nB = int(input())\nprint((A - 2) * (B - 2))",
        "result": "failed: testcase 0"
    },
    "4315": {
        "body": "import math\n\nR = int(input())\ncircumference = 2 * math.pi * R\nprint(circumference)",
        "result": "passed"
    },
    "4633": {
        "body": "import sys\n\n    moves = 0\n    while sum(int(digit) for digit in str(n)) > s:\n        n += 1\n        moves += 1\n    return moves\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    n, s = map(int, input().split())\n    results.append(min_moves_to_digit_sum(n, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4734": {
        "body": "    if Y.endswith('ex'):\n        return Y + P\n    elif Y[-1] in 'aeiou':\n        return Y[:-1] + 'ex' + P\n    else:\n        return Y + 'ex' + P\n\n# Read input from stdin\nY, P = input().split()\n\n# Print the result\nprint(extend_name(Y, P))",
        "result": "failed: testcase 0"
    },
    "4229": {
        "body": "    total = 0\n    for i in range(1, N + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            continue\n        elif i % 3 == 0:\n            continue\n        elif i % 5 == 0:\n            continue\n        else:\n            total += i\n    print(total)\n\nN = int(input())\nfizz_buzz_sum(N)",
        "result": "failed: testcase 0"
    },
    "4321": {
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result\nprint(tanya_decrease(n, k))",
        "result": "failed: testcase 0"
    },
    "4503": {
        "body": "    used = set()\n    for move in A:\n        if H % move not in used:\n            used.add(H % move)\n            H -= move\n            if H <= 0:\n                return \"Yes\"\n    return \"No\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nH = int(data[0])\nN = int(data[1])\nA = list(map(int, data[2:]))\n\nprint(can_win(H, N, A))",
        "result": "failed: testcase 0"
    },
    "4855": {
        "body": "import math\n\nA, I = map(int, input().split())\ntotal_citations_needed = I * A - 1\nscientists_to_bribe = math.ceil(total_citations_needed / (A + total_citations_needed))\nprint(scientists_to_bribe)",
        "result": "failed: testcase 0"
    },
    "4704": {
        "body": "import sys\n\n    total_sum = sum(a)\n    left_sum = 0\n    min_diff = float('inf')\n    \n    for i in range(N-1):\n        left_sum += a[i]\n        right_sum = total_sum - left_sum\n        diff = abs(left_sum - right_sum)\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff\n\n# Read input\nN = int(input())\na = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_difference(N, a)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4829": {
        "body": "l, r = map(int, input().split())\nif l == 0 and r == 0:\n    print(\"Not a moose\")\nelif l == r:\n    points = l + r\n    print(f\"Even {points}\")\nelse:\n    points = max(l, r) * 2\n    print(f\"Odd {points}\")",
        "result": "passed"
    },
    "4730": {
        "body": "    L = int(input())\n    program = input()\n    stack = []\n    delimiters = {')': '(', ']': '[', '}': '{'}\n    \n    for i, char in enumerate(program):\n        if char in delimiters.values():\n            stack.append((char, i))\n        elif char in delimiters:\n            if not stack or stack[-1][0] != delimiters[char]:\n                print(char, i)\n                return\n            stack.pop()\n    \n    if stack:\n        open_delimiter, index = stack.pop()\n        print(delimiters[open_delimiter], index)\n    else:\n        print('ok so far')\n\nvalidate_delimiters()",
        "result": "failed: testcase 0"
    },
    "4729": {
        "body": "    password_set = set(password)\n    index = 0\n    for char in message:\n        if char in password_set:\n            if char == password[index]:\n                index += 1\n                if index == len(password):\n                    return \"PASS\"\n            else:\n                break\n    return \"FAIL\"\n\n# Read input from stdin\npassword, message = input().split()\nprint(is_valid_message(password, message))",
        "result": "failed: testcase 0"
    },
    "4582": {
        "body": "a = input()\nb = input()\n\nif a == 'H':\n    if b == 'H':\n        print('H')\n    else:\n        print('D')\nelse:\n    if b == 'H':\n        print('D')\n    else:\n        print('H')",
        "result": "failed: testcase 0"
    },
    "4910": {
        "body": "from collections import Counter\nimport sys\n\n    N = int(input())\n    costumes = [input().strip() for _ in range(N)]\n    costume_counts = Counter(costumes)\n    max_count = max(costume_counts.values())\n    winners = sorted([costume for costume, count in costume_counts.items() if count == max_count])\n    print(*winners, sep='\\n')\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4323": {
        "body": "from sys import stdin\n\n    a = [x[0] for x in sizes]\n    b = [x[1] for x in sizes]\n    \n    # Check if it's possible to fit all songs without any compression\n    if sum(a) <= m:\n        return 0\n    \n    # Sort the songs by the difference between original and compressed size\n    diff = sorted([(a[i], b[i]) for i in range(n)], key=lambda x: x[0] - x[1])\n    \n    total_size = 0\n    compress_count = 0\n    \n    # Try to compress as few songs as possible\n    for a_i, b_i in diff:\n        if total_size + b_i <= m:\n            total_size += b_i\n        else:\n            total_size -= (a_i - b_i)\n            compress_count += 1\n            total_size += b_i\n    \n    # If we can't fit any songs after compression, return -1\n    if total_size > m:\n        return -1\n    \n    return compress_count\n\n# Read input\nn, m = map(int, stdin.readline().split())\nsizes = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n# Output the result\nprint(min_songs_to_compress(n, m, sizes))",
        "result": "failed: testcase 0"
    },
    "4626": {
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nq = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(q):\n    a = int(data[index])\n    b = int(data[index + 1])\n    c = int(data[index + 2])\n    index += 3\n    \n    distances = sorted([abs(a - b), abs(b - c), abs(c - a)])\n    \n    min_distance = float('inf')\n    for i in range(3):\n        new_distances = distances[:]\n        if i == 0:\n            new_distances[0] = 1\n        elif i == 1:\n            new_distances[1] = 1\n        else:\n            new_distances[2] = 1\n        \n        min_distance = min(min_distance, sum(new_distances))\n    \n    results.append(min_distance)\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4400": {
        "body": "print(max(S.count('R'), S[::-1].count('R')))",
        "result": "failed: testcase 0"
    },
    "4794": {
        "body": "import sys\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < R and 0 <= y < C and grid[x][y] == 'X'\n    \n        count = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny):\n                count += 1\n        return count\n    \n    parking_spaces = [0] * 5\n    visited = set()\n    \n    for i in range(R):\n        for j in range(C):\n            if (i, j) not in visited and grid[i][j] == 'X':\n                cars_to_squash = 0\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if (x, y) in visited:\n                        continue\n                    visited.add((x, y))\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if is_valid(nx, ny):\n                            cars_to_squash += 1\n                            stack.append((nx, ny))\n                parking_spaces[cars_to_squash] += 1\n    \n    return parking_spaces\n\n    R, C = map(int, input().split())\n    grid = [input().strip() for _ in range(R)]\n    result = count_parking_spaces(R, C, grid)\n    print(result[0])\n    print(result[1])\n    print(result[2])\n    print(result[3])\n    print(result[4])\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4096": {
        "body": "    a.sort(reverse=True)\n    days = 0\n    while m > 0:\n        day_pages = 0\n        for i in range(days + 1):\n            if i < n and day_pages + max(0, a[i] - (days + 1)) <= m:\n                day_pages += max(0, a[i] - (days + 1))\n            else:\n                break\n        if day_pages == 0:\n            return -1\n        m -= day_pages\n        days += 1\n    return days\n\n# Read input from stdin\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_days_to_complete_coursework(n, m, a))",
        "result": "failed: testcase 0"
    },
    "4530": {
        "body": "import sys\n\n    from collections import Counter\n    \n    skill_counter = Counter(skills)\n    \n    unique_skills = list(skill_counter.keys())\n    max_size = 0\n    \n    for skill in unique_skills:\n        team1_size = len(set(skills[:skill_counter[skill]]))\n        remaining_students = n - skill_counter[skill]\n        if remaining_students > 0 and remaining_students % 2 == 0:\n            team2_size = remaining_students // 2\n            max_size = max(max_size, min(team1_size, team2_size))\n    \n    return max_size\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        skills = list(map(int, data[index + 1:index + n + 1]))\n        index += n + 1\n        result = max_team_size(n, skills)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4724": {
        "body": "R = int(input())\nG = int(input())\nprint((R + G) // 2)",
        "result": "failed: testcase 0"
    },
    "4276": {
        "body": "    min_cost = float('inf')\n    for c, t in routes:\n        if t <= T and c < min_cost:\n            min_cost = c\n    return min_cost if min_cost != float('inf') else 'TLE'\n\n# Read input\nN, T = map(int, input().split())\nroutes = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Find and print the result\nprint(find_min_cost_route(N, T, routes))",
        "result": "failed: testcase 0"
    },
    "4708": {
        "body": "N = int(input())\nK = int(input())\nX = int(input())\nY = int(input())\n\ntotal_fee = K * X + max(0, N - K) * Y\nprint(total_fee)",
        "result": "failed: testcase 1"
    },
    "4396": {
        "body": "import sys\n\n    N = int(input())\n    total_yen = 0.0\n    bitcoin_rate = 380000.0\n    \n    for _ in range(N):\n        x, u = input().split()\n        x = float(x)\n        \n        if u == \"JPY\":\n            total_yen += x\n        elif u == \"BTC\":\n            total_yen += x * bitcoin_rate\n    \n    print(total_yen)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4155": {
        "body": "    operations = 0\n    current_heights = [0] * N\n    \n    for i in range(N):\n        if h[i] > current_heights[i]:\n            operations += 1\n            for j in range(i, min(N, i + h[i])):\n                current_heights[j] += 1\n    \n    return operations\n\n# Read input from stdin\nN = int(input().strip())\nh = list(map(int, input().strip().split()))\n\n# Print the result\nprint(min_watering_operations(N, h))",
        "result": "failed: testcase 0"
    },
    "4557": {
        "body": "A, B, X = map(int, input().split())\nif A <= X <= A + B:\n    print(\"YES\")\nelse:\n    print(\"NO\")",
        "result": "passed"
    },
    "4930": {
        "body": "    vowels = \"aeiou\"\n    decoded_word = \"\"\n    i = 0\n    \n    while i < len(encoded_sentence):\n        if encoded_sentence[i] in vowels:\n            decoded_word += encoded_sentence[i-1:i+3]\n            i += 3\n        else:\n            decoded_word += encoded_sentence[i]\n            i += 1\n    \n    print(decoded_word)\n\n# Read input from stdin\nencoded_sentence = input()\ndecode_sentence(encoded_sentence)",
        "result": "failed: testcase 0"
    },
    "4715": {
        "body": "    colors = {a, b, c}\n    return len(colors)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Output the result\nprint(count_colors(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4008": {
        "body": "    if n < k:\n        return \"NO\"\n    \n    # Try to assign colors such that each number gets its own color and different numbers get different colors\n    color_map = {}\n    used_colors = set()\n    \n    for i in range(n):\n        num = a[i]\n        if num not in color_map:\n            if len(used_colors) == k:\n                return \"NO\"\n            color_map[num] = len(used_colors) + 1\n            used_colors.add(color_map[num])\n        \n        a[i] = color_map[num]\n    \n    return \"YES\\n\" + \" \".join(map(str, a))\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(color_array(n, k, a))",
        "result": "failed: testcase 0"
    },
    "4257": {
        "body": "A, B = map(int, input().split())\nprint(A * B)",
        "result": "passed"
    },
    "4584": {
        "body": "import sys\n\n    subordinates = [0] * (N + 1)\n    for i in range(2, N + 1):\n        subordinates[A[i - 1]] += 1\n    return subordinates[1:]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    result = count_subordinates(N, A)\n    for r in result:\n        print(r)",
        "result": "failed: testcase 0"
    },
    "4195": {
        "body": "    count = 0\n    num = 0\n    while True:\n        if D == 0 and num % 100 != 0:\n            count += 1\n        elif D == 1 and num % 100 == 0:\n            count += 1\n        elif D == 2 and num % 100 == 0 and (num // 100) % 100 == 0:\n            count += 1\n        if count == N:\n            return num\n        num += 1\n\nif __name__ == \"__main__\":\n    import sys\n    D, N = map(int, input().split())\n    print(find_happy_integer(D, N))",
        "result": "failed: testcase 0"
    },
    "4176": {
        "body": "import math\n\nA, B = map(int, input().split())\nprint(A * B)",
        "result": "failed: testcase 1"
    },
    "4166": {
        "body": "import sys\n\n    digits = [0] * N\n    for s, c in conditions:\n        digits[s - 1] = c\n    \n    if digits[0] == 0:\n        return -1\n    \n    number = int(''.join(map(str, digits)))\n    \n    while True:\n        valid = True\n        for s, c in conditions:\n            if digits[s - 1] != c:\n                valid = False\n                break\n        if valid:\n            return number\n        if number % 10 == 0:\n            return -1\n        number -= 1\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n    \n    result = find_smallest_integer(N, M, conditions)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4827": {
        "body": "import sys\n\n    if n < 10:\n        return [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"][n-1]\n    elif 10 <= n <= 19:\n        return [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"][n-10]\n    elif n % 10 == 0:\n        tens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"][n//10 - 2]\n        return tens\n    else:\n        tens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"][n//10 - 2]\n        ones = [\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"][n%10-1]\n        return tens + ones\n\n    N = int(input())\n    words = [input().strip() for _ in range(N)]\n    \n    for i, word in enumerate(words):\n        if word == '$':\n            number = len(' '.join(words[:i+1]))\n            words[i] = number_to_words(number)\n            break\n    \n    print(' '.join(words))\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0"
    },
    "4871": {
        "body": "import sys\n\n    total = sum(scores)\n    group_score = total / 5\n    weighted_sum = sum(score * (4/5)**i for i, score in enumerate(scores))\n    return group_score, weighted_sum / n\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    scores = [int(input().strip()) for _ in range(n)]\n    current_group_score, average_new_group_score = calculate_group_score(n, scores)\n    print(current_group_score)\n    print(average_new_group_score)",
        "result": "failed: testcase 0"
    },
    "4148": {
        "body": "    result = []\n    for char in S:\n        if 'A' <= char <= 'Z':\n            shifted_char = chr((ord(char) - ord('A') + N) % 26 + ord('A'))\n            result.append(shifted_char)\n        else:\n            result.append(char)\n    return ''.join(result)\n\n# Read input\nN = int(input().strip())\nS = input().strip()\n\n# Output the result\nprint(shift_string(N, S))",
        "result": "failed: testcase 0"
    },
    "4316": {
        "body": "from collections import Counter\n\n    char_count = Counter(s)\n    if len(char_count) == 2 and all(count == 2 for count in char_count.values()):\n        return \"Yes\"\n    else:\n        return \"No\"\n\n# Read input from stdin\ns = input().strip()\nprint(check_string(s))",
        "result": "failed: testcase 0"
    },
    "4397": {
        "body": "N, i = map(int, input().split())\nj = N - i + 1\nprint(j)",
        "result": "passed"
    },
    "4180": {
        "body": "N = int(input())\nchange = N % 1000\nprint(change)",
        "result": "failed: testcase 0"
    },
    "4907": {
        "body": "    if n % 2 == 0:\n        return \"Alice\", 1\n    else:\n        return \"Bob\", 1\n\n# Read input\nn = int(input())\n\n# Print output\nwinner, move = bob_and_alice_pastime_conundrum(n)\nprint(winner)\nif winner == \"Alice\":\n    print(move)",
        "result": "failed: testcase 0"
    },
    "4839": {
        "body": "    canisters = sorted(capacities)\n    balloons = list(range(1, n + 1))\n    balloons.sort(reverse=True)\n\n    for i in range(n):\n        if canisters[i] < balloons[i]:\n            return \"impossible\"\n    \n    total_capacity = sum(balloons)\n    filled_volume = sum(canisters)\n    max_fraction = filled_volume / total_capacity\n    \n    return max_fraction\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncapacities = list(map(int, data[1:]))\n\nresult = max_fraction(n, capacities)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4665": {
        "body": "from collections import namedtuple\n\n    N = int(input())\n    columns = input().split()\n    Student = namedtuple('Student', columns)\n    \n    total_marks = 0\n    for _ in range(N):\n        student_data = input().split()\n        student = Student(*student_data)\n        total_marks += float(student.MARKS)\n    \n    average_marks = total_marks / N\n    print(f\"{average_marks:.2f}\")\n\ncalculate_average_marks()",
        "result": "failed: testcase 0"
    },
    "4785": {
        "body": "if 'ss' in input():\n    print('hiss')\nelse:\n    print('no hiss')",
        "result": "passed"
    },
    "4272": {
        "body": "N = int(input())\nS = input()\ncount = S.count('ABC')\nprint(count)",
        "result": "passed"
    },
    "4092": {
        "body": "    prefix_sum = 0\n    insertions = 0\n    seen_sums = set()\n    \n    for i in range(n):\n        prefix_sum += a[i]\n        if prefix_sum in seen_sums:\n            insertions += 1\n            prefix_sum = 0\n        seen_sums.add(prefix_sum)\n    \n    return insertions\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\na = list(map(int, data[1:]))\n\n# Print the result\nprint(min_insertions_to_avoid_zero_subsegments(n, a))",
        "result": "failed: testcase 0"
    },
    "4023": {
        "body": "    max_height = max(a)\n    total_bricks_needed = 0\n    \n    for height in a:\n        if height < max_height:\n            total_bricks_needed += max_height - height\n    \n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output the result\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0"
    },
    "4160": {
        "body": "import sys\n\n    X = int(input())\n    balance = 100\n    years = 0\n    \n    while balance < X:\n        balance += balance // 100\n        years += 1\n    \n    print(years)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4815": {
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    p = int(data[1])\n    m = int(data[2])\n    \n    players = data[3:3+n]\n    scores = {player: 0 for player in players}\n    \n    index = 3 + n\n    for _ in range(m):\n        player = data[index]\n        points = int(data[index + 1])\n        scores[player] += points\n        if scores[player] >= p:\n            print(f\"{player} wins!\")\n        index += 2\n    \n    if all(score < p for score in scores.values()):\n        print(\"No winner!\")\n\nif __name__ == \"__main__\":\n    find_winners()",
        "result": "failed: testcase 0"
    },
    "4514": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i - 1]].append(i)\n\n        queue = deque([(u, 0)])\n        received = []\n        while queue:\n            current, depth = queue.popleft()\n            if len(received) == k:\n                return received[-1]\n            if depth == k:\n                return received[-1] if received else -1\n            received.append(current)\n            for v in tree[current]:\n                queue.append((v, depth + 1))\n        return -1\n\n    results = []\n    for u, k in queries:\n        results.append(dfs(u, k))\n    \n    return results\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nq = int(data[1])\n\np = list(map(int, data[2:n + 1]))\n\nqueries = []\nfor i in range(q):\n    u_i = int(data[n + 2 + 2 * i]) - 1\n    k_i = int(data[n + 3 + 2 * i])\n    queries.append((u_i, k_i))\n\n# Process the queries and print the results\nresults = process_queries(n, q, p, queries)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4585": {
        "body": "import math\n\nX = int(input())\ntime = math.ceil(math.sqrt(2 * X))\nprint(time)",
        "result": "failed: testcase 0"
    },
    "4781": {
        "body": "    players = list(range(1, 9))\n    current_index = players.index(K)\n    \n    for time, answer in questions:\n        if answer == \"P\":\n            continue\n        else:\n            current_index = (current_index + 1) % len(players)\n    \n    return players[current_index]\n\n# Read input from stdin\nK = int(input())\nN = int(input())\nquestions = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Find and print the player who had the box when it finally exploded\nprint(find_explosion_player(K, N, questions))",
        "result": "failed: testcase 0"
    },
    "4551": {
        "body": "A, B, C, D = map(int, input().split())\nL = A + B\nR = C + D\nif L > R:\n    print(\"Left\")\nelif L < R:\n    print(\"Right\")\nelse:\n    print(\"Balanced\")",
        "result": "passed"
    },
    "4345": {
        "body": "    increasing = []\n    decreasing = []\n    \n    i = 0\n    while i < n:\n        if not increasing or increasing[-1] <= a[i]:\n            increasing.append(a[i])\n        else:\n            break\n        i += 1\n    \n    if i == n:\n        return \"NO\"\n    \n    j = i\n    while j < n:\n        if not decreasing or decreasing[-1] >= a[j]:\n            decreasing.append(a[j])\n        else:\n            break\n        j += 1\n    \n    if j != n:\n        return \"NO\"\n    \n    res = [0] * n\n    for k in range(i):\n        res[k] = 0\n    for k in range(i, n):\n        res[k] = 1\n    \n    return \"YES\\n\" + \" \".join(map(str, res))\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(split_sequence(n, a))",
        "result": "failed: testcase 0"
    },
    "4075": {
        "body": "import itertools\n\n    count = 0\n    for switches in itertools.product([0, 1], repeat=N):\n        if all(sum(switches[s-1] for s in connections) % 2 == p for connections, p in zip(switch_connections, bulb_conditions)):\n            count += 1\n    print(count)\n\n# Read input from stdin\nN, M = map(int, input().split())\nswitch_connections = [list(map(int, input().split()))[1:] for _ in range(M)]\nbulb_conditions = list(map(int, input().split()))\n\n# Call the function with the input values\ncount_valid_combinations(N, M, switch_connections, bulb_conditions)",
        "result": "failed: testcase 0"
    },
    "4408": {
        "body": "import sys\nfrom collections import Counter\n\n    card_count = Counter(cards)\n    total_joy = 0\n    \n    for i in range(n):\n        favorite_count = sum(1 for card in card_count if card == favorites[i])\n        total_joy += joy_levels[min(favorite_count, k-1)]\n    \n    return total_joy\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    cards = list(map(int, data[2:2+3*n]))\n    favorites = list(map(int, data[3+3*n:3+3*n+n]))\n    joy_levels = list(map(int, data[4+3*n+3*n:]))\n\n    result = max_joy_levels(n, k, cards, favorites, joy_levels)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4282": {
        "body": "import sys\nfrom collections import defaultdict\n\n    next_kid = [0] * (n + 1)\n    for i in range(1, n + 1):\n        a, b = remembered[i - 1]\n        if next_kid[a] == 0:\n            next_kid[a] = b\n        else:\n            next_kid[b] = a\n    \n    start = next_kid[remembered[0][0]]\n    order = [start]\n    current = start\n    for _ in range(n - 1):\n        current = next_kid[current]\n        order.append(current)\n    \n    return order\n\n# Read input from stdin\nn = int(input().strip())\nremembered = []\nfor _ in range(n):\n    a, b = map(int, input().strip().split())\n    remembered.append((a, b))\n\n# Find the dance order and print it\norder = find_dance_order(n, remembered)\nprint(\" \".join(map(str, order)))",
        "result": "failed: testcase 0"
    },
    "4331": {
        "body": "N = int(input())\nif '7' in str(N):\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed"
    },
    "4550": {
        "body": "    total_candies = a + b + c\n    if total_candies % 2 != 0:\n        return \"No\"\n    target = total_candies // 2\n    for i in range(target + 1):\n        for j in range(target + 1 - i):\n            k = target - i - j\n            if a >= i and b >= j and c >= k:\n                return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4271": {
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    B = list(map(int, data[N+1:2*N+1]))\n    C = list(map(int, data[2*N+1:3*N]))\n    \n    total_satisfaction = 0\n    \n    for i in range(N):\n        total_satisfaction += B[A[i] - 1]\n        if i < N - 1 and A[i + 1] == A[i] + 1:\n            total_satisfaction += C[i]\n    \n    print(total_satisfaction)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4848": {
        "body": "import math\n\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % (i * i) == 0:\n            return False\n    return True\n\n    for m in range(2, n):\n        if is_squarefree(m * n):\n            return m\n\nn = int(input())\nprint(find_m(n))",
        "result": "failed: testcase 0"
    },
    "4694": {
        "body": "import sys\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    a.sort()\n    return abs(a[0] - a[-1])\n\nif __name__ == \"__main__\":\n    print(min_travel_distance())",
        "result": "failed: testcase 0"
    },
    "4213": {
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    min_val = min(A)\n    max_val = max(A)\n    print(max_val - min_val)\n\nmax_abs_difference()",
        "result": "failed: testcase 0"
    },
    "4471": {
        "body": "    while True:\n        if all(h == 0 for h in heights):\n            return \"YES\"\n        placed = False\n        for i in range(n):\n            if heights[i] > 1:\n                heights[i] -= 2\n                placed = True\n                break\n        if not placed:\n            return \"NO\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\nindex = 1\n\nfor _ in range(t):\n    n = int(data[index])\n    heights = list(map(int, data[index + 1:index + n + 1]))\n    index += n + 1\n    results.append(can_clear_field(n, heights))\n\nprint(\"\\n\".join(results))",
        "result": "failed: testcase 0"
    },
    "4802": {
        "body": "H, M = map(int, input().split())\nif M < 45:\n    H -= 1\n    M += 60 - 45\nelse:\n    M -= 45\nif H < 0:\n    H += 24\nprint(H, M)",
        "result": "passed"
    },
    "4890": {
        "body": "import sys\nfrom typing import List\n\n    free_slots = [d - c for c in current_sodas if c < d]\n    \n    if len(free_slots) < n:\n        return \"impossible\"\n    \n    new_bottles = [0] * s\n    remaining_students = m\n    \n    while remaining_students > 0 and free_slots:\n        max_free_slot_index = free_slots.index(max(free_slots))\n        if current_sodas[max_free_slot_index] + n < d:\n            new_bottles[max_free_slot_index] += 1\n            n -= 1\n            remaining_students -= 1\n        free_slots[max_free_slot_index] -= 1\n    \n    return ' '.join(map(str, new_bottles))\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    s = int(data[2])\n    d = int(data[3])\n    current_sodas = list(map(int, data[4:]))\n    \n    result = refill_fridge(n, m, s, d, current_sodas)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4286": {
        "body": "import sys\nfrom heapq import heappop, heappush\n\n    graph = [[] for _ in range(n)]\n    for x, y, w in offers:\n        graph[x-1].append((y-1, w))\n        graph[y-1].append((x-1, w))\n\n    min_heap = []\n    visited = [False] * n\n    heappush(min_heap, (0, 0))\n    \n    total_cost = 0\n    edges_used = 0\n    \n    while min_heap:\n        cost, node = heappop(min_heap)\n        if visited[node]:\n            continue\n        \n        visited[node] = True\n        total_cost += cost\n        edges_used += 1\n        \n        for neighbor, offer_cost in graph[node]:\n            if not visited[neighbor]:\n                heappush(min_heap, (offer_cost, neighbor))\n    \n    return total_cost + sum(a) * (n - edges_used)\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\noffers = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(min_cost_to_connect_graph(n, m, a, offers))",
        "result": "failed: testcase 0"
    },
    "4713": {
        "body": "N = int(input())\nS = input()\nx = 0\nmax_x = 0\n\nfor char in S:\n    if char == 'I':\n        x += 1\n    else:\n        x -= 1\n    max_x = max(max_x, x)\n\nprint(max_x)",
        "result": "passed"
    },
    "4698": {
        "body": "import sys\n\n    N = int(input())\n    T = list(map(int, input().split()))\n    M = int(input())\n    drinks = []\n    for _ in range(M):\n        P, X = map(int, input().split())\n        drinks.append((P-1, X))\n    \n    results = []\n    for P, X in drinks:\n        total_time = sum(max(T[i], T[P] + (X - T[P]) * (i == P)) for i in range(N))\n        results.append(total_time)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4841": {
        "body": "    n = int(input())\n    bites = input().split()\n    \n    expected_count = 0\n    for bite in bites:\n        if bite == \"mumble\":\n            if expected_count != 0:\n                print(\"something is fishy\")\n                return\n        else:\n            current_count = int(bite)\n            if current_count != expected_count + 1:\n                print(\"something is fishy\")\n                return\n            expected_count += 1\n    \n    print(\"makes sense\")\n\ncheck_arilds_counting()",
        "result": "failed: testcase 0"
    },
    "4865": {
        "body": "import sys\n\n    if adjustment_type == 'F':\n        total_minutes = current_hour * 60 + current_minute + minutes\n        new_hour = total_minutes // 60 % 24\n        new_minute = total_minutes % 60\n    elif adjustment_type == 'B':\n        total_minutes = current_hour * 60 + current_minute - minutes\n        new_hour = total_minutes // 60 % 24\n        new_minute = total_minutes % 60\n    return f\"{new_hour} {new_minute}\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    for _ in range(n):\n        adjustment_type, minutes, current_hour, current_minute = input().split()\n        minutes = int(minutes)\n        current_hour = int(current_hour)\n        current_minute = int(current_minute)\n        result = calculate_new_time(adjustment_type, minutes, current_hour, current_minute)\n        print(result)",
        "result": "failed: testcase 0"
    },
    "4957": {
        "body": "    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                # Check if placing a coffee shop here satisfies the constraints\n                valid = True\n                for x in range(max(0, i-1), min(n, i+2)):\n                    for y in range(max(0, j-1), min(m, j+2)):\n                        if grid[x][y] == 'E':\n                            valid = False\n                            break\n                    if not valid:\n                        break\n                if valid:\n                    grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n    return grid\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n, m = int(data[0]), int(data[1])\n    grid = data[2:]\n    \n    result = place_coffee_shops(n, m, grid)\n    \n    for row in result:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4382": {
        "body": "N = int(input())\nprint(N ** 3)",
        "result": "passed"
    },
    "4456": {
        "body": "import sys\n\n    if n < k or k > 26:\n        return \"NO\"\n    \n    distinct_chars = set()\n    while len(distinct_chars) < k:\n        char = chr(ord('a') + len(distinct_chars))\n        distinct_chars.add(char)\n    \n    s = [''] * n\n    for i in range(n):\n        if p[i] <= q[i]:\n            s[p[i] - 1] = next(iter(distinct_chars))\n            distinct_chars.remove(s[p[i] - 1])\n        else:\n            s[q[i] - 1] = next(iter(distinct_chars))\n            distinct_chars.remove(s[q[i] - 1])\n    \n    if any(char == '' for char in s):\n        return \"NO\"\n    \n    return \"YES\\n\" + ''.join(s)\n\n# Read input\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# Print result\nprint(restore_string(n, k, p, q))",
        "result": "failed: testcase 0"
    },
    "4594": {
        "body": "    diameters.sort()\n    max_layers = 1\n    current_layer_diameter = diameters[0]\n    \n    for i in range(1, N):\n        if diameters[i] < current_layer_diameter:\n            max_layers += 1\n            current_layer_diameter = diameters[i]\n    \n    return max_layers\n\n# Read input from stdin\nN = int(input())\ndiameters = [int(input()) for _ in range(N)]\n\n# Print the result\nprint(max_kagami_mochi_layers(N, diameters))",
        "result": "failed: testcase 0"
    },
    "4560": {
        "body": "    for i in range(A + 1):\n        if (N - 500 * i) % 1 == 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\nN = int(input())\nA = int(input())\n\n# Print the result\nprint(can_pay_exactly(N, A))",
        "result": "failed: testcase 0"
    },
    "4320": {
        "body": "import sys\n\n    k = 2\n    while True:\n        if n % (2**k - 1) == 0:\n            return n // (2**k - 1)\n        k += 1\n\nt = int(input())\nresults = [find_x(int(input())) for _ in range(t)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4500": {
        "body": "A, B, C = map(int, input().split())\nif A + B >= C:\n    print(\"Yes\")\nelse:\n    print(\"No\")",
        "result": "passed"
    },
    "4739": {
        "body": "import sys\n\n    possible_speeds = set()\n    distances = []\n    \n    for i in range(1, M):\n        time_diff = T[i] - T[0]\n        distance_diff = X[T.index(T[i])] - X[0]\n        speed = distance_diff / time_diff\n        if speed not in possible_speeds:\n            possible_speeds.add(speed)\n            distances.append(distance_diff)\n    \n    distinct_speeds_count = len(possible_speeds)\n    sorted_distances = sorted(distances)\n    \n    print(distinct_speeds_count)\n    print(' '.join(map(str, sorted_distances)))\n\n# Read input from stdin\nM, N = map(int, input().split())\nT = list(map(int, input().split()))\nX = list(map(int, input().split()))\n\nfind_possible_speeds_and_distances(M, N, T, X)",
        "result": "failed: testcase 0"
    },
    "4410": {
        "body": "    count = 0\n    i = 0\n    while i < n:\n        if s[i] == '1':\n            i += k + 1\n        else:\n            count += 1\n            i += 1\n    return count\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    k = int(data[index + 1])\n    s = data[index + 2]\n    index += 3\n    results.append(max_free_tables(n, k, s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2441": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    MOD = 10**9 + 7\n    \n    # Build the adjacency list for the graph\n    adj_list = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for u, v in roads:\n        adj_list[u].append(v)\n        in_degree[v] += 1\n    \n    # Initialize the queue with junctions that have no incoming edges\n    queue = deque(u for u in range(1, n + 1) if in_degree[u] == 0)\n    \n    # Initialize the cost and count arrays\n    min_cost = [float('inf')] * (n + 1)\n    min_cost[1] = costs[0]\n    num_ways = [0] * (n + 1)\n    num_ways[1] = 1\n    \n    while queue:\n        u = queue.popleft()\n        \n        for v in adj_list[u]:\n            if min_cost[v] > min_cost[u] + costs[v-1]:\n                min_cost[v] = min_cost[u] + costs[v-1]\n                num_ways[v] = num_ways[u]\n            elif min_cost[v] == min_cost[u] + costs[v-1]:\n                num_ways[v] = (num_ways[v] + num_ways[u]) % MOD\n            \n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n    \n    # Find the maximum cost among all junctions\n    max_cost = max(min_cost[1:])\n    \n    # Count the number of ways to achieve this maximum cost\n    count_ways = sum(num_ways[i] for i in range(1, n + 1) if min_cost[i] == max_cost)\n    \n    return max_cost, count_ways\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\ncosts = list(map(int, data[1:n+1]))\nm = int(data[n+1])\nroads = [(int(data[n+2 + 2*i]) - 1, int(data[n+3 + 2*i]) - 1) for i in range(m)]\n\n# Get the result\nresult = min_cost_to_secure(n, costs, roads)\n\n# Print the output\nprint(result[0], result[1])",
        "result": "failed: testcase 0"
    },
    "276": {
        "body": "    gems = [\"purple\", \"green\", \"blue\", \"orange\", \"red\", \"yellow\"]\n    seen_colors = set(input().strip() for _ in range(int(input())))\n    \n    absent_gems = [gem.capitalize() for gem in gems if gem not in seen_colors]\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()",
        "result": "failed: testcase 0"
    },
    "2635": {
        "body": "    if not matrix:\n        return []\n    \n    top, bottom = 0, len(matrix) - 1\n    left, right = 0, len(matrix[0]) - 1\n    result = []\n    \n    while top <= bottom and left <= right:\n        # Traverse from left to right along the top row\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        \n        # Traverse downwards along the right column\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        \n        if top <= bottom:\n            # Traverse from right to left along the bottom row\n            for i in range(right, left - 1, -1):\n                result.append(matrix[bottom][i])\n            bottom -= 1\n        \n        if left <= right:\n            # Traverse upwards along the left column\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n    \n    return result\n\n# Example usage:\nmatrix = eval(input())\nprint(spiralOrder(matrix))",
        "result": "failed: testcase 0"
    },
    "281": {
        "body": "        if n == 0:\n            return 1\n        result = 1\n        for i in range(2, n + 1):\n            result = (result * i) % 10\n        return result\n    \n    last_digit_a_fact = factorial(a)\n    last_digit_b_fact = factorial(b)\n    \n    if a == b:\n        return 1\n    elif b - a >= 4:\n        return 0\n    else:\n        return (last_digit_b_fact * pow(last_digit_a_fact, 10, 10)) % 10\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(last_digit_of_factorial_division(a, b))",
        "result": "failed: testcase 0"
    },
    "2300": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    operations = []\n    idx = 2 + n\n    for i in range(m):\n        t = int(data[idx])\n        if t == 1:\n            x_i = int(data[idx+1]) - 1\n            v_i = int(data[idx+2])\n            operations.append((t, x_i, v_i))\n        elif t == 2:\n            l_i = int(data[idx+1]) - 1\n            r_i = int(data[idx+2])\n            operations.append((t, l_i, r_i))\n        elif t == 3:\n            l_i = int(data[idx+1]) - 1\n            r_i = int(data[idx+2])\n            d_i = int(data[idx+3])\n            operations.append((t, l_i, r_i, d_i))\n        idx += 4 if t == 3 else 3\n    \n    MOD = 10**9\n    \n    f = [1, 1]\n    for i in range(2, m + 1):\n        f.append(f[i-1] - 1 + f[i-2])\n    \n    result = []\n    for op in operations:\n        t = op[0]\n        if t == 1:\n            x_i, v_i = op[1], op[2]\n            a[x_i] = v_i\n        elif t == 2:\n            l_i, r_i = op[1], op[2]\n            total_sum = 0\n            for i in range(l_i, r_i):\n                total_sum += f[i - l_i] * a[i]\n            result.append(total_sum % MOD)\n        elif t == 3:\n            l_i, r_i, d_i = op[1], op[2], op[3]\n            for i in range(l_i, r_i + 1):\n                a[i] += d_i\n    \n    for res in result:\n        print(res)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "2104": {
        "body": "import sys\nfrom math import gcd\n\n    pairs = []\n    if (r - l + 1) % 2 != 0:\n        return \"NO\"\n    for i in range(l, r + 1):\n        for j in range(i + 1, r + 1):\n            if gcd(i, j) == 1:\n                pairs.append((i, j))\n                break\n        else:\n            continue\n        break\n    if len(pairs) != (r - l + 1) // 2:\n        return \"NO\"\n    return \"YES\\n\" + \"\\n\".join(f\"{i} {j}\" for i, j in pairs)\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    result = find_pairs(l, r)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "1995": {
        "body": "    for l, r, k in queries:\n        substring = s[l-1:r]\n        shifted_substring = substring[-k:] + substring[:-k]\n        s = s[:l-1] + shifted_substring + s[r:]\n    return s\n\n# Read input\ns = input().strip()\nm = int(input().strip())\nqueries = [tuple(map(int, input().strip().split())) for _ in range(m)]\n\n# Process queries and print the result\nresult = process_queries(s, queries)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "2064": {
        "body": "    if n == 0:\n        return 0\n    elif n < 7:\n        return n\n    else:\n        digits = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n        result = []\n        for i in range(9, -1, -1):\n            if n >= digits[i]:\n                result.append(i)\n                n -= digits[i]\n        return int(''.join(map(str, result)))\n\n# Read input from stdin\nn = int(input())\nprint(max_number(n))",
        "result": "failed: testcase 0"
    },
    "1715": {
        "body": "import sys\n\n    results = []\n    for xi in x:\n        i = 0\n        while i < A and s[i] < xi:\n            i += 1\n        if i == 0:\n            dist_to_shrine = abs(xi - s[0])\n        elif i == A:\n            dist_to_shrine = abs(xi - s[-1])\n        else:\n            dist_to_shrine = min(abs(xi - s[i]), abs(xi - s[i-1]))\n        \n        j = 0\n        while j < B and t[j] < xi:\n            j += 1\n        if j == 0:\n            dist_to_temple = abs(xi - t[0])\n        elif j == B:\n            dist_to_temple = abs(xi - t[-1])\n        else:\n            dist_to_temple = min(abs(xi - t[j]), abs(xi - t[j-1]))\n        \n        results.append(dist_to_shrine + dist_to_temple)\n    return results\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    A = int(data[0])\n    B = int(data[1])\n    Q = int(data[2])\n    \n    s = [int(data[3 + i]) for i in range(A)]\n    t = [int(data[3 + A + i]) for i in range(B)]\n    x = [int(data[3 + A + B + i]) for i in range(Q)]\n    \n    results = min_distance_to_shrine_and_temple(A, B, Q, s, t, x)\n    \n    for result in results:\n        print(result)",
        "result": "failed: testcase 0"
    },
    "2074": {
        "body": "import sys\n\n    min_costs = [min(row) for row in costs]\n    return max(min_costs)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    costs = []\n    index = 2\n    for i in range(n):\n        row = list(map(int, data[index:index+m]))\n        costs.append(row)\n        index += m\n    \n    result = find_dinner_cost(n, m, costs)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2921": {
        "body": "import sys\n\n    drinks = []\n    for _ in range(d):\n        name, strength, size, cost = input().split()\n        strength = float(strength)\n        size = 1 if size == '1/1' else (0.5 if size == '1/2' else 0.3333)\n        cost = float(cost)\n        drinks.append((name, strength * size / 100, cost))\n\n    for i in range(1 << d):\n        total_cost = 0\n        total_units = 0\n        selected_drinks = []\n        for j in range(d):\n            if (i & (1 << j)) > 0:\n                total_cost += drinks[j][2]\n                total_units += drinks[j][1]\n                selected_drinks.append((drinks[j][0], 1))\n        if abs(total_cost - m) < 1e-9 and abs(total_units - u) < 1e-9:\n            return '\\n'.join(f\"{name} {count}\" for name, count in selected_drinks)\n    return \"IMPOSSIBLE\"\n\nif __name__ == \"__main__\":\n    m, u, d = map(float, input().split())\n    print(beer_tasting(m, u, int(d)))",
        "result": "failed: testcase 0"
    },
    "1642": {
        "body": "from typing import List\nimport math\n\n    max_d = 0.0\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)\n        max_d = max(max_d, dist / 2)\n    return max_d\n\n# Read input\nn = int(input())\nvertices = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    vertices.append([x, y])\n\n# Calculate and print the result\nresult = max_movement(n, vertices)\nprint(f\"{result:.12f}\")",
        "result": "failed: testcase 0"
    },
    "947": {
        "body": "import sys\n\n    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return (n - 1) // 2, n // 2 + 1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a, b = min_lcm_pair(n)\n    print(a, b)",
        "result": "failed: testcase 0"
    },
    "743": {
        "body": "    numbers.sort()\n    for i in range(1, n):\n        numbers[0] -= numbers[i]\n    return numbers[0]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nnumbers = list(map(int, data[1:]))\n\nprint(minimize_sum(n, numbers))",
        "result": "failed: testcase 0"
    },
    "1397": {
        "body": "    from collections import defaultdict\n    graph = defaultdict(list)\n    \n    # Add all possible roads except the forbidden ones\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in forbidden and (j, i) not in forbidden:\n                graph[i].append(j)\n                graph[j].append(i)\n    \n    # Function to check if there is a path of length at most 2 between two nodes\n        visited = set()\n        queue = [(u, 0)]\n        while queue:\n            node, dist = queue.pop(0)\n            if node == v and dist <= 2:\n                return True\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor != u:\n                        queue.append((neighbor, dist + 1))\n        return False\n    \n    # Check all pairs of nodes to ensure the condition is met\n    roads_to_build = []\n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            if not has_path_of_length_at_most_two(u, v):\n                for w in range(1, n + 1):\n                    if u != w and v != w and w != u and w != v:\n                        if (u, w) not in forbidden and (w, u) not in forbidden and (v, w) not in forbidden and (w, v) not in forbidden:\n                            roads_to_build.append((u, w))\n                            roads_to_build.append((v, w))\n                            break\n                else:\n                    continue\n                break\n    \n    # Remove duplicate roads\n    roads_to_build = list(set(roads_to_build))\n    \n    # Output the result\n    print(len(roads_to_build))\n    for road in roads_to_build:\n        print(*road)",
        "result": "failed: testcase 0"
    },
    "1144": {
        "body": "    t = 'a' * (m // 2 + m % 2) + 'b' * (m // 2)\n    replacements = 0\n    \n    for i in range(m - 1):\n        if s[i] == '?' and s[i + 1] == '?':\n            replacements += 1\n        elif s[i] != '?' and s[i + 1] != '?' and (s[i] != 'a' or s[i + 1] != 'b'):\n            replacements += 2\n    \n    if i + 1 < n:\n        replacements += sum(s[i:] != t)\n    \n    return replacements\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ns = data[1]\nm = int(data[2])\n\nprint(max_replacements(n, s, m))",
        "result": "failed: testcase 0"
    },
    "890": {
        "body": "from itertools import combinations\n\n    count = 0\n    for r in range(2, n + 1):\n        for combo in combinations(difficulties, r):\n            if l <= sum(combo) <= r and max(combo) - min(combo) >= x:\n                count += 1\n    return count\n\n# Read input\nn, l, r, x = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Print the result\nprint(count_problemsets(n, l, r, x, difficulties))",
        "result": "failed: testcase 0"
    },
    "2410": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        yasser_tastiness = sum(a)\n        adel_min_tastiness = float('inf')\n        \n        current_sum = 0\n        for i in range(n):\n            current_sum += a[i]\n            if i >= 1:\n                current_sum -= a[i - 1]\n            adel_min_tastiness = min(adel_min_tastiness, current_sum)\n        \n        if yasser_tastiness > adel_min_tastiness:\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nis_yasser_happy()",
        "result": "failed: testcase 0"
    },
    "1004": {
        "body": "    stack = []\n    days = []\n    current_day = 0\n    \n    for event in a:\n        if event > 0:\n            if not stack or stack[-1] < event:\n                stack.append(event)\n                current_day += 1\n            else:\n                return -1\n        else:\n            if not stack or stack[-1] != -event:\n                return -1\n            stack.pop()\n    \n    if not stack and current_day > 0:\n        days.append(current_day)\n    elif stack:\n        return -1\n    \n    return len(days), ' '.join(map(str, days))\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nresult = partition_events(n, a)\nprint(result[0])\nif result[0] != -1:\n    print(result[1])",
        "result": "failed: testcase 0"
    },
    "531": {
        "body": "import sys\n\n    n = int(input().strip())\n    x = list(map(int, input().strip().split()))\n    \n    min_val = min(x)\n    max_val = max(x)\n    target_avg = sum(x) / n\n    \n    count_equal = 0\n    result = []\n    \n    for i in range(n):\n        if x[i] == target_avg:\n            result.append(x[i])\n            count_equal += 1\n        else:\n            value_to_add = round(target_avg)\n            if min_val <= value_to_add <= max_val:\n                result.append(value_to_add)\n                if value_to_add != x[i]:\n                    count_equal += 1\n    \n    print(count_equal)\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "510": {
        "body": "import sys\n\n    # Sort the positions to simplify calculations\n    a, b, c = sorted([a, b, c])\n    \n    # Calculate the minimum moves needed for each pair to be at least distance d apart\n    moves_a_b = max(0, d - (b - a) - 1)\n    moves_b_c = max(0, d - (c - b) - 1)\n    \n    # The total duration is the maximum of the two moves needed\n    return max(moves_a_b, moves_b_c)\n\n# Read input from stdin\na, b, c, d = map(int, input().split())\n\n# Output the result\nprint(min_performance_duration(a, b, c, d))",
        "result": "failed: testcase 0"
    },
    "2555": {
        "body": "import sys\n\n    n = len(a)\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0], dp[0][1] = a[0], -a[0]\n    max_strength = max(dp[0])\n    \n    for i in range(1, n):\n        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + a[i])\n        dp[i][1] = max(dp[i-1][1], dp[i-1][0] - a[i])\n        max_strength = max(max_strength, dp[i][0], dp[i][1])\n    \n    return max_strength\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        q = int(data[index + 1])\n        index += 2\n        \n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        initial_strength = calculate_max_strength(a)\n        results.append(initial_strength)\n        \n        for _ in range(q):\n            l = int(data[index]) - 1\n            r = int(data[index + 1]) - 1\n            index += 2\n            \n            a[l], a[r] = a[r], a[l]\n            strength = calculate_max_strength(a)\n            results.append(strength)\n    \n    for result in results:\n        print(result, end=\" \")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "324": {
        "body": "import sys\n\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return True\n        return False\n    \n    a = n + 2\n    while not is_composite(a):\n        a += 2\n    b = a - n\n    while not is_composite(b):\n        b -= 2\n    print(a, b)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    find_composite_pair(n)",
        "result": "failed: testcase 0"
    },
    "2912": {
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\nstrings = data[1:N+1]\noperations = [(int(data[N+i])-1, int(data[N+i+N])-1) for i in range(N-1)]\n\nfor a, b in operations:\n    strings[a] += strings[b]\n    strings[b] = \"\"\n\nprint(strings[0])",
        "result": "failed: testcase 0"
    },
    "9": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    d = int(data[0])\n    n, m = map(int, data[1:3])\n    \n    sofas = []\n    index = 3\n    for _ in range(d):\n        x1, y1, x2, y2 = map(int, data[index:index+4])\n        sofas.append(((x1, y1), (x2, y2)))\n        index += 4\n    \n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, data[index:])\n    \n    for i in range(d):\n        left_count = right_count = top_count = bottom_count = 0\n        x1, y1 = sofas[i][0]\n        x2, y2 = sofas[i][1]\n        \n        for j in range(d):\n            if i == j:\n                continue\n            x3, y3 = sofas[j][0]\n            x4, y4 = sofas[j][1]\n            \n            if (x1 <= x3 <= x2 and (y1 == y3 or y2 == y4)):\n                if y1 < y3 < y2 or y1 > y3 > y2:\n                    left_count += 1\n                elif x1 < x3 < x2 or x1 > x3 > x2:\n                    top_count += 1\n            elif (y1 <= y3 <= y2 and (x1 == x3 or x2 == x4)):\n                if x1 < x3 < x2 or x1 > x3 > x2:\n                    left_count += 1\n                elif y1 < y3 < y2 or y1 > y3 > y2:\n                    top_count += 1\n        \n        if left_count == cnt_l and right_count == cnt_r and top_count == cnt_t and bottom_count == cnt_b:\n            print(i + 1)\n            return\n    \n    print(-1)\n\nfind_grandpas_sofa()",
        "result": "failed: testcase 0"
    },
    "249": {
        "body": "    needed_marks = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(a[j] - a[i])\n            if diff == x or diff == y:\n                continue\n            elif diff < x:\n                needed_marks.add(x - diff)\n            elif diff < y:\n                needed_marks.add(y - diff)\n    return len(needed_marks), sorted(list(needed_marks))\n\n# Read input from stdin\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\n# Get the result\nv, p = min_additional_marks(n, l, x, y, a)\n\n# Print the result\nprint(v)\nfor mark in p:\n    print(mark, end=' ')",
        "result": "failed: testcase 0"
    },
    "2999": {
        "body": "from itertools import combinations\n\n    bets = [b for t, b in participants]\n    total_bets = sum(bets)\n    winning_participants = []\n\n        return sum(group) == s\n\n    for r in range(1, n + 1):\n        for group in combinations(bets, r):\n            if is_winning_group(group):\n                winners_indices = [i for i, b in enumerate(bets) if b in group]\n                winning_participants.extend([participants[i][0] for i in winners_indices])\n                break\n        else:\n            continue\n        break\n\n    return len(winning_participants), sorted(set(winning_participants))\n\n# Read input\nn, s = map(int, input().split())\nparticipants = [input().split() for _ in range(n)]\nfor i in range(n):\n    participants[i][1] = int(participants[i][1])\n\n# Find and print the winners\nk, winners = find_lottery_winners(n, s, participants)\nprint(k)\nfor winner in winners:\n    print(winner)",
        "result": "failed: testcase 0"
    },
    "2239": {
        "body": "    if x < 2 or x > 7:\n        return None\n    rolls = 0\n    while x > 0:\n        for i in range(7, 1, -1):\n            if x >= i:\n                x -= i\n                rolls += 1\n                break\n    return rolls\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    queries = [int(data[i]) for i in range(1, t+1)]\n    \n    results = [min_rolls(x) for x in queries]\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2615": {
        "body": "import sys\n\n    sieve = [True] * (n + 1)\n    for i in range(2, int(n**0.5) + 1):\n        if sieve[i]:\n            sieve[i*i:n+1:i] = [False] * ((n//i - i)//i + 1)\n    \n    primes = [i for i, is_prime in enumerate(sieve) if is_prime and i > 1]\n    \n        factors = []\n        for prime in primes:\n            if x < prime:\n                break\n            while x % prime == 0:\n                factors.append(prime)\n                x //= prime\n        return factors\n    \n    from collections import Counter\n    from math import gcd\n    from functools import reduce\n    \n        return reduce(gcd, nums)\n    \n    elegant_count = 0\n    for i in range(2, n + 1):\n        factors = prime_factors(i)\n        factor_counts = list(Counter(factors).values())\n        if gcdn(factor_counts) == 1:\n            elegant_count += 1\n    \n    return elegant_count\n\n    T = int(input().strip())\n    results = []\n    for _ in range(T):\n        n_i = int(input().strip())\n        results.append(count_elegant_numbers(n_i))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2542": {
        "body": "    n = len(s)\n    for i in range(n):\n        if s[:i] == s[-i:]:\n            return n - 2 * i\n    return n - 1\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input().strip()\n    results.append(min_erasures_to_good_string(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "511": {
        "body": "import math\n\n    if b == 0:\n        return 0\n    else:\n        return 1 + f(a, b - math.gcd(a, b))\n\nx, y = map(int, input().split())\nprint(f(x, y))",
        "result": "failed: testcase 0"
    },
    "1409": {
        "body": "from collections import Counter\n\n    count = Counter(y)\n    valid_teams = 0\n    \n    for i in range(6):\n        if count[i] >= k:\n            valid_teams += count[i] // k\n    \n    return valid_teams // 3\n\n# Read input\nn, k = map(int, input().split())\ny = list(map(int, input().split()))\n\n# Output the result\nprint(max_teams(n, k, y))",
        "result": "failed: testcase 0"
    },
    "2274": {
        "body": "import sys\n\n    changes = 0\n    stack = [(n-1, m-1)]\n    \n    while stack:\n        x, y = stack.pop()\n        \n        if x < 0 or y < 0 or x >= n or y >= m or directions[x][y] == 'C':\n            continue\n        \n        if directions[x][y] == 'R':\n            stack.append((x, y+1))\n        elif directions[x][y] == 'D':\n            stack.append((x+1, y))\n        \n        changes += 1\n        directions[x][y] = 'C'\n    \n    return changes\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        m = int(data[index + 1])\n        directions = [list(data[index + 2 + i]) for i in range(n)]\n        index += 2 + n\n        \n        results.append(min_changes_to_functional(n, m, directions))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2420": {
        "body": "        return abs(x - cx) + abs(y - cy) <= r\n\n    max_covered = 0\n    for i in range(n):\n        covered = sum(1 for x, y in points if in_ball(x, y, points[i][0], points[i][1], r))\n        max_covered = max(max_covered, covered)\n    \n    return max_covered\n\n# Read input from stdin\nn, r = map(int, input().split())\npoints = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(max_points_in_ball(n, r, points))",
        "result": "failed: testcase 0"
    },
    "1267": {
        "body": "    max_score = max(scores)\n    dp = [0] * (max_score + 1)\n    dp[0] = 1\n    \n    for score in scores:\n        if score == 0:\n            continue\n        for j in range(max_score, score - 1, -1):\n            dp[j] += dp[j - score]\n    \n    return sum(dp)\n\n# Read input\nn = int(input())\nscores = list(map(int, input().split()))\n\n# Output the result\nprint(count_ways_to_choose_diplomas(n, scores))",
        "result": "failed: testcase 0"
    },
    "2356": {
        "body": "import sys\nfrom typing import List\n\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j - arr[j] == i - arr[i]:\n                return False\n    return True\n\n    while not is_good_array(arr):\n        import random\n        random.shuffle(arr)\n    return arr\n\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    good_a = shuffle_to_good_array(a)\n    results.append(good_a)\n\nfor result in results:\n    print(len(result))\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "108": {
        "body": "    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    index = 0\n    for char in s:\n        if char == alphabet[index]:\n            index += 1\n        if index == len(alphabet):\n            break\n    return alphabet if index == len(alphabet) else \"-1\"\n\n# Read input from stdin\ns = input().strip()\n# Print the result\nprint(can_form_alphabet_subsequence(s))",
        "result": "failed: testcase 0"
    },
    "1833": {
        "body": "MOD = 10**9 + 7\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for num in a:\n        new_dp = dp[:]\n        for i in range(1, n + 1):\n            if num % i == 0:\n                new_dp[i] = (new_dp[i] + dp[i - 1]) % MOD\n        dp = new_dp\n    return sum(dp[1:]) % MOD\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Print the result\nprint(count_good_subsequences(n, a))",
        "result": "failed: testcase 0"
    },
    "2324": {
        "body": "    n = len(s)\n    dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n+1)]\n    \n    for length in range(1, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if length == 1:\n                dp[1][i][j] = j - i + 1\n            elif s[i] == s[j]:\n                dp[length][i][j] = dp[length-2][i+1][j-1] + (2 * dp[1][i][j] if length > 3 else 1)\n            else:\n                dp[length][i][j] = max(dp[length-1][i+1][j], dp[length-1][i][j-1])\n    \n    result = []\n    for k in range(1, n + 1):\n        count = 0\n        for i in range(n - k + 1):\n            j = i + k - 1\n            if dp[k][i][j] >= k:\n                count += 1\n        result.append(count)\n    \n    print(' '.join(map(str, result)))\n\npalindromic_characteristics(input().strip())",
        "result": "failed: testcase 0"
    },
    "2372": {
        "body": "import sys\nfrom collections import deque\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = deque([(C_h, C_w, 0)])\n    visited = set()\n    visited.add((C_h, C_w))\n    \n    while queue:\n        x, y, magic_used = queue.popleft()\n        \n        if (x, y) == (D_h, D_w):\n            return magic_used\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and S[nx][ny] == '.' and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, magic_used))\n        \n        # Check the 5x5 area for a road\n        center_x, center_y = x // 2 * 2 + 1, y // 2 * 2 + 1\n        found_road = False\n        for i in range(center_x - 2, center_x + 3):\n            for j in range(center_y - 2, center_y + 3):\n                if 0 <= i < H and 0 <= j < W and S[i][j] == '.' and (i, j) not in visited:\n                    found_road = True\n                    queue.append((i, j, magic_used + 1))\n                    break\n            if found_road:\n                break\n    \n    return -1\n\n# Read input\nH, W = map(int, input().split())\nC_h, C_w = map(int, input().split())\nD_h, D_w = map(int, input().split())\nS = [input().strip() for _ in range(H)]\n\n# Output the result\nprint(min_magic_moves(H, W, C_h - 1, C_w - 1, D_h - 1, D_w - 1, S))",
        "result": "failed: testcase 0"
    },
    "1984": {
        "body": "    levels = []\n    for _ in range(k):\n        level = [input().strip() for _ in range(n)]\n        levels.append(level)\n\n        return sum(row1 != row2 for row1, row2 in zip(level1, level2))\n\n    transferred_bytes = 0\n    transmission_plan = []\n\n    current_level = None\n    for i in range(k):\n        if i == 0:\n            transferred_bytes += n * m\n            transmission_plan.append((i + 1, 0))\n            current_level = levels[i]\n        else:\n            min_diff = float('inf')\n            best_prev = -1\n            for j in range(i):\n                diff = diff_cells(levels[i], levels[j])\n                if diff < min_diff:\n                    min_diff = diff\n                    best_prev = j + 1\n\n            transferred_bytes += min_diff * w\n            transmission_plan.append((i + 1, best_prev))\n            current_level = levels[i]\n\n    print(transferred_bytes)\n    for plan in transmission_plan:\n        print(plan[0], plan[1])\n\n# Read input from stdin\nn, m, k, w = map(int, input().split())\nmin_transferred_bytes(n, m, k, w)",
        "result": "failed: testcase 0"
    },
    "1253": {
        "body": "    negative_count = sum(1 for x in a if x < 0)\n    positive_count = n - negative_count\n    \n    if k <= negative_count:\n        return sum(a) + 2 * sum(x for x in a[:k] if x < 0)\n    else:\n        remaining_changes = k - negative_count\n        if remaining_changes % 2 == 0:\n            return sum(a) + 2 * sum(x for x in a[:negative_count])\n        else:\n            return sum(a) + 2 * (sum(x for x in a[:negative_count]) - min(abs(x) for x in a[:negative_count]))\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0"
    },
    "523": {
        "body": "        return s == s[::-1]\n\n    max_length = 0\n    best_palindrome = \"\"\n\n    for i in range(1 << n):\n        selected = [strings[j] for j in range(n) if (i & (1 << j))]\n        concatenation = \"\".join(selected)\n        reversed_concatenation = concatenation[::-1]\n        \n        for j in range(len(concatenation)):\n            candidate = concatenation[:j + 1] + reversed_concatenation\n            if is_palindrome(candidate):\n                length = len(candidate)\n                if length > max_length:\n                    max_length = length\n                    best_palindrome = candidate\n\n    return max_length, best_palindrome\n\n# Read input from stdin\nn, m = map(int, input().split())\nstrings = [input().strip() for _ in range(n)]\n\n# Get the result\nmax_length, best_palindrome = longest_palindrome(n, m, strings)\n\n# Print the result\nprint(max_length)\nif best_palindrome:\n    print(best_palindrome)",
        "result": "failed: testcase 0"
    },
    "2934": {
        "body": "    MOD = 10**9\n    if N == 1:\n        return (2 ** (M - 1)) % MOD\n    dp = [[0] * (M + 1) for _ in range(N + 1)]\n    dp[1][0] = 1\n    for i in range(1, N + 1):\n        for j in range(M + 1):\n            if j >= 2:\n                dp[i][j] = (dp[i][j - 1] + dp[i][j - 2]) % MOD\n            if i > 1 and j >= 1:\n                dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD\n    return dp[N][M]\n\nN = int(input())\nM = int(input())\nprint(count_tilings(N, M))",
        "result": "failed: testcase 0"
    },
    "1745": {
        "body": "        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n        if turns > 2:\n            return 0\n        if (x, y, dx, dy) in memo:\n            return memo[(x, y, dx, dy)]\n        if x == n - 1 and y == m - 1 and is_valid(x, y):\n            return 1\n        count = 0\n        for i in range(4):\n            nx, ny = x + dx * directions[i][0], y + dy * directions[i][1]\n            ndx, ndy = directions[i][2], directions[i][3]\n            if is_valid(nx, ny) and (nx != x or ny != y):\n                count += dfs(nx, ny, ndx, ndy, turns + 1)\n        memo[(x, y, dx, dy)] = count\n        return count\n\n    directions = [(0, 1, 0, 1), (0, -1, 0, -1), (1, 0, 1, 0), (-1, 0, -1, 0)]\n    memo = {}\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                for dx, dy in directions:\n                    if dx * dy == 0 and (i != 0 or j != 0) and (i != n - 1 or j != m - 1):\n                        result += dfs(i, j, dx, dy, 0)\n    return result\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Output the result\nprint(count_pipe_ways(n, m, grid))",
        "result": "failed: testcase 0"
    },
    "1422": {
        "body": "    if m == 0:\n        return \"YES\"\n    \n    left_sum = 0\n    right_sum = 0\n    placed_weights = []\n    \n    for weight in range(1, 11):\n        if weights[weight - 1] == '1':\n            while True:\n                if len(placed_weights) % 2 == 0:  # Even index (left pan)\n                    if right_sum + weight > left_sum:\n                        placed_weights.append(weight)\n                        left_sum += weight\n                        break\n                else:  # Odd index (right pan)\n                    if left_sum + weight > right_sum:\n                        placed_weights.append(weight)\n                        right_sum += weight\n                        break\n    return \"YES\\n\" + \" \".join(map(str, placed_weights)) if len(placed_weights) == m else \"NO\"\n\n# Read input from stdin\nweights = input().strip()\nm = int(input().strip())\n\n# Print the result\nprint(can_place_weights(weights, m))",
        "result": "failed: testcase 0"
    },
    "1763": {
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nA = int(data[1])\nR = int(data[2])\nM = int(data[3])\nh = list(map(int, data[4:]))\n\n# Calculate the target height for all pillars\ntarget_height = sum(h) // N\n\n# Initialize variables to track the number of bricks above and below the target height\nabove_target = 0\nbelow_target = 0\n\n# Calculate the cost to move bricks from above to below the target height\nfor height in h:\n    if height > target_height:\n        above_target += (height - target_height) * A\n    elif height < target_height:\n        below_target += (target_height - height) * R\n\n# The minimal total cost is the minimum of moving bricks up or down\nmin_cost = min(above_target, below_target)\n\nprint(min_cost)",
        "result": "failed: testcase 0"
    },
    "974": {
        "body": "from collections import deque\n\n    stack = deque()\n    reorder_count = 0\n    required_boxes = list(range(1, n + 1))\n    \n    for command in commands:\n        if command.startswith(\"add\"):\n            box = int(command.split()[1])\n            stack.append(box)\n        elif command == \"remove\":\n            while stack and stack[0] != required_boxes[0]:\n                stack.append(stack.popleft())\n                reorder_count += 1\n            if stack:\n                stack.popleft()\n                required_boxes.pop(0)\n    \n    return reorder_count\n\n# Read input\nn = int(input().strip())\ncommands = [input().strip() for _ in range(2 * n)]\n\n# Output the result\nprint(min_reorders(n, commands))",
        "result": "failed: testcase 0"
    },
    "2343": {
        "body": "import sys\n\n    if n == 0:\n        return True, 0\n    max_splits = (n * (n + 1)) // 2\n    if k > max_splits:\n        return False, -1\n    path_size = n - k\n    return True, path_size\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        possible, path_size = can_split(n, k)\n        if possible:\n            print(\"YES\", path_size)\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "627": {
        "body": "    n = len(s)\n    for i in range(n):\n        if i == 0 or s[i] < s[i - 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\n\n# Read input\nn = int(input())\ns = input()\n\n# Output result\nprint(remove_one_char(s))",
        "result": "failed: testcase 0"
    },
    "1655": {
        "body": "    alive = [True] * n\n    for i in range(n):\n        if L[i] > 0:\n            start = max(0, i - L[i])\n            for j in range(start, i):\n                alive[j] = False\n    return sum(alive)\n\n# Read input\nn = int(input())\nL = list(map(int, input().split()))\n\n# Output the result\nprint(count_alive_people(n, L))",
        "result": "failed: testcase 0"
    },
    "2124": {
        "body": "import sys\n\n    results = []\n    \n    for _ in range(chats):\n        n = int(input())\n        usernames = input().split()\n        m = int(input())\n        messages = [input().strip() for _ in range(m)]\n        \n        known_senders = set()\n        unknown_messages = []\n        current_sender = None\n        \n        for message in messages:\n            if message.startswith('?'):\n                unknown_messages.append(message)\n            else:\n                sender, text = message.split(':')\n                if sender not in known_senders:\n                    if current_sender is None or current_sender != sender:\n                        known_senders.add(sender)\n                        current_sender = sender\n                    elif sender in current_sender.lower():\n                        results.append(\"Impossible\")\n                        break\n                else:\n                    results.append(message)\n        \n        if len(known_senders) < m - len(unknown_messages):\n            results.append(\"Impossible\")\n        else:\n            for message in unknown_messages:\n                while True:\n                    sender = next((user for user in usernames if user not in known_senders and user.lower() != current_sender), None)\n                    if sender is None:\n                        results.append(\"Impossible\")\n                        break\n                    if current_sender is None or current_sender != sender:\n                        known_senders.add(sender)\n                        current_sender = sender\n                        break\n                if \"Impossible\" in results:\n                    break\n                results.append(f\"{sender}:{message.split(':')[1]}\")\n        \n        if \"Impossible\" not in results:\n            for i in range(m):\n                results[i] = f\"{known_senders.pop()}: {messages[i].split(':')[1]}\"\n    \n    return \"\\n\".join(results)\n\nif __name__ == \"__main__\":\n    print(recover_senders(int(input())))",
        "result": "failed: testcase 0"
    },
    "1093": {
        "body": "    max_climb = 0\n    max_descent = 0\n    current_elevation = n\n\n    for col in range(m):\n        min_elevation = n\n        for row in range(n-1, -1, -1):\n            if terrain[row][col] == '*':\n                min_elevation = row\n                break\n        elevation_change = current_elevation - min_elevation\n        if elevation_change > max_climb:\n            max_climb = elevation_change\n        if elevation_change < 0 and abs(elevation_change) > max_descent:\n            max_descent = abs(elevation_change)\n        current_elevation = min_elevation\n\n    print(max_climb, max_descent)\n\n# Read input\nn, m = map(int, input().split())\nterrain = [input().strip() for _ in range(n)]\n\n# Call the function with the input data\nfind_max_elevation_changes(n, m, terrain)",
        "result": "failed: testcase 0"
    },
    "899": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    n = len(graph)\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist[u]:\n            continue\n        \n        for v, weight in graph[u]:\n            distance = current_dist + weight\n            \n            if distance < dist[v]:\n                dist[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    return dist\n\n    graph = defaultdict(list)\n    for a, b, c in edges:\n        graph[a-1].append((b-1, c))\n        graph[b-1].append((a-1, c))\n    \n    total_edges = set()\n    non_shortest_path_edges = 0\n    \n    for i in range(n):\n        dist = dijkstra(graph, i)\n        for j in range(i+1, n):\n            if dist[j] == float('inf'):\n                continue\n            shortest_path = []\n            current = j\n            while current != i:\n                for neighbor, weight in graph[current]:\n                    if dist[neighbor] + weight == dist[current]:\n                        shortest_path.append((current, neighbor))\n                        current = neighbor\n                        break\n            total_edges.update(shortest_path)\n    \n    non_shortest_path_edges = len(edges) - len(total_edges)\n    \n    return non_shortest_path_edges\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    edges = []\n    index = 2\n    for _ in range(m):\n        a = int(data[index])\n        b = int(data[index + 1])\n        c = int(data[index + 2])\n        edges.append((a, b, c))\n        index += 3\n    \n    result = count_non_shortest_path_edges(n, edges)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "551": {
        "body": "    if n % 2 != 0:\n        return \"No\"\n    y.sort()\n    for i in range(1, n//2 + 1):\n        if y[i] - y[0] != y[n-i] - y[n-1]:\n            return \"No\"\n    return \"Yes\"\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\ny = list(map(int, data[1:]))\n\nprint(can_draw_lines(n, y))",
        "result": "failed: testcase 0"
    },
    "1772": {
        "body": "    odd_count = sum(1 for f in flowers if f % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, (even_count + 1) // 2)\n\n# Read input\nn = int(input())\nflowers = list(map(int, input().split()))\n\n# Print result\nprint(max_large_bouquets(n, flowers))",
        "result": "failed: testcase 0"
    },
    "1339": {
        "body": "    left = float('inf')\n    right = -float('inf')\n    for i in range(n):\n        l, r = segments[i]\n        if l < left:\n            left = l\n            index = i + 1\n        elif l == left and r > right:\n            right = r\n            index = i + 1\n    return index\n\nif __name__ == \"__main__\":\n    n = int(input())\n    segments = [tuple(map(int, input().split())) for _ in range(n)]\n    result = find_covering_segment(n, segments)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "440": {
        "body": "    vowels = \"aeiouy\"\n    stack = []\n    \n    for char in s:\n        if char not in vowels:\n            stack.append(char)\n        else:\n            if stack and stack[-1] in vowels and len(stack) > 1:\n                stack.pop()\n            stack.append(char)\n    \n    return ''.join(stack)\n\n# Read input\nn = int(input())\ns = input()\n\n# Get corrected word\ncorrected_word = correct_word(s)\n\n# Print result\nprint(corrected_word)",
        "result": "failed: testcase 0"
    },
    "2801": {
        "body": "import sys\nfrom collections import deque\n\n    graph = [[] for _ in range(n)]\n    for s, t in connections:\n        graph[s].append(t)\n    \n        if node in visited:\n            return 0\n        visited.add(node)\n        satisfaction = c[node] * (1 - eaten_fraction) / 2 ** len(visited)\n        max_satisfaction = satisfaction\n        for neighbor in graph[node]:\n            max_satisfaction = max(max_satisfaction, dfs(neighbor, visited, eaten_fraction + 1/len(graph)))\n        visited.remove(node)\n        return max_satisfaction\n    \n    visited = set()\n    return dfs(0, visited, 0)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    c = list(map(int, data[2:2+n]))\n    connections = []\n    for i in range(m):\n        s = int(data[2+n+i*2]) - 1\n        t = int(data[3+n+i*2]) - 1\n        connections.append((s, t))\n    \n    result = max_satisfaction(n, m, c, connections)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2749": {
        "body": "import sys\n\n    grid = [[0] * W for _ in range(H)]\n    colors = list(range(1, N + 1))\n    \n        return 0 <= x < H and 0 <= y < W\n    \n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            if grid[cx][cy] != 0 or not is_valid(cx, cy):\n                continue\n            grid[cx][cy] = color\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and grid[nx][ny] == 0:\n                    stack.append((nx, ny))\n    \n    color_index = 0\n    for i in range(N):\n        count = a[i]\n        while count > 0:\n            found = False\n            for x in range(H):\n                for y in range(W):\n                    if grid[x][y] == 0:\n                        dfs(x, y, colors[color_index])\n                        found = True\n                        break\n                if found:\n                    break\n            color_index += 1\n            count -= 1\n    \n    for row in grid:\n        print(' '.join(map(str, row)))\n\n# Read input from stdin\nH, W = map(int, input().split())\nN = int(input())\na = list(map(int, input().split()))\n\npaint_grid(H, W, N, a)",
        "result": "failed: testcase 0"
    },
    "2319": {
        "body": "    n = len(s)\n    if s == t:\n        return 0\n    for i in range(n):\n        rotated_s = s[i:] + s[:i]\n        if rotated_s == t:\n            return 1\n    return -1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        s = data[index]\n        index += 1\n        t_str = data[index]\n        index += 1\n        \n        result = min_operations(s, t_str)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2121": {
        "body": "        if len(path) > k:\n            return float('inf')\n        if node in visited:\n            return min(path)\n        visited.add(node)\n        path.append(times[node-1])\n        result = float('inf')\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                result = min(result, dfs(neighbor, visited, path))\n        path.pop()\n        visited.remove(node)\n        return result\n\n    graph = [[] for _ in range(n+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    max_grade = 0\n    for i in range(1, n+1):\n        max_grade = max(max_grade, dfs(i, set(), []))\n    \n    return max_grade\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nk = int(data[1])\n\ntimes = list(map(int, data[2:2+n]))\nedges = []\n\nindex = 2 + n\nfor _ in range(n-1):\n    u = int(data[index]) - 1\n    v = int(data[index+1]) - 1\n    edges.append((u, v))\n    index += 2\n\nprint(max_grade(n, k, times, edges))",
        "result": "failed: testcase 0"
    },
    "2617": {
        "body": "    if n == 1:\n        return 0, []\n    \n    days = 0\n    target = n\n    \n    while True:\n        splits = []\n        current_mass = 1\n        \n        for _ in range(days + 1):\n            split_count = 0\n            for m in splits:\n                split_count += m // 2\n                current_mass += m\n            \n            if current_mass >= target:\n                break\n            \n            splits.append(current_mass)\n        \n        if current_mass == target:\n            return days, splits\n        \n        days += 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\n\nindex = 1\nfor _ in range(t):\n    n = int(data[index])\n    index += 1\n    \n    result = min_nights_to_target_mass(n)\n    if result[0] == -1:\n        results.append(-1)\n    else:\n        results.extend(result)\n\nprint('\\n'.join(map(str, results)))",
        "result": "failed: testcase 0"
    },
    "175": {
        "body": "    while a != 0 and b != 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    print(a, b)\n\n# Read input\na, b = map(int, input().split())\n\n# Call the function with the input values\nprocess(a, b)",
        "result": "failed: testcase 0"
    },
    "995": {
        "body": "from collections import Counter\nimport math\n\n    n = len(a)\n    result = [0] * (n + 1)\n    \n    for k in range(1, n + 1):\n        count = Counter()\n        groups = 0\n        current_product = 1\n        \n        for i in range(n):\n            current_product *= a[i]\n            while current_product % k != 0:\n                factor = abs(math.gcd(current_product, k))\n                if factor == 1:\n                    break\n                current_product //= factor\n                groups += count[factor]\n                count[factor] -= 1\n            \n            count[current_product] += 1\n            result[k] += 1\n    \n    return result[1:]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(*min_groups(a))",
        "result": "failed: testcase 0"
    },
    "582": {
        "body": "    from collections import Counter\n    \n    current_counts = Counter(a)\n    target_counts = sorted(current_counts.values())\n    \n    additional_time = 0\n    \n    for i in range(1, n):\n        if target_counts[i] <= target_counts[i-1]:\n            diff = target_counts[i-1] - target_counts[i]\n            additional_time += diff * t[i]\n            target_counts[i] += diff\n    \n    return additional_time\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nt = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_time_to_add_publications(n, a, t))",
        "result": "failed: testcase 0"
    },
    "1402": {
        "body": "    MOD = 10**9 + 7\n    \n        dp = [0] * (n + 1)\n        dp[0] = 1\n        \n        for i in range(1, n + 1):\n            new_dp = [0] * (n + 1)\n            for j in range(n):\n                if template[j] == '?':\n                    new_dp[j] += dp[j-1]\n                    if j > 0:\n                        new_dp[j] += dp[j-2]\n                elif int(template[j]) <= i:\n                    new_dp[j] += dp[j-1]\n            dp = [x % MOD for x in new_dp]\n        \n        return dp[n - 1]\n    \n    count_s = count_valid_numbers(s)\n    count_w = count_valid_numbers(w)\n    \n    result = (count_s * count_w) % MOD\n    return result\n\n# Read input from stdin\nn = int(input())\ns = input().strip()\nw = input().strip()\n\nprint(count_incomparable_ways(n, s, w))",
        "result": "failed: testcase 0"
    },
    "1141": {
        "body": "    for l, r, c1, c2 in operations:\n        s = s[:l-1] + s[l-1:r].replace(c1, c2) + s[r:]\n    return s\n\n# Read input\nn, m = map(int, input().split())\ns = input()\noperations = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(transform_string(n, m, s, operations))",
        "result": "failed: testcase 0"
    },
    "2836": {
        "body": "    max_distance = -1\n    best_name = -1\n    \n    for X in range(A, B + 1):\n        if X % 2 == 1:  # Check if the number is odd\n            min_distance = float('inf')\n            for P in boys:\n                distance = abs(X - P)\n                if distance < min_distance:\n                    min_distance = distance\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_name = X\n    \n    return best_name\n\n# Read input\nN = int(input())\nboys = list(map(int, input().split()))\nA, B = map(int, input().split())\n\n# Output the result\nprint(find_little_girl_name(N, boys, A, B))",
        "result": "failed: testcase 0"
    },
    "1109": {
        "body": "    period = a[:k]\n    target = [period[i % k] for i in range(n)]\n    changes = sum(a[i] != target[i] for i in range(n))\n    return changes\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(min_changes_to_k_periodic(n, k, a))",
        "result": "failed: testcase 0"
    },
    "2125": {
        "body": "    count = 0\n    for i in range(n - 2):\n        for j in range(m):\n            if grid[i][j] != grid[i + 1][j] == grid[i + 2][j]:\n                count += 1\n            for k in range(j + 1, m):\n                if grid[i][k] != grid[i + 1][k] == grid[i + 2][k]:\n                    count += 1\n    return count\n\n# Read input from stdin\nn, m = map(int, input().split())\ngrid = [input().strip() for _ in range(n)]\n\n# Print the result\nprint(count_flags(n, m, grid))",
        "result": "failed: testcase 0"
    },
    "1746": {
        "body": "    # Create a list to store the number of leaf children for each vertex\n    leaf_children = [0] * (n + 1)\n    \n    # Iterate through each edge to count leaf children\n    for i in range(1, n):\n        u = parent[i]\n        if leaf_children[u] == 2:\n            return \"No\"\n        leaf_children[u] += 1\n    \n    # Check if all non-leaf vertices have at least 3 leaf children\n    for i in range(1, n + 1):\n        if parent[i - 1] != 0 and leaf_children[i] < 3:\n            return \"No\"\n    \n    return \"Yes\"\n\n# Read input\nn = int(input())\nparent = [int(input()) for _ in range(n - 1)]\n\n# Output the result\nprint(is_spruce(n, parent))",
        "result": "failed: testcase 0"
    },
    "1294": {
        "body": "    n = len(s)\n    working_buttons = set()\n    \n    for i in range(n):\n        if i % 2 == 0:\n            working_buttons.add(s[i])\n        else:\n            if s[i] != s[i-1]:\n                return \"\"\n    \n    return ''.join(sorted(working_buttons))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    \n    index = 1\n    for _ in range(t):\n        s = data[index]\n        index += 1\n        result = find_working_buttons(s)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "1159": {
        "body": "import sys\nfrom math import sqrt\n\n    if num <= 1:\n        return False\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n    if n < 3:\n        return -1\n    \n    degrees = [is_prime(i) for i in range(n)]\n    total_edges = sum(degrees)\n    \n    if not is_prime(total_edges):\n        return -1\n    \n    edges = []\n    used = [False] * n\n    for i in range(n):\n        if not used[i]:\n            j = i + 1\n            while j < n and (degrees[j] or used[j]):\n                j += 1\n            if j == n:\n                return -1\n            edges.append((i + 1, j + 1))\n            degrees[i] = False\n            degrees[j] = False\n            used[i] = True\n            used[j] = True\n    \n    return total_edges, edges\n\n    n = int(input().strip())\n    result = generate_graph(n)\n    if result == -1:\n        print(-1)\n    else:\n        m, edges = result\n        print(m)\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2025": {
        "body": "    if n < 4:\n        return -1\n    count = 0\n    while n >= 6:\n        n -= 6\n        count += 1\n    if n == 4 or n == 8:\n        count += 1\n    elif n != 0:\n        return -1\n    return count\n\nq = int(input())\nresults = [max_composite_summands(int(input())) for _ in range(q)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "1429": {
        "body": "from collections import Counter\n\n        return Counter(s1) == Counter(s2)\n\n        complements = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return all(complements[s1[i]] == s2[i] for i in range(len(s1)))\n\n    count = 0\n    for start in range(N):\n        for end in range(start, N):\n            T = S[start:end+1]\n            for perm in set(permutations(T)):\n                if is_complementary(T, ''.join(perm)):\n                    count += 1\n    return count\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    print(count_complementary_substrings(N, S))",
        "result": "failed: testcase 0"
    },
    "1950": {
        "body": "    return sum(a)\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\na = list(map(int, data[1:]))\n\nprint(min_penalty(n, a))",
        "result": "failed: testcase 0"
    },
    "631": {
        "body": "    n = len(a)\n    for _ in range(100):  # Attempt to reorder up to 100 times\n        total = 0\n        for i in range(n):\n            current_sum = sum(a[j] / (j + 1) for j in range(i, n))\n            if current_sum > m:\n                break\n            total += current_sum\n            if total == m:\n                return True\n    return False\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\nfor _ in range(t):\n    n = int(data[index])\n    m = int(data[index + 1])\n    a = list(map(int, data[index + 2:index + 2 + n]))\n    index += 2 + n\n    if can_reorder_to_sum(m, a):\n        results.append(\"YES\")\n    else:\n        results.append(\"NO\")\n\nprint('\\n'.join(results))",
        "result": "failed: testcase 0"
    },
    "2480": {
        "body": "from collections import defaultdict\n\n    remainder_count = defaultdict(int)\n    remainder_count[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(N):\n        current_sum += A[i]\n        target_remainder = (current_sum - (i + 1)) % K\n        count += remainder_count[target_remainder]\n        remainder_count[current_sum % K] += 1\n    \n    return count\n\n# Read input from stdin\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_subsequences(N, K, A))",
        "result": "failed: testcase 0"
    },
    "2363": {
        "body": "    results = []\n    for a, b in pairs:\n        count = 0\n        while a > 0 and b > 0:\n            if a < b:\n                b -= a\n            else:\n                a -= b\n            count += 1\n        results.append(count)\n    return results\n\n# Read input\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print results\nresults = count_operations(n, pairs)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "909": {
        "body": "a = int(input())\nb = int(input())\nc = int(input())\n\nprint(max(a + b * c, a * (b + c), a * b * c))",
        "result": "failed: testcase 0"
    },
    "154": {
        "body": "MOD = 998244353\n\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = dp[1] = 1\n    \n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * (3 * i - 4)) % MOD\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    result = count_balanced_striped_trees(n)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "39": {
        "body": "    n = len(s)\n    max_len = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring != substring[::-1] and len(substring) > max_len:\n                max_len = len(substring)\n    \n    return max_len\n\n# Read input from stdin\ns = input().strip()\n\n# Print the result\nprint(longest_non_palindrome_substring(s))",
        "result": "failed: testcase 0"
    },
    "1885": {
        "body": "from math import comb\n\nn = int(input())\nresult = sum(comb(n, i) for i in range(5, 8))\nprint(result)",
        "result": "passed"
    },
    "1180": {
        "body": "    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n        for j in range(k + 1):\n            if s[i - 1] == '0':\n                continue\n            dp[i][j] += dp[i - 1][j]\n            if j > 0:\n                dp[i][j] += dp[i - 2][j - 1] * int(s[i - 2:i])\n                dp[i][j] %= MOD\n\n    total_sum = sum(dp[n]) % MOD\n    return total_sum\n\n# Read input from stdin\nn, k = map(int, input().split())\ns = input().strip()\n\n# Print the result\nprint(sum_of_expressions(n, k, s))",
        "result": "failed: testcase 0"
    },
    "1856": {
        "body": "from collections import defaultdict\n\n    graph = defaultdict(set)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if any(c in passwords[i] for c in passwords[j]):\n                graph[i].add(j)\n                graph[j].add(i)\n    \n    visited = [False] * n\n    components = 0\n    \n        stack = [node]\n        while stack:\n            node = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                for neighbor in graph[node]:\n                    stack.append(neighbor)\n    \n    for i in range(n):\n        if not visited[i]:\n            components += 1\n            dfs(i)\n    \n    return components\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\npasswords = data[1:]\nprint(min_passwords(n, passwords))",
        "result": "failed: testcase 0"
    },
    "522": {
        "body": "    result = 1\n    base = base % mod\n    while exp > 0:\n        if exp % 2 == 1:\n            result = (result * base) % mod\n        exp = exp >> 1\n        base = (base * base) % mod\n    return result\n\n    MOD = 10**9 + 7\n    if n == 4:\n        return ((c**2 * f1 * f2 * f3) % MOD)\n    elif n == 5:\n        return ((c**2 * f1 * f2 * f3 * f4) % MOD)\n    \n    f = [0] * (n + 1)\n    f[1], f[2], f[3] = f1, f2, f3\n    for i in range(4, n + 1):\n        f[i] = ((c**2 * f[i-1] * f[i-2] * f[i-3]) % MOD)\n    \n    return f[n]\n\nn, f1, f2, f3, c = map(int, input().split())\nresult = compute_f(n, f1, f2, f3, c)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1719": {
        "body": "    MOD = 10**9 + 7\n    \n    if N == 3:\n        return 61\n    \n    # Initialize DP arrays\n    dp = [[[[0] * 4 for _ in range(4)] for _ in range(2)] for _ in range(2)]\n    dp[0][0][0][0] = 1\n    \n    for length in range(3, N + 1):\n        new_dp = [[[[0] * 4 for _ in range(4)] for _ in range(2)] for _ in range(2)]\n        \n        for i in range(4):\n            for j in range(4):\n                for k in range(2):\n                    for l in range(2):\n                        if (i, j, k) == (1, 0, 2):  # AGC is not allowed\n                            continue\n                        \n                        if k == 0:\n                            new_dp[0][j][k][l] = (new_dp[0][j][k][l] + dp[i][j][k][l]) % MOD\n                        else:\n                            new_dp[k][i][1][l] = (new_dp[k][i][1][l] + dp[i][j][k][l]) % MOD\n                        \n                        if l == 0:\n                            new_dp[0][i][k][l] = (new_dp[0][i][k][l] + dp[i][j][k][l]) % MOD\n                        else:\n                            new_dp[k][j][1][l] = (new_dp[k][j][1][l] + dp[i][j][k][l]) % MOD\n        \n        dp = new_dp\n    \n    total_count = sum(dp[i][j][0][0] for i in range(4) for j in range(4)) % MOD\n    total_count = (total_count * 2) % MOD\n    \n    return total_count\n\nN = int(input())\nprint(count_valid_strings(N))",
        "result": "failed: testcase 0"
    },
    "1842": {
        "body": "import math\n\na, b, c = map(int, input().split())\ndiscriminant = b**2 - 4*a*c\nroot1 = (-b + math.sqrt(discriminant)) / (2*a)\nroot2 = (-b - math.sqrt(discriminant)) / (2*a)\n\nprint(root1)\nprint(root2)",
        "result": "passed"
    },
    "806": {
        "body": "    MOD = 10**9 + 7\n    total_sum_range = (r - l + 1) * n\n    if total_sum_range % 3 != 0:\n        return 0\n    \n    possible_sums = [i for i in range(l * n, r * n + 1, 3)]\n    count = 0\n    \n    for s in possible_sums:\n        if (s - l * n) % (r - l + 1) == 0:\n            count += 1\n            count %= MOD\n    \n    return count\n\n# Read input from stdin\nn, l, r = map(int, input().split())\nprint(count_ways(n, l, r))",
        "result": "failed: testcase 0"
    },
    "365": {
        "body": "    total_length = sum(a)\n    if total_length != x or len(a) > n:\n        return \"NO\"\n    \n    remaining_length = x - total_length\n    for i in range(1, n):\n        if a[i-1] >= a[i]:\n            return \"NO\"\n    \n    return \"YES\" if remaining_length == 0 else \"NO\"\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(check_crossword(n, x, a))",
        "result": "failed: testcase 0"
    },
    "1158": {
        "body": "from collections import Counter\n\n    counter = Counter(utensils)\n    max_common_type = max(counter.values())\n    return n - max_common_type * k\n\n# Read input from stdin\nn, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\n# Print the result\nprint(min_stolen_utensils(n, k, utensils))",
        "result": "failed: testcase 0"
    },
    "33": {
        "body": "    if a1 == a2:\n        if b1 != b2:\n            return 0\n        start = max(L, (L - b1) // a1)\n        end = min(R, (R - b1) // a1)\n        return max(0, end - start + 1)\n    else:\n        g = abs(a1 * a2 - a2 * a1)\n        if (b1 - b2) % g != 0:\n            return 0\n        k_diff = (b2 - b1) // g\n        lcm = abs(a1 * a2) // g\n        start = max(L, ((L - b1 + k_diff) // lcm) * lcm)\n        end = min(R, ((R - b1 - k_diff) // lcm) * lcm)\n        return max(0, (end - start) // lcm + 1)\n\n# Read input from stdin\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))",
        "result": "failed: testcase 0"
    },
    "2498": {
        "body": "import sys\n\n    semi_common_multiples = set()\n    \n    for a in A:\n        p = 1 / a\n        while True:\n            X = a * (p + 0.5)\n            if X > M:\n                break\n            semi_common_multiples.add(int(X))\n            p += 2\n    \n    return len(semi_common_multiples)\n\n# Read input from stdin\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = count_semi_common_multiples(N, M, A)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "2309": {
        "body": "from collections import defaultdict\n\n    vowels = 'aeiou'\n    return sum(1 for char in word if char in vowels)\n\n    consonants = 'bcdfghjklmnpqrstvwxyz'\n    return sum(1 for char in word if char in consonants)\n\n    vowels = 'aeiou'\n    for char in reversed(word):\n        if char in vowels:\n            return char\n    return None\n\n    n = len(words)\n    beautiful_lyrics = []\n\n    # Create a dictionary to count words by their vowel and consonant properties\n    word_count = defaultdict(lambda: [0, 0, 0])\n    for word in words:\n        vowel_count = count_vowels(word)\n        consonant_count = count_consonants(word)\n        last_vowel_char = last_vowel(word)\n        word_count[(vowel_count, consonant_count, last_vowel_char)][1] += 1\n\n    # Try to form beautiful lyrics\n    for (v1_c1_l1, v2_c2_l2), count in word_count.items():\n        if count < 2:\n            continue\n        for _ in range(count // 2):\n            beautiful_lyrics.append((v1_c1_l1[0], v1_c1_l1[1], v2_c2_l2[0], v2_c2_l2[1]))\n    \n    # Print the number of beautiful lyrics\n    m = len(beautiful_lyrics)\n    print(m)\n\n    # Print the beautiful lyrics\n    for (v1_c1_l1, c1), (v2_c2_l2, c2) in beautiful_lyrics:\n        for word in words:\n            if count_vowels(word) == v1_c1_l1[0] and count_consonants(word) == v1_c1_l1[1] and last_vowel(word) == v1_c1_l1[2]:\n                print(f\"{word} \", end=\"\")\n                c1 -= 1\n                if c1 == 0:\n                    break\n        for word in words:\n            if count_vowels(word) == v2_c2_l2[0] and count_consonants(word) == v2_c2_l2[1] and last_vowel(word) == v2_c2_l2[2]:\n                print(f\"{word}\")\n                c2 -= 1\n                break\n\n# Read input from stdin\nn = int(input())\nwords = [input().strip() for _ in range(n)]\n\n# Find and print the beautiful lyrics\nfind_beautiful_lyrics(words)",
        "result": "failed: testcase 0"
    },
    "1326": {
        "body": "import sys\n\n        divisors_count = 0\n        for i in range(1, int(x**0.5) + 1):\n            if x % i == 0:\n                if i * i == x:\n                    divisors_count += 1\n                else:\n                    divisors_count += 2\n        return divisors_count\n\n    total_sum = 0\n    for k in range(1, n + 1):\n        total_sum += k * count_divisors(k)\n    return total_sum\n\n# Read input from stdin\nN = int(input().strip())\n\n# Output the result\nprint(sum_of_k_times_f(N))",
        "result": "failed: testcase 0"
    },
    "2950": {
        "body": "    max_height = max(heights)\n    charges = 0\n    for i in range(max_height, 0, -1):\n        if any(h > i for h in heights):\n            charges += 1\n            for j in range(n):\n                if heights[j] > i:\n                    heights[j] -= 1\n    return charges\n\n# Read input from stdin\nn = int(input())\nheights = list(map(int, input().split()))\n\n# Print the result\nprint(min_charges_to_tear_down_blocks(n, heights))",
        "result": "failed: testcase 0"
    },
    "1983": {
        "body": "import sys\n\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return dp[-1]\n\n    t = int(input().strip())\n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().strip().split()))\n        result = longest_increasing_subsequence(n, a)\n        results.append(result * 2)\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0"
    },
    "1767": {
        "body": "    max_sum = 0\n    for l in range(n):\n        current_a_or = 0\n        current_b_or = 0\n        for r in range(l, n):\n            current_a_or |= a[r]\n            current_b_or |= b[r]\n            max_sum = max(max_sum, current_a_or + current_b_or)\n    return max_sum\n\n# Read input from stdin\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Print the result\nprint(max_bitwise_or_sum(n, a, b))",
        "result": "failed: testcase 0"
    },
    "2382": {
        "body": "from collections import Counter\nimport sys\n\n    target = Counter(S)\n    queue = [(1, 0)]\n    \n    while queue:\n        current_time, health = queue.pop(0)\n        if current_time == N:\n            return True\n        \n        for new_health in range(health - 1, 0, -1):\n            if new_health not in target or target[new_health] <= 0:\n                continue\n            target[new_health] -= 1\n            queue.append((current_time + 1, new_health))\n            target[health] += 1\n    \n    return False\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = list(map(int, input().split()))\n    if can_reproduce(N, S):\n        print(\"Yes\")\n    else:\n        print(\"No\")",
        "result": "failed: testcase 0"
    },
    "3907": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    coupons = []\n    for i in range(m):\n        q_i = int(data[2 + 2 * i])\n        w_i = int(data[3 + 2 * i])\n        coupons.append((q_i, w_i))\n    \n    coupons.sort(key=lambda x: x[1], reverse=True)\n    \n    beautiful_array = [coupons[0][0]] * n\n    total_cost = 0\n    \n    for i in range(1, m):\n        q_i, w_i = coupons[i]\n        if len(set(beautiful_array)) == 1:\n            beautiful_array.append(q_i)\n        else:\n            beautiful_array = [q_i] * n\n        total_cost += w_i\n    \n    print(total_cost)\n\nmax_money_to_dima()",
        "result": "failed: testcase 0"
    },
    "3676": {
        "body": "    if R == 1 and C == 1:\n        return 1\n    if R == 1 or C == 1:\n        return 2 * min(R, C)\n    return (R + C) * (R + C - 1) // 2\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nR = int(data[0])\nC = int(data[1])\n\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0"
    },
    "3293": {
        "body": "    n = int(input())\n    snacks = []\n    \n    for _ in range(n):\n        f, p, m, s = map(int, input().split())\n        snacks.append((f-1, p, m, s))\n    \n    snacks.sort(key=lambda x: x[2], reverse=True)\n    \n    profit = 0\n    max_price = 0\n    \n    for i in range(n):\n        if snacks[i][3] > 0:\n            if snacks[i][1] < max_price:\n                profit += max_price - snacks[i][1]\n            max_price = snacks[i][2]\n            snacks[snacks[i][0]][3] -= 1\n    \n    print(profit)\n\nmax_profit()",
        "result": "failed: testcase 0"
    },
    "3587": {
        "body": "    N = len(taboo_strings)\n    if N == 0:\n        return -1\n    \n    # Initialize a trie to store all taboo strings\n    from collections import defaultdict\n    trie = defaultdict(dict)\n    \n    for taboo in taboo_strings:\n        node = trie\n        for char in taboo:\n            node = node[char]\n        node['#'] = True\n    \n    # Function to check if a suffix of a string is in the trie\n        node = trie\n        for char in suffix:\n            if char not in node:\n                return False\n            node = node[char]\n            if '#' in node:\n                return True\n        return '#' in node\n    \n    # Function to generate the longest non-taboo string\n        for i in range(2**n, 0, -1):\n            binary_string = format(i, '0{}b'.format(n))\n            if not any(is_suffix_in_trie(binary_string[j:]) for j in range(len(binary_string))):\n                return binary_string\n    \n    # Try to generate the longest non-taboo string for each possible length\n    for n in range(1, 25):  # Upper limit based on constraints\n        result = generate_longest_non_taboo(n)\n        if result:\n            return result\n    \n    return None\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nN = int(data[0])\ntaboo_strings = data[1:]\n\n# Output the result\nprint(longest_non_taboo_string(taboo_strings))",
        "result": "failed: testcase 0"
    },
    "3530": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    coasters = []\n    for _ in range(N):\n        a_i = int(data[index])\n        b_i = int(data[index + 1])\n        t_i = int(data[index + 2])\n        index += 3\n        coasters.append((a_i, b_i, t_i))\n    \n    Q = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(Q):\n        T_i = int(data[index])\n        index += 1\n        \n        total_fun = 0\n        times_ridden = [0] * N\n        \n        while sum(times_ridden) < T_i:\n            for i, (a_i, b_i, t_i) in enumerate(coasters):\n                fun = a_i - (times_ridden[i]) ** 2 * b_i\n                if fun > 0:\n                    times_ridden[i] += 1\n                    total_fun += fun\n                    break\n        \n        results.append(total_fun)\n    \n    for result in results:\n        print(result)\n\nmax_fun()",
        "result": "failed: testcase 0"
    },
    "3900": {
        "body": "import sys\nfrom collections import defaultdict\n\n    graph = defaultdict(list)\n    for i in range(n):\n        x, y = statements[i]\n        graph[x-1].append(i)\n        graph[y-1].append(i)\n\n        visited[node] = True\n        path.append(node)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path)\n        return path\n\n    components = []\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            component = dfs(i, visited, [])\n            components.append(component)\n\n    count = 0\n    m = len(components)\n    for i in range(m):\n        for j in range(i+1, m):\n            if any(x in components[j] for x in components[i]):\n                count += 1\n\n    return count\n\n# Read input\nn, p = map(int, input().split())\nstatements = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(count_suspect_pairs(n, p, statements))",
        "result": "failed: testcase 0"
    },
    "3996": {
        "body": "from fractions import Fraction\nimport sys\n\n# Read input\nk = int(input())\na = list(map(int, input().split()))\n\n# Calculate n as the product of all elements in the array\nn = 1\nfor ai in a:\n    n *= ai\n\n# The probability that the girl guessed right is 1/n\nprobability = Fraction(1, n)\n\n# Output the result as x/y where x and y are remainders when divided by 10^9 + 7\nmodulus = 10**9 + 7\nx = probability.numerator % modulus\ny = probability.denominator % modulus\n\nprint(f\"{x}/{y}\")",
        "result": "failed: testcase 1"
    },
    "3276": {
        "body": "    for i in range(N - 2):\n        for j in range(M - 2):\n            target = [list(art[x][j:j+3]) for x in range(i, i+3)]\n            found = False\n            for color in 'RGB':\n                if all(target[r][c] == color or target[r][c] == 'W' for r in range(3) for c in range(3)):\n                    found = True\n                    break\n            if not found:\n                return \"NO\"\n    return \"YES\"\n\n# Read input from stdin\nN, M = map(int, input().split())\nart = [input() for _ in range(N)]\n\n# Print the result\nprint(can_reproduce_art(N, M, art))",
        "result": "failed: testcase 0"
    },
    "3834": {
        "body": "        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if table[i][j] != table[x1][y1]:\n                    return False\n        return True\n\n        stack = [(x, y)]\n        while stack:\n            cx, cy = stack.pop()\n            if (cx, cy) in visited:\n                continue\n            visited.add((cx, cy))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == value:\n                    stack.append((nx, ny))\n\n        visited = set()\n        components = 0\n        for i in range(n):\n            for j in range(m):\n                if (i, j) not in visited and table[i][j] != 0:\n                    dfs(i, j, visited, table[i][j])\n                    components += 1\n        return components\n\n    components = count_components()\n    if components == 1:\n        return 0\n\n    changes_needed = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] != 0 and not is_valid_rect(0, 0, i, j):\n                changes_needed += 1\n                if changes_needed > k:\n                    return -1\n\n    return changes_needed\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    table = [list(map(int, input().split())) for _ in range(n)]\n    print(min_changes_to_meet_requirement(n, m, k, table))",
        "result": "failed: testcase 0"
    },
    "3012": {
        "body": "MOD = 10**9 + 7\n\n    total = a11 + a12 + a21 + a22\n    if N == 0:\n        return 1\n    if N < 3 or total < 2:\n        return 0\n    \n    dp = [[[[0] * (total + 1) for _ in range(total + 1)] for _ in range(3)] for _ in range(2)]\n    \n        dp[a][b][c][d] += 1\n        dp[a][b][c][d] %= MOD\n    \n    update_dp(0, 0, a11, a12)\n    update_dp(1, 0, a21, a22)\n    \n    for _ in range(N - 1):\n        new_dp = [[[[0] * (total + 1) for _ in range(total + 1)] for _ in range(3)] for _ in range(2)]\n        for a in range(2):\n            for b in range(2):\n                for c in range(total + 1):\n                    for d in range(total + 1):\n                        if dp[a][b][c][d] == 0:\n                            continue\n                        if b == 0 and a == 0:\n                            for e in range(a11):\n                                update_dp(0, 1, c - 1, e)\n                            for e in range(a21):\n                                update_dp(1, 1, c - 1, e)\n                        elif b == 0 and a == 1:\n                            for e in range(a22):\n                                update_dp(1, 1, c - 1, e)\n                        else:\n                            if d > 0:\n                                update_dp(b, a, c + 1, d - 1)\n                            if d == 0:\n                                for e in range(total - c):\n                                    update_dp(b, a, c + 1, e)\n        dp = new_dp\n    \n    result = (dp[0][1][total][0] + dp[1][1][total][0]) % MOD\n    return result\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\na11 = int(data[0])\na12 = int(data[1])\na21 = int(data[2])\na22 = int(data[3])\nN = int(data[4])\n\nprint(count_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0"
    },
    "3745": {
        "body": "    from collections import defaultdict, deque\n    \n    # Build adjacency list\n    adj = defaultdict(list)\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Check if a valid string exists\n        visited[node] = True\n        colors[node] = color\n        for neighbor in adj[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited and colors[neighbor] == colors[node]:\n                return False\n            if neighbor not in visited and not dfs(neighbor, node, 3 - color):\n                return False\n        return True\n    \n    visited = [False] * (n + 1)\n    colors = [-1] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            if not dfs(i, -1, 1):\n                return \"No\"\n    \n    # Find a valid string\n        if node == 1:\n            return \"abc\"[colors[node]]\n        for neighbor in adj[node]:\n            if neighbor != parent and colors[neighbor] == colors[node]:\n                return find_string(neighbor, node)\n        return \"\"\n    \n    result = find_string(1, -1)\n    if len(result) != n:\n        return \"No\"\n    \n    return \"Yes\\n\" + result\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(can_form_string(n, m, edges))",
        "result": "failed: testcase 0"
    },
    "3028": {
        "body": "import sys\n\n    n, m, p = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(n)]\n    \n    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                moves.append((i + 1) * m + j + 1)\n                for x in range(n):\n                    board[x][j] = (board[x][j] % p + 1) % p\n                for y in range(m):\n                    board[i][y] = (board[i][y] % p + 1) % p\n    \n    if all(board[i][j] == p for i in range(n) for j in range(m)):\n        print(len(moves))\n        print(' '.join(map(str, moves)))\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve_primonimo()",
        "result": "failed: testcase 0"
    },
    "3196": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for A, B in roads:\n        graph[A].append(B)\n\n    queue = deque([(1, 0)])\n    visited = set()\n    result = 0\n\n    while queue:\n        current, path_length = queue.popleft()\n\n        if current == 2 and path_length > 0:\n            result += 1\n            continue\n\n        for neighbor in graph[current]:\n            new_path_length = path_length + 1\n            if (neighbor, new_path_length) not in visited:\n                visited.add((neighbor, new_path_length))\n                queue.append((neighbor, new_path_length))\n\n    return result % 1000000009 if result != float('inf') else \"inf\"\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n    roads = [(int(data[2 + 2 * i]), int(data[3 + 2 * i])) for i in range(M)]\n    print(count_routes(N, M, roads))",
        "result": "failed: testcase 0"
    },
    "3405": {
        "body": "    X_str = str(X)\n    decimal_places = len(X_str.split('.')[1]) if '.' in X_str else 0\n    multiplier = int('1' + '0' * decimal_places)\n    valid_numbers = []\n    \n    for i in range(1, 10**8):\n        num_str = str(i)\n        new_num = int(num_str[1:] + num_str[0])\n        if new_num == i * X:\n            valid_numbers.append(i)\n    \n    return valid_numbers\n\nif __name__ == \"__main__\":\n    X = float(input())\n    valid_numbers = find_valid_numbers(X)\n    if valid_numbers:\n        for number in valid_numbers:\n            print(number)\n    else:\n        print(\"No solution\")",
        "result": "failed: testcase 0"
    },
    "3126": {
        "body": "    positions.sort()\n    n = len(positions)\n    total_jumps = 0\n\n    for i in range(n):\n        diff = abs(positions[i] - t)\n        if i % 2 == 0:\n            total_jumps += (i + 1) * diff\n        else:\n            total_jumps += (n - i) * diff\n\n    return total_jumps\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nt = int(data[1])\npositions = list(map(int, data[2:2+n]))\nC = int(data[2+n])\n\nresults = []\nfor i in range(2+n+C):\n    if i < 2 + n:\n        continue\n    command = data[2+n+i]\n    if command == 't':\n        t = int(data[3+n+i])\n    elif command.startswith('+'):\n        positions.append(int(command[1:]))\n        positions.sort()\n    elif command.startswith('-'):\n        positions.remove(int(command[1:]))\n\n    results.append(min_jumps(n, t, positions))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3279": {
        "body": "    n = int(input())\n    vertical_spec = list(map(int, input().split()))\n    horizontal_spec = list(map(int, input().split()))\n\n    # Initialize the grid with zeros\n    grid_v = [[0] * (n + 1) for _ in range(n)]\n    grid_h = [[0] * n for _ in range(n + 1)]\n\n        index = 0\n        i = 0\n        while index < len(spec):\n            length = spec[index]\n            if length > 0:\n                if is_vertical:\n                    grid[i][length - 1] = 1\n                else:\n                    grid[length - 1][i] = 1\n                index += 1\n            i += 1\n\n    place_bars(grid_v, vertical_spec, True)\n    place_bars(grid_h, horizontal_spec, False)\n\n    # Output the result\n    for row in grid_v:\n        print(''.join(map(str, row)))\n    for row in grid_h:\n        print(''.join(map(str, row)))\n\nbar_code()",
        "result": "failed: testcase 0"
    },
    "3599": {
        "body": "import sys\nfrom typing import List\n\n    result = []\n    current_time = 0\n    \n    for i in range(N):\n        break_duration = breaks[i]\n        if current_time + break_duration > T:\n            result.append(0)\n        else:\n            result.append(current_time)\n            current_time += break_duration - (current_time % (break_duration // 2))\n    \n    return result\n\n# Read input from stdin\nT, N = map(int, input().split())\nbreaks = list(map(int, input().split()))\n\n# Generate and print the output\noutput = schedule_breaks(T, N, breaks)\nprint(\" \".join(map(str, output)))",
        "result": "failed: testcase 0"
    },
    "3687": {
        "body": "    for _ in range(n):\n        d, *a = map(int, input().split())\n        if sum(a) > d:\n            return \"impossible\"\n        \n        queue_used = [0] * (q + 1)\n        for i in range(s):\n            q_id = queue_sensors[i]\n            if a[i] <= queue_sizes[q_id - 1] - queue_used[q_id]:\n                queue_used[q_id] += a[i]\n            else:\n                return \"impossible\"\n    \n    for used in queue_used[1:]:\n        if used != queue_sizes[queue_sensors.index(used + 1) - 1]:\n            return \"impossible\"\n    \n    return \"possible\"\n\n# Read input\nn, q, s = map(int, input().split())\nqueue_sensors = list(map(int, input().split()))\nqueue_sizes = list(map(int, input().split()))\ndownlink_windows = [list(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(can_transfer_data(n, q, s, queue_sensors, queue_sizes, downlink_windows))",
        "result": "failed: testcase 0"
    },
    "3864": {
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = ((i - 1) * dp[i - 1] + (i - 1)) % MOD\n    \n    total_boards = 2 ** n\n    result = sum(dp[i] * 2 for i in range(n + 1)) // total_boards\n    return result\n\nn = int(input())\nresults = [expected_black_stones(i) for i in range(1, n + 1)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3504": {
        "body": "    results = []\n    \n    for x, y in droplets:\n        disintegrate_y = 0\n        for x1, x2, y_sensor in sensors:\n            if x1 <= x <= x2 and y == y_sensor:\n                disintegrate_y = y_sensor\n                break\n        results.append(disintegrate_y)\n    \n    return results\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nD = int(data[0])\nS = int(data[1])\n\ndroplets = []\nindex = 2\nfor _ in range(D):\n    x = int(data[index])\n    y = int(data[index + 1])\n    droplets.append((x, y))\n    index += 2\n\nsensors = []\nfor _ in range(S):\n    x1 = int(data[index])\n    x2 = int(data[index + 1])\n    y_sensor = int(data[index + 2])\n    sensors.append((x1, x2, y_sensor))\n    index += 3\n\n# Calculate and print results\nresults = antimatter_rain(droplets, sensors)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3451": {
        "body": "    stack = []\n    changes_needed = 0\n    \n    for i in range(n):\n        if seq[i] == '(':\n            stack.append(i)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                changes_needed += costs[i]\n    \n    remaining_changes = k - len(stack)\n    if remaining_changes >= 0:\n        return '?'\n    \n    min_cost = float('inf')\n    for i in range(n):\n        if seq[i] == '(' and stack:\n            cost = abs(costs[i]) + abs(costs[stack.pop()])\n            min_cost = min(min_cost, cost)\n        elif seq[i] == ')' and len(stack) > remaining_changes:\n            cost = abs(costs[i]) + abs(costs[stack[-1]])\n            min_cost = min(min_cost, cost)\n    \n    return min_cost if min_cost != float('inf') else '?'\n\n# Read input\nn, k = map(int, input().split())\nseq = input().strip()\ncosts = [int(input()) for _ in range(n)]\n\n# Calculate and print result\nresult = min_effort_to_impossible(n, k, seq, costs)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3156": {
        "body": "from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    in_degree = [0] * N\n    \n    for i in range(K):\n        store_id, item = inventory[i]\n        graph[store_id].append(item)\n        in_degree[store_id] += 1\n    \n    queue = deque([i for i in range(N) if in_degree[i] == 0])\n    \n    path = []\n    while queue:\n        if len(queue) > 1:\n            return \"ambiguous\"\n        current_store = queue.popleft()\n        path.append(current_store)\n        \n        for item in graph[current_store]:\n            print(item, end=\" \")\n    \n    if len(path) != N:\n        return \"impossible\"\n    \n    return \"unique\"\n\n# Read input\nN = int(input())\nK = int(input())\ninventory = [tuple(map(str, input().split())) for _ in range(K)]\nM = int(input())\nbought_items = [input().strip() for _ in range(M)]\n\n# Output result\nresult = find_path(N, K, inventory, M, bought_items)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3697": {
        "body": "import sys\n\n    votes = [0] * (n + 1)\n    last_vote_time = [-1] * (n + 1)\n    \n    for j in range(1, a + 1):\n        candidate = int(input())\n        votes[candidate] += 1\n        if last_vote_time[candidate] == -1 or j > last_vote_time[candidate]:\n            last_vote_time[candidate] = j\n    \n    top_candidates = sorted(range(1, n + 1), key=lambda x: (-votes[x], -last_vote_time[x]))\n    \n    outcomes = [0] * (n + 1)\n    \n    for i in range(k):\n        outcomes[top_candidates[i]] = 1\n    \n    for candidate in range(1, n + 1):\n        if outcomes[candidate] == 0:\n            possible_votes = k - sum(outcomes)\n            max_needed = votes[top_candidates[k - 1]]\n            min_remaining = votes[candidate]\n            if max_needed > 0 and min_remaining + max_needed <= m - a:\n                outcomes[candidate] = 2\n            else:\n                outcomes[candidate] = 3\n    \n    for i in range(1, n + 1):\n        print(outcomes[i], end=' ')",
        "result": "failed: testcase 0"
    },
    "3647": {
        "body": "from collections import deque\n\n    C, R = len(maze[0]), len(maze)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n        return 0 <= x < R and 0 <= y < C and maze[x][y] != '#'\n    \n        queue = deque()\n        distances = [[-1 for _ in range(C)] for _ in range(R)]\n        goal_found = False\n        \n        for i in range(R):\n            for j in range(C):\n                if maze[i][j] == 'M':\n                    queue.append((i, j))\n                    distances[i][j] = 0\n                    goal_found = True\n        \n        if not goal_found:\n            return distances\n        \n        while queue:\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny):\n                    if maze[nx][ny] == '.' or maze[nx][ny] == 'M':\n                        if distances[nx][ny] == -1:\n                            queue.append((nx, ny))\n                            distances[nx][ny] = distances[x][y] + 1\n                    elif maze[nx][ny] == '_':\n                        if distances[nx][ny] == -1:\n                            queue.append((nx, ny))\n                            distances[nx][ny] = distances[x][y]\n        \n        return distances\n    \n    return bfs()\n\n# Read input\nC, R = map(int, input().split())\nmaze = [input().strip() for _ in range(R)]\n\n# Compute and print the result\nresult = min_moves_to_goal(maze)\nfor row in result:\n    print(' '.join(map(str, row)))",
        "result": "failed: testcase 0"
    },
    "3699": {
        "body": "import sys\nimport math\n\n    return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    n = len(bottles)\n    if n == 0:\n        return 0\n    \n    total_distance = float('inf')\n    \n    for i in range(n):\n        adil_path = distance(a_x, a_y, bottles[i][0], bottles[i][1]) + distance(bottles[i][0], bottles[i][1], t_x, t_y)\n        bera_path = distance(b_x, b_y, bottles[i][0], bottles[i][1]) + distance(bottles[i][0], bottles[i][1], t_x, t_y)\n        \n        remaining_bottles = bottles[:i] + bottles[i+1:]\n        \n        for j in range(len(remaining_bottles)):\n            adil_path += distance(remaining_bottles[j][0], remaining_bottles[j][1], t_x, t_y)\n            bera_path += distance(remaining_bottles[j][0], remaining_bottles[j][1], t_x, t_y)\n        \n        total_distance = min(total_distance, adil_path + bera_path)\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    a_x = int(data[0])\n    a_y = int(data[1])\n    b_x = int(data[2])\n    b_y = int(data[3])\n    t_x = int(data[4])\n    t_y = int(data[5])\n    \n    n = int(data[6])\n    bottles = []\n    for i in range(n):\n        x = int(data[7 + 2 * i])\n        y = int(data[8 + 2 * i])\n        bottles.append((x, y))\n    \n    result = min_distance(a_x, a_y, b_x, b_y, t_x, t_y, bottles)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3145": {
        "body": "    count = 0\n    for num in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(num)) and num % X == 0:\n            count += 1\n    return count\n\n# Read input from stdin\nX, A, B = map(int, input().split())\nallowed_digits = input().strip()\n\n# Print the result\nprint(count_multiples(X, A, B, allowed_digits))",
        "result": "failed: testcase 0"
    },
    "3795": {
        "body": "    # Calculate the number of euros Andrew can buy with his rubles\n    euros = n // e\n    remaining_rubles = n % e\n    \n    # Try to minimize the remaining rubles by buying dollar bills\n    for i in range(0, remaining_rubles + 1, d):\n        if (remaining_rubles - i) % e == 0:\n            dollars = (remaining_rubles - i) // e\n            total_bills = euros + dollars\n            return n - total_bills * min(d, e)\n    \n    # If no combination is found, return the initial amount of rubles\n    return n\n\n# Read input from stdin\nn = int(input())\nd = int(input())\ne = int(input())\n\n# Print the result\nprint(min_rubles(n, d, e))",
        "result": "failed: testcase 0"
    },
    "3353": {
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    left_bank = -2\n    right_bank = -1\n    \n    # Build the graph\n    graph = defaultdict(list)\n    for E1, E2 in logs:\n        graph[E1].append(E2)\n        graph[E2].append(E1)\n    \n        visited = set()\n        queue = deque([(start, 0)])\n        while queue:\n            current, time = queue.popleft()\n            if current == right_bank:\n                return time\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, time + 1))\n        return float('inf')\n    \n    times_to_cross = [bfs(i) for i in range(R)]\n    times_to_cross.sort()\n    \n    total_time = 0\n    people_left = P\n    \n    for _ in range(P):\n        if times_to_cross:\n            min_time = min(times_to_cross)\n            total_time += min_time\n            times_to_cross.remove(min_time)\n        else:\n            break\n    \n    return total_time if len(times_to_cross) == 0 else people_left\n\n# Read input from stdin\nP, R, L = map(int, input().split())\nlogs = [tuple(map(int, input().split())) for _ in range(L)]\n\n# Calculate and print the result\nresult = min_time_to_cross(P, R, L, logs)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3065": {
        "body": "import sys\nfrom fractions import Fraction\n\n    queue = [(start, 0)]\n    visited = set()\n    while queue:\n        node, time = queue.pop(0)\n        if node == target:\n            return time\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, time + 1))\n    return float('inf')\n\n    dp = [[Fraction(0) for _ in range(L)] for _ in range(N)]\n    dp[walk[0]][0] = Fraction(1)\n    \n    for t in range(1, L):\n        new_dp = [[Fraction(0) for _ in range(L)] for _ in range(N)]\n        for u in range(N):\n            if dp[u][t-1]:\n                for v in graph[u]:\n                    new_dp[v][t] += dp[u][t-1] / len(graph[u])\n        dp = new_dp\n    \n    return sum(dp[walk[-1]][L-1])\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    L = int(data[index])\n    index += 1\n    walk = list(map(int, data[index:index+L]))\n    index += L\n    \n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        n = int(data[index])\n        index += 1\n        neighbors = list(map(int, data[index:index+n]))\n        index += n\n        graph[i] = neighbors\n    \n    probability = calculate_probability(N, L, walk, graph)\n    print(probability)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3250": {
        "body": "    for m in range(1, b):\n        if all((pow(d, k) * (-1)**k % m == 0 for k in range(m))):\n            return \"yes\"\n    return \"no\"\n\n# Read input from stdin\nb, d = map(int, input().split())\n\n# Print the result\nprint(is_valid_divisibility_hack(b, d))",
        "result": "failed: testcase 0"
    },
    "3306": {
        "body": "    calls = [0] * (M + 1)\n    for P, C in detectors:\n        calls[P] += C\n        calls[P + 1] -= C\n    total_calls = prev = 0\n    for i in range(1, M + 1):\n        if calls[i] != prev:\n            total_calls += max(calls[i], prev)\n        prev = max(calls[i], prev)\n    return total_calls\n\n# Read input from stdin\nN, M = map(int, input().split())\ndetectors = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Output the result\nprint(min_phone_calls(N, M, detectors))",
        "result": "failed: testcase 0"
    },
    "3970": {
        "body": "    a.sort()\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j] == 0 and a[i] // a[j] == k:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(largest_k_multiple_free_subset(n, k, a))",
        "result": "failed: testcase 0"
    },
    "3655": {
        "body": "import sys\n\n    # Read input\n    robot_w, robot_h = map(int, input().split())\n    robot_image = [list(map(int, input().split())) for _ in range(robot_h)]\n    floor_w, floor_h = map(int, input().split())\n    floor_image = [list(map(int, input().split())) for _ in range(floor_h)]\n\n    # Initialize variables\n    max_matches = 0\n    candidates = []\n\n    # Iterate over all possible positions to overlay the robot image on the floor image\n    for y in range(floor_h - robot_h + 1):\n        for x in range(floor_w - robot_w + 1):\n            matches = 0\n            for i in range(robot_h):\n                for j in range(robot_w):\n                    if robot_image[i][j] == floor_image[y + i][x + j]:\n                        matches += 1\n            if matches > max_matches:\n                max_matches = matches\n                candidates = [(x, y)]\n            elif matches == max_matches:\n                candidates.append((x, y))\n\n    # Sort the candidates by x-coordinate and then by y-coordinate\n    candidates.sort()\n\n    # Print the candidates\n    for candidate in candidates:\n        print(candidate[0], candidate[1])\n\nif __name__ == \"__main__\":\n    find_candidates()",
        "result": "failed: testcase 0"
    },
    "3589": {
        "body": "        product = 1\n        while n > 0:\n            digit = n % 10\n            if digit != 0:\n                product *= digit\n            n //= 10\n        return product\n    \n    count = [0] * 9\n    for x in range(L, R + 1):\n        result = reduce_product(x)\n        if 1 <= result <= 9:\n            count[result - 1] += 1\n    print(' '.join(map(str, count)))\n\n# Read input from stdin\nL, R = map(int, input().split())\ncount_product_digits(L, R)",
        "result": "failed: testcase 0"
    },
    "3257": {
        "body": "import sys\nfrom math import sqrt, acos\n\n    # Check if the given distances can form a triangle using the triangle inequality theorem\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    \n    # Calculate the semi-perimeter of the triangle\n    s = (a + b + c) / 2\n    \n    # Calculate the area using Heron's formula\n    area = sqrt(s * (s - a) * (s - b) * (s - c))\n    return area\n\n# Read input from stdin\nline = input().strip()\na, b, c = map(float, line.split())\n\n# Calculate and print the area or -1 if not valid\nprint(calculate_area(a, b, c))",
        "result": "failed: testcase 0"
    },
    "3927": {
        "body": "from collections import Counter\n\n    # Calculate the frequency of each weight mass\n    freq = Counter(a)\n    \n    # Initialize variables to track the maximum number of weights revealed\n    max_revealed = 0\n    \n    # Iterate through the unique masses and their frequencies\n    for mass, count in freq.items():\n        # For each mass, consider all possible subsets with different numbers of weights\n        for k in range(1, count + 1):\n            if k * mass <= sum(freq.keys()):\n                max_revealed = max(max_revealed, k)\n    \n    return max_revealed\n\n# Read input from stdin\nn = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Print the result\nprint(max_weights_revealed(n, a))",
        "result": "failed: testcase 0"
    },
    "3319": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n = int(data[index])\n    nx, ny, nz = map(int, data[index+1:index+4])\n    index += 4\n    \n    planetoids = []\n    for _ in range(n):\n        m = int(data[index])\n        x, y, z = map(int, data[index+1:index+4])\n        vx, vy, vz = map(int, data[index+4:index+7])\n        index += 7\n        planetoids.append((m, x, y, z, vx, vy, vz))\n    \n        return (x % n + n) % n\n    \n        m, x, y, z, vx, vy, vz = planetoid\n        new_x = wrap(x + vx, nx)\n        new_y = wrap(y + vy, ny)\n        new_z = wrap(z + vz, nz)\n        return (m, new_x, new_y, new_z, vx, vy, vz)\n    \n    while True:\n        moved_planetoids = [move(planetoid) for planetoid in planetoids]\n        collisions = {}\n        for i in range(n):\n            x, y, z = moved_planetoids[i][1:]\n            key = (x, y, z)\n            if key not in collisions:\n                collisions[key] = [i]\n            else:\n                collisions[key].append(i)\n        \n        new_planetoids = []\n        for collision in collisions.values():\n            if len(collision) == 1:\n                new_planetoids.append(moved_planetoids[collision[0]])\n            else:\n                masses = sum(planetoids[i][0] for i in collision)\n                x, y, z = planetoids[collision[0]][1:]\n                vx = round(sum(planetoids[i][4] for i in collision) / len(collision))\n                vy = round(sum(planetoids[i][5] for i in collision) / len(collision))\n                vz = round(sum(planetoids[i][6] for i in collision) / len(collision))\n                new_planetoids.append((masses, x, y, z, vx, vy, vz))\n        \n        if len(new_planetoids) == n:\n            break\n        planetoids = new_planetoids\n    \n    planets = sorted(planetoids, key=lambda p: (-p[0], p[1], p[2], p[3]))\n    \n    print(len(planets))\n    for i, (m, x, y, z, vx, vy, vz) in enumerate(planets):\n        print(f\"P{i}: {m} {x} {y} {z} {vx} {vy} {vz}\")\n\nsimulate_planetoid_collisions()",
        "result": "failed: testcase 0"
    },
    "3009": {
        "body": "import sys\nfrom fractions import Fraction\nfrom collections import deque\n\n    # Convert lamps to a list of tuples for easier manipulation\n    lamps = [(x, y, e) for x, y, e in lamps]\n    \n    # Function to calculate the distance between two points\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n    \n    # Function to calculate the energy balance for a given line segment\n        inside, outside = 0, 0\n        for x in range(1, 100):\n            for y in range(1, 100):\n                if (x - 1) <= lamps[segment[0]][0] <= x and (y - 1) <= lamps[segment[0]][1] <= y:\n                    inside += lamps[segment[0]][2]\n                elif (x - 1) <= lamps[segment[1]][0] <= x and (y - 1) <= lamps[segment[1]][1] <= y:\n                    outside += lamps[segment[1]][2]\n        return Fraction(inside, 1), Fraction(outside, 1)\n    \n    # Function to check if a line segment divides the energy equally\n        inside, outside = energy_balance(segment)\n        return inside == outside\n    \n    # Check all possible line segments\n    min_length = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            if lamps[i][2] * lamps[j][2] < 0:  # Ensure one lamp has positive energy and the other negative\n                length = dist(lamps[i], lamps[j])\n                if is_balanced((i, j)):\n                    min_length = min(min_length, length)\n    \n    return \"IMPOSSIBLE\" if min_length == float('inf') else round(min_length, 10)\n\n# Read input from stdin\nN = int(input())\nlamps = [tuple(map(int, input().split())) for _ in range(N)]\n\n# Output the result\nprint(find_shortest_balancing_line(N, lamps))",
        "result": "failed: testcase 0"
    },
    "3896": {
        "body": "    n = len(x)\n    count_ones = x.count('1')\n    count_zeros = n - count_ones\n    complexity = (count_ones * count_zeros) % 1000000007\n    return complexity\n\n# Read input from stdin\nx = input().strip()\n# Calculate and print the result\nprint(calculate_complexity(x))",
        "result": "failed: testcase 0"
    },
    "3509": {
        "body": "import sys\nimport heapq\n\n    n = len(graph)\n    distances = [float('inf')] * n\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > distances[u]:\n            continue\n        \n        for v, t in graph[u]:\n            distance = current_dist + t\n            if distance < distances[v]:\n                distances[v] = distance\n                heapq.heappush(pq, (distance, v))\n    \n    return distances\n\n    graph = [[] for _ in range(n)]\n    for u, v, t in roads:\n        graph[u-1].append((v-1, t))\n    \n    dist_to_janet = dijkstra(graph, 0)\n    max_wait = 0\n    \n    for time in range(a, b+1):\n        min_time_to_reach = float('inf')\n        for i in range(n):\n            if dist_to_janet[i] <= time:\n                min_time_to_reach = min(min_time_to_reach, time - dist_to_janet[i])\n        max_wait = max(max_wait, min_time_to_reach)\n    \n    return max_wait\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\na = int(data[0])\nb = int(data[1])\nn = int(data[2])\nm = int(data[3])\n\nroads = []\nindex = 4\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    t = int(data[index + 2])\n    roads.append((u, v, t))\n    index += 3\n\n# Calculate and print the result\nresult = min_wait_time(a, b, n, m, roads)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3547": {
        "body": "import sys\n\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\n    n = int(input())\n    plots = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        plots.append([(x1, y1), (x2, y1), (x2, y2), (x1, y2)])\n\n    total_area = 0.0\n    for plot in plots:\n        area = area_of_polygon(plot)\n        total_area += area\n\n    print(f\"{total_area:.2f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3017": {
        "body": "    power_of_two = str(2 ** e)\n    count = 0\n    for i in range(n + 1):\n        if power_of_two in str(i):\n            count += 1\n    return count\n\n# Read input from stdin\nn, e = map(int, input().split())\n\n# Print the result\nprint(count_numbers_with_power_of_two(n, e))",
        "result": "failed: testcase 0"
    },
    "3076": {
        "body": "    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        s, v = jewels[i - 1]\n        for j in range(k + 1):\n            if j < s:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - s] + v)\n    \n    result = [dp[n][i] for i in range(1, k + 1)]\n    return result\n\n# Read input\nn, k = map(int, input().split())\njewels = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Get the result\nresult = max_jewel_value(n, k, jewels)\n\n# Print the result\nprint(' '.join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3923": {
        "body": "    if N == 1:\n        return [1] if A == B == 1 else -1\n    \n    if A > B or B > N:\n        return -1\n    \n    permutation = list(range(1, N + 1))\n    \n    # Adjust the permutation to match the given g(i) values\n    for i in range(N):\n        if (i + 1) % A == 0 and (i + 1) % B != 0:\n            permutation[i] = B\n        elif (i + 1) % B == 0 and (i + 1) % A != 0:\n            permutation[i] = A\n    \n    return permutation\n\n# Read input from stdin\nN, A, B = map(int, input().split())\n\n# Find the permutation\nresult = find_permutation(N, A, B)\n\n# Print the result\nif result == -1:\n    print(-1)\nelse:\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3332": {
        "body": "import sys\nfrom collections import deque\n\n    n = int(input())\n    streams = []\n    \n    for _ in range(n):\n        s, d, p = map(int, input().split())\n        streams.append((s, s + d, p))\n    \n    streams.sort(key=lambda x: (x[0], -x[2]))\n    \n    processors = deque(range(1, n + 1))\n    max_priority = 0\n    current_time = 0\n    \n    for start, end, priority in streams:\n        while processors and processors[0] < current_time:\n            processors.popleft()\n        \n        if processors:\n            processors.append(start)\n            current_time = end\n            max_priority += priority\n    \n    print(max_priority)\n\nif __name__ == \"__main__\":\n    max_priority_subset()",
        "result": "failed: testcase 0"
    },
    "3240": {
        "body": "import sys\n\n    p = [0] * (v - 1)\n    b = [0] * (v - 1)\n    \n    for i in range(v - 1):\n        p[i], b[i] = map(float, input().split())\n    \n        total_votes = sum(p[i] * (balls == b[i]) for i in range(v - 1))\n        total_votes += (1 - p[v-2]) * (balls == 0)\n        count_yraglac = 0\n        for j in range(k):\n            if (total_votes >> j) & 1:\n                count_yraglac += 1\n        return k - count_yraglac\n    \n    max_val = 0\n    best_balls = 0\n    for balls in range(2**k):\n        val = expected_value(balls)\n        if val > max_val:\n            max_val = val\n            best_balls = balls\n    \n    print(best_balls)\n\nif __name__ == \"__main__\":\n    k, v = map(int, input().split())\n    max_expected_positions(k, v)",
        "result": "failed: testcase 0"
    },
    "3368": {
        "body": "from collections import defaultdict\n\n    target_enclosures = defaultdict(list)\n    current_enclosures = defaultdict(int)\n\n    for i in range(n):\n        line = input().strip().split()\n        animal_type = line[0]\n        num_animals = int(line[1])\n        animals = line[2:]\n        target_enclosures[i + 1] = animals\n        current_enclosures[i + 1] = num_animals\n\n    for i in range(1, n + 1):\n        if target_enclosures[i] != current_enclosures[i]:\n            return \"POSSIBLE\"\n\n    return \"FALSE ALARM\"\n\n# Read input\nn, m = map(int, input().strip().split())\n\n# Call the function and print the result\nresult = can_relocate_animals(n, m, n)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3538": {
        "body": "    # Sort frogs by height in descending order to maximize the number of escapable frogs\n    frogs.sort(key=lambda x: -x[2])\n    \n    escape_count = 0\n    current_weight = 0\n    \n    for l, w, h in frogs:\n        if h + current_weight <= d:\n            escape_count += 1\n            current_weight += w\n    \n    return escape_count\n\n# Read input from stdin\nn, d = map(int, input().split())\nfrogs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(max_frogs_to_escape(n, d, frogs))",
        "result": "failed: testcase 0"
    },
    "3183": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))\n\n        dist = [float('inf')] * n\n        dist[s] = 0\n        prev_node = [-1] * n\n        prev_edge = [-1] * n\n        queue = deque([s])\n        \n        while queue:\n            u = queue.popleft()\n            for v, c, w in graph[u]:\n                if c > 0 and dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    prev_node[v] = u\n                    prev_edge[v] = len(graph[u]) - 1 if u == v else len(graph[u]) - 2\n                    queue.append(v)\n        \n        return dist, prev_node, prev_edge\n\n    flow = 0\n    min_cost = 0\n    \n    while True:\n        dist, prev_node, prev_edge = bfs()\n        if dist[t] == float('inf'):\n            break\n        \n        # Find the maximum flow value from s to t in the residual graph\n        f = float('inf')\n        v = t\n        while v != s:\n            u = prev_node[v]\n            e = prev_edge[v]\n            if u == v:\n                f = min(f, edges[e][1] - edges[e][2])\n            else:\n                f = min(f, edges[e][1])\n            v = u\n        \n        # Update the flow and cost\n        v = t\n        while v != s:\n            u = prev_node[v]\n            e = prev_edge[v]\n            if u == v:\n                edges[e][1] += f\n                edges[e][2] += f * edges[e][3]\n            else:\n                edges[e][1] -= f\n                edges[e][2] -= f * edges[e][3]\n            if edges[e][0] != u:\n                e = len(graph[u]) - 2\n            v = u\n        \n        flow += f\n        min_cost += f * dist[t]\n\n    return flow, min_cost\n\n# Read input\nn, m, s, t = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nflow, cost = min_cost_flow(n, edges, s, t)\nprint(flow, cost)",
        "result": "failed: testcase 0"
    },
    "3916": {
        "body": "from math import factorial\nfrom collections import defaultdict\n\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(x**0.5) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\n    graph = defaultdict(list)\n    visited = set()\n    \n        if node in visited:\n            return 0\n        visited.add(node)\n        for neighbor in graph[node]:\n            graph[neighbor].append(node)\n            dfs(neighbor)\n        \n        while len(graph[node]) > 1:\n            neighbor = graph[node].pop()\n            graph[neighbor].remove(node)\n            dfs(neighbor)\n        \n        if node not in graph or not graph[node]:\n            return 0\n        \n        distance = 1\n        for neighbor in graph[node]:\n            distance += dfs(neighbor)\n        \n        return distance\n    \n    for fragment in fragments:\n        current = factorial(fragment)\n        while current > 1:\n            graph[current].append(current // lowest_prime_divisor(current))\n            current //= lowest_prime_divisor(current)\n    \n    min_path_sum = float('inf')\n    for node in range(1, max(fragments) + 2):\n        visited.clear()\n        path_sum = dfs(node)\n        if path_sum < min_path_sum:\n            min_path_sum = path_sum\n    \n    return min_path_sum\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nfragments = list(map(int, data[1:]))\n\nprint(find_min_path_sum(n, fragments))",
        "result": "failed: testcase 0"
    },
    "3195": {
        "body": "import sys\nfrom fractions import Fraction\n\n    total_time = Tg + Ty + Tr\n    state_counts = [0] * 3\n    for t, c in observations:\n        if c == 'green':\n            state_counts[0] += 1\n        elif c == 'yellow':\n            state_counts[1] += 1\n        else:  # red\n            state_counts[2] += 1\n    \n    total_observations = sum(state_counts)\n    probability = Fraction(state_counts['g' if observations[-1][1] == 'green' else (1, 0)], total_observations).limit_denominator()\n    \n    return float(probability)\n\n    Tg, Ty, Tr = map(int, input().split())\n    n = int(input())\n    observations = []\n    for _ in range(n):\n        t, c = input().split()\n        observations.append((int(t), c))\n    \n    tq, cq = input().split()\n    tq, cq = int(tq), cq\n    \n    result = cycle_probability(Tg, Ty, Tr, observations)\n    print(f\"{result:.3f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3998": {
        "body": "import sys\nfrom collections import Counter\n\n    max_rating = max(ratings)\n    matches = []\n    \n    for _ in range(max_rating - min(ratings)):\n        match = [0] * n\n        played = False\n        for i in range(n):\n            if ratings[i] < max_rating:\n                for j in range(i + 1, n):\n                    if ratings[j] > ratings[i]:\n                        match[i] = 1\n                        match[j] = 1\n                        ratings[i] += 1\n                        ratings[j] -= 1\n                        played = True\n        if not played:\n            break\n        matches.append(''.join(map(str, match)))\n    \n    return max_rating, len(matches), matches\n\n    n = int(input())\n    ratings = list(map(int, input().split()))\n    final_rating, num_matches, match_list = max_equal_rating(n, ratings)\n    print(final_rating)\n    print(num_matches)\n    for match in match_list:\n        print(match)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3150": {
        "body": "import sys\nfrom collections import defaultdict\n\n    while b:\n        a, b = b, a % b\n    return a\n\n    (x1, y1), (x2, y2) = trench1, trench2\n    dx, dy = x2 - x1, y2 - y1\n    g = gcd(dx, dy)\n    return (dx // g, dy // g)\n\n    n = len(trenches)\n    lines = defaultdict(set)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            line = get_line(trenches[i], trenches[j])\n            lines[line].add(i)\n            lines[line].add(j)\n    \n    ways = 0\n    for points in lines.values():\n        if len(points) == 3:\n            ways += 6\n    \n    return ways\n\nif __name__ == \"__main__\":\n    n = int(input())\n    trenches = [tuple(map(int, input().split())) for _ in range(n)]\n    print(count_ways(trenches))",
        "result": "failed: testcase 0"
    },
    "3566": {
        "body": "from sys import stdin, stdout\n\n    for _ in range(q):\n        i, x = map(int, input().split())\n        a[i] = x\n        \n        total_left = 0\n        total_right = sum(a[i+1:])\n        \n        min_diff = float('inf')\n        best_pos = -1\n        \n        for j in range(n):\n            left = total_left + (a[j] // 2)\n            right = total_right + ((a[j] + 1) // 2)\n            diff = abs(left - right)\n            \n            if diff < min_diff:\n                min_diff = diff\n                best_pos = j\n        \n        stdout.write(f\"{best_pos}\\n\")\n\n# Read input\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Process each query\nfind_best_position(n, q, a)",
        "result": "failed: testcase 0"
    },
    "3401": {
        "body": "import sys\nfrom heapq import heappush, heappop\n\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            current_dist, u = heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            \n            for v, height_diff in graph[u]:\n                length = abs(height_diff) * q / (height_diff ** 2 + max_length ** 2)\n                new_dist = current_dist + length\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heappush(pq, (new_dist, v))\n        \n        return dist\n    \n    graph = [[] for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            x_i, y_i, h_i = hills[i - 1]\n            x_j, y_j, h_j = hills[j - 1]\n            height_diff = h_j - h_i\n            length = ((x_j - x_i) ** 2 + (y_j - y_i) ** 2) ** 0.5\n            graph[i].append((j, height_diff))\n            graph[j].append((i, height_diff))\n    \n    min_length = float('inf')\n    for s_hill in springs:\n        dist_s = dijkstra(s_hill, q)\n        for t_hill in towns:\n            if dist_s[t_hill] < min_length:\n                min_length = dist_s[t_hill]\n    \n    if min_length == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return f\"{min_length:.6f}\"\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = int(data[1])\n    t = int(data[2])\n    q = int(data[3])\n    \n    hills = []\n    index = 4\n    for _ in range(n):\n        x_i = int(data[index])\n        y_i = int(data[index + 1])\n        h_i = int(data[index + 2])\n        hills.append((x_i, y_i, h_i))\n        index += 3\n    \n    springs = list(map(int, data[index:index + s]))\n    towns = list(map(int, data[index + s:]))\n    \n    result = find_minimal_aqueducts(n, s, t, q, hills, springs, towns)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3660": {
        "body": "from sys import stdin\n\n    n = len(stickers)\n    dp = [[float('inf')] * 2 for _ in range(len(message) + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, len(message) + 1):\n        dp[i][0] = min(dp[i][0], dp[i-1][0])\n        dp[i][1] = min(dp[i][1], dp[i-1][1])\n        \n        for j in range(i - 1, max(-1, i - 20), -1):\n            word, cost = stickers[j]\n            if message.startswith(word, j):\n                dp[i][0] = min(dp[i][0], dp[j][0] + cost)\n                dp[i][1] = min(dp[i][1], dp[j][1] + cost)\n    \n    return dp[-1][0]\n\nif __name__ == \"__main__\":\n    message = input().strip()\n    n = int(input())\n    stickers = [tuple(input().strip().split()) for _ in range(n)]\n    \n    result = min_cost_message(message, stickers)\n    if result == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        print(result)",
        "result": "failed: testcase 0"
    },
    "3721": {
        "body": "    rows = set()\n    cols = set()\n    \n    for r, c in [(r-1, c-1) for r, c in [map(int, input().split()) for _ in range(q)]]:\n        rows.add(r)\n        cols.add(c)\n    \n    return (n - len(rows)) * (m - len(cols))\n\n# Read input\nn, m, q = map(int, input().split())\nprint(min_elements_to_purchase(n, m, q))",
        "result": "failed: testcase 0"
    },
    "3811": {
        "body": "import sys\n\n    while b:\n        a, b = b, a % b\n    return a\n\n    if not pairs:\n        return -1\n    \n    current_wcd = pairs[0][0]\n    for pair in pairs:\n        current_wcd = gcd(current_wcd, gcd(pair[0], pair[1]))\n    \n    return current_wcd if current_wcd > 1 else -1\n\nif __name__ == \"__main__\":\n    n = int(input())\n    pairs = [tuple(map(int, input().split())) for _ in range(n)]\n    result = wcd(pairs)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3528": {
        "body": "import sys\nfrom collections import deque\n\n    x1, y1 = points[0]\n    return sum((x2 * y1 - x1 * y2) for x2, y2 in points[1:]) / 2.0\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    nails = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    picks = [data[N*2+i] for i in range(N-2)]\n    \n    areas = []\n    queue = deque(sorted(nails))\n    \n    for pick in picks:\n        if pick == 'L':\n            point = queue.popleft()\n        elif pick == 'R':\n            point = queue.pop()\n        elif pick == 'U':\n            point = max(queue, key=lambda p: p[1])\n            queue.remove(point)\n        elif pick == 'D':\n            point = min(queue, key=lambda p: p[1])\n            queue.remove(point)\n        \n        areas.append(calculate_area(list(queue)))\n    \n    for area in areas:\n        print(f\"{area:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3890": {
        "body": "    MOD = 1000000007\n    \n    if n == 1:\n        return 1\n    \n    # Initialize dp array\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    # Calculate the number of ways to get back to house 1 starting from house i\n    for i in range(2, n + 1):\n        dp[i] = sum(dp[j] for j in range(1, i)) % MOD\n    \n    # Calculate the total number of valid configurations\n    total_ways = 0\n    for i in range(1, k + 1):\n        total_ways = (total_ways + dp[i]) % MOD\n    \n    return total_ways\n\n# Read input\nn, k = map(int, input().split())\n\n# Output result\nprint(count_penguin_plaque_ways(n, k))",
        "result": "failed: testcase 0"
    },
    "3534": {
        "body": "    max_correct = 0\n    best_K = 0\n    \n    for K in range(2 * 10**9 + 1):\n        correct = 1\n        prev = a[0]\n        \n        for i in range(1, N):\n            if a[i] > prev:\n                next_key = prev + K\n            elif a[i] < prev:\n                next_key = prev - K\n            else:\n                next_key = prev\n            \n            if next_key == a[i]:\n                correct += 1\n            prev = next_key\n        \n        if correct > max_correct:\n            max_correct = correct\n            best_K = K\n    \n    return max_correct, best_K\n\n# Read input\nN = int(input())\na = list(map(int, input().split()))\n\n# Output result\nresult = max_correct_pitches(N, a)\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0"
    },
    "3371": {
        "body": "import sys\nfrom collections import defaultdict\n\n    # Create a graph where each participant is a node\n    graph = defaultdict(list)\n    \n    for a, b, y in encounters:\n        graph[a].append((b, y))\n        graph[b].append((a, y))\n    \n        visited = [False] * (n + 1)\n        queue = [(i, float('inf')) for i in range(1, n + 1)]\n        \n        while queue:\n            u, earliest_meeting = heapq.heappop(queue)\n            if visited[u]:\n                continue\n            visited[u] = True\n            \n            for v, meeting_year in graph[u]:\n                if meeting_year < year and earliest_meeting > meeting_year:\n                    earliest_meeting = meeting_year\n                heapq.heappush(queue, (v, earliest_meeting))\n        \n        return earliest_meeting\n    \n    min_y = float('inf')\n    max_y = 2007\n    \n    while min_y <= max_y:\n        mid = (min_y + max_y) // 2\n        if can_divide(mid):\n            max_y = mid - 1\n        else:\n            min_y = mid + 1\n    \n    return \"Impossible\" if min_y > 2007 else str(min_y)\n\n    # Check if we can partition the participants into two groups\n    # such that all pairs in one group met before year and all pairs in the other group met on or after year\n    n = len(graph)\n    visited = [False] * (n + 1)\n    stack = [(i, True) for i in range(1, n + 1)]\n    \n    while stack:\n        u, first_group = stack.pop()\n        if visited[u]:\n            continue\n        visited[u] = True\n        \n        for v, meeting_year in graph[u]:\n            if (meeting_year < year and first_group) or (meeting_year >= year and not first_group):\n                return False\n            stack.append((v, not first_group))\n    \n    return True\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    c = int(input().strip())\n    encounters = []\n    for _ in range(c):\n        a, b, y = map(int, input().strip().split())\n        encounters.append((a, b, y))\n    \n    result = find_division(n, c, encounters)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3621": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\nMOD = 10**9 + 7\n\n    n = len(graph)\n    visited = [False] * n\n    queue = deque([start])\n    visited[start] = True\n    size = 1\n    while queue:\n        node = queue.popleft()\n        for neighbor in range(n):\n            if graph[node][neighbor] == color and not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n                size += 1\n    return size\n\n    n = len(graph)\n    components = []\n    for i in range(n):\n        if graph[i][i] == 0:\n            component_size = bfs(graph, i, color)\n            if component_size > 1:\n                components.append(component_size)\n    return max(components) if components else 0\n\n    n = int(input())\n    graph = [list(map(int, input().split())) for _ in range(n)]\n    \n    total_sum = 0\n    all_subsets_sum = (1 << n) - 1  # Sum of all subsets excluding the empty set\n    \n    for mask in range(1, 1 << n):\n        subset_size = bin(mask).count('1')\n        if subset_size == 1:\n            continue\n        \n        color_count = defaultdict(int)\n        for i in range(n):\n            if mask & (1 << i):\n                for j in range(i + 1, n):\n                    if mask & (1 << j) and graph[i][j] != 0:\n                        color_count[graph[i][j]] += 1\n        \n        max_size = 0\n        for color in color_count:\n            max_size = max(max_size, max_same_color_subset(graph, color))\n        \n        total_sum += subset_size * max_size\n    \n    print(total_sum % MOD)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3392": {
        "body": "import sys\nfrom collections import deque\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n        return 0 <= x < N and 0 <= y < N\n    \n        for i in range(N):\n            for j in range(N):\n                heights[i][j] += growth_speeds[i][j] * years\n    \n        queue = deque([(x, y)])\n        visited = set()\n        visited.add((x, y))\n        size = 1\n        \n        while queue:\n            cx, cy = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited and heights[nx][ny] == target_height:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    size += 1\n        \n        return size\n    \n    max_size = 0\n    for years in range(1, N * N + 1):\n        grow_heights(heights, growth_speeds, years)\n        target_height = heights[0][0]\n        size = bfs(0, 0, target_height)\n        max_size = max(max_size, size)\n    \n    return max_size\n\n# Read input\nN = int(input())\nheights = [list(map(int, input().split())) for _ in range(N)]\ngrowth_speeds = [list(map(int, input().split())) for _ in range(N)]\n\n# Output the result\nprint(largest_group_of_trees(N, heights, growth_speeds))",
        "result": "failed: testcase 0"
    },
    "3095": {
        "body": "        r = len(submatrix)\n        s = len(submatrix[0])\n        if r <= 1 or s <= 1:\n            return False\n        for i in range(2, r):\n            for j in range(2, s):\n                if submatrix[1][j] + submatrix[i-1][1] < submatrix[1][i-1] + submatrix[i-1][j]:\n                    return False\n        return True\n\n    max_elements = 0\n    for i in range(R):\n        for j in range(S):\n            for r in range(i+2, R+1):\n                for s in range(j+2, S+1):\n                    submatrix = [row[j:s] for row in matrix[i:r]]\n                    if is_cool(submatrix):\n                        max_elements = max(max_elements, (r-i) * (s-j))\n    return max_elements\n\n# Read input\nR, S = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(R)]\n\n# Output the result\nprint(max_elements_in_extremely_cool_submatrix(R, S, matrix))",
        "result": "failed: testcase 0"
    },
    "3769": {
        "body": "    MOD = 10**9 + 7\n    if k == 0:\n        return pow(2, p, MOD)\n    else:\n        return pow(p, p, MOD)\n\n# Read input from stdin\np, k = map(int, input().split())\n\n# Print the result\nprint(count_functions(p, k))",
        "result": "failed: testcase 0"
    },
    "3563": {
        "body": "    # Sort holes based on their x-coordinates\n    holes.sort()\n    \n    lines = 0\n    i = 0\n    \n    while i < n:\n        # Find the rightmost hole in the current line\n        max_x = holes[i][0]\n        j = i + 1\n        \n        while j < n and holes[j][0] <= max_x + holes[i][1]:\n            max_x = max(max_x, holes[j][0])\n            j += 1\n        \n        # Move to the next set of holes\n        i = j\n    \n    return lines\n\n# Read input\nn = int(input())\nholes = [tuple(map(int, input().split())) for _ in range(n * 2)]\n\n# Calculate and print the result\nresult = min_lines_to_cover_holes(n, holes)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3618": {
        "body": "    MOD = 998244353\n    if n == 1:\n        return 10\n    dp = [0] * (n + 1)\n    dp[1] = 10\n    for i in range(2, n + 1):\n        dp[i] = (2 * dp[i - 1] + 8) % MOD\n    return dp[n]\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nprint(count_best_friend_pairs(n))",
        "result": "failed: testcase 0"
    },
    "3830": {
        "body": "import sys\n\n    returnable = 0\n    for i in range(n):\n        if s[i] == '-' or (i > 0 and s[(i-1) % n] == '<') or (i < n-1 and s[(i+1) % n] == '>'):\n            returnable += 1\n    return returnable\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        s = data[index]\n        index += 1\n        results.append(count_returnable_rooms(n, s))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3912": {
        "body": "from collections import Counter\nimport sys\n\n    n = len(s)\n    char_count = Counter(s)\n    \n    # Calculate the minimum number of palindromes needed\n    k = sum(1 for count in char_count.values() if count % 2 != 0)\n    if k % 2 != 0:\n        k += 1\n    \n    # Construct the palindromes\n    result = []\n    used = [False] * n\n    i = 0\n    while i < n:\n        if not used[i]:\n            j = i + 1\n            while j < n and s[j] == s[i]:\n                j += 1\n            char_freq = Counter(s[i:j])\n            palindrome = s[i:i+(j-i)//2]\n            for char, freq in char_freq.items():\n                if freq % 2 != 0:\n                    palindrome += char\n            result.append(palindrome)\n            for l in range(i, j):\n                used[l] = True\n        i += 1\n    \n    return k, ' '.join(result)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input().strip()\n    k, palindromes = min_palindromes(s)\n    print(k)\n    print(palindromes)",
        "result": "failed: testcase 0"
    },
    "3878": {
        "body": "import sys\nfrom collections import defaultdict\n\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n        if node in visited:\n            return 0\n        visited.add(node)\n        return 1 + sum(dfs(neigh, visited) for neigh in graph[node])\n\n    max_friends = 0\n    for i in range(1, n + 1):\n        max_friends = max(max_friends, dfs(i, set()))\n\n    steps = 0\n    guests = []\n    visited = set()\n    while len(visited) < n:\n        step_guests = []\n        for node in range(1, n + 1):\n            if node not in visited and len(graph[node]) == max_friends - 1:\n                step_guests.append(node)\n                for neigh in graph[node]:\n                    visited.add(neigh)\n        steps += 1\n        guests.extend(step_guests)\n\n    return steps, guests\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nm = int(data[1])\n\nedges = []\nindex = 2\nfor _ in range(m):\n    u = int(data[index]) - 1\n    v = int(data[index + 1]) - 1\n    edges.append((u, v))\n    index += 2\n\nsteps, guests = find_min_steps(n, m, edges)\nprint(steps)\nprint(' '.join(map(str, [x + 1 for x in guests])))",
        "result": "failed: testcase 0"
    },
    "3010": {
        "body": "    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        if x0 == x1:\n            min_y = min(y0, y1)\n            max_y = max(y0, y1)\n            for j in range(min_y, max_y + 1):\n                points.add((x0, j))\n        elif y0 == y1:\n            min_x = min(x0, x1)\n            max_x = max(x0, x1)\n            for j in range(min_x, max_x + 1):\n                points.add((j, y0))\n    return len(points) if -1 not in points else -1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nlines = [(int(data[i*4+1]), int(data[i*4+2]), int(data[i*4+3]), int(data[i*4+4])) for i in range(n)]\nprint(count_intersection_points(n, lines))",
        "result": "failed: testcase 0"
    },
    "3068": {
        "body": "from itertools import combinations\n\n    N = int(input())\n    investigations = [input().split() for _ in range(N)]\n    \n    suspects = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    all_combinations = list(combinations(suspects, 3))\n    \n    admissible_solutions = []\n    \n    for combination in all_combinations:\n        valid = True\n        for i, j, reply in investigations:\n            count_i = sum(1 for x in combination if x in i)\n            count_j = sum(1 for x in combination if x in j)\n            if (count_i + count_j) != int(reply):\n                valid = False\n                break\n        if valid:\n            admissible_solutions.append(combination)\n    \n    print(len(admissible_solutions))\n\ncount_admissible_solutions()",
        "result": "failed: testcase 0"
    },
    "3030": {
        "body": "import sys\n\n    parent = [0] * n\n    for i in range(1, n):\n        parent[nodes[i][1]] = i\n    \n    dp = [1] * n\n    for i in range(1, n):\n        if nodes[i][1] != 0:\n            dp[i] = max(dp[i], dp[parent[i]] + 1)\n    \n    return max(dp)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nodes = []\n    for i in range(1, n):\n        v = int(data[2 * i + 1])\n        p = int(data[2 * i + 2]) - 1\n        nodes.append((v, p))\n    \n    result = max_heap_subset(n, nodes)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3630": {
        "body": "    n = len(s1)\n    moves = 0\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            diff = (ord(s2[i]) - ord(s1[i])) % 26\n            if s2[i] < s1[i]:\n                diff = (diff + 26) % 26\n            moves += diff\n    \n    return moves\n\n# Read input from stdin\ninput_line = input().strip()\ns1, s2 = input_line.split()\n\n# Print the result\nprint(min_moves_to_modify(s1, s2))",
        "result": "failed: testcase 0"
    },
    "3133": {
        "body": "        queue = [start]\n        visited = set()\n        while queue:\n            current = queue.pop(0)\n            if (current, 1) in visited or (current, -1) in visited:\n                continue\n            visited.add((current, 1))\n            visited.add((current, -1))\n            if intersections[current][2] == 1:\n                return True\n            left = intersections[current][0]\n            right = intersections[current][1]\n            if left != current and (left, 1) not in visited:\n                queue.append(left)\n            if right != current and (right, -1) not in visited:\n                queue.append(right)\n        return False\n\n    alice_can_see = can_see_tower(A)\n    bob_can_see = can_see_tower(B)\n\n    if alice_can_see and not bob_can_see:\n        return 0\n    elif bob_can_see and not alice_can_see:\n        return 0\n    else:\n        return \"indistinguishable\"\n\n# Read input from stdin\nn, A, B = map(int, input().split())\nintersections = [list(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(min_turns_to_distinguish(n, A, B, intersections))",
        "result": "failed: testcase 0"
    },
    "3480": {
        "body": "import sys\n\n    L, D = map(int, input().split())\n    for _ in range(L):\n        first_voice, second_voice_times = input(), list(map(int, input().split()))\n        first_voice_parts = first_voice.split()\n        second_voice_output = [''] * len(first_voice_parts)\n        \n        current_time = 0\n        second_voice_index = 0\n        \n        for i in range(len(first_voice_parts)):\n            syllable = first_voice_parts[i]\n            time_units = second_voice_times[i]\n            start_time = current_time + D\n            \n            if start_time < time_units:\n                second_voice_output[i] += '_' * (start_time - current_time)\n            \n            second_voice_output[i] += syllable\n            second_voice_output[i] += '_' * max(0, time_units - len(second_voice_output[i]))\n            \n            current_time += time_units\n        \n        for line in second_voice_output:\n            if not line:\n                print('/')\n            else:\n                print(line)\n\nif __name__ == \"__main__\":\n    generate_round()",
        "result": "failed: testcase 0"
    },
    "3389": {
        "body": "    current_type = None\n    clicks = 0\n    \n    for video in videos:\n        if video != current_type:\n            current_type = video\n            clicks += 1\n    \n    return clicks\n\n# Read input\nn, k = map(int, input().split())\nvideos = input()\n\n# Calculate and print the result\nprint(min_clicks(n, k, videos))",
        "result": "failed: testcase 0"
    },
    "3925": {
        "body": "    n = len(s)\n    max_length = 0\n    \n    for i in range(n):\n        length = 1\n        for j in range(i + 1, n):\n            if s[j] == s[j - 1]:\n                break\n            length += 1\n        max_length = max(max_length, length)\n    \n    return max_length\n\n# Read input from stdin\ns = input().strip()\nprint(max_zebra_length(s))",
        "result": "failed: testcase 0"
    },
    "3700": {
        "body": "n, k = map(int, input().split())\ncount = 0\nfor i in range(1, n):\n    if k - i > i and k - i <= n:\n        count += 1\nprint(count)",
        "result": "timed out"
    },
    "3944": {
        "body": "    MOD = 10**9 + 7\n    \n    # Calculate the number of ways to win based on Alice's card\n    if N == 0:\n        return (3 * count_winning_patterns(0, M, K) % MOD) % MOD\n    if M == 0:\n        return (3 * count_winning_patterns(N, 0, K) % MOD) % MOD\n    if K == 0:\n        return (3 * count_winning_patterns(N, M, 0) % MOD) % MOD\n    \n    # Calculate the number of ways Alice can win based on Bob's and Charlie's cards\n    a_win = count_winning_patterns(N-1, M, K)\n    b_win = count_winning_patterns(N, M-1, K)\n    c_win = count_winning_patterns(N, M, K-1)\n    \n    return (a_win + b_win + c_win) % MOD\n\n# Read input\nN, M, K = map(int, input().split())\n\n# Output the result\nprint(count_winning_patterns(N, M, K))",
        "result": "failed: testcase 0"
    },
    "3821": {
        "body": "import sys\n\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for p in probabilities:\n        for i in range(n, 0, -1):\n            dp[i] += dp[i-1] * (1 - p)\n    \n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    probabilities = list(map(float, input().strip().split()))\n    result = max_probability(n, probabilities)\n    print(f\"{result:.10f}\")",
        "result": "failed: testcase 0"
    },
    "3667": {
        "body": "import sys\nfrom collections import defaultdict\n\n    # Build the graph\n    graph = defaultdict(list)\n    for s, x, y in pipes:\n        graph[s].append((x, y))\n    \n    # Check if it's possible to clean all intersections\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in graph[node]:\n            if not dfs(neighbor, visited):\n                return False\n        return True\n    \n    # Start DFS from each well\n    for i in range(1, w + 1):\n        if not dfs(i, set()):\n            return \"impossible\"\n    \n    return \"possible\"\n\n# Read input\nw, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for _ in range(w)]\npipes = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output result\nprint(can_clean_intersections(w, p, wells, pipes))",
        "result": "failed: testcase 0"
    },
    "3959": {
        "body": "from collections import Counter\nimport math\n\n    MOD = 10**9 + 7\n    \n    # Count the total number of each Pokemon type across all gyms\n    total_counts = Counter()\n    for gym in gyms:\n        for poke_type in gym[1:]:\n            total_counts[poke_type] += 1\n    \n    # Calculate the product of factorials of the counts modulo MOD\n    result = 1\n    for count in total_counts.values():\n        result = (result * math.factorial(count)) % MOD\n    \n    return result\n\n# Read input\nn, m = map(int, input().split())\ngyms = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(count_evolution_plans(n, m, gyms))",
        "result": "failed: testcase 0"
    },
    "3692": {
        "body": "import sys\n\n    if n == 1:\n        return 2\n    elif n == 2:\n        x1, y1, r1 = circles[0]\n        x2, y2, r2 = circles[1]\n        dx = abs(x1 - x2)\n        dy = abs(y1 - y2)\n        d = dx**2 + dy**2\n        if d > (r1 + r2)**2:\n            return 4\n        elif d < abs(r1 - r2)**2:\n            return 2\n        else:\n            return 3\n    else:\n        regions = count_regions(n-1, circles[:-1])\n        x1, y1, r1 = circles[-1]\n        intersections = 0\n        for i in range(n-1):\n            x2, y2, r2 = circles[i]\n            dx = abs(x1 - x2)\n            dy = abs(y1 - y2)\n            d = dx**2 + dy**2\n            if d < (r1 + r2)**2 and d > abs(r1 - r2)**2:\n                intersections += 1\n        return regions + 2 * intersections\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    circles = []\n    for _ in range(n):\n        x, y, r = map(int, input().strip().split())\n        circles.append((x, y, r))\n    \n    result = count_regions(n, circles)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3894": {
        "body": "    total_cows = sum(a)\n    if total_cows % 2 == 0:\n        return \"Nicky\"\n    else:\n        return \"Kevin\"\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, k, a))",
        "result": "failed: testcase 0"
    },
    "3856": {
        "body": "        return w * h\n    \n    width = [max(w, h) for w, h in friends]\n    height = max(min(w, h) for w, h in friends)\n    \n    width.sort()\n    half_n = n // 2\n    min_area = float('inf')\n    \n    for i in range(half_n + 1):\n        current_width = sum(width[:i]) + sum(width[n - 1:i - 1:-1])\n        total_height = max(height, max(min(w, h) for w, h in friends if (w, h) not in [friends[j] for j in range(i)]))\n        min_area = min(min_area, area(current_width, total_height))\n    \n    return min_area\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nfriends = [(int(data[2 * i + 1]), int(data[2 * i + 2])) for i in range(n)]\nprint(min_photo_area(n, friends))",
        "result": "failed: testcase 0"
    },
    "3282": {
        "body": "import sys\n\n    total_count = 0\n    valid_bills = []\n    \n    for beverage in range(1, P):\n        if P % beverage != 0:\n            continue\n        main_dish = P // beverage\n        digits = set(str(beverage) + str(main_dish))\n        if len(digits) == len(str(beverage)) + len(str(main_dish)):\n            total_count += 1\n            valid_bills.append((beverage, main_dish))\n    \n    return total_count, valid_bills\n\nif __name__ == \"__main__\":\n    P = int(input())\n    count, bills = count_valid_bills(P)\n    print(count)\n    for bill in bills:\n        if len(valid_bills) > 5000:\n            break\n        print(f\"{bill[0]} {bill[1]}\")",
        "result": "failed: testcase 0"
    },
    "3596": {
        "body": "import math\nfrom scipy.special import gamma, erf, jn\nfrom scipy.misc import derivative\n\n    t1, t2, t3, t4 = map(int, input().split())\n    return c * (t1 * gamma(x) + (math.log(erf(t3 * x)) / math.pow(t2, 0.5))) - J_k(x)**t4\n\n    f_prime = derivative(f, 0, dx=1e-6)\n    taylor_poly = sum(f_prime**i / math.factorial(i) * x**i for i in range(r + 1))\n    return taylor_poly\n\n    if n == 0:\n        return P(x)\n    else:\n        return sum(P(n-1)(i) * x**i for i in range(r + n + 1))\n\n    deg = len(str(P_s(x))) - 1\n    return derivative(lambda x: (P_s(x) + l)**2 / math.pi * math.e, x, dx=1e-6)\n\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\nn, k, r, s, l = map(int, input().split())\n\nJ_k = lambda x: (1 / math.pi) * sum(math.cos(k * tau - x * math.sin(tau)) for tau in [tau/1000 for tau in range(31415926537)])\n\nP_s = P_n(n, s)\ng_value = g(P_s(b))\nresult = (g_value + l)**2 / (math.pi * math.e) + 1 / (l + 1)\nprint(f\"{result:.6f}\")",
        "result": "failed: testcase 0"
    },
    "3540": {
        "body": "    # Read the input grid\n    grid = [list(input().strip()) for _ in range(4)]\n    \n    # Define the target state\n    target_state = [['R', 'G', 'B', 'Y']] + [['G', 'B', 'Y', 'R']] + [['B', 'Y', 'R', 'G']] + [['Y', 'R', 'G', 'B']]\n    \n    min_moves = float('inf')\n    \n    # Check all possible starting positions\n    for i in range(4):\n        for j in range(4):\n            current_state = [grid[(i + k) % 4][j] for k in range(4)]\n            moves = 0\n            \n            # Calculate the number of moves to align with the target state\n            for k in range(4):\n                if current_state[k] != target_state[0][k]:\n                    moves += abs((target_state[0].index(current_state[k]) - k + 4) % 4)\n            \n            min_moves = min(min_moves, moves)\n    \n    # Output the minimum number of moves\n    print(min_moves)\n\nmin_moves_to_solve()",
        "result": "failed: testcase 0"
    },
    "3354": {
        "body": "import math\n\n    s, r = map(float, input().split())\n    n, z = map(int, input().split())\n    \n    area_sandwich = math.pi * s**2\n    max_area_covered = (z / 100) * area_sandwich\n    \n    radius_square = r**2\n    circle_area = math.pi * radius_square\n    \n    # Calculate the maximum number of pickles that can be placed without exceeding the area limit\n    max_pickles = int(max_area_covered // circle_area)\n    \n    return min(max_pickles, n)\n\nprint(max_pickles_on_sandwich())",
        "result": "failed: testcase 0"
    },
    "3217": {
        "body": "    x_min = min(cell[0] for cell in defective_cells)\n    x_max = max(cell[0] for cell in defective_cells)\n    y_min = min(cell[1] for cell in defective_cells)\n    y_max = max(cell[1] for cell in defective_cells)\n    z_min = min(cell[2] for cell in defective_cells)\n    z_max = max(cell[2] for cell in defective_cells)\n    \n    width = x_max - x_min + 1\n    height = y_max - y_min + 1\n    depth = z_max - z_min + 1\n    \n    return 2 * (width * height + height * depth + depth * width)\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\nn = int(data[0])\n\nprint(min_panels(defective_cells))",
        "result": "failed: testcase 0"
    },
    "3520": {
        "body": "import sys\n\n    # Sort pills by their introduction time\n    pills.sort()\n    \n    # Initialize variables\n    max_age = n\n    current_age = 0\n    last_pill_index = -1\n    \n    for i in range(p):\n        t_i, x_i, y_i = pills[i]\n        \n        if t_i > 0:\n            # Age due to time passing without a pill\n            current_age += max(0, t_i - current_age)\n        \n        if last_pill_index >= 0 and last_pill_index != i:\n            # Age due to switching pills\n            current_age += c\n        \n        # Calculate the maximum age you can achieve with this pill\n        max_age = max(max_age, current_age + (x_i - y_i))\n        \n        # Update the last pill index\n        last_pill_index = i\n    \n    return max_age\n\n# Read input\nn, p, c = map(int, input().split())\npills = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output the result\nprint(max_life(n, p, c, pills))",
        "result": "failed: testcase 0"
    },
    "3475": {
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    n = int(data[index + 1])\n    index += 2\n    \n    transportation_types = []\n    for _ in range(t):\n        d_min = int(data[index])\n        a_max = int(data[index + 1])\n        transportation_types.append((d_min, a_max))\n        index += 2\n    \n    distances = []\n    headings = []\n    for _ in range(n - 1):\n        d_i = int(data[index])\n        h_i = int(data[index + 1])\n        distances.append(d_i)\n        headings.append(h_i)\n        index += 2\n    \n        d_min, a_max = transp_type\n        total_distance = sum(distances[start:end])\n        if total_distance < d_min:\n            return False\n        \n        for i in range(start + 1, end):\n            angle_diff = abs(headings[i - 1] - headings[i])\n            if angle_diff > a_max and (360000 - angle_diff) > a_max:\n                return False\n        return True\n    \n        calls = 0\n        current_type_index = 0\n        i = 0\n        \n        while i < n - 1:\n            found = False\n            for j in range(current_type_index, t):\n                if can_visit_with_transp_type(i, j + 2, transportation_types[j]):\n                    calls += 1\n                    current_type_index = j\n                    i = j + 1\n                    found = True\n                    break\n            if not found:\n                return \"IMPOSSIBLE\"\n        \n        return calls\n    \n    print(min_transp_calls())\n\nmin_transportations()",
        "result": "failed: testcase 0"
    },
    "3977": {
        "body": "import sys\n\n    # Create a set of government nodes for quick lookup\n    government_set = set(governments)\n    \n    # Count the number of edges that connect non-government nodes\n    valid_edges = 0\n    for u, v in edges:\n        if u not in government_set and v not in government_set:\n            valid_edges += 1\n    \n    # Calculate the maximum number of edges that can be added\n    max_possible_edges = (n - k) * (n - k - 1) // 2\n    additional_edges = max(0, max_possible_edges - valid_edges)\n    \n    return additional_edges\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\ngovernments = list(map(int, data[3:3+k]))\nedges = []\nindex = 3 + k\nfor _ in range(m):\n    u = int(data[index])\n    v = int(data[index + 1])\n    edges.append((u, v))\n    index += 2\n\n# Calculate and print the result\nresult = max_edges(n, m, k, governments, edges)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3626": {
        "body": "    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, x2, y2 = rectangles[i]\n            x3, y3, x4, y4 = rectangles[j]\n            if not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1):\n                return 1\n    return 0\n\n# Read input from stdin\nn = int(input())\nrectangles = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(do_rectangles_intersect(n, rectangles))",
        "result": "failed: testcase 0"
    },
    "3584": {
        "body": "import sys\nfrom scipy.spatial import ConvexHull\nfrom itertools import combinations\n\n    hull = ConvexHull(posts)\n    post_indices = set(hull.vertices)\n    \n        return sum(1 for onion in onions if all((post[0] - onion[0]) * (post[1] + post[1]) >= 0 for post in post_subset))\n    \n    max_protected = 0\n    for r in range(K, M + 1):\n        for post_subset in combinations(post_indices, r):\n            protected = count_protected_onions(post_subset)\n            if protected > max_protected:\n                max_protected = protected\n    \n    return max_protected\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nM = int(data[1])\nK = int(data[2])\n\nonions = []\nindex = 3\nfor _ in range(N):\n    X = int(data[index])\n    Y = int(data[index + 1])\n    onions.append((X, Y))\n    index += 2\n\nposts = []\nfor _ in range(M):\n    A = int(data[index])\n    B = int(data[index + 1])\n    posts.append((A, B))\n    index += 2\n\n# Output the result\nprint(max_onions_protected(N, M, K, onions, posts))",
        "result": "failed: testcase 0"
    },
    "3950": {
        "body": "    if any(x == 0 for x in a):\n        return \"NO\"\n    \n    result = [1] * n\n    for i in range(q - 1, -1, -1):\n        l = max(1, i + 1)\n        r = min(n, i + q - i)\n        if all(result[j] == j + 1 for j in range(l - 1, r)):\n            continue\n        else:\n            return \"NO\"\n    \n    return \"YES\\n\" + ' '.join(map(str, result))\n\n# Read input\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(can_be_obtained(n, q, a))",
        "result": "failed: testcase 0"
    },
    "3075": {
        "body": "    stations.sort()\n    tank = g\n    cost = 0\n    current_station = 0\n    \n    while current_station < n:\n        if stations[current_station][0] > tank:\n            return \"cancel road trip\"\n        \n        fuel_needed = stations[current_station][0] - tank\n        if fuel_needed > 0:\n            cost += fuel_needed * stations[current_station][1]\n            tank -= fuel_needed\n        \n        tank += g\n        current_station += 1\n    \n    return cost\n\n# Read input from stdin\nn, g = map(int, input().split())\nstations = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(min_cost_to_travel(n, g, stations))",
        "result": "failed: testcase 0"
    },
    "3711": {
        "body": "    if n * m - 1 < k or k > n + m - 2:\n        return -1\n    total_cuts = n + m - 2\n    remaining_cuts = total_cuts - k\n    min_side = min(n, m)\n    max_area = (n - remaining_cuts) * (m - remaining_cuts)\n    return max_area\n\n# Read input from stdin\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\n# Output the result\nprint(max_smallest_piece(n, m, k))",
        "result": "failed: testcase 0"
    }
}