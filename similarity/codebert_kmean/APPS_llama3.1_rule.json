{
    "4693": {
        "body": "import sys\n\n    a = int(input().split(' ')[0])\n    b = int(input().split(' ')[1])\n\n    if a + b >= 10:\n        return 'error'\n    else:\n        return str(a + b)\n\nprint(sum_numbers())",
        "result": "failed: testcase 0"
    },
    "4077": {
        "body": "import sys\n\n    pairs = 0\n    left = [n+1] * n\n    right = [-1] * n\n\n    for i in range(n-1, -1, -1):\n        curr = arr[i]\n        while i < len(arr) and curr >= arr[i]:\n            curr = arr[i]\n            j = left[i]\n            if arr[j] > m:\n                break\n            right[left[i]] = i\n            left[i] += 1\n\n    for i in range(n):\n        curr = arr[i]\n        while i < len(arr) and curr >= arr[i]:\n            curr = arr[i]\n            j = right[i]\n            if j == -1 or arr[j] <= m:\n                break\n            k = left[j-1]\n            pairs += (left[j-1] - max(i, left[j-1]))\n    return pairs\n\nn, m = map(int, input().split())\narr = list(map(int, input().split()))\nresult = find_pairs(n, m, arr)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4006": {
        "body": "import sys\n    num_set = set()\n    for _ in range(2000):  # arbitrary limit, should be enough\n        n += 1\n        while n >= 10:\n            n //= 10\n            last_digit = n % 10\n            n //= 10\n            if last_digit == 0:\n                break\n        num_set.add(n)\n    return len(num_set)",
        "result": "failed: testcase 0"
    },
    "4556": {
        "body": "    for char in s.split():\n        if char == 'AtCoder':\n            return f'{char[0]}{char[1]}C'\n\nprint(contest_name(input()))",
        "result": "failed: testcase 0"
    },
    "4571": {
        "body": "import sys\n\n    total = 0\n    for i in range(1, min(m+1, n+1)):\n        total += (i * 1900) / (2 ** i)\n    return int(total)\n\nn, m = map(int, input().split())\nprint(expected_time(n, m))",
        "result": "failed: testcase 0"
    },
    "4019": {
        "body": "import sys\nfrom collections import deque\n\n    graph = [[] for _ in range(n)]\n    degrees = [0] * n\n    edges = []\n    parent = [-1] * n\n\n    for i in range(m):\n        u, v = map(int, input().split())\n        if u > v:\n            u, v = v, u\n        graph[u].append(v)\n        graph[v].append(u)\n        degrees[u] += 1\n        degrees[v] += 1\n        edges.append((u, v))\n\n    visited = [False] * n\n\n    for i in range(1, D):\n        if degrees[0] < D:\n            return \"NO\"\n        visited[0] = True\n        for u in graph[0]:\n            if not visited[u]:\n                parent[u] = 0\n                visited[u] = True\n                break\n\n    for u in range(1, n):\n        if not visited[u]:\n            q = deque([u])\n            while q:\n                cu = q.popleft()\n                visited[cu] = True\n                for nu in graph[cu]:\n                    if not visited[nu]:\n                        parent[nu] = cu\n                        visited[nu] = True\n                        q.append(nu)\n\n    spanning_tree = []\n    for u, v in edges:\n        if u != 0 and v != 0 and (not visited[u] or not visited[v]):\n            spanning_tree.append((min(u, v), max(u, v)))\n        elif parent[u] == v or parent[v] == u:\n            spanning_tree.append((u, v))\n\n    if len(spanning_tree) < n - 1:\n        return \"NO\"\n\n    print(\"YES\")\n    for i in range(n - 1):\n        print(*spanning_tree[i])\n\nfind_spanning_tree(int(input().split()[0]), int(input().split()[1]), int(input().split()[2]))",
        "result": "failed: testcase 0"
    },
    "4265": {
        "body": "from collections import Counter\n\n    s_count = Counter()\n    t_count = Counter()\n\n    for i in range(len(S)):\n        s_count[S[i]] += 1\n        t_count[T[i]] += 1\n\n    operations = 0\n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        operations += abs(s_count[char] - t_count[char])\n\n    return operations - len(S)\n\nS = input()\nT = input()\n\nprint(min_operations(S, T))",
        "result": "failed: testcase 0"
    },
    "4657": {
        "body": "    prefix_sum = [0] * len(a)\n    for i in range(len(prefix_sum)):\n        if i > 0:\n            prefix_sum[i] = prefix_sum[i - 1]\n        if a[i] % 2 == 1:\n            prefix_sum[i] += 1\n\n    odd_count = sum(x % 2 == 1 for x in prefix_sum)\n    if odd_count < k or (odd_count - k) % 2 != 0:\n        return \"NO\"\n\n    result = []\n    start, end = 0, len(a)\n    for _ in range(k):\n        min_odd_idx = next((i for i, x in enumerate(prefix_sum[start:end]) if x % 2 == 1), None)\n        if min_odd_idx is not None:\n            result.append(min_odd_idx + 1)\n            start = end\n            end = prefix_sum[min_odd_idx] + 1\n        else:\n            result.append(end)\n            start += 1\n\n    return \"YES\\n\" + ' '.join(map(str, result))\n\nimport sys\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(split_array(a, k))",
        "result": "failed: testcase 0"
    },
    "4599": {
        "body": "import sys\n    num_cards, cards = map(int, input().split())\n    alices_score = 0\n    bobs_score = 0\n    for i in range(num_cards):\n        if i % 2 == 0:\n            alices_score += cards[i]\n        else:\n            bobs_score += cards[i]\n    return alices_score - bobs_score\n\nprint(optimal_game())",
        "result": "failed: testcase 0"
    },
    "4774": {
        "body": "import sys\n\n    a, b, c, d = map(int, input().split())\n    operators = ['+', '-', '*', '/']\n\n    for op1 in operators:\n        for op2 in operators:\n            try:\n                if eval(f'{a} {op1} {b} == {c} {op2} {d}') and op1 != op2:\n                    print(f'{a} {op1} {b} = {c} {op2} {d}')\n            except ZeroDivisionError:\n                continue\n    if not operators:\n        print('problems ahead')\n\nfind_expressions()",
        "result": "failed: testcase 0"
    },
    "4851": {
        "body": "import sys\n\n    num = n\n    while True:\n        digit_sum = sum(int(digit) for d in str(num))\n        if num % digit_sum == 0:\n            return num\n        num += 1\n\nn = int(input())\nprint(find_harshad_number(n))",
        "result": "failed: testcase 0"
    },
    "4655": {
        "body": "    for _ in range(q):\n        a, b, c = sorted(map(int, input().split()))[1:]\n        bob_gets = min(c, 2 * a + b)\n        alice_gets = (b + c) - bob_gets\n        print((alice_gets + bob_gets) // 2)\n\nmax_candies(int(input()))",
        "result": "failed: testcase 0"
    },
    "4132": {
        "body": "import sys\n\n    N = int(input())\n    A = list(map(int, input().split()))\n    B = sorted(A)\n    i = 1\n    while len(B) > 1 and B[-1] != B[-2]:\n        if B[-i] <= B[-(i + 1)]:\n            B[-i] -= B[-(i + 1)]\n        else:\n            B[-(i + 1)] -= B[-i]\n        i += 1\n    return B[-1]\n\nprint(findMinHealth())",
        "result": "failed: testcase 0"
    },
    "4085": {
        "body": "import sys\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        divisors = sorted([int(x) for x in input().split()])\n        \n        if len(divisors) != n:\n            print(-1)\n            continue\n        \n        sqrt_n = (divisors[0] ** 2 == divisors[-1]) and divisors[0] <= int((n / 2) ** 0.5)\n        \n        x = 1\n        if not sqrt_n and len(divisors) > 2:\n            for i in range(len(divisors)):\n                if divisors[i] != divisors[0]:\n                    x *= divisors[i]\n            x *= divisors[-1]\n            if n == 2 or divisors[0] * divisors[-1] < x:\n                print(-1)\n            else:\n                print(x)\n        elif sqrt_n and len(divisors) > 1:\n            for i in range(len(divisors)):\n                if divisors[i] != divisors[0]:\n                    x *= divisors[i]\n            x = divisors[0] * divisors[-1]\n            if n == 2 or divisors[0] * divisors[-1] < x:\n                print(-1)\n            else:\n                print(x)\n\nfind_min_x()",
        "result": "failed: testcase 0"
    },
    "4399": {
        "body": "import sys\n\n    stations_a = [0] * 3\n    for i in range(3):\n        if S[i] == 'A':\n            stations_a[i] = 1\n\n    count = 0\n    for i in range(3):\n        for j in range(i + 1, 3):\n            if stations_a[i] != stations_a[j]:\n                count += 1\n\n    return 'Yes' if count > 0 else 'No'\n\nS = input()\nprint(has_bus_service(S))",
        "result": "failed: testcase 0"
    },
    "4999": {
        "body": "import sys\n\n    ops = 0\n    while a != b:\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a += 1\n        ops += 1\n        if a == b: break\n        if a % 2 == 0:\n            a = a // 2\n        else:\n            a += 1\n        ops += 1\n    return ops\n\na, b = map(int, input().split())\nprint(min_operations(a, b))",
        "result": "failed: testcase 0"
    },
    "4727": {
        "body": "import sys\n\n    if grid[i][j] == 0:\n        return\n    for k in range(j + 1, 4):\n        if grid[i][k] != 0 and grid[i][k] == grid[i][j]:\n            grid[i][j] *= 2\n            grid[i][k] = 0\n            break\n\n    for i in range(4):\n        new_grid_row = [grid[i][0], 0, 0, 0]\n        j = 1\n        while j < 4:\n            if grid[i][j] != 0:\n                k = 1\n                while k < 4 and grid[i][k] == 0:\n                    new_grid_row[k] = grid[i][j]\n                    k += 1\n                merge(new_grid_row, 1)\n                merge(new_grid_row, 2)\n                merge(new_grid_row, 3)\n                break\n            else:\n                j += 1\n        for k in range(4):\n            grid[i][k] = new_grid_row[k]\n\n    for i in range(4):\n        new_grid_row = [0, 0, 0, 0]\n        j = 3\n        while j >= 0:\n            if grid[i][j] != 0:\n                k = 3\n                while k >= 0 and grid[i][k] == 0:\n                    new_grid_row[k] = grid[i][j]\n                    k -= 1\n                merge(new_grid_row, 2)\n                merge(new_grid_row, 1)\n                merge(new_grid_row, 0)\n                break\n            else:\n                j -= 1\n        for k in range(4):\n            grid[i][k] = new_grid_row[k]\n\n    for i in range(4):\n        new_grid_col = [grid[0][i], 0, 0, 0]\n        j = 1\n        while j < 4:\n            if grid[j][i] != 0:\n                k = 1\n                while k < 4 and grid[k][i] == 0:\n                    new_grid_col[k] = grid[j][i]\n                    k += 1\n                merge(new_grid_col, 1)\n                merge(new_grid_col, 2)\n                merge(new_grid_col, 3)\n                break\n            else:\n                j += 1\n        for k in range(4):\n            grid[k][i] = new_grid_col[k]\n\n    for i in range(4):\n        new_grid_col = [0, 0, 0, 0]\n        j = 3\n        while j >= 0:\n            if grid[j][i] != 0:\n                k = 3\n                while k >= 0 and grid[k][i] == 0:\n                    new_grid_col[k] = grid[j][i]\n                    k -= 1\n                merge(new_grid_col, 2)\n                merge(new_grid_col, 1)\n                merge(new_grid_col, 0)\n                break\n            else:\n                j -= 1\n        for k in range(4):\n            grid[k][i] = new_grid_col[k]\n\n    for i in range(4):\n        new_row = [grid[i][j] for j in range(4) if grid[i][j] != 0]\n        grid[i] = new_row + [0] * (4 - len(new_row))\n\n    for i in range(4):\n        print(' '.join(str(cell) for cell in grid[i]))\n\ngrid = []\nfor _ in range(4):\n    row = list(map(int, input().split()))\n    grid.append(row)\n\ndirection = int(input())\n\nif direction == 0:\n    move_left(grid)\nelif direction == 1:\n    move_up(grid)\nelif direction == 2:\n    move_right(grid)\nelse:\n    move_down(grid)\n\nfor i in range(4):\n    compress(grid[i])\n\nprint_grid(grid)",
        "result": "failed: testcase 0"
    },
    "4906": {
        "body": "import sys\n\n    encoded_message = ''\n    current_char = message[0]\n    count = 1\n    for i in range(1, len(message)):\n        if message[i] == current_char:\n            count += 1\n        else:\n            encoded_message += current_char + str(count)\n            current_char = message[i]\n            count = 1\n    encoded_message += current_char + str(count)\n    return encoded_message\n\n    decoded_message = ''\n    i = 0\n    while i < len(encoded_message):\n        char = encoded_message[i]\n        count = int(encoded_message[i+1])\n        decoded_message += char * count\n        i += 2\n    return decoded_message\n\nmode = input().strip()\nmessage = input().strip()\n\nif mode == 'E':\n    print(rle_encode(message))\nelif mode == 'D':\n    print(rle_decode(message))",
        "result": "failed: testcase 0"
    },
    "4011": {
        "body": "import sys\n\n    arr = list(map(int, f))\n    dp = [[0]*10 for _ in range(2)]\n    dp[0] = [0]*10\n\n    for i in range(len(a)):\n        prev_max = 1 if i > 0 else 0\n        for j in range(9):\n            curr_num = int(a[i])\n            new_val = (curr_num + arr[j]) % 10\n            dp[prev_max][j] = max(dp[(prev_max+1)%2][new_val], prev_max + (new_val > curr_num))\n\n    result = 0\n    for i in range(9):\n        result = max(result, dp[int(not bool(i))%2][i])\n\n    return str(int((result-int(bool(i)))*10**n))\n\nn = int(input())\na = input()\nf = input().split(' ')\nprint(max_number(n, a, f))",
        "result": "failed: testcase 0"
    },
    "4099": {
        "body": "import sys\n\n    total = sum(A)\n    avg = (total + x) / N for x in range(K+1)\n    if any(x >= M for x in avg):\n        return max(int(M * N - total), 0)\n    else:\n        return -1\n\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\nprint(min_points_to_score(N, K, M, A))",
        "result": "failed: testcase 0"
    },
    "4465": {
        "body": "a = int(input())\nb = int(input())\n\n    return a * b - 2 - 2\n\nresult = farm_area(a, b)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4315": {
        "body": "import math\n\n    circumference = 2 * math.pi * R\n    for i in range(0, 100):\n        if abs(circumference - round(circumference, 2)) <= 0.1:\n            return round(circumference, 2)\n        else:\n            circumference = round(circumference, 2)\n\nR = int(input())\nprint(circle_circumference(R))",
        "result": "failed: testcase 0"
    },
    "4633": {
        "body": "import sys\n\n    moves = 0\n    while True:\n        sum_digits = 0\n        for digit in str(n):\n            sum_digits += int(digit)\n        if sum_digits <= s:\n            return moves\n        n += 1\n        moves += 1\n\nt = int(input())\nfor _ in range(t):\n    n, s = map(int, input().split())\n    print(min_moves(n, s))",
        "result": "failed: testcase 0"
    },
    "4734": {
        "body": "import sys\n\n    if y[-1] == 'e':\n        return y + 'x' + p\n    elif y[-1] in ['a', 'i', 'o', 'u']:\n        vowel = y[-1]\n        return y[:-1].replace(vowel, '') + 'ex' + p\n    else:\n        return y + 'ex' + p\n\ny, p = input().split()\nprint(extend_apaxian_name(y, p))",
        "result": "failed: testcase 0"
    },
    "4229": {
        "body": "import sys\n\n    total = 0\n    i = 1\n    for _ in range(n):\n        if i % 15 == 0:\n            total += 'FizzBuzz'\n        elif i % 3 == 0:\n            total += 'Fizz'\n        elif i % 5 == 0:\n            total += 'Buzz'\n        else:\n            total += str(i)\n        i += 1\n    fizz_buzz_numbers = [int(num) for num in str(total).split(',') if num != 'Fizz' and num != 'Buzz']\n    return sum(fizz_buzz_numbers)\n\nn = int(input())\nprint(fizz_buzz_sum(n))",
        "result": "failed: testcase 0"
    },
    "4321": {
        "body": "import sys\n\n    for _ in range(k):\n        last_digit = n % 10\n        if last_digit != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\nn, k = map(int, input().split())\nprint(tanya_subtract(n, k))",
        "result": "failed: testcase 0"
    },
    "4503": {
        "body": "import sys\n\n    used = [False] * N\n    health_left = H\n    for i in range(N):\n        if health_left <= 0:\n            return True\n        used[i] = True\n        health_left -= A[i]\n        for j in range(N):\n            if not used[j]:\n                if health_left - A[j] <= 0:\n                    return True\n    return False\n\nH, N = map(int, input().split())\nA = list(map(int, input().split()))\nprint('Yes' if can_win_without_repeating(H, N, A) else 'No')",
        "result": "failed: testcase 0"
    },
    "4855": {
        "body": "import math\n    articles, impact_factor = map(int, input().split())\n    citations = math.ceil(articles * impact_factor)\n    return citations - articles\nprint(calculate_bribes())",
        "result": "failed: testcase 0"
    },
    "4704": {
        "body": "import sys\n\n    ans = float('inf')\n    for i in range(2, N + 1):\n        Snuke_sum = sum(cards[:i])\n        Raccoon_sum = sum(cards[i:])\n        diff = abs(Snuke_sum - Raccoon_sum)\n        if diff < ans:\n            ans = diff\n    return ans\n\nN = int(input())\ncards = list(map(int, input().split()))\nprint(min_diff(N, cards))",
        "result": "failed: testcase 0"
    },
    "4829": {
        "body": "    if left == 0 or right == 0:\n        return \"Not a moose\"\n    elif left == right:\n        return f\"Even {2 * left}\"\n    else:\n        return f\"Odd {2 * max(left, right)}\"\n\nleft, right = map(int, input().split())\nprint(moose_points(left, right))",
        "result": "failed: testcase 0"
    },
    "4730": {
        "body": "import sys\n\n    opening = {'(': ')', '[': ']', '{': '}'}\n    closing = {')': '(', ']': '[', '}': '{'}\n    stack = []\n    for i, char in enumerate(program):\n        if char in opening:\n            stack.append((char, opening[char]))\n        elif char in closing:\n            if not stack or stack[-1][0] != closing[char]:\n                return (char, i)\n            else:\n                stack.pop()\n    if len(stack) > 0:\n        first_opening, expected_closing = stack[0]\n        for j, char in enumerate(program[len(stack):]):\n            if char == expected_closing:\n                return (char, len(stack) + j)\n\n    n = int(input())\n    program = input()\n    result = match_delimiters(' ' + program)\n    if result is None or n <= len(result[1]):\n        print(\"ok so far\")\n    else:\n        char, loc = result\n        sys.stdout.write(char + \" \" + str(loc) + \"\\n\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4729": {
        "body": "import sys\n\n    password_chars = [None] * len(password)\n    for i in range(len(message)):\n        if password_chars[i % len(password)] == None:\n            char = message[i]\n            k = 0\n            while k < len(password) and password[k] != char:\n                k += 1\n            password_chars[i % len(password)] = (char, k + 1)\n    for i in range(len(password)):\n        if password_chars[i] == None or (password_chars[i][0], i + 1) != (password[i], len(password)):\n            return False\n    return True\n\nmessage = input()\npassword, msg = message.split()\nif is_valid_message(password, msg):\n    print('PASS')\nelse:\n    print('FAIL')",
        "result": "failed: testcase 0"
    },
    "4582": {
        "body": "    if a == 'H' or b == 'D':\n        return 'H'\n    else:\n        return 'D'\n\na = input()\nb = input()\n\nprint(game(a, b))",
        "result": "failed: testcase 0"
    },
    "4910": {
        "body": "import sys\n\n    categories = {}\n    for response in colleague_responses:\n        if response not in categories:\n            categories[response] = 1\n        else:\n            categories[response] += 1\n\n    max_count = -1\n    best_categories = []\n    for category, count in sorted(categories.items()):\n        if count > max_count:\n            max_count = count\n            best_categories = [category]\n        elif count == max_count:\n            best_categories.append(category)\n\n    return '\\n'.join(sorted(best_categories))\n\ncolleague_responses = []\nfor _ in range(int(input())):\n    colleague_responses.append(input())\n\nprint(most_win_categories(colleague_responses))",
        "result": "failed: testcase 0"
    },
    "4323": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    a = []\n    b = []\n\n    for i in range(n):\n        ai, bi = map(int, input().split())\n        a.append(ai)\n        b.append(bi)\n\n    for i in range(n - 1, -1, -1):\n        if sum(a[:i+1]) <= m:\n            return 0\n        elif sum(b[:i+1]) > m:\n            continue\n\n        num_compress = n\n        for j in range(i + 1, n):\n            if a[j] <= m:\n                num_compress -= 1\n            else:\n                break\n        if sum(a[:i+1]) - max(a[i], b[i]) - (sum(b[:i+1]) - min(a[i], b[i])) <= m and num_compress < n:\n            return num_compress\n\n    return -1\n\nprint(min_compress_songs())",
        "result": "failed: testcase 0"
    },
    "4626": {
        "body": "    a, b, c = sorted(map(int, input().split()))\n    return abs(a - b) + abs(b - c)\n\nfor _ in range(int(input())):\n    print(min_distance())",
        "result": "failed: testcase 0"
    },
    "4400": {
        "body": "import sys\n\n    s = input()\n    max_count = 0\n    current_count = 0\n    for char in s:\n        if char == 'R':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    return max_count\n\nprint(max_consecutive_rainy_days())",
        "result": "failed: testcase 0"
    },
    "4794": {
        "body": "import sys\n\n    free_spaces = 0\n    one_squashed = 0\n    two_squashed = 0\n    three_squashed = 0\n    four_squashed = 0\n\n    for row_index in range(len(map_)):\n        for col_index in range(len(map_[row_index])):\n            is_monster_truck_possible = True\n            if map_[row_index][col_index] == 'X':\n                is_monster_truck_possible = False\n            elif map_[row_index][col_index] == '#':\n                continue\n\n            if is_monster_truck_possible:\n                for i in range(row_index, row_index + 2):\n                    for j in range(col_index, col_index + 2):\n                        if (i < len(map_) and\n                            j < len(map_[i]) and\n                            map_[i][j] == 'X'):\n                            is_monster_truck_possible = False\n\n            if is_monster_truck_possible:\n                if row_index > 1 and col_index > 1:\n                    four_squashed += 1\n                elif row_index > 0 or col_index > 1:\n                    three_squashed += 1\n                elif row_index > 1 or col_index > 0:\n                    two_squashed += 1\n                else:\n                    one_squashed += 1\n\n    print(one_squashed)\n    print(two_squashed)\n    print(three_squashed)\n    print(four_squashed)\n\n    r, c = map(int, input().split())\n    map_ = [input() for _ in range(r)]\n    count_parking_spaces(map_)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4096": {
        "body": "    days = 0\n    total_pages = 0\n\n    for i in range(n):\n        if total_pages + max(0, a[i] - i) >= m:\n            return days + 1\n\n        total_pages += max(0, a[i] - i)\n\n        days += 1\n\n    return -1\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(min_days(n, m, a))",
        "result": "failed: testcase 0"
    },
    "4530": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    unique_skills = set(a)\n    count_dict = {}\n    for skill in a:\n        if skill not in count_dict:\n            count_dict[skill] = 0\n        count_dict[skill] += 1\n\n    distinct_count = len(count_dict)\n\n    max_size = 0\n    distinct_skills = list(unique_skills)[:distinct_count]\n\n    for x in range(1, min(distinct_count + 1, n + 1)):\n        can_form_team = True\n        team_a = set()\n        team_b = []\n\n        for i in range(x):\n            skill = distinct_skills[i]\n            if count_dict[skill] == 1:\n                team_a.add(skill)\n            else:\n                team_b.append((skill, count_dict[skill]))\n                while len(team_a) + len(team_b) >= x and not can_form_team:\n                    first_skill, first_count = team_b.pop(0)\n                    if first_count > 1:\n                        team_a.add(first_skill)\n\n        for skill in unique_skills - set(distinct_skills):\n            count = count_dict[skill]\n            if count > x or count == 1:\n                can_form_team = False\n                break\n\n        max_size = max(max_size, x) if can_form_team else max_size\n\n    return max_size\n\nfor _ in range(int(input())):\n    print(find_max_team_size())",
        "result": "failed: testcase 0"
    },
    "4724": {
        "body": "    R = int(input())\n    G = int(input())\n\n    for b in range(0, 4501):\n        a_avg_b = (R + b) / 2\n        if a_avg_b == G:\n            return b\n\nprint(find_performance())",
        "result": "failed: testcase 0"
    },
    "4276": {
        "body": "    n, t = map(int, input().split())\n    routes = []\n    for _ in range(n):\n        cost, time = map(int, input().split())\n        if time <= t:\n            routes.append((cost, time))\n    min_cost = TLE\n    for route in sorted(routes):\n        if route[1] > t:\n            break\n        min_cost = min(min_cost, route[0])\n    return str(min_cost) if min_cost != TLE else 'TLE'\n\nprint(find_smallest_cost())",
        "result": "failed: testcase 0"
    },
    "4708": {
        "body": "    n = int(input())\n    k = int(input())\n    x = int(input())\n    y = int(input())\n\n    total_fee = 0\n    for i in range(1, n + 1):\n        if i <= k:\n            total_fee += x\n        else:\n            total_fee += y\n\n    print(total_fee)\n\nhotel_fees()",
        "result": "failed: testcase 0"
    },
    "4396": {
        "body": "    n = int(input())\n    total_yen = 0\n    for i in range(n):\n        x, u = input().split()\n        x = float(x)\n        if u == \"JPY\":\n            total_yen += x\n        elif u == \"BTC\":\n            total_yen += x * 380000.0\n    print(total_yen)\n\ncalculate_otoshidama()",
        "result": "failed: testcase 0"
    },
    "4155": {
        "body": "import sys\n\n    N = int(input())\n    heights = list(map(int, input().split()))\n    max_heights = [0] * N\n\n    for i in range(N):\n        if heights[i] > max_heights[i]:\n            max_heights[i] = heights[i]\n\n    operations = 0\n    current_max = 0\n    for i in range(N):\n        current_max = max(current_max, max_heights[i])\n        if current_max != max_heights[i]:\n            operations += 1\n            current_max = max_heights[i]\n\n    print(operations)\n\nmin_watering_operations()",
        "result": "failed: testcase 0"
    },
    "4557": {
        "body": "import sys\n\n    for num_cats in range(X + 1):\n        if A >= num_cats and B >= (X - num_cats):\n            return 'YES'\n    return 'NO'\n\nA, B, X = map(int, input().split())\nprint(determine_cats(A, B, X))",
        "result": "failed: testcase 0"
    },
    "4930": {
        "body": "import re\n\n    words = s.split()\n    decoded_words = []\n    \n    for word in words:\n        i = 0\n        while i < len(word):\n            if word[i] in 'aeiou':\n                decoded_word = word[:i] + 'p' + word[i] + word[i+1:]\n                i += 2\n            else:\n                decoded_word = word[:i] + word[i]\n                i += 1\n        decoded_words.append(decoded_word)\n    \n    return ' '.join(decoded_words)\n\ns = input()\nprint(decode_luka_sentence(s))",
        "result": "failed: testcase 0"
    },
    "4715": {
        "body": "import sys\n\n    a, b, c = map(int, input().split())\n    unique_colors = set()\n    \n    for color in [a, b, c]:\n        if 1 <= color <= 100:\n            unique_colors.add(color)\n            \n    return len(unique_colors)\n\nprint(count_paint_cans())",
        "result": "failed: testcase 0"
    },
    "4008": {
        "body": "    a.sort()\n    colors = [0] * n\n    used_colors = 0\n    current_color = 1\n    duplicates_found = False\n\n    for i in range(n - 1, 0, -1):\n        if a[i] == a[i - 1]:\n            duplicates_found = True\n        while colors[i - 1] > 0 and current_color <= k:\n            if current_color != colors[i - 1]:\n                used_colors += 1\n                colors[i] = current_color\n                break\n            current_color += 1\n\n        if current_color > k or (a[i] == a[i - 1] and not duplicates_found):\n            return \"NO\"\n        else:\n            if a[i] != a[i - 1]:\n                used_colors += 1\n                colors[i] = current_color\n\n    for i in range(n):\n        if colors[i] == 0:\n            colors[i] = 1\n\n    return \"YES\\n\" + ' '.join(map(str, colors))\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(color_array(n, k, a))",
        "result": "failed: testcase 0"
    },
    "4257": {
        "body": "a = int(input())\nb = int(input())\n\nproduct = a * b\n\nprint(product)",
        "result": "failed: testcase 0"
    },
    "4584": {
        "body": "    immediate_subordinates = [0] * N\n    for i in range(1, N):\n        if A[i - 1] == i:\n            continue\n        immediate_subordinates[A[i - 1] - 1] += 1\n        immediate_subordinates[i - 1] += 1\n    return \"\\n\".join(str(subordinate) for subordinate in immediate_subordinates)\n\nN = int(input())\nA = list(map(int, input().split()))\nprint(get_immediate_subordinates(N, A))",
        "result": "failed: testcase 0"
    },
    "4195": {
        "body": "    D, n = map(int, input().split())\n    if D == 0:\n        for i in range(1, N + 1):\n            yield i\n    elif D == 1:\n        for k in range(N):\n            yield k * 100 + 1\n\nsmallest = list(find_smallest(int(input())))\nprint(smallest[-1])",
        "result": "failed: testcase 0"
    },
    "4176": {
        "body": "import sys\n\n    a, b = map(int, input().split())\n    min_a = 0\n    for pieces in range(1, a*b + 1):\n        if a % pieces == 0 and b % (pieces // a) == 0:\n            min_a = pieces\n    return min_a\n\nprint(find_min_pieces())",
        "result": "failed: testcase 0"
    },
    "4166": {
        "body": "import sys\n\n    N = int(input())\n    M = int(input().split()[1])\n    digits = []\n    for i in range(M):\n        s, c = map(int, input().split())\n        digits.append((s - 1, c))\n    min_num = 10 ** (N - 1)\n    for num in range(min_num, 10 ** N + 1):\n        valid = True\n        num_str = str(num)\n        for s, c in digits:\n            if int(num_str[s]) != c:\n                valid = False\n                break\n        if valid:\n            return num\n    return -1\n\nprint(find_integer())",
        "result": "failed: testcase 0"
    },
    "4827": {
        "body": "import sys\n\n    if num < 10:\n        return {\n            1: 'one', 2: 'two', 3: 'three', 4: 'four',\n            5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine', 0: ''\n        }[num]\n    elif num < 20:\n        return {\n            11: 'eleven', 12: 'twelve', 13: 'thirteen',\n            14: 'fourteen', 15: 'fifteen', 16: 'sixteen',\n            17: 'seventeen', 18: 'eighteen', 19: 'nineteen'\n        }[num]\n    else:\n        return {\n            2: '', 3: 'onehundred', 4: 'twohundred',\n            5: 'threehundred', 6: 'fourhundred', 7: 'fivehundred',\n            8: 'sixhundred', 9: 'sevenhundred'\n        }[num // 100] + (name_number(num % 100) if num % 100 != 0 else '')\n\n    return len(word)\n\n    result = ''\n    for word in words:\n        result += word + ' '\n        if word == '$':\n            target_word = name_number(target_length)\n            result = result.rstrip() + ' ' + target_word\n            break\n    return result.strip()\n\nn = int(input())\nwords = []\nfor _ in range(n):\n    words.append(input().strip())\n\ntotal_length = sum(count_letters(word) for word in words if word != '$')\ntarget_word = name_number(total_length)\nprint(generate_sentence(words, total_length))",
        "result": "failed: testcase 0"
    },
    "4871": {
        "body": "    n = len(scores)\n    group_score = 0\n    for i in range(n):\n        group_score += scores[i] * ((4 / 5) ** i)\n    return group_score / 5.0\n\n    new_scores_sum = 0\n    for i in range(n):\n        other_scores = scores[:i] + scores[i+1:]\n        group_score = calc_group_score(other_scores)\n        new_scores_sum += group_score\n    return new_scores_sum / n\n\nn = int(input())\nscores = [float(input()) for _ in range(n)]\ngroup_score = calc_group_score(scores)\naverage_new_score = average_new_scores(n, scores)\n\nprint(\"%f\" % group_score)\nprint(\"%f\" % average_new_score)",
        "result": "failed: testcase 0"
    },
    "4148": {
        "body": "import sys\n\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    shifted_S = ''\n    for s in S:\n        index = (alphabet.index(s) + N) % 26\n        shifted_S += alphabet[index]\n    return shifted_S\n\nN = int(input())\nS = input()\nprint(shift_string(N, S))",
        "result": "failed: testcase 0"
    },
    "4316": {
        "body": "from collections import Counter\n\n    counts = Counter(sorted(S))\n    kinds = len(counts)\n    for count in counts.values():\n        if count != 2:\n            return False\n    return kinds == 2\n\nS = input()\nprint('Yes' if has_two_kinds(S) else 'No')",
        "result": "failed: testcase 0"
    },
    "4397": {
        "body": "    N, i = map(int, input().split())\n    j = N - i + 1\n    return j\n\nprint(find_car())",
        "result": "failed: testcase 0"
    },
    "4180": {
        "body": "import sys\n\n    min_bills = N // 1000\n    N %= 1000\n    change = 0\n    for i in range(min_bills, -1, -1):\n        if 1000 * i <= N:\n            change += (N - 1000 * i)\n            break\n    return change\n\nN = int(input())\nprint(calc_change(N))",
        "result": "failed: testcase 0"
    },
    "4907": {
        "body": "n = int(input())\n\nfor length in range(n, 0, -1):\n    if length * 3 <= n and (n - length) % 2 == 1:\n        print('Alice')\n        print(length)\n        break\nelse:\n    print('Bob')",
        "result": "failed: testcase 0"
    },
    "4839": {
        "body": "import sys\n\n    cans.sort()\n    total = sum(cans)\n    if total < n:\n        return \"impossible\"\n    \n    max_fill = 0\n    for i in range(1, n + 1):\n        canister_capacity = min(i, total - (n - i))\n        fraction = (total - canister_capacity) / (i * (n + 1))\n        if fraction > max_fill:\n            max_fill = fraction\n    \n    return str(max_fill)\n\nn = int(input())\ncans = list(map(int, input().split()))\nprint(max_fill(n, cans))",
        "result": "failed: testcase 0"
    },
    "4665": {
        "body": "from collections import namedtuple\nimport sys\n\n    n = int(input())\n    column_names = list(map(str, input().split()))\n    marks_index = -1\n    for i in range(len(column_names)):\n        if 'MARKS' == column_names[i]:\n            marks_index = i\n            break\n    student_info = []\n    for _ in range(n):\n        info = namedtuple('StudentInfo', ', '.join(column_names))(input())\n        student_info.append(info)\n    total_marks = sum(getattr(student, 'MARKS') for student in student_info)\n    average_mark = (total_marks / n) if n != 0 else 0\n    print(f'{average_mark:.2f}')\n\ncalculate_average_marks()",
        "result": "failed: testcase 0"
    },
    "4785": {
        "body": "import sys\n\n    prev_char = None\n    for char in input_string:\n        if char == 's' and prev_char == 's':\n            return 'hiss'\n        prev_char = char\n    return 'no hiss'\n\ninput_string = input()\nprint(check_for_hissing_s(input_string))",
        "result": "failed: testcase 0"
    },
    "4272": {
        "body": "import sys\n\n    n = len(S)\n    count = 0\n    for i in range(n - 2):\n        if S[i] == 'A' and S[i + 1] == 'B' and S[i + 2] <= 'C':\n            count += 1\n    return count\n\nn, S = input().split()\nprint(count_abc(S))",
        "result": "failed: testcase 0"
    },
    "4092": {
        "body": "    cur_sum = 0\n    count = 0\n    for i in range(n):\n        cur_sum += arr[i]\n        if cur_sum == 0:\n            count += 1\n            cur_sum = arr[i]\n        elif cur_sum < 0:\n            count += 1\n            cur_sum = -cur_sum\n    return count\n\nn = int(input())\narr = list(map(int, input().split()))\nprint(min_integers_to_insert(n, arr))",
        "result": "failed: testcase 0"
    },
    "4023": {
        "body": "import sys\n\n    min_height = heights[0]\n    for height in heights:\n        if height < min_height:\n            return \"NO\"\n        min_height = height\n    max_height = heights[0]\n    for i in range(1, n):\n        if heights[i] != heights[i - 1]:\n            max_height = heights[i - 1]\n            break\n    for i in range(n - 2, -1, -1):\n        if heights[i] != heights[i + 1]:\n            max_height = heights[i + 1]\n            break\n    return \"YES\" if min_height == max_height else \"NO\"\n\nn = int(input())\nheights = list(map(int, input().split()))\nprint(can_complete_wall(n, heights))",
        "result": "failed: testcase 0"
    },
    "4160": {
        "body": "import math\n    x = int(input())\n    years = 0\n    balance = 100\n    while True:\n        if balance >= x:\n            return years\n        balance += 1.01 * balance - math.floor(1.01 * balance)\n        years += 1\n\nprint(bank_balance_reached())",
        "result": "failed: testcase 0"
    },
    "4815": {
        "body": "import sys\n\n    n, p, m = map(int, input().split())\n    names = []\n    scores = {}\n    for _ in range(n):\n        name = input()\n        names.append(name)\n    for _ in range(m):\n        name, points = input().split()\n        if name not in scores:\n            scores[name] = 0\n        scores[name] += int(points)\n\n    winners = []\n    threshold_reached = False\n\n    for name in sorted(names):\n        if scores[name] >= p:\n            threshold_reached = True\n            print(f\"{name} wins!\")\n            winners.append(name)\n        elif threshold_reached and scores[name] < p:\n            break\n\n    if not threshold_reached:\n        print(\"No winner!\")\n\nfind_winners()",
        "result": "failed: testcase 0"
    },
    "4514": {
        "body": "    subordinates = []\n    stack = [(u, p)]\n    while stack:\n        u, parent = stack.pop()\n        for v in range(n + 1, n + m + 1):\n            if tree[v][0] == u and not seen[v]:\n                stack.append((v, u))\n        subordinates.append(u)\n        seen[u] = True\n    return subordinates\n\n    order = [1]\n    for i in range(2, n + 1):\n        if not seen[i]:\n            subordinates = find_subordinates(i, 1)\n            order.extend(subordinates)\n    return order\n\n    order = dfs_order()\n    idx = order.index(k)\n    if idx < u - 1:\n        return -1\n    else:\n        return order[idx]\n\nn, m = map(int, input().split())\ntree = [[0] * 2 for _ in range(n + m + 1)]\nseen = [False] * (n + m + 1)\np_list = list(map(int, input().split()))\nfor i in range(2, n + 1):\n    tree[i][0] = p_list[i - 2]\ntree[1][0] = 0\nfor i in range(n + 1, n + m + 1):\n    seen[i] = True\n\nfor _ in range(m):\n    u, k = map(int, input().split())\n    print(query(u, k))",
        "result": "failed: testcase 0"
    },
    "4585": {
        "body": "import sys\n\n    x = int(input())\n    for t in range(1, 10**9):\n        if x - t <= 0 <= x + t:\n            return t\n        if t ** 2 >= 4 * x:\n            return None\n        t_squared = t ** 2\n\n    print(find_earliest_time())\n\nmain()",
        "result": "failed: testcase 0"
    },
    "4781": {
        "body": "import sys\n\n    players = [0]*9\n    for _ in range(n):\n        t, z = input().split()\n        t = int(t)\n        if z == \"T\":\n            k = (k + t - 1) % 8 + 1\n        elif z != \"P\":\n            k = (k + 1000 - 1) % 8 + 1\n    return k\n\nk = int(input())\nn = int(input())\nprint(box_explodes(k, n))",
        "result": "failed: testcase 0"
    },
    "4551": {
        "body": "import sys\n\n    left_weight = A + B\n    right_weight = C + D\n    \n    if left_weight < right_weight:\n        return \"Left\"\n    elif left_weight > right_weight:\n        return \"Right\"\n    else:\n        return \"Balanced\"\n\nA, B, C, D = map(int, input().split())\nprint(balance_scale(A, B, C, D))",
        "result": "failed: testcase 0"
    },
    "4345": {
        "body": "    n = len(a)\n    increasing = [0] * n\n    decreasing = [1] * n\n\n    for i in range(n):\n        if i > 0:\n            if a[i - 1] < a[i]:\n                increasing[i] = increasing[i-1]\n            elif a[i - 1] == a[i]:\n                increasing[i] = 2\n            else:\n                increasing[i] = 3\n\n            if a[i - 1] > a[i]:\n                decreasing[i] = decreasing[i-1]\n            elif a[i - 1] == a[i]:\n                decreasing[i] = 2\n            else:\n                decreasing[i] = 3\n\n    for i in range(n):\n        if increasing[i] >= 3 or decreasing[i] >= 3:\n            return \"NO\"\n\n    res = [0] * n\n    for i in range(n):\n        if increasing[i] != 2 and decreasing[i] == 2:\n            res[i] = 1\n\n    return [\"YES\", ' '.join(map(str, res))]\n\nn = int(input())\na = list(map(int, input().split()))\nprint(insertions(a)[0])\nif insertions(a)[0] == \"YES\":\n    print(\" \".join(map(str,insertions(a)[1])))",
        "result": "failed: testcase 0"
    },
    "4075": {
        "body": "import sys\n\n    N, M = map(int, input().split())\n    bulbs_on = [0] * (M + 1)\n    k_values = []\n    p_values = []\n\n    for _ in range(M):\n        line = list(map(int, input().split()))\n        k_i = line[0]\n        switches = line[1:]\n        for s_ij in switches:\n            if bulbs_on[s_ij] == 0:\n                k_values.append((s_ij, k_i))\n                for j in range(k_i):\n                    bulbs_on[switches[j]] += (j % 2) * 2 - 1\n        p_values.append(line[-1])\n\n    total_combinations = 2 ** N\n    for i in range(1, N + 1):\n        if bulbs_on[i] == 0:\n            k_i = [k for s, k in k_values if s == i][0]\n            total_combinations //= k_i\n\n    remaining_bulbs = sum(p % 2 != p_values[i] % 2 and k > 0 for i, (s, k) in enumerate(k_values))\n    return int(total_combinations * 1 if remaining_bulbs else 0)\n\nprint(count_combinations())",
        "result": "failed: testcase 0"
    },
    "4408": {
        "body": "import sys\n\n    n, k = map(int, input().split())\n    cards = list(map(int, input().split()))\n    favorite_numbers = list(map(int, input().split()))\n\n    h_values = sorted(map(int, input().split()), reverse=True)\n\n    max_joy_levels = 0\n    for t in range(k):\n        counts = [0] * 10**5\n        for f in favorite_numbers:\n            counts[f] += 1\n\n        remaining_cards = cards[:]\n        assigned_cards = [[] for _ in range(n)]\n        for i in range(len(cards)):\n            if counts[cards[i]] == 0 or len(assigned_cards[n - 1]) >= k:\n                continue\n            assigned_cards[counts[cards[i]]].append(cards[i])\n            remaining_cards.remove(cards[i])\n            counts[cards[i]] += 1\n\n        total_joy = 0\n        for i in range(n):\n            card_count = len(assigned_cards[i])\n            if card_count == 0:\n                continue\n            joy_level = h_values[card_count - 1]\n            total_joy += joy_level * (k - card_count)\n            assigned_cards[i] = []\n\n        for c in remaining_cards:\n            f_index = favorite_numbers.index(min(favorite_numbers, key=lambda x:abs(x-c)))\n            assigned_cards[f_index].append(c)\n\n        max_joy_levels = max(max_joy_levels, total_joy)\n\n    print(max_joy_levels)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4282": {
        "body": "import sys\n\n    seen = [0] * n\n    for i in range(n):\n        next1, next2 = 0, 0\n        for j in range(i + 1, n) + [i]:\n            if kids[j][0] == i + 1:\n                next1 = j\n            elif kids[j][0] == i:\n                next1 = kids[j][1]\n            elif kids[j][1] == i + 1:\n                next2 = j\n            elif kids[j][1] == i:\n                next2 = kids[j][0]\n\n        if seen[next1] and seen[next2]:\n            continue\n\n        for kid in [next1, next2]:\n            seen[kid] = 1\n\n        x, y = sorted([next1, next2])\n        ans.append(i + 1)\n        ans.extend(sorted([x + 1, y + 1]))\n    return ' '.join(map(str, ans))\n\nn = int(input())\nkids = [list(map(int, input().split())) for _ in range(n)]\nprint(restore_circle(n, kids))",
        "result": "failed: testcase 0"
    },
    "4331": {
        "body": "    n_str = str(n)\n    found = False\n    for i in range(3):\n        if n_str[i] == '7':\n            found = True\n            break\n    return \"Yes\" if found else \"No\"\n\nn = int(input())\nprint(check_n(n))",
        "result": "failed: testcase 0"
    },
    "4550": {
        "body": "    a, b, c = map(int, input().split())\n\n    sum_packs = a + b + c\n    if sum_packs % 2 == 0:\n        max_pack = max(a, b, c)\n        min_pack = min(a, b, c)\n\n        for i in range(max_pack - 1, -1, -1):\n            for j in range(i + 1, max_pack):\n                if (i * 2 + j * 2) == sum_packs and (min_pack == i or min_pack == j):\n                    return 'Yes'\n\n    return 'No'\n\nprint(is_distributable())",
        "result": "failed: testcase 0"
    },
    "4271": {
        "body": "    n = int(input())\n    a_values = list(map(int, input().split()))\n    b_values = list(map(int, input().split()))\n    c_values = list(map(int, input().split()))\n\n    satisfaction_points = 0\n    for i in range(n):\n        if i == (n - 1):\n            satisfaction_points += b_values[a_values[i] - 1]\n        else:\n            satisfaction_points += b_values[a_values[i] - 1] + c_values[i]\n\n    return satisfaction_points\n\nprint(calculate_satisfaction_points())",
        "result": "failed: testcase 0"
    },
    "4848": {
        "body": "import math\n\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            return False\n    return True\n\nn = int(input())\nfor m in range(2, n):\n    if is_squarefree(m * n):\n        print(m)\n        break",
        "result": "failed: testcase 0"
    },
    "4694": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    min_dist = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = (a[j] - a[i]) * 2\n            for k in range(n):\n                if k != i and k != j:\n                    dist += abs(a[k] - a[i])\n                    dist += abs(a[k] - a[j])\n\n            min_dist = min(min_dist, dist)\n\n    return min_dist\n\nprint(min_distance())",
        "result": "failed: testcase 0"
    },
    "4213": {
        "body": "import sys\n\n    min_val = abs(A[0])\n    max_val = 0\n    for num in A:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n    return max_val - min_val\n\nN = int(input())\nA = [int(x) for x in input().split()]\nprint(max_abs_diff(A))",
        "result": "failed: testcase 0"
    },
    "4471": {
        "body": "import sys\n\n    min_height = 1000000\n    for i in range(1, n + 1):\n        if a[i] > 0:\n            min_height = min(min_height, (a[i] - 1) // 2)\n    return min_height >= max(a)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print('YES' if can_clear_field(n, a) else 'NO')",
        "result": "failed: testcase 0"
    },
    "4802": {
        "body": "    hours, minutes = sorted(map(int, input().split()))\n    adjusted_minutes = minutes - 45\n    if adjusted_minutes < 0:\n        adjusted_hours = (hours - 1) % 24\n        adjusted_minutes += 60\n    else:\n        adjusted_hours = hours\n    print(f\"{adjusted_hours} {adjusted_minutes}\")",
        "result": "passed"
    },
    "4890": {
        "body": "import sys\n\n    slots = []\n    for i in range(s):\n        if c[i] < d:\n            slots.append((i, c[i]))\n\n    slots.sort(key=lambda x: (x[1], -x[0]))\n    slots.reverse()\n\n    max_m_in_slot = sum(c) + n\n    if max_m_in_slot <= m * d:\n        ans = [0] * s\n        for i in range(s):\n            if slots[i][1] < d and len(ans) < n:\n                ans[slots[i][0]] += min(d - slots[i][1], n - len(ans))\n        return ' '.join(map(str, ans))\n\n    return \"impossible\"\n\nn, m, s, d = map(int, input().split())\nc = list(map(int, input().split()))\nprint(refill_soda(n, m, s, d, c))",
        "result": "failed: testcase 0"
    },
    "4286": {
        "body": "import sys\nfrom collections import defaultdict\n\n    n, m = map(int, input().split())\n    a = [0] + list(map(int, input().split()))\n    edges = []\n    for _ in range(m):\n        x, y, w = map(int, input().split())\n        edges.append([x, y, w])\n\n    adj = defaultdict(list)\n    for i in range(1, n+1):\n        adj[i].append(i)\n\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n        rootx = find(x)\n        rooty = find(y)\n        if rootx == rooty:\n            return\n        if rank[rootx] > rank[rooty]:\n            parent[rooty] = rootx\n        else:\n            parent[rootx] = rooty\n            if rank[rootx] == rank[rooty]:\n                rank[rooty] += 1\n\n        for j in adj[i]:\n            if find(j) != find(i):\n                union(i, j)\n                dfs(j)\n\n    connected_components = n\n    cost = sum(a)\n    edges.sort(key=lambda x: a[x[0]] + a[x[1]])\n    for u, v, w in edges:\n        if find(u) != find(v):\n            union(u, v)\n            cost -= (a[u] + a[v]) - w\n            connected_components -= 1\n    if connected_components > 1:\n        dfs(1)\n        return sum(a) - cost\n\n    sys.stdout.write(str(cost))\n\nmin_coins_to_connect_graph()",
        "result": "failed: testcase 0"
    },
    "4713": {
        "body": "import sys\n\n    x = 0\n    max_val = 0\n    for c in S:\n        if c == 'I':\n            x += 1\n        elif c == 'D':\n            x -= 1\n        max_val = max(max_val, x)\n    return max_val\n\nN = int(input())\nS = input()\nprint(find_max_x(N, S))",
        "result": "failed: testcase 0"
    },
    "4698": {
        "body": "import sys\n\n    time_with_drink = [0] * M\n    for i in range(M):\n        total_time = 0\n        for j in range(N):\n            if P[j] - 1 == i:\n                total_time += X[i]\n            else:\n                total_time += T[j]\n        time_with_drink[i] = total_time\n\n    return time_with_drink\n\nN = int(input())\nT = list(map(int, input().split()))\nM = int(input())\nP = [0] * N\nX = [0] * M\n\nfor i in range(M):\n    p, x = map(int, input().split())\n    P[p - 1] = x\n\ntime_with_drink = calculate_time(N, T, M, P, X)\n\nfor time in time_with_drink:\n    print(time)",
        "result": "failed: testcase 0"
    },
    "4841": {
        "body": "import sys\n\n    n = int(input())\n    words = list(map(str, input().split()))\n    prev_num = 0\n    for word in words:\n        if word == \"mumble\":\n            continue\n        num = int(word)\n        if num < prev_num or (num - prev_num) != len(words) - words.index(word):\n            return \"something is fishy\"\n        prev_num = num\n    return \"makes sense\"\n\nprint(count_mouthfuls())",
        "result": "failed: testcase 0"
    },
    "4865": {
        "body": "import sys\n\n    for _ in range(n):\n        direction, minutes_change, hour, minute = input().split()\n        minutes_change = int(minutes_change)\n        minute = int(minute)\n\n        if direction == 'F':\n            minute += minutes_change\n        else:\n            minute -= minutes_change\n\n        while minute < 0:\n            minute += 60\n            hour -= 1\n\n        while minute >= 60:\n            minute -= 60\n            hour += 1\n\n        print(f\"{hour} {minute}\")\n\ncalculate_time(int(input()))",
        "result": "failed: testcase 0"
    },
    "4957": {
        "body": "import sys\n\n    n = len(grid)\n    m = len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[False for _ in range(m)] for _ in range(n)]\n\n        return 0 <= i < n and 0 <= j < m\n\n        if not is_valid(i, j) or visited[i][j]:\n            return\n        grid[i][j] = 'E'\n        for d in directions:\n            x, y = i + d[0], j + d[1]\n            if is_valid(x, y) and grid[x][y] == '.' and not visited[x][y]:\n                dfs(x, y)\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                continue\n            for d in directions:\n                x, y = i + d[0], j + d[1]\n                if is_valid(x, y) and grid[x][y] == 'E':\n                    dfs(i, j)\n                    break\n\n    return grid\n\ngrid = [list(input()) for _ in range(int(input().split()[0]))]\nresult = add_cafes(grid)\nfor row in result:\n    print(''.join(row))\n\nThis code defines a function `add_cafes` that takes the input grid as a 2D list and applies DFS from each land cell to find a valid placement of coffee shops. The main part of the script reads the input, calls this function on the grid, and prints the result.",
        "result": "failed: testcase 0"
    },
    "4382": {
        "body": "    n = int(input())\n    total = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                total += 1\n    print(total)",
        "result": "passed"
    },
    "4456": {
        "body": "import sys\n\n    n, k = map(int, input().split())\n    p = list(map(int, input().split()))\n    q = list(map(int, input().split()))\n\n    chars = [[] for _ in range(26)]\n    for i in range(n):\n        chars[p[i] - 1].append(chr(ord('a') + (q[i] - 1) % k))\n        chars[q[i] - 1].append(chr(ord('a') + (p[i] - 1) % k))\n\n    s = [''] * n\n    count = [0] * 26\n\n    for i in range(n):\n        c = 0\n        while c < len(chars[p[i] - 1]):\n            if count[ord(chars[p[i] - 1][c]) - ord('a')] >= k:\n                c += 1\n                continue\n            s[i] = chars[p[i] - 1][c]\n            count[ord(s[i]) - ord('a')] += 1\n            break\n\n    if count.count(0) > (k - 1):\n        return 'NO'\n\n    for i in range(n):\n        c = 0\n        while c < len(chars[q[i] - 1]):\n            s[i] = max(s[i], chars[q[i] - 1][c])\n            count[ord(s[i]) - ord('a')] += 1\n            if count.count(0) <= (k - 1):\n                break\n            c += 1\n\n    return 'YES\\n' + ''.join(s)\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "4594": {
        "body": "import sys\n\n    n = int(input())\n    diameters = sorted([int(input()) for _ in range(n)], reverse=True)\n\n    layers = 1\n    current_diameter = diameters[0]\n\n    for diameter in diameters[1:]:\n        if diameter < current_diameter:\n            layers += 1\n            current_diameter = diameter\n\n    return layers\n\nprint(max_kagami_mochi_layers())",
        "result": "failed: testcase 0"
    },
    "4560": {
        "body": "import sys\n\n    count_500_yen = 0\n    remaining_n = n\n\n    while True:\n        if remaining_n < 500 * count_500_yen:\n            break\n        else:\n            remaining_n -= 500\n            count_500_yen += 1\n\n    for _ in range(count_500_yen + 1):\n        multiple_of_500 = 500 * _\n        one_yen_needed = n - multiple_of_500\n\n        if one_yen_needed < 0 or one_yen_needed % 1 != 0:\n            break\n        else:\n            count_1_yen = int(one_yen_needed)\n            a_remaining = a - count_1_yen\n\n            if a_remaining >= 0 and (remaining_n == 0 or n == remaining_n):\n                return \"Yes\"\n\n    return \"No\"\n\nn, a = [int(x) for x in input().split()]\nresult = can_pay_exactly_n_yen(n, a)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4320": {
        "body": "    n = int(input())\n    for x in range(1, n + 1):\n        k = 2\n        sum = 0\n        while True:\n            sum += x * (k - 1)\n            if sum >= n:\n                break\n            k += 1\n        if sum == n:\n            return x\n\nfor _ in range(int(input())):\n    print(find_x())",
        "result": "failed: testcase 0"
    },
    "4500": {
        "body": "import sys\n\n    a, b, c = map(int, input().split())\n\n    for i in range(min(a, b) + 1):\n        total_yen = a - i + b - (min(a, b) - i)\n        \n        if total_yen >= c:\n            print('Yes')\n            return\n\n    print('No')\n\ntakahashi_coin_problem()",
        "result": "failed: testcase 0"
    },
    "4739": {
        "body": "import sys\n\n    M, N = map(int, input().split())\n    times = list(map(int, input().split()))\n    milestones = list(map(int, input().split()))\n\n    possible_distances = set()\n    for i in range(M):\n        for j in range(i + 1, M):\n            distance = (milestones[j] - milestones[i]) * 137.800000000000 / (times[j] - times[i])\n            if int(distance) <= milestones[-1]:\n                possible_distances.add(int(distance))\n\n    print(len(possible_distances))\n    print(' '.join(map(str, sorted(possible_distances))))\n\nmilestone_speed()",
        "result": "failed: testcase 0"
    },
    "4410": {
        "body": "    count = 0\n    max_ones = 1\n    index_of_last_one = -k-1\n    for i in range(n):\n        if s[i] == '0':\n            if i >= index_of_last_one + k + 1:\n                index_of_last_one = i\n                count += 1\n        elif i - index_of_last_one > k and max_ones < count:\n            max_ones = count\n    return max(max_ones, count)\n\nfor _ in range(int(input())):\n    n, k = map(int, input().split())\n    s = input()\n    print(max_tables(n, k, s))",
        "result": "failed: testcase 0"
    },
    "2441": {
        "body": "import sys\nfrom collections import deque\n\n    visited = set()\n    reachable_costs = [[] for _ in range(n)]\n    road_map = [[] for _ in range(n)]\n\n    for i in range(n):\n        visited.add(i)\n\n    for u, v in roads:\n        road_map[u - 1].append(v - 1)\n        if u not in visited or v not in visited:\n            continue\n        reachable_costs[u - 1].append(costs[v - 1])\n        reachable_costs[v - 1].append(costs[u - 1])\n\n    min_cost = [float('inf')] * n\n    for i in range(n):\n        queue = deque()\n        if costs[i] < min_cost[i]:\n            min_cost[i] = costs[i]\n            queue.append((i, costs[i]))\n\n        while queue:\n            current_junction, current_min_cost = queue.popleft()\n\n            for adjacent_junction in road_map[current_junction]:\n                if costs[adjacent_junction] + current_min_cost < min_cost[adjacent_junction]:\n                    min_cost[adjacent_junction] = costs[adjacent_junction] + current_min_cost\n                    reachable_costs[adjacent_junction].append(min_cost[adjacent_junction])\n                    queue.append((adjacent_junction, min_cost[adjacent_junction]))\n\n    dp = [[0 for _ in range(2)] for _ in range(n)]\n    count_set = set()\n\n        if current_junction not in visited:\n            return\n\n        visited.add(current_junction)\n        dp[current_junction][0] = min_cost[current_junction]\n        dp[current_junction][1] = 1\n\n        for adjacent_junction, cost in enumerate(reachable_costs[current_junction]):\n            dfs(adjacent_junction)\n\n            if dp[adjacent_junction][0] + cost < dp[current_junction][0]:\n                dp[current_junction][0] = dp[adjacent_junction][0] + cost\n                dp[current_junction][1] = dp[adjacent_junction][1]\n\n            elif dp[adjacent_junction][0] + cost == dp[current_junction][0]:\n                count_set.add(dp[adjacent_junction][1])\n\n        return\n\n    for i in range(n):\n        if costs[i] < min_cost[i]:\n            dfs(i)\n\n    result = [dp[0][0], len(count_set) % 1000000007]\n    print(result[0], result[1])",
        "result": "failed: testcase 0"
    },
    "276": {
        "body": "import sys\n\n    n = int(input())\n    colors = []\n    absent_names = []\n\n    for i in range(n):\n        color = input()\n        colors.append(color)\n\n    all_colors = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']\n    for name, color in zip(['Power', 'Time', 'Space', 'Soul', 'Reality', 'Mind'], all_colors):\n        if color not in colors:\n            absent_names.append(name)\n\n    print(len(absent_names))\n    for name in absent_names:\n        print(name)\n\nget_absent_gems()",
        "result": "failed: testcase 0"
    },
    "2635": {
        "body": "import sys\n\n    if not matrix:\n        return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    top, bottom, left, right = 0, m - 1, 0, n - 1\n    result = []\n\n    while True:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n\n        top += 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n\n        right -= 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(right, left - 1, -1):\n            result.append(matrix[bottom][i])\n\n        bottom -= 1\n\n        if top > bottom or left > right:\n            break\n\n        for i in range(bottom, top - 1, -1):\n            result.append(matrix[i][left])\n\n        left += 1\n\n    return result",
        "result": "failed: testcase 0"
    },
    "281": {
        "body": "import math\n    a, b = sorted(map(int, input().split()))\n    fact_b = 1\n    for i in range(2, b + 1):\n        if i >= a:\n            fact_b *= i\n        elif (i % 10) == 7 or (i % 10) == 0:\n            fact_b *= 10\n        else:\n            fact_b *= (i * 10 % 10)\n    for i in range(2, a + 1):\n        if fact_b // (10 ** (a - i)) % 10 == 0 or fact_b // (10 ** (a - i)) % 10 == 7:\n            return 0\n    return fact_b % 10\n\nprint(last_digit_of_phoenix_reincarnations())",
        "result": "failed: testcase 0"
    },
    "2300": {
        "body": "    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    x_v_queries = []\n    l_r_queries = []\n    l_r_d_queries = []\n\n    for _ in range(m):\n        t = int(input())\n\n        if t == 1:\n            x_i, v_i = map(int, input().split())\n            x_v_queries.append((x_i - 1, v_i))\n        elif t == 2:\n            l_i, r_i = map(int, input().split())\n            l_r_queries.append((l_i - 1, r_i - 1))\n        else:\n            l_i, r_i, d_i = map(int, input().split())\n            l_r_d_queries.append((l_i - 1, r_i - 1, d_i))\n\n    for x_i, v_i in x_v_queries:\n        a[x_i] = v_i\n\n    f = [0, 1]\n    for i in range(2, max(map(max, (r_i for _, r_i in l_r_queries))) + 1):\n        f.append(f[-1] - 1 + f[-2] - 2)\n\n    s = [0] * n\n    for i, (l_i, r_i) in enumerate(l_r_queries):\n        for x in range(l_i, r_i + 1):\n            s[x] += a[l_i + x] * f[i]\n\n    for l_i, r_i, d_i in l_r_d_queries:\n        for x in range(l_i, r_i + 1):\n            a[x] += d_i\n\n    for i, (l_i, r_i) in enumerate(l_r_queries):\n        s[l_i:r_i+1] = [a[x] * f[i] for x in range(l_i, r_i + 1)]\n\n    print(sum(s) % 1000000000)\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0"
    },
    "2104": {
        "body": "import sys\n\n    l, r = map(int, input().split())\n    if (r - l + 1) % 2 == 0:\n        return \"NO\"\n\n    pairs = []\n    for i in range(l, r + 1, 2):\n        pairs.append((i, i + 1))\n    print(\"YES\")\n    total_pairs = (r - l + 1) // 2\n    for i in range(total_pairs):\n        if pairs[i][0] % 2 == 1:\n            j = i * 2\n        else:\n            j = i * 2 + 1\n        print(pairs[j])\n\nget_pairs()",
        "result": "failed: testcase 0"
    },
    "1995": {
        "body": "    m = len(queries)\n    for l_i, r_i, k_i in queries:\n        substring = s[l_i - 1:r_i]\n        shifted_substring = substring[-k_i % len(substring):] + substring[:-k_i % len(substring)]\n        s = s[:l_i - 1] + shifted_substring + s[r_i:]\n    return s\n\ns = input()\nm = int(input())\nqueries = []\nfor _ in range(m):\n    l_i, r_i, k_i = map(int, input().split())\n    queries.append((l_i, r_i, k_i))\n\nresult = cyclic_shift_queries(s, queries)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "2064": {
        "body": "    count = 0\n    for i in range(10, 0, -1):\n        if n >= i:\n            count += 9 * i + 10\n            n -= i\n        else:\n            count += n * 9\n            break\n    return str(count)\n\nn = int(input())\nprint(max_integer(n))",
        "result": "failed: testcase 0"
    },
    "1715": {
        "body": "import sys\n\n    shrines = []\n    temples = []\n\n    for i in range(1, A+1):\n        s_i = int(input())\n        shrines.append(s_i)\n\n    for i in range(1, B+1):\n        t_i = int(input())\n        temples.append(t_i)\n\n    sorted_shrines = sorted(shrines)\n    sorted_temples = sorted(temples)\n\n    results = []\n    for x_i in queries:\n        min_distance = sys.maxsize\n\n        for shrine_index in range(len(sorted_shrines)):\n            closest_shrine = abs(x_i - sorted_shrines[shrine_index])\n            for temple_index in range(len(sorted_temples)):\n                min_val = abs(closest_shrine + sorted_temples[temple_index] - x_i)\n                if min_val < min_distance:\n                    min_distance = min_val\n\n        results.append(min_distance)\n\n    return results\n\nA, B, Q = map(int, input().split())\nqueries = []\nfor _ in range(Q):\n    queries.append(int(input()))\n\nresults = calculate_min_distance(A, B, queries)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2074": {
        "body": "import sys\n\n    max_street = [0] * n\n    min_avenue = [float('inf')] * m\n\n    for j in range(m):\n        for i in range(n):\n            if costs[i][j] > max_street[i]:\n                max_street[i] = costs[i][j]\n    for i in range(n):\n        for j in range(m):\n            if costs[i][j] < min_avenue[j]:\n                min_avenue[j] = costs[i][j]\n\n    min_max_cost = float('inf')\n    for j in range(m):\n        max_i = 0\n        for i in range(1, n):\n            if max_street[i] > max_street[max_i]:\n                max_i = i\n        if max_street[max_i] < min_max_cost:\n            min_max_cost = min(min_avenue[j], max_street[max_i])\n    return min_max_cost\n\nn, m = map(int, input().split())\ncosts = [list(map(int, input().split())) for _ in range(n)]\nprint(find_min_max_cost(n, m, costs))",
        "result": "failed: testcase 0"
    },
    "2921": {
        "body": "import sys\n\n    drinks = []\n    for _ in range(d):\n        name, strength, size, cost = input().split()\n        strength = float(strength)\n        drink_cost = float(cost)\n        if size == '1/1':\n            volume = 1\n        elif size == '1/2':\n            volume = 0.5\n        else:\n            volume = 1 / 3\n        drinks.append({'name': name, 'strength': strength, 'volume': volume, 'cost': drink_cost})\n\n    # Sort the drinks by price per unit in descending order\n    drinks.sort(key=lambda x: (x['strength'] * x['volume']) / x['cost'], reverse=True)\n\n    purchased_drinks = []\n    remaining_budget = m\n\n    for drink in drinks:\n        units = drink['strength'] * drink['volume']\n        if u % units == 0 and remaining_budget >= u // units * drink['cost']:\n            count = u // units\n            remaining_budget -= count * drink['cost']\n            purchased_drinks.append((drink['name'], count))\n\n    if sum(count for _, count in purchased_drinks) != u:\n        return ['IMPOSSIBLE']\n\n    # Format the output\n    formatted_output = []\n    for name, count in purchased_drinks:\n        formatted_output.append(f'{name} {count}')\n\n    return formatted_output\n\n# Read input from stdin and print the result\nm, u, d = map(float, input().split())\nresult = find_optimal_purchases(m, u, int(d))\nprint('\\n'.join(result))",
        "result": "failed: testcase 0"
    },
    "1642": {
        "body": "import sys\nimport math\n\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    return 0 if val == 0 else 1 if val > 0 else -1\n\n    o = orientation(p1, q1, p2)\n    o1 = orientation(p1, q1, q2)\n    o2 = orientation(p2, q2, p1)\n    return True if (o == 0 and (o1 != 0 or o2 != 0)) else False\n\n    return math.sqrt((q[0] - p[0])**2 + (q[1] - p[1])**2)\n\n    n = len(polygon)\n    for i in range(n):\n        if is_intersect(polygon[i], polygon[(i+1)%n], [polygon[(i-1)%n][0]-D, polygon[(i-1)%n][1]], [polygon[i][0]+D, polygon[i][1]]):\n            return False\n    return True\n\n    max_dist = 0.000001\n    min_dist = -0.000001\n    while max_dist - min_dist > 1e-6:\n        D = (max_dist + min_dist) / 2\n        if check_polygon(points, D):\n            min_dist = D\n        else:\n            max_dist = D\n    return round(max_dist, 7)",
        "result": "failed: testcase 0"
    },
    "947": {
        "body": "    if a >= b:\n        smaller = b\n    else:\n        smaller = a\n    while True:\n        if ((smaller % a == 0) and (smaller % b == 0)):\n            return smaller\n        smaller += 1\n\nfor _ in range(int(input())):\n    n = int(input())\n    for a in range(2, n):\n        b = n - a\n        if find_lcm(a, b) <= find_lcm(b, a):\n            print(a, b)\n            break",
        "result": "failed: testcase 0"
    },
    "743": {
        "body": "import sys\n\n    n = int(input())\n    nums = list(map(int, input().split()))\n    sorted_nums = [0] * n\n\n    for i in range(n):\n        j = 0\n        while j < i:\n            if nums[j] <= nums[i]:\n                break\n            j += 1\n        sorted_nums[i] = nums[j]\n\n    for i in range(1, n):\n        sorted_nums[i] -= sorted_nums[i - 1]\n    return sum(sorted_nums)\n\nprint(min_sum())",
        "result": "failed: testcase 0"
    },
    "1397": {
        "body": "import sys\nfrom collections import deque\n\n    graph = [[] for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    queue = deque()\n\n    for a, b in no_road_pairs:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            queue.append(i)\n            while queue:\n                curr_node = queue.popleft()\n                for neighbor in graph[curr_node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n\n    roads_needed = []\n    for i in range(1, n + 1):\n        if len(graph[i]) < 2:\n            continue\n        elif len(graph[i]) == 2:\n            a, b = graph[i]\n            if not visited[a] or not visited[b]:\n                roads_needed.append((i, min(a, b)))\n\n    print(len(roads_needed))\n    for road in roads_needed:\n        print(*road)",
        "result": "failed: testcase 0"
    },
    "1144": {
        "body": "    occurrences = []\n    for i in range(n - m + 1):\n        possible = True\n        for j in range(m):\n            if s[i + j] != '?' and s[i + j] != t[j]:\n                possible = False\n                break\n        if possible:\n            occurrences.append(i)\n    count = len(occurrences) if occurrences else 0\n    max_count = count\n\n    for i in range(n - m + 1):\n        for j in range(m):\n            prev_replacement = s[i + j] == 'a' and t[j] == 'b'\n            curr_replacement = s[i + j] != '?' and s[i + j] != t[j]\n            if prev_replacement or curr_replacement:\n                count = 0\n                for k in range(m):\n                    if i + k in occurrences and (s[occurrences[k] + k] == 'a' and t[k] == 'b' or s[occurrences[k] + k] != '?' and s[occurrences[k] + k] != t[k]):\n                        count += 1\n                        occurrences.remove(occurrences[k])\n                for k in range(m):\n                    if i + k not in occurrences:\n                        valid = True\n                        for l in range(k):\n                            if (s[i + l] == 'a' and t[l] == 'b') or (s[i + l] != '?' and s[i + l] != t[l]):\n                                valid = False\n                                break\n                        if valid:\n                            occurrences.append(i + k)\n                count += len(occurrences) if occurrences else 0\n\n            max_count = max(max_count, count)\n\n    return m - max_count",
        "result": "failed: testcase 0"
    },
    "890": {
        "body": "import sys\n    min_diff = max(c)\n    num_ways = 0\n    for i in range(1, n + 1):\n        curr_min_diff = max(c) - c[i - 1]\n        if curr_min_diff >= x:\n            for j in range(i, n + 1):\n                total_difficulty = sum(c[:j])\n                min_curr_diff = max(c[:j]) - c[i - 1]\n                if l <= total_difficulty <= r and min_curr_diff >= x:\n                    num_ways += 1\n    return num_ways\n\nn, l, r, x = map(int, input().split())\nc = list(map(int, input().split()))\nprint(count_problemsets(n, l, r, x, c))",
        "result": "failed: testcase 0"
    },
    "2410": {
        "body": "    prefix_sum = [0] * (n + 1)\n    for i in range(1, n+1):\n        prefix_sum[i] = prefix_sum[i-1] + a[i-1]\n    \n    max_adel_tastiness = prefix_sum[n]\n    \n    for r in range(n-1, 0, -1):\n        if prefix_sum[r] > max_adel_tastiness:\n            return \"YES\"\n        \n        max_adel_tastiness = max(max_adel_tastiness, prefix_sum[r] - prefix_sum[r-1])\n    \n    return \"NO\"",
        "result": "failed: testcase 0"
    },
    "1004": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    in_stack = []\n    day = 0\n    out = []\n\n    for i in range(n):\n        if a[i] > 0:\n            if len(in_stack) != 0 and abs(in_stack[-1]) == a[i]:\n                print(-1)\n                return\n\n            in_stack.append(a[i])\n            day += 1\n        else:\n            if len(in_stack) == 0 or abs(in_stack[-1]) != a[i] * -1:\n                print(-1)\n                return\n            out.append(len(in_stack))\n            while len(in_stack) > 0 and in_stack.pop() == -a[i]:\n\n    print(day)\n    for i in range(day):\n        print(out[i], end=' ')",
        "result": "failed: testcase 0"
    },
    "531": {
        "body": "    n = int(input())\n    x_values = sorted(map(int, input().split()))\n    max_val = x_values[-1]\n    min_val = x_values[0]\n    y_values = []\n\n    for val in x_values:\n        if val == min_val or val == max_val:\n            y_values.append(val)\n        else:\n            num_same = 0\n            for i, v in enumerate(x_values):\n                if v == val and not (i < len(y_values) and y_values[i] != v):\n                    num_same += 1\n\n            avg = sum(x_values) / n\n            count = x_values.count(val)\n            if num_same + count > 0 and avg - ((num_same + count) * val) <= min_val:\n                for i in range(num_same):\n                    y_values.append(val)\n                break\n\n    result_avg = sum(y_values) / len(y_values)\n\n    print(n - len(y_values))\n    print(' '.join(map(str, y_values)))\n\nmin_equal_measurements()",
        "result": "failed: testcase 0"
    },
    "510": {
        "body": "    a = int(a)\n    b = int(b)\n    c = int(c)\n    d = int(d)\n\n    max_val = max(abs(a - b), abs(a - c), abs(b - c))\n    if max_val < d:\n        distance_ab = (d - abs(a - b)) // 2\n        distance_ac = (d - abs(a - c)) // 2\n        distance_bc = (d - abs(b - c)) // 2\n\n        max_distance = max(distance_ab, distance_ac, distance_bc)\n        min_duration = max_val + max_distance * 3\n    else:\n        min_duration = max_val\n\n    return min_duration\n\n\nif __name__ == \"__main__\":\n    input_data = [int(x) for x in input().split()]\n    print(min_duration(*input_data))",
        "result": "failed: testcase 0"
    },
    "2555": {
        "body": "    max_val = 0\n    pref_max = [0] * n\n    suff_min = [0] * n\n    pref_max[0] = a[0]\n    for i in range(1, n):\n        if a[i] >= a[i - 1]:\n            pref_max[i] = max(pref_max[i - 1], a[i])\n        else:\n            pref_max[i] = pref_max[i - 1]\n\n    suff_min[n - 1] = a[n - 1]\n    for i in range(n - 2, -1, -1):\n        if a[i] <= a[i + 1]:\n            suff_min[i] = min(suff_min[i + 1], a[i])\n        else:\n            suff_min[i] = suff_min[i + 1]\n\n    max_val = pref_max[-1]\n    result = [max_val]\n    for i in range(q):\n        l, r = ops[i][0], ops[i][1]\n        if l < r:\n            new_pref_max = pref_max[:l - 1]\n            if a[l] >= a[r]:\n                new_pref_max.append(max(pref_max[r - 1], a[l]))\n            else:\n                new_pref_max.append(pref_max[r - 1])\n            pref_max = new_pref_max\n            for i in range(l, r):\n                if a[i] >= a[i - 1]:\n                    pref_max[i] = max(pref_max[i - 1], a[i])\n                else:\n                    pref_max[i] = pref_max[i - 1]\n\n            new_suff_min = suff_min[:r + 1]\n            if a[l] <= a[r]:\n                new_suff_min[-1] = min(suff_min[l - 1], a[r])\n            else:\n                new_suff_min[-1] = suff_min[l - 1]\n            for i in range(r, n - 1):\n                if a[i] <= a[i + 1]:\n                    new_suff_min[i + 1] = min(new_suff_min[i], a[i])\n                else:\n                    new_suff_min[i + 1] = new_suff_min[i]\n            suff_min = new_suff_min\n\n        elif l > r:\n            new_pref_max = pref_max[:r - 1]\n            if a[l] >= a[r]:\n                new_pref_max.append(pref_max[r - 1])\n            else:\n                new_pref_max.append(max(pref_max[r - 1], a[l]))\n            for i in range(r, l):\n                if a[i] >= a[i + 1]:\n                    new_pref_max[i] = max(new_pref_max[i + 1], a[i])\n                else:\n                    new_pref_max[i] = new_pref_max[i + 1]\n            pref_max = new_pref_max\n\n            new_suff_min = suff_min[:l + 1]\n            if a[l] <= a[r]:\n                new_suff_min[-1] = min(suff_min[l - 1], a[r])\n            else:\n                new_suff_min[-1] = suff_min[l - 1]\n\n            for i in range(l, n - 1):\n                if a[i] <= a[i + 1]:\n                    new_suff_min[i + 1] = min(new_suff_min[i], a[i])\n                else:\n                    new_suff_min[i + 1] = new_suff_min[i]\n            suff_min = new_suff_min\n\n        max_val = pref_max[r - 1] - suff_min[l]\n\n        result.append(max_val)\n\n    return result",
        "result": "failed: testcase 0"
    },
    "324": {
        "body": "import math\n    for i in range(2, int(math.sqrt(a)) + 1):\n        if a % i == 0:\n            return True\n    return False\n\nn = int(input())\nfor a in range(n * 3 + 4, 10**9 + 5):\n    if find_composite(a) and find_composite(a - n):\n        print(a, a - n)\n        break",
        "result": "failed: testcase 0"
    },
    "2912": {
        "body": "    N = int(input())\n    strings = [None] * (N + 1)\n    for i in range(1, N + 1):\n        strings[i] = input()\n    operations = []\n    for _ in range(N - 1):\n        a, b = map(int, input().split())\n        operations.append((a, b))\n    result = strings[operations[-1][0]]\n    for i, (a, b) in enumerate(operations[::-1]):\n        if i == len(operations) - 1:\n            continue\n        result += strings[b]\n        del strings[b]\n    return result\n\nprint(merge_strings())",
        "result": "failed: testcase 0"
    },
    "9": {
        "body": "    d = int(input())\n    n, m = map(int, input().split())\n\n    sofas = []\n    for i in range(d):\n        x1, y1, x2, y2 = map(int, input().split())\n        if abs(x1 - x2) + abs(y1 - y2) == 1:\n            sofas.append((x1, y1, x2, y2))\n\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, input().split())\n\n    for i in range(d):\n        found = True\n        left_count = 0\n        right_count = 0\n        top_count = 0\n        bottom_count = 0\n\n        for j in range(len(sofas)):\n            if sofas[j][0] == sofas[i][0]:\n                if abs(sofas[j][1] - sofas[i][1]) + abs(sofas[j][2] - sofas[i][2]) != 1:\n                    continue\n                if i < j and (sofas[j][0], sofas[j][1]) > (sofas[i][0], sofas[i][1]):\n                    right_count += 1\n                elif i < j and (sofas[j][0], sofas[j][1]) <= (sofas[i][0], sofas[i][1]):\n                    left_count += 1\n            if sofas[j][1] == sofas[i][1]:\n                if abs(sofas[j][0] - sofas[i][0]) + abs(sofas[j][2] - sofas[i][2]) != 1:\n                    continue\n                if i < j and (sofas[j][0], sofas[j][2]) > (sofas[i][0], sofas[i][2]):\n                    bottom_count += 1\n                elif i < j and (sofas[j][0], sofas[j][2]) <= (sofas[i][0], sofas[i][2]):\n                    top_count += 1\n\n        if left_count == cnt_l and right_count == cnt_r and top_count == cnt_t and bottom_count == cnt_b:\n            return str(i + 1)\n    return \"-1\"",
        "result": "failed: testcase 0"
    },
    "249": {
        "body": "        for i in range(n + 1):\n            for j in range(i, n + 1):\n                if a[j] - a[i] == d:\n                    return True\n        return False\n\n    x_needed = max(0, y // x * x - x)\n    y_needed = max(0, (y + 1) // x * x - y)\n\n    needed = max(x_needed, y_needed)\n    if needed == 0:\n        return []\n\n    p = [a[n] + i for i in range(min(l, needed))]\n\n    while not can_measure(p[-1]):\n        needed -= 1\n        p.pop()\n\n    return p\n\nn, l, x, y = map(int, input().split())\na = list(map(int, input().split()))\n\nprint(len(min_marks(n, l, x, y, a)))\nif min_marks(n, l, x, y, a):\n    print(*min_marks(n, l, x, y, a))",
        "result": "failed: testcase 0"
    },
    "2999": {
        "body": "    highest_bid = 0\n    for participant in sorted(participants):\n        name, bid = participant\n        if bid > highest_bid:\n            highest_bid = bid\n\n    winners = set()\n    for i in range(len(participants)):\n        total = 0\n        for j in range(i + 1):\n            name, bid = participants[j]\n            total += bid\n            group_sum = sum([bid for _, bid in participants[k] if k <= i and k >= j])\n            if group_sum == s:\n                winners.add((name, tuple(sorted([_, bid] for _, bid in participants[k] if k <= i and k >= j))))\n\n    return len(winners), '\\n'.join(name for name, _ in sorted(winners))\n\nimport sys\nn, s = map(int, input().split())\nparticipants = [tuple(input().split()) for _ in range(n)]\nresult = lottery_winners(n, s, participants)\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0"
    },
    "2239": {
        "body": "import sys\nmin_num = 2\nmax_num = 7\n\n    num = 0\n    while True:\n        total = min_num * num\n        if total >= x:\n            return num\n        num += 1\n\nt = int(input())\nfor _ in range(t):\n    x = int(input())\n    print(find_min_rolls(x))",
        "result": "failed: testcase 0"
    },
    "2615": {
        "body": "    max_power = {2: 0, 3: 0, 5: 0}\n    powers = [1] * len(max_power)\n    for p in max_power:\n        power = 1\n        while p ** (max_power[p] + 1) <= n:\n            max_power[p] += 1\n            for i in range(len(powers)):\n                if i == max_power[p]:\n                    powers[i] *= p\n                else:\n                    powers[i] //= p\n    result = sum(1 for power in powers if power == 1)\n    return result\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(count_elegant_numbers(n))",
        "result": "failed: testcase 0"
    },
    "2542": {
        "body": "    s = input()\n    n = len(s)\n    erased = [0] * 10\n    for i in range(n):\n        erased[int(s[i])] += 1\n    max_side = -1\n    for i in range(10):\n        if erased[i] > (n + 1) // 2:\n            max_side = n - erased[i]\n        elif erased[(i + 1) % 10] < (n + 1) // 2:\n            max_side = min(max_side, erased[i])\n    return max_side\n\nfor _ in range(int(input())):\n    print(min_erase_to_good())",
        "result": "failed: testcase 0"
    },
    "511": {
        "body": "import math\n\n    if b == 0:\n        return a\n    else:\n        return gcd(b, a % b)\n\n    for _ in range(b):\n        a = 1 + f(a, b - gcd(a, b))\n    return a",
        "result": "failed: testcase 0"
    },
    "1409": {
        "body": "import sys\n\n    sorted_participants = sorted(participants)\n    teams = 0\n    i = n - 1\n    while i >= 2:\n        if (sorted_participants[i] + sorted_participants[i-1] +\n            sorted_participants[i-2]) >= k:\n            teams += 1\n            for _ in range(3):\n                i -= 1\n    return teams\n\nn, k = map(int, input().split())\nparticipants = list(map(int, input().split()))\nprint(max_teams(n, k, participants))",
        "result": "failed: testcase 0"
    },
    "2274": {
        "body": "import sys\nfrom collections import deque\n\n    n, m = len(grid), len(grid[0])\n    directions = {'R': 1, 'D': 2}\n    visited = [[False]*m for _ in range(n)]\n    \n    q = deque([])\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'C' or (i < n-1 and j < m-1 and grid[i+1][j] != 'R'\n                                     and grid[i][j+1] != 'D'):\n                q.append((i, j))\n                visited[i][j] = True\n    \n    total_moves = 0\n    while q:\n        x, y = q.popleft()\n        if (x == n-1) and (y == m-1):\n            continue\n        elif grid[x][y] != 'C' and not visited[x][y]:\n            if directions[grid[x][y]] < directions['R']:\n                if 0 <= x + 1 < n and not visited[x+1][y]:\n                    q.append((x+1, y))\n                    visited[x+1][y] = True\n                else:\n                    total_moves += 1\n            else:\n                if 0 <= y + 1 < m and not visited[x][y+1]:\n                    q.append((x, y+1))\n                    visited[x][y+1] = True\n                else:\n                    total_moves += 1\n                    \n    return total_moves\n\nfor _ in range(int(input())):\n    n, m = map(int, input().split())\n    grid = [input() for i in range(n)]\n    print(min_changes(grid))",
        "result": "failed: testcase 0"
    },
    "2420": {
        "body": "import sys\n    max_points = 0\n    for i in range(n):\n        points.sort(key=lambda x: abs(x[0] - points[i][0]) + abs(x[1] - points[i][1]))\n        j = 1\n        while j < n and abs(points[j][0] - points[i][0]) + abs(points[j][1] - points[i][1]) <= r:\n            j += 1\n        max_points = max(max_points, j)\n    return max_points\n\nn, r = map(int, input().split())\npoints = []\nfor _ in range(n):\n    x, y = map(int, input().split())\n    points.append((x, y))\nprint(max_points(n, r, points))",
        "result": "failed: testcase 0"
    },
    "1267": {
        "body": "    n = int(input())\n    scores = sorted([int(x) for x in input().split()])\n    prev_min_score = None\n    ways = 1\n    score_count = {}\n\n    for i, s in enumerate(scores):\n        if s != 0 and (prev_min_score is None or s < prev_min_score):\n            score_count[s] = score_count.get(s, 0) + 1\n            prev_min_score = s\n\n    min_score = scores[-1]\n    ways *= score_count[min_score]\n\n    for i in range(n - 2, -1, -1):\n        if scores[i] == min_score:\n            break\n        ways *= score_count[scores[i]]\n\n    return ways\n\nprint(count_diploma_subsets())",
        "result": "failed: testcase 0"
    },
    "2356": {
        "body": "import sys\n\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if abs(j - a[j]) == abs(i - a[i]):\n                return False\n    return True\n\n    n = len(a)\n    freq_map = {}\n    for i in range(n):\n        freq_map[a[i]] = freq_map.get(a[i], 0) + 1\n    sorted_a = sorted(a, reverse=True)\n    shuffled_a = []\n    for num in sorted_a:\n        while freq_map[num] == 0 and len(shuffled_a) < n:\n            num = -num\n        if freq_map[num] > 0:\n            shuffled_a.append(num)\n            freq_map[num] -= 1\n\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        a = list(map(int, input().split()))\n        shuffle_array(a)\n        print(' '.join(map(str, a)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "108": {
        "body": "import sys\n\n    s = input()\n    target = 'abcdefghijklmnopqrstuvwxyz'\n    index = 0\n    ans = []\n\n    for char in s:\n        while index < len(target) and (char > target[index] or target[index] not in s):\n            ans.append(target[index])\n            index += 1\n\n        if index == len(target) or target[index] != char:\n            return '-1'\n\n        ans.append(char)\n        index += 1\n\n    for i in range(index, len(target)):\n        ans.append(target[i])\n\n    print(''.join(ans))\n\nget_alphabet_subsequence()",
        "result": "failed: testcase 0"
    },
    "1833": {
        "body": "import sys\nfrom collections import defaultdict\nmod = 10**9 + 7\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    count = [0] * (n + 1)\n    dp = [[0 for _ in range(n+1)] for __ in range(n+1)]\n    dp[0][0] = 1\n\n    for i, num in enumerate(a):\n        for j in range(i+1, -1, -1):\n            if num % (j+1) == 0:\n                dp[j+1][i+1] = (dp[j+1][i+1] + dp[j][i]) % mod\n            dp[0][i+1] = (dp[0][i+1] + dp[0][i]) % mod\n\n        for j in range(i, -1, -1):\n            if num % (j+1) == 0:\n                count[i+1] += dp[j+1][i]\n                count[i+1] %= mod\n            count[i+1] += dp[0][i]\n\n    return sum(count) % mod\n\nprint(count_good_subsequences())",
        "result": "failed: testcase 0"
    },
    "2324": {
        "body": "import math\n    n = len(s)\n    counts = [0] * (n + 1)\n\n    for i in range(n):\n        for j in range(i, n):\n            sub = s[i:j+1]\n            if sub == sub[::-1]:\n                k = int(math.floor((j - i + 1) / 2))\n                counts[k] += 1\n\n    return ' '.join(map(str, counts[:n]))\n\nprint(palindromic_characteristics(input()))",
        "result": "failed: testcase 0"
    },
    "2372": {
        "body": "import sys\n\n    H, W = map(int, input().split())\n    C_h, C_w = map(int, input().split())\n    D_h, D_w = map(int, input().split())\n    S = [list(input()) for _ in range(H)]\n    visited = [[False]*W for _ in range(H)]\n\n    queue = [(C_h-1, C_w-1, 0)]\n    while queue:\n        x, y, steps = queue.pop(0)\n        if (x, y) == (D_h-1, D_w-1):\n            return steps\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < H and 0 <= ny < W and S[nx][ny] == '.' and not visited[nx][ny]:\n                queue.append((nx, ny, steps))\n\n        for dx in range(-2, 3):\n            for dy in range(-2, 3):\n                if abs(dx) + abs(dy) != 1:\n                    continue\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < H and 0 <= ny < W and S[nx][ny] == '.':\n                    queue.append((nx, ny, steps+1))\n\n    return -1\n\nprint(min_magic_steps())",
        "result": "failed: testcase 0"
    },
    "1984": {
        "body": "import sys\n\n    levels = []\n    for _ in range(k):\n        level = [list(input()) for _ in range(n)]\n        levels.append(level)\n\n        n, m = len(a), len(a[0])\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] != b[i][j]:\n                    count += 1\n        return count\n\n    dp = [float('inf')] * k\n    parent = [-1] * k\n    parent[0] = 0\n\n    for i in range(1, k):\n        for j in range(i):\n            curr_diff = diff(levels[i], levels[j])\n            if curr_diff <= w:\n                cost = dp[j] + curr_diff * (n * m)\n                if cost < dp[i]:\n                    dp[i] = cost\n                    parent[i] = j\n\n        if index == -1:\n            return path[::-1]\n        else:\n            return reconstruct_path(parent[index], [index + 1]) + path\n\n    for i in range(k):\n        print(n * m if dp[i] == float('inf') else dp[i])\n\n    for i in range(1, k + 1):\n        next_level = parent[i - 1]\n        print(f\"{i} {' '.join(map(str, reconstruct_path(i - 1)))}\")\n\nn, m, k, w = map(int, input().split())\nmin_traffic(n, m, k, w)",
        "result": "failed: testcase 0"
    },
    "1253": {
        "body": "import sys\n\n    pos = sum(x > 0 for x in arr)\n    neg = n - pos\n    if neg >= k:\n        return sum(abs(x) for x in arr)\n\n    ans = 0\n    for i in range(k):\n        if pos < n and arr[pos] <= 0:\n            pos += 1\n            ans -= arr[pos-1]\n        else:\n            neg -= 1\n            ans += arr[neg]\n\n    return ans\n\nn, k = map(int, input().split())\narr = list(map(int, input().split()))\nprint(max_income(n, k, arr))",
        "result": "failed: testcase 0"
    },
    "523": {
        "body": "    strs = []\n    for i in range(n):\n        s = input()\n        if len(s) != m:\n            return 0\n        strs.append(s)\n    strs.sort(reverse=True)\n    palindrome = \"\"\n    for i in range(m):\n        left = \"\"\n        right = \"\"\n        for j in range(n):\n            if (i + n - j) % 2 == 1 and len(strs[j]) > i:\n                right += strs[j][i]\n            elif len(left) < len(right) or (len(left) == len(right) and left <= right):\n                left = strs[j][:i+1]\n            if len(left) + len(right) >= n * m // 2:\n                palindrome = left + right[::-1]\n                break\n    return len(palindrome), palindrome\n\nn, m = map(int, input().split())\nresult = find_longest_palindrome(n, m)\nprint(result[0])\nif result[0] > 0:\n    print(result[1])",
        "result": "failed: testcase 0"
    },
    "2934": {
        "body": "import sys\n    dp = [[0] * (M + 1) for _ in range(2)]\n    dp[0][0] = 1\n    for n in range(1, N + 1):\n        prev_dp = dp[n % 2]\n        curr_dp = dp[(n - 1) % 2]\n        curr_dp.fill(0)\n        for m in range(M + 1):\n            if prev_dp[m]:\n                curr_dp[max(0, m - 1)] += prev_dp[m]\n                curr_dp[m] += prev_dp[m]\n                if n < N:\n                    curr_dp[min(m + 2, M)] += prev_dp[m]\n        dp[(n - 1) % 2], dp[n % 2] = dp[n % 2], prev_dp\n    return sum(dp[N % 2]) % (10 ** 9)\n\nN = int(input())\nM = int(input())\nprint(calculate_tilings(N, M))",
        "result": "failed: testcase 0"
    },
    "1745": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    grid = [list(input()) for _ in range(n)]\n    border = [[0]*m for _ in range(n)]\n\n        return 0 <= x1 < n and 0 <= y1 < m and 0 <= x2 < n and 0 <= y2 < m\n\n        if border[x][y]:\n            return False\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if not is_valid(nx, ny) or grid[nx][ny] == '#':\n                continue\n            if abs(nx-x)+abs(ny-y) <= max(n-1, m-1):\n                return True\n        for i in range(2):\n            for j in range(4):\n                nx = x + dx[i]\n                ny = y + dy[j]\n                if not is_valid(nx, ny) or grid[nx][ny] == '#':\n                    continue\n                border[nx][ny] = 1\n                if dfs(nx, ny, turns+1):\n                    return True\n                border[nx][ny] = 0\n        return False\n\n    ways = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.' and (i == 0 or j == 0) and not (i == 0 and j == 0) and not (i == n-1 or j == m-1):\n                border[i][j] = 1\n                ways += int(dfs(i, j, 0))\n                border[i][j] = 0\n\n    print(ways)\n\ncount_ways()",
        "result": "failed: testcase 0"
    },
    "1422": {
        "body": "import sys\n\n    weights = [int(x) for x in weights_str if x != '0']\n    left_sum = 0\n    right_sum = 0\n    sequence = []\n    for i in range(m):\n        weight_index = i % len(weights)\n        if i > 0 and weights[weight_index] == weights[(i - 1) % len(weights)]:\n            return False, None\n        new_left_sum = left_sum + weights[weight_index]\n        new_right_sum = right_sum + weights[weight_index]\n        if (new_left_sum <= new_right_sum or \n            new_left_sum > 0 and i == 0):\n            return False, None\n        sequence.append(weights[weight_index])\n        if i % 2 == 1:\n            left_sum = new_left_sum\n            right_sum = new_right_sum\n        else:\n            left_sum = new_right_sum\n            right_sum = new_left_sum\n    return True, sequence\n\nweights_str = input().strip()\nm = int(input())\n\ncan_do, sequence = can_put_weights(weights_str, m)\nif can_do:\n    print('YES')\n    print(' '.join(map(str, sequence)))\nelse:\n    print('NO')\n",
        "result": "failed: testcase 0"
    },
    "1763": {
        "body": "import sys\n    n, a, r, m = map(int, input().split())\n    heights = list(map(int, input().split()))\n    total_sum = sum(heights)\n    avg_height = total_sum // n\n    diff_sum = 0\n    for h in heights:\n        if h > avg_height:\n            diff_sum += (h - avg_height) * a + r\n        elif h < avg_height:\n            diff_sum += m * (avg_height - h)\n    return diff_sum\n\nprint(min_cost())",
        "result": "failed: testcase 0"
    },
    "974": {
        "body": "    n = int(input())\n    added = []\n    removed = [0] * (n + 1)\n    reorder_count = 0\n\n    for _ in range(2 * n):\n        command, arg = input().split()\n        arg = int(arg)\n\n        if command == 'add':\n            added.append(arg)\n            while added and removed[added[-1]] > 0:\n                removed.pop()\n\n        else:\n            removed[arg] += 1\n\n    for i in range(n - 1):\n        if added[i + 1] < added[i]:\n            reorder_count += 1\n            max_i = i + 1\n            while max_i < n and removed[added[max_i]] > 0:\n                max_i += 1\n            while i >= 0 and added[i + 1] < added[i]:\n                i -= 1\n            for j in range(i + 1, max_i):\n                removed[added[j]] = 0\n\n    return reorder_count\n\nprint(min_reorders())",
        "result": "failed: testcase 0"
    },
    "2343": {
        "body": "import math\n\n    if 2 ** n == 1:\n        return \"YES\" + ' ' + str(0)\n    elif 4 * 2 ** n <= 1 + (k - 1) * 4 or not k % 2:\n        return \"YES\" + ' ' + str(math.log2(2 ** int((n + k - 1) / 2)))\n    else:\n        return \"NO\"\n\nt = int(input())\nfor _ in range(t):\n    n, k = map(int, input().split())\n    print(check(n, k))",
        "result": "failed: testcase 0"
    },
    "627": {
        "body": "import sys\n\n    n = len(s)\n    max_idx = 0\n    for i in range(n - 1, -1, -1):\n        if s[i] != 'a':\n            max_idx = i\n            break\n    min_idx = n\n    for i in range(n - 1):\n        if s[i] < s[min_idx]:\n            min_idx = i\n\n    if min_idx == n:\n        return s[max_idx:max_idx+1]\n    elif max_idx != 0:\n        return ''.join([s[:max_idx], s[min_idx:min_idx+1], s[max_idx:]])\n    else:\n        return s[min_idx:]\n\ns = input()\nn = int(input())\nprint(remove_one_char(s))",
        "result": "failed: testcase 0"
    },
    "1655": {
        "body": "import sys\n\n    n = int(input())\n    L = list(map(int, input().split()))\n    l = [0] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + max(L[i], 1), i):\n            l[j] += 1\n    return sum(l)\n\nprint(total_alive())",
        "result": "failed: testcase 0"
    },
    "2124": {
        "body": "    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        usernames = list(map(str, input().split()))\n        m = int(input())\n\n        senders = [None] * m\n        prev_sender = None\n        impossible = False\n\n        for i in range(m):\n            line = input()\n            sender, text = line.split(':')\n            sender = sender.strip()\n\n            if sender == '?' and prev_sender is not None:\n                sender_index = usernames.index(prev_sender)\n                next_sender_index = (sender_index + 1) % n\n                senders[i] = usernames[next_sender_index]\n                if usernames[next_sender_index].lower() in text.lower():\n                    impossible = True\n            else:\n                senders[i] = sender\n\n            prev_sender = sender\n\n        if impossible:\n            print('Impossible')\n        else:\n            for i in range(m):\n                print(f'{senders[i]}:{input()}')",
        "result": "failed: testcase 0"
    },
    "1093": {
        "body": "    ascent = 0\n    descent = 0\n    for i in range(m-1):\n        max_height = 0\n        prev_max_height = 0\n        for j in range(n):\n            if table[j][i] == '*':\n                height = 0\n                k = j\n                while k < n and table[k][i+1] == '*':\n                    height += 1\n                    k += 1\n                max_height = max(max_height, height)\n                prev_max_height = max(prev_max_height, height - 1)\n        if max_height > prev_max_height:\n            ascent = max(ascent, max_height - prev_max_height)\n        else:\n            descent = max(descent, prev_max_height - max_height)\n    return f\"{ascent} {descent}\"\n\nn, m = map(int, input().split())\ntable = [list(input()) for _ in range(n)]\nprint(max_ascent_descent(n, m, table))",
        "result": "failed: testcase 0"
    },
    "899": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        edges.append((a - 1, b - 1, c))\n\n    # build adjacency matrix\n    adj_matrix = [[float('inf')] * n for _ in range(n)]\n    for u, v, c in edges:\n        adj_matrix[u][v] = min(adj_matrix[u][v], c)\n        adj_matrix[v][u] = min(adj_matrix[v][u], c)\n\n    # Floyd-Warshall algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if adj_matrix[i][k] + adj_matrix[k][j] < adj_matrix[i][j]:\n                    adj_matrix[i][j] = min(adj_matrix[i][j], adj_matrix[i][k] + adj_matrix[k][j])\n\n    # count non-shortest edges\n    non_shortest_count = 0\n    for u, v, c in edges:\n        if adj_matrix[u][v] > c:\n            non_shortest_count += 1\n\n    return non_shortest_count\n\nprint(find_non_shortest_edges())",
        "result": "failed: testcase 0"
    },
    "551": {
        "body": "    counts = {}\n    for i, yi in enumerate(y):\n        if yi not in counts:\n            counts[yi] = 0\n        counts[yi] += 1\n\n    unique_y_values = len(counts)\n    min_count = min(counts.values())\n\n    if unique_y_values == 2 and (min_count == 2 or n - min_count == 2):\n        return \"Yes\"\n    elif unique_y_values == 1:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nn = int(input())\ny = [int(x) for x in input().split()]\nprint(can_draw_two_lines(n, y))",
        "result": "failed: testcase 0"
    },
    "1772": {
        "body": "    n = int(input())\n    flowers = list(map(int, input().split()))\n    \n    odd_count = 0\n    even_count = 0\n    \n    for flower in flowers:\n        if flower % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n            \n    large_bouquets = min(odd_count, even_count)\n            \n    return large_bouquets\n\nprint(max_large_bouquets())",
        "result": "failed: testcase 0"
    },
    "1339": {
        "body": "import sys\n\n    n = int(input())\n    segments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        segments.append((l, r))\n\n    max_right = 0\n    best_i = -1\n    for i in range(n):\n        if segments[i][1] > max_right:\n            max_right = segments[i][1]\n            best_i = i\n\n    min_left = float('inf')\n    for i in range(n):\n        l, r = segments[i]\n        if i != best_i and l <= max_right <= r:\n            min_left = min(min_left, l)\n\n    if min_left < max_right:\n        print(best_i + 1)\n    else:\n        print(-1)\n\nfind_covering_segment()",
        "result": "failed: testcase 0"
    },
    "440": {
        "body": "    n = int(input())\n    word = input()\n    vowels = 'aeiouy'\n    i = 0\n    while i < n - 1:\n        if word[i] in vowels and word[i + 1] in vowels:\n            k = i\n            while k > 0 and word[k] not in vowels:\n                k -= 1\n            if k > 0 and word[k] in vowels:\n                del word[k]\n                n -= 1\n            else:\n                i += 1\n        else:\n            i += 1\n    print(word)",
        "result": "failed: testcase 0"
    },
    "2801": {
        "body": "import sys\nfrom collections import deque\n\n    n = len(stalls)\n    satis = [0] * n\n    visited = [False] * n\n    queue = deque()\n    for i in range(n):\n        for v in connections[i]:\n            if not visited[v]:\n                queue.append((i, 1 / (2 ** (v + 1))))\n                break\n        else:\n            continue\n        break\n\n    while queue:\n        curr_stall, remaining_satisfaction = queue.popleft()\n        satis[curr_stall] += stalls[curr_stall] * remaining_satisfaction\n        if not visited[curr_stall]:\n            visited[curr_stall] = True\n        for i in range(n):\n            if connections[curr_stall][i] and not visited[i]:\n                new_remaining_satisfaction = remaining_satisfaction / 2\n                queue.append((i, new_remaining_satisfaction))\n                break\n\n    return round(sum(satis), 6)\n\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\nconnections = [[] for _ in range(n)]\nfor _ in range(m):\n    s, t = map(int, input().split())\n    connections[s].append(t)\nprint(max_satisfaction(c, connections))",
        "result": "failed: testcase 0"
    },
    "2749": {
        "body": "import sys\n\n    H, W = map(int, input().split())\n    N = int(input())\n    a = list(map(int, input().split()))\n    colors = [0] * (H * W + 1)\n    color_idx = 1\n    for i in range(N):\n        while a[i] > 0:\n            idx = i + 1\n            for _ in range(a[i]):\n                if colors[idx] == 0:\n                    colors[idx] = color_idx\n                color_idx += 1\n                a[i] -= 1\n                for x, y in [(idx - 1, 0), (idx + 1, 0),\n                             (idx, W - 1), (idx, 1)]:\n                    if 0 <= x < H * W and colors[x] == color_idx - 1:\n                        idx = x\n            a[i] -= 1\n\n    for i in range(H):\n        row = []\n        for j in range(W):\n            idx = i * W + j + 1\n            row.append(str(colors[idx]))\n        print(' '.join(row))\n\npaint_squares()",
        "result": "failed: testcase 0"
    },
    "2319": {
        "body": "    s = s + s\n    for i in range(len(t)):\n        if s[i:i+len(s)] == t:\n            return len(s) // 2 - i\n    return -1\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    s = input()\n    t = input()\n    print(min_rotations(s, t))",
        "result": "failed: testcase 0"
    },
    "2121": {
        "body": "import sys\nfrom collections import deque\n\n        stack = deque([(root, 0)])\n        visited = {root}\n        min_times = [float('inf')] * (n + 1)\n        for i in range(1, n + 1):\n            min_times[i] = float('inf')\n        \n        while len(stack) > 0:\n            node, parent = stack[-1]\n            if node != root and min_times[node] >= times[parent - 1]:\n                min_times[0] = min(min_times[0], min_times[node])\n                del stack[-1]\n            else:\n                for neighbor in edges[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        stack.append((neighbor, node))\n                min_times[node] = times[node - 1]\n        \n        return min_times[0]\n\n    ans = 0\n    for i in range(1, n + 1):\n        ans = max(ans, dfs(i))\n\n    return ans\n\nn, k = map(int, input().split())\ntimes = list(map(int, input().split()))\nedges = [[] for _ in range(n + 1)]\n\nfor _ in range(n - 1):\n    u, v = map(int, input().split())\n    edges[u].append(v)\n    edges[v].append(u)\n\nprint(max_grade(n, k, times, edges))",
        "result": "failed: testcase 0"
    },
    "2617": {
        "body": "import sys\n\n    for d in range(62):  # log2(10^9) + 1 = 60, so we check up to 62 days\n        max_mass = 0\n        splits = []\n        cur_day = n\n        for i in range(d, -1, -1):\n            if (cur_day & (1 << i)) == 0:\n                max_mass += 2 ** (i + 1)\n                continue\n            num_splits = (cur_day >> i) - 1\n            splits.append(num_splits)\n            cur_day -= (num_splits * (1 << i))\n            max_mass += num_splits * 2 ** i\n        for _ in range(d, 0, -1):\n            max_mass *= 2\n            if max_mass > n:\n                break\n        if max_mass == n:\n            return [d + 1] + splits[::-1]\n\nfor _ in range(int(input())):\n    n = int(input())\n    res = min_nights(n)\n    print(len(res) - 1, *res[1:])",
        "result": "failed: testcase 0"
    },
    "175": {
        "body": "import sys\na = int(input())\nb = int(input())\n\nwhile True:\n    if a <= 0 or b <= 0:\n        break\n    if a >= 2 * b:\n        a -= 2 * b\n    elif b >= 2 * a:\n        b -= 2 * a\n    else:\n        break\n\nprint(a, b)",
        "result": "failed: testcase 0"
    },
    "995": {
        "body": "import math\nimport sys\n\n        if x < 0: return False\n        sqrt = int(math.sqrt(x))\n        return sqrt * sqrt == x\n\n    n = len(A)\n    dp = [[0] * (n + 1) for _ in range(n)]\n    ans = [0] * (n + 1)\n\n    for i in range(n):\n        group = set()\n        curr_group_idx = -1\n        curr_group_len = 0\n\n        for j in range(i, n):\n            a = A[j]\n            if is_perfect_square(a):\n                curr_group_idx += 1\n                curr_group_len += 1\n                dp[i][curr_group_idx] = curr_group_len\n            else:\n                factors = set()\n                fct = 2\n                while fct * fct <= a and fct < abs(a):\n                    if a % fct == 0:\n                        factors.add(fct)\n                        if a // fct != fct: factors.add(a // fct)\n                    fct += 1\n\n                factors.add(abs(a))\n                curr_group_len = 0\n                for fac in factors:\n                    if is_perfect_square(A[i] * fac) and not fac in group:\n                        curr_group_idx += 1\n                        curr_group_len = dp[i][curr_group_idx]\n                        break\n                else:\n                    continue\n\n            if j > i: ans[dp[j][curr_group_idx]] += 1\n            group.add(a)\n    return ' '.join(map(str, ans[:-1]))\n\nn = int(input())\nA = list(map(int, input().split()))\nprint(solve(A))",
        "result": "failed: testcase 0"
    },
    "582": {
        "body": "import sys\nfrom collections import defaultdict\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    t = list(map(int, input().split()))\n\n    counts = {}\n    for i in range(n):\n        if a[i] not in counts:\n            counts[a[i]] = []\n        counts[a[i]].append((a[i], t[i]))\n\n    sorted_counts = sorted(counts.keys())\n\n    result = 0\n    prev_count = None\n\n    for count in sorted_counts:\n        for (num, time) in counts[count]:\n            if prev_count is not None and num == prev_count:\n                result += min(time, prev_count - num)\n            else:\n                result += time * (count - num)\n\n        prev_count = count\n\n    return result\n\nprint(minimal_time_for_publications())",
        "result": "failed: testcase 0"
    },
    "1402": {
        "body": "import sys\n\n    n = int(input())\n    s1 = input()\n    s2 = input()\n\n    count_s1 = [0] * 10\n    count_s2 = [0] * 10\n    diff = [0] * (n + 1)\n    ways = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n):\n        if s1[i] != '?':\n            count_s1[int(s1[i])] += 1\n        if s2[i] != '?':\n            count_s2[int(s2[i])] += 1\n\n    for i in range(10):\n        diff[0] += (count_s2[i] - count_s1[i]) * (count_s1[i] <= count_s2[i])\n\n    for i in range(n):\n        if s1[i] == '?' or s2[i] == '?':\n            j = 0\n            while diff[j]:\n                ways[s1[i] != '?' and j < int(s1[i])] += diff[j]\n                j += 1\n\n            k = 9\n            while k >= 0:\n                if count_s1[k] > count_s2[k] or (count_s1[k] <= count_s2[k] and s1[i] == '?'):\n                    ways[s1[i] != '?' and int(s1[i]) == k] += diff[0]\n                    for l in range(k - 1, -1, -1):\n                        if count_s1[l] < count_s2[l] or (count_s2[l] <= count_s1[l] and s2[i] == '?'):\n                            ways[s2[i] != '?' and int(s2[i]) == k and s1[i] != '?' and int(s1[i]) == l] += diff[0]\n                elif count_s2[k] > count_s1[k] or (count_s1[k] <= count_s2[k] and s2[i] == '?'):\n                    ways[s2[i] != '?' and int(s2[i]) == k] += diff[0]\n\n                k -= 1\n\n            for j in range(10):\n                if s1[i] == '?' or (s1[i] == s2[i] and int(s1[i]) > j) or count_s1[j] <= count_s2[j]:\n                    diff[j + 1] += diff[j]\n                elif s2[i] == '?':\n                    diff[0] += diff[j]\n\n    result = sum(ways[n][i] * (n - i) for i in range(n + 1)) % 1000000007\n    print(result)\n\ncount_incomparable_ways()",
        "result": "failed: testcase 0"
    },
    "1141": {
        "body": "    n, m = map(int, input().split())\n    s = list(input())\n\n    for _ in range(m):\n        l, r, c1, c2 = map(str, input().split())\n        l, r = int(l) - 1, int(r) - 1\n\n        i = max(0, l - 1)\n        while i <= min(n - 1, r - 1):\n            if s[i] == c1:\n                s[i] = c2\n            i += 1\n\n    return ''.join(s)\n\n\nprint(get_final_string())",
        "result": "failed: testcase 0"
    },
    "2836": {
        "body": "    n = int(input())\n    boy_names = sorted(map(int, input().split()))\n    a, b = map(int, input().split())\n\n    max_distance = 0\n    best_choice = 0\n\n    for i in range(a, b + 1):\n        if i % 2 != 0:\n            min_distance = float('inf')\n            for j in range(n):\n                distance = abs(i - boy_names[j])\n                min_distance = min(min_distance, distance)\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_choice = i\n\n    return best_choice",
        "result": "failed: testcase 0"
    },
    "1109": {
        "body": "import sys\n\n    one_count = 0\n    two_count = 0\n    for i in range(k):\n        if a[i] == 1:\n            one_count += 1\n        else:\n            two_count += 1\n    max_one = (k * one_count) // n\n    min_two = k - ((k * two_count) // n)\n    return max(max_one - one_count, min_two - two_count)\n\nn, k = map(int, input().split())\na = list(map(int, input().split()))\nprint(min_changes(a, k))",
        "result": "failed: testcase 0"
    },
    "2125": {
        "body": "import sys\n\n        return (c1 != c2) and (blanket[y1][x1] == c1) and \\\n               (blanket[y1][x1] == blanket[y1][x2]) and \\\n               (blanket[y1][x1] == blanket[y2][x1]) and \\\n               (blanket[y1][x1] == blanket[y2][x2])\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            colors = []\n            for k in range(i, n):\n                if blanket[k][j] != blanket[i][j]:\n                    colors.append(blanket[i][j])\n                elif len(colors) < 3:\n                    colors.append(blanket[i][j])\n            if len(colors) == 3 and is_valid(j, j+1, i, k, colors[0], colors[1]):\n                count += (k - i + 1)\n    return count\n\nn, m = map(int, input().split())\nblanket = []\nfor _ in range(n):\n    blanket.append(input())\n\nprint(count_flags(n, m, blanket))",
        "result": "failed: testcase 0"
    },
    "1746": {
        "body": "import sys\n\n    visited = [False] * n\n    children_count = [0] * n\n    leaf_children_count = [[] for _ in range(n)]\n\n    for i in range(1, n - 1):\n        parent = parents[i]\n        visited[parent] = True\n\n    for i in range(1, n - 1):\n        child = i + 1\n        parent = parents[child]\n        children_count[parent] += 1\n        if children_count[parent] > 2:\n            leaf_children_count[parent].append(children_count[parent])\n        else:\n            leaf_children_count[parent].append(-1)\n\n    for i in range(1, n):\n        if visited[i]:\n            if len(leaf_children_count[i]) < 3 or any(count <= 2 for count in leaf_children_count[i]):\n                return False\n\n    return True\n\nn = int(input())\nparents = [0] + list(map(int, input().split())) * (n - 1)\nresult = \"Yes\" if is_spruce(n, parents) else \"No\"\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1294": {
        "body": "    char_count = {}\n    for c in s:\n        if c not in char_count:\n            char_count[c] = 1\n        else:\n            char_count[c] += 1\n    working = []\n    for c in sorted(char_count.keys()):\n        if char_count[c] % 2 == 0 and char_count[c] > 0:\n            continue\n        working.append(c)\n    return ''.join(working)\n\nt = int(input())\nfor _ in range(t):\n    s = input()\n    print(working_buttons(s))",
        "result": "failed: testcase 0"
    },
    "1159": {
        "body": "from sys import stdin\nfrom math import sqrt\n\n    if num < 2:\n        return False\n    for i in range(2, int(sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n    primes = []\n    for i in range(2, n * (n - 1) // 2 + 1):\n        if is_prime(i):\n            primes.append(i)\n    return primes\n\n    primes = get_primes(n)\n    if len(primes) < n:\n        print(-1)\n        return\n    num_edges = primes[n-1]\n    for i in range(2, n + 1):\n        degree = 0\n        for j in range(1, n + 1):\n            if j != i and (i, j) not in edges and (j, i) not in edges:\n                edges.append((i, j))\n                degree += 1\n        if not is_prime(degree):\n            print(-1)\n            return\n    print(num_edges)\n    for edge in edges:\n        print(edge[0], edge[1])\n\nn = int(stdin.readline())\nedges = []\ngenerate_graph(n)",
        "result": "failed: testcase 0"
    },
    "2025": {
        "body": "import sys\n\n    if n <= 3 or (n & 1) == 1:\n        return -1\n    if n % 2 == 0:\n        count = n // 4\n    else:\n        count = (n - 9) // 4 + 1\n    return count\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    print(max_summands(n))",
        "result": "failed: testcase 0"
    },
    "1429": {
        "body": "import sys\n\n    N = len(S)\n    A = []\n    C = []\n    G = []\n\n    for i in range(N):\n        if S[i] == 'A':\n            A.append(i + 1)\n        elif S[i] == 'C':\n            C.append(i + 1)\n        else:\n            G.append(i + 1)\n\n    count = 0\n    for i in range(1, N + 1):\n        ac_set = set()\n        ag_set = set()\n        ca_set = set()\n        cg_set = set()\n\n        for j in A[:i]:\n            if j not in C and (j - 1) // 2 + 1 <= i:\n                ac_set.add((j, (j - 1) // 2))\n            elif j not in G and (j - 1) >= i * 2:\n                ag_set.add((j, (j - 1) // 2))\n\n        for j in C[:i]:\n            if j not in A and (j - 1) // 2 + 1 <= i:\n                ca_set.add((j, (j - 1) // 2))\n            elif j not in G and (j - 1) >= i * 2:\n                cg_set.add((j, (j - 1) // 2))\n\n        for pair in ac_set:\n            if pair[0] <= N:\n                count += 1\n        for pair in ag_set:\n            if pair[0] <= N:\n                count += 1\n        for pair in ca_set:\n            if pair[0] <= N:\n                count += 1\n        for pair in cg_set:\n            if pair[0] <= N:\n                count += 1\n\n    return count - len(A) - len(C) - len(G)\n\nN = int(input().split()[0])\nS = input()\nprint(count_substrings(S))",
        "result": "failed: testcase 0"
    },
    "1950": {
        "body": "    n = int(input())\n    a = list(map(int, input().split()))\n    sorted_a = sorted(enumerate(a), key=lambda x: x[1], reverse=True)\n    penalty = 0\n    k = 3\n    i = 0\n    while i < n:\n        penalty += sorted_a[i][1]\n        j = i + 1\n        for _ in range(k):\n            if j >= len(sorted_a) or sorted_a[j][1] == sorted_a[i][1]:\n                break\n            k_2 = (len(sorted_a) - j) // (k - _)\n            for s in range(j, max(j + k_, len(sorted_a))):\n                if sorted_a[s][1] > 0:\n                    penalty += sorted_a[s][1]\n                    sorted_a[s] = (-1, sorted_a[s][1])\n            i = j\n        while i < len(sorted_a) and sorted_a[i][0] == -1:\n            i += 1\n    return penalty\n\nprint(min_penalty())",
        "result": "failed: testcase 0"
    },
    "631": {
        "body": "    sums = []\n    for i in range(n):\n        total = 0\n        for j in range(i, n):\n            total += a[j] / (j + 1)\n        sums.append(total)\n    return sum(sums) == m\n\nt = int(input())\nfor _ in range(t):\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    print(\"YES\" if can_reorder(n, m, a) else \"NO\")",
        "result": "failed: testcase 0"
    },
    "2480": {
        "body": "    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    count = 0\n    for i in range(n):\n        s = 0\n        for j in range(i, n):\n            s += a[j]\n            if (s % k) == (j - i + 1):\n                count += 1\n    return count\n\nprint(count_subsequences())",
        "result": "failed: testcase 0"
    },
    "2363": {
        "body": "import sys\n\n    n = int(input())\n    for _ in range(n):\n        a, b = sorted(map(int, input().split()))\n        operations = 0\n        while a != b:\n            operations += 1\n            if a > b:\n                a -= b\n            else:\n                b -= a\n        print(operations)\n\ncount_operations()",
        "result": "failed: testcase 0"
    },
    "909": {
        "body": "import sys\n\n    values = [a + b * c, a * (b + c), a * b * c, \n              (a + b) * c, a + b * c]\n    return max(values)\n\na = int(input())\nb = int(input())\nc = int(input())\n\nprint(max_value(a, b, c))",
        "result": "failed: testcase 0"
    },
    "154": {
        "body": "import sys\ninput = sys.stdin.readline\n\nM = 998244353\n\n    dp = [[0] * n for _ in range(n)]\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            if i == j:\n                dp[i-1][j-1] = 2\n            else:\n                s = [1]\n                for k in range(i+1, j):\n                    p = (k * (k-1)) % M\n                    s.append((p + sum(s[:-1])) % M)\n                x = s[-1]\n                dp[i-1][j-1] = (x * dp[j-i][i-1]) % M\n\n    ans = 0\n    for i in range(1, n+1):\n        if ((n - i) & 1) == 0:\n            ans += dp[0][i-1]\n    return ans % M\n\nn = int(input())\nprint(f(n))",
        "result": "failed: testcase 0"
    },
    "39": {
        "body": "import sys\n\n    max_len = 0\n    for len_ in range(1, len(s) + 1):\n        for i in range(len(s) - len_ + 1):\n            substr = s[i:i+len_]\n            is_palindrome = True\n            for j in range(len(substr) // 2):\n                if substr[j] != substr[-j-1]:\n                    is_palindrome = False\n                    break\n            if not is_palindrome:\n                max_len = len_\n    return max_len\n\nprint(longest_non_palindrome(input()))",
        "result": "failed: testcase 0"
    },
    "1885": {
        "body": "import math\n\n\n    total = 0\n    for i in range(5, n + 1):\n        for j in range(i, n + 1):\n            if i <= j:\n                k = j - i + 1\n                comb = math.comb(j, i)\n                diff = (math.comb(n, j) - comb) // k\n                total += (comb - diff) * k\n    return total",
        "result": "failed: testcase 0"
    },
    "1180": {
        "body": "    mod = 10**9 + 7\n    max_val = int(s)\n    ways = [[0] * (k+1) for _ in range(n)]\n    dp = [0] * (n + 1)\n\n    for i in range(1, n+1):\n        val = int(s[i-1])\n        for j in range(k, -1, -1):\n            if j == k:\n                ways[i][j] = max_val\n            elif i < n and s[i] != '0':\n                ways[i][j] += val + dp[i]\n            if i > 1 and s[i-1] != '0' and s[i-2] != '0':\n                ways[i][j] += ways[i-2][j+1]\n        dp[i] = ways[i][k] % mod\n\n    return (dp[n] + max_val) % mod\n\nn, k = map(int, input().split())\ns = input()\nprint(calc_exp(n, k, s))",
        "result": "failed: testcase 0"
    },
    "1856": {
        "body": "    n = int(input())\n    passwords = []\n    for _ in range(n):\n        password = input()\n        passwords.append(password)\n    visited = set()\n    max_size = 0\n    for i in range(n):\n        flag = False\n        temp_visited = set()\n        for j in range(i, n):\n            if len(passwords[i]) < len(passwords[j]):\n                continue\n            is_eq = True\n            for k, letter in enumerate(passwords[j]):\n                if passwords[i][k] != letter:\n                    is_eq = False\n                    break\n            if is_eq:\n                temp_visited.add(j)\n        for idx in sorted(list(temp_visited), reverse=True):\n            password = passwords[idx]\n            for j in range(n):\n                if len(password) < len(passwords[j]) and (passwords[j] not in visited or passwords[j] != password):\n                    break\n                is_eq = True\n                for k, letter in enumerate(passwords[j]):\n                    if password[k] != letter:\n                        is_eq = False\n                        break\n                if is_eq:\n                    max_size += 1\n                    visited.add(j)\n    print(max_size)",
        "result": "failed: testcase 0"
    },
    "522": {
        "body": "import sys\nmod = 1000000007\n\n    n, f_1, f_2, f_3, c = [int(x) for x in input().split()]\n    ans = [f_1, f_2, f_3]\n    for i in range(4, int(n) + 1):\n        temp = pow(c, (2 * i - 12) % mod, mod)\n        if len(ans) < i:\n            ans += [0] * (i - len(ans))\n        for j in range(len(ans) - 3, max(i-1, -1), -1):\n            ans[j] = (ans[j] * temp + ans[j-1]) % mod\n    return ans[-1]\n\nprint(calculate_f_n())",
        "result": "failed: testcase 0"
    },
    "1719": {
        "body": "import sys\nmod = 1000000007\n\n    dp = [[0] * 6 for _ in range(N + 1)]\n    dp[0][0] = 1\n    for n in range(1, N + 1):\n        dp[n][0] += dp[n - 1][0]\n        dp[n][2] += dp[n - 1][1]\n        dp[n][3] += dp[n - 1][2]\n        if n > 1:\n            dp[n][4] = (dp[n - 1][0] + dp[n - 2][1]) % mod\n            dp[n][5] = (dp[n - 1][0] + dp[n - 2][3]) % mod\n        for k in range(6):\n            dp[n][(k * 4) % 6] += dp[n - 1][k]\n    return sum(dp[N]) % mod\n\nN = int(input())\nprint(count_strings(N))",
        "result": "failed: testcase 0"
    },
    "1842": {
        "body": "import math\n\n    discriminant = b**2 - 4*a*c\n    sqrt_discriminant = math.sqrt(discriminant)\n    root1 = (-b + sqrt_discriminant) / (2 * a)\n    root2 = (-b - sqrt_discriminant) / (2 * a)\n    return max(root1, root2), min(root1, root2)\n\na, b, c = map(int, input().split())\nprint(get_roots(a, b, c)[0])\nprint(get_roots(a, b, c)[1])",
        "result": "failed: testcase 0"
    },
    "806": {
        "body": "import sys\nimport math\nfrom functools import reduce\nfrom operator import mul\n\nmod = 10**9 + 7\n\n    ways = [[0 for _ in range(3)] for _ in range(r+1)]\n    ways[0][0] = 1\n\n    for i in range(1, r+1):\n        for j in range(3):\n            if (l + i) % 3 == j:\n                for k in range(j, 3):\n                    ways[i][k] += ways[i-1][k-j]\n\n    ans = sum([ways[n][i] for i in range(3)]) % mod\n    return ans\n\nn, l, r = map(int, input().split())\nprint(num_ways(n, l, r))",
        "result": "failed: testcase 0"
    },
    "365": {
        "body": "import sys\n\n    n, x = map(int, input().split())\n    a = list(map(int, input().split()))\n    total = sum(a)\n    if total > x:\n        return \"NO\"\n    i = 0\n    while i < len(a) - 1:\n        if a[i] + a[i+1] <= x % (a[i] + a[i+1]):\n            i += 2\n        elif a[i] == x % (a[i] + a[i+1]) and a[i+1] == 0:\n            i += 2\n    return \"YES\" if a[0] != x - total or len(a) > 1 else \"NO\"\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "1158": {
        "body": "import sys\n\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    freq = {}\n    for i in range(n):\n        if a[i] not in freq:\n            freq[a[i]] = 1\n        else:\n            freq[a[i]] += 1\n\n    count = sum(val % k == 0 and val >= k for val in freq.values())\n\n    stolen_utensils = n - max(freq.values())\n    return min(stolen_utensils, count)\n\nprint(min_stolen_utensils())",
        "result": "failed: testcase 0"
    },
    "33": {
        "body": "import sys\n\na1, b1, a2, b2, L, R = map(int, input().split())\n\n    cnt = 0\n    for k in range(R // a1 + 1):\n        d1 = (R - a1 * k) / a2\n        if d1 <= 0 or not d1.is_integer() or b2 + a2 * int(d1) < L:\n            continue\n\n        for l in range(int(d1) + 1, min(R // a2 + 1, int(d1) + 10)):\n            if b2 + a2 * l == a1 * k + b1:\n                cnt += 1\n    return cnt\n\nprint(count_x())",
        "result": "failed: testcase 0"
    },
    "2498": {
        "body": "import sys\n\n    N, M = map(int, input().split())\n    a_list = sorted(list(map(int, input().split())))\n    max_value = int(2e9)\n    semicommon_count = 0\n\n    for i in range(N):\n        p = (max_value // a_list[i]) + 1\n        k = 1\n        while True:\n            x = a_list[i] * (k + 0.5)\n            if x > M:\n                break\n            semicommon_count += 1\n            k += 1\n\n    return semicommon_count\n\nprint(count_semicommon_multiples())",
        "result": "failed: testcase 0"
    },
    "2309": {
        "body": "import sys\nfrom collections import defaultdict\n\n    vowels = set('aeiou')\n    return sum(1 for char in word if char in vowels)\n\n    vowels = set('aeiou')\n    for i in range(len(word) - 1, -1, -1):\n        if word[i] in vowels:\n            return word[i]\n\n    pairs = []\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            first_word, second_word = words[i], words[j]\n            if count_vowels(first_word) == count_vowels(second_word) and last_vowel(first_word) == last_vowel(second_word):\n                pairs.append((first_word, second_word))\n    return pairs\n\n    word_counts = defaultdict(int)\n    for pair in pairs:\n        word1, word2 = pair\n        for char in word1 + word2:\n            if char in 'aeiou':\n                word_counts[char] += 1\n    available_words = []\n    for i in range(len(words)):\n        available_words.append((words[i], count_vowels(words[i]), last_vowel(words[i])))\n    max_count = -1\n    best_pairs = []\n    for pair in pairs:\n        first_word, second_word = pair\n        word1, count1, last_char1 = available_words[words.index(first_word)]\n        word2, count2, last_char2 = available_words[words.index(second_word)]\n        if count1 == count2 and last_char1 == last_char2:\n            if max_count < count1:\n                max_count = count1\n                best_pairs.clear()\n                best_pairs.append((first_word, second_word))\n            elif max_count == count1:\n                best_pairs.append((first_word, second_word))\n\n    available_words.sort(key=lambda x: (x[0], -x[1]))\n    words.sort(key=lambda x: (-count_vowels(x), last_vowel(x)))\n    used_words = [False] * len(words)\n    for pair in pairs:\n        first_word, second_word = pair\n        word1, count1, _ = available_words[words.index(first_word)]\n        word2, count2, _ = available_words[words.index(second_word)]\n        used_words[words.index(word1)] = True\n        used_words[words.index(word2)] = True\n\n    lyric_count = 0\n    lyrics = []\n    for pair in best_pairs:\n        first_word, second_word = pair\n        count1, last_char1 = count_vowels(first_word), last_vowel(first_word)\n        count2, last_char2 = count_vowels(second_word), last_vowel(second_word)\n\n        while True:\n            max_count = -1\n            best_pair = None\n            for i in range(len(words)):\n                if used_words[i]:\n                    continue\n                word, new_count, _ = available_words[i]\n                if new_count == count2 and last_char2 == last_char1:\n                    if max_count < new_count:\n                        max_count = new_count\n                        best_pair = (word, second_word)\n            if best_pair is None:\n                break\n\n            used_words[words.index(best_pair[0])] = True\n            lyrics.append((best_pair[0] + ' ' + first_word, best_pair[1] + ' ' + second_word))\n            count2 = new_count\n\n    print(len(lyrics))\n    for lyric in lyrics:\n        print(' '.join(lyric))",
        "result": "failed: testcase 0"
    },
    "1326": {
        "body": "import math\n\n    divisor_count = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            divisor_count += 2\n        if i * i == n:\n            divisor_count -= 1\n    return divisor_count\n\nn = int(input())\ntotal_sum = 0\nfor k in range(1, n + 1):\n    total_sum += k * count_divisors(k)\nprint(total_sum)",
        "result": "failed: testcase 0"
    },
    "2950": {
        "body": "import sys\n\n    n = int(input())\n    heights = list(map(int, input().split()))\n    all_floors = sum(heights)\n    charges = 0\n    max_height = max(heights)\n\n    for height in sorted(set(heights)):\n        remaining_floors = all_floors\n        for block_height in heights:\n            if block_height < height or block_height > height and (block_height - height) % 2 == 1:\n                remaining_floors -= (block_height - 1)\n            elif block_height <= height:\n                remaining_floors -= block_height\n\n        if remaining_floors <= 0:\n            charges += 1\n        else:\n            all_floors = remaining_floors\n    return charges + 1 if all_floors > 0 else charges\n\nprint(min_charges())",
        "result": "failed: testcase 0"
    },
    "1983": {
        "body": "    lis = [a[0]]\n    for i in range(1, n):\n        if a[i] > lis[-1]:\n            lis.append(a[i])\n        else:\n            idx = 0\n            while idx < len(lis) and lis[idx] >= a[i]:\n                idx += 1\n            lis[idx] = a[i]\n    return len(lis)\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(longest_increasing_subsequence(n, a))",
        "result": "failed: testcase 0"
    },
    "1767": {
        "body": "max_sum = -1\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nfor r in range(1, len(a) + 1):\n    for l in range(r):\n        or_a = 0\n        or_b = 0\n        for i in range(l, r):\n            or_a |= a[i]\n            or_b |= b[i]\n        max_sum = max(max_sum, or_a + or_b)\n\nprint(max_sum)",
        "result": "failed: testcase 0"
    },
    "2382": {
        "body": "import sys\n\n    slime_counts = [0] * 40\n    for h in healths:\n        slime_counts[h] += 1\n\n    slimes = [None] * (2 ** N)\n    for i in range(2 ** N - 1, -1, -1):\n        if not slime_counts[i]:\n            continue\n        j = i + (i & -i)\n        while j <= (1 << 30) and slime_counts[j]:\n            slimes[i] = j\n            slime_counts[j] -= 1\n            j += j & -j\n\n    for i in range(2 ** N):\n        if slime_counts[slimes[i]] > 0:\n            return False\n\n    return True\n\nN = int(input())\nhealths = list(map(int, input().split()))\n\nresult = 'No'\nif is_possible(N, healths):\n    result = 'Yes'\n\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3907": {
        "body": "    n, m = map(int, input().split())\n    q = []\n    for _ in range(m):\n        x, y = map(int, input().split())\n        q.append((x, y))\n    return n, m, q\n\n    a = [0] * (n + 1)\n    q.sort(key=lambda x: x[0])\n    for i in range(1, len(q) + 1):\n        a[q[i - 1][0]] = i\n    for i in range(1, n + 1):\n        if a[i] == 0:\n            continue\n        j = i\n        while j <= n and a[j] == 0:\n            j += 1\n        if j != n + 1:\n            a[j - 1] -= 1\n    return a\n\n    w_max = [0] * (10 ** 5 + 1)\n    for x, y in q:\n        w_max[x] = max(w_max[x], y)\n    res = 0\n    for i in range(1, len(a)):\n        if a[i] > 0 and a[i - 1] == 0:\n            res += w_max[i]\n    return res\n\nn, m, q = get_input()\na = build_array(n, q)\nprint(get_result(a, q))",
        "result": "failed: testcase 0"
    },
    "3676": {
        "body": "    ways = [[0 for _ in range(C+1)] for _ in range(R+1)]\n\n    for r in range(1, R+1):\n        for c in range(1, C+1):\n            if r == 1 and c == 1:\n                ways[r][c] = 1\n            elif r == 1 or c == 1:\n                ways[r][c] = ways[r][c-1] + ways[r-1][c] - 1\n            else:\n                ways[r][c] = (ways[r-1][c-2] + ways[r-2][c-1] +\n                              4 * (r - 2) * (c - 2))\n\n    return ways[R][C]\n\nR, C = map(int, input().split())\nprint(count_ways(R, C))",
        "result": "failed: testcase 0"
    },
    "3293": {
        "body": "import sys\n\n    f = [0] * n\n    p = [0] * n\n    m = [0] * n\n    s = [0] * n\n\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        f[i], p[i], m[i], s[i] = a - 1, b, c, d\n\n    max_gain = 0\n    total_cost = 0\n\n    for i in range(n):\n        if s[f[i]] > 0:\n            total_cost += p[i]\n            s[f[i]] -= 1\n            max_gain = max(max_gain, m[f[i]] - p[i])\n\n    print(max_gain + total_cost)\n\nmax_net_gain(int(input()))",
        "result": "failed: testcase 0"
    },
    "3587": {
        "body": "import sys\n\n    n = int(input())\n    taboo_strings = []\n    for _ in range(n):\n        taboo_strings.append(input())\n\n    max_length = 0\n    max_string = \"\"\n\n    for length in range(1, len(taboo_strings[0]) + 2):\n        strings = {}\n        for i in range(len(taboo_strings)):\n            string = taboo_strings[i]\n            for j in range(len(string) - length + 1):\n                substr = string[j:j+length]\n                if substr not in strings:\n                    strings[substr] = 1\n                else:\n                    del strings[substr]\n\n        longest_substring_length = max(length, max(strings.keys(), default='') or '0')\n        if longest_substring_length > max_length:\n            max_length = longest_substring_length\n            max_string = ''.join([bit * length for bit in set(longest_substring)])\n\n    return max_string if max_length != len(max_string) else -1\n\nprint(longest_clue())",
        "result": "failed: testcase 0"
    },
    "3530": {
        "body": "    n = int(input())\n    roller_coasters = []\n    for _ in range(n):\n        a, b, t = map(int, input().split())\n        roller_coasters.append((a, b, t))\n\n    q = int(input())\n    times = []\n    for _ in range(q):\n        time = int(input())\n        times.append(time)\n\n    total_fun = 0\n    for i in range(len(times)):\n        max_fun = 0\n        for j in range(n):\n            a, b, t = roller_coasters[j]\n            k = min(t, (a // (b + 1)) ** 0.5) if b > 0 else t\n            fun = a - (k - 1) ** 2 * b\n            max_fun += max(0, fun)\n        total_fun += max_fun\n\n    print(total_fun)\n\nfun_roller_coaster()",
        "result": "failed: testcase 0"
    },
    "3900": {
        "body": "import sys\n\nn, p = map(int, input().split())\nsuspects = set()\nagree_count = [0] * n\n\nfor i in range(n):\n    x, y = map(lambda s: int(s) - 1, input().split())\n    suspects.add(i)\n    if i < x or i < y:\n        agree_count[x] += 1\n    if x < i or y < i:\n        agree_count[y] += 1\n\nsuspect_pairs = []\n\nfor suspect in sorted(suspects):\n    for other_suspect in sorted(suspects - {suspect}):\n        pair = tuple(sorted((suspect, other_suspect)))\n        if len([i for i in range(n) if i != suspect and i != other_suspect and agree_count[i] >= p]) > 0:\n            suspect_pairs.append(pair)\n\nprint(len(suspect_pairs))",
        "result": "failed: testcase 0"
    },
    "3996": {
        "body": "import sys\nfrom functools import reduce\nfrom math import gcd\n\nMOD = 10**9 + 7\n\n    arr = list(map(int, input().split()))\n    prod = reduce(lambda x, y: x * y, arr)\n\n    for i in range(1, n+1):\n        if pow(i, 2, MOD) == 1:\n            inv_i = pow(i, -1, MOD)\n        else:\n            inv_i = (pow(i, MOD-2, MOD) * pow(-1, -1)) % MOD\n\n        prod *= inv_i\n        prod %= MOD\n\n    inv_prod = pow(prod, -1, MOD)\n\n    for i in arr:\n        inv_i = pow(i, -1, MOD)\n        inv_prod *= inv_i\n        inv_prod %= MOD\n\n    print(f'{prod*inv_prod % MOD}/{MOD}')\n\ncups_and_key(int(input()))",
        "result": "failed: testcase 0"
    },
    "3276": {
        "body": "import sys\n\n    colors = ['R', 'G', 'B']\n    for i in range(N - 2):\n        for j in range(M - 2):\n            block = [board[i + k][j:j + 3] for k in range(3)]\n            if ''.join(block).count('W') == 9:\n                continue\n            flag = True\n            for color in colors:\n                sub_block = [''.join(row[j + i] for row in block) for i in range(3)]\n                if ''.join(sub_block).count(color) == 9 and all(\n                    cell == color or cell == 'W' for row in block for cell in row\n                ):\n                    flag = False\n                    break\n            if flag:\n                return \"NO\"\n    return \"YES\"\n\nN, M = map(int, input().split())\nboard = [list(input()) for _ in range(N)]\nprint(can_reproduce(N, M, board))",
        "result": "failed: testcase 0"
    },
    "3834": {
        "body": "import sys\n\n        if i < 0 or i >= n or j < 0 or j >= m or table[i][j] != value:\n            return False\n        table[i][j] = -1\n        visited.add((i, j))\n        for x in range(max(0, i-1), min(n, i+2)):\n            for y in range(max(0, j-1), min(m, j+2)):\n                if (x, y) not in visited:\n                    dfs(x, y, value)\n        return True\n\n    rows = [[-1] * m for _ in range(n)]\n    columns = [[-1] * n for _ in range(m)]\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] != -1:\n                visited = set()\n                if dfs(i, j, table[i][j]):\n                    count += 1\n\n    rows_sum = [sum(row) for row in rows]\n    columns_sum = [sum(col) for col in columns]\n\n    for i in range(n):\n        for j in range(m):\n            if (rows[i] + columns[j]) % 2 == table[i][j] and -rows_sum[i] <= k and -columns_sum[j] <= k:\n                return 0\n\n    return -1 if count == n * m else min(-k, -max(rows_sum) // 2 + max(columns_sum) // 2)\n\nn, m, k = map(int, input().split())\ntable = []\nfor _ in range(n):\n    table.append(list(map(int, input().split())))\n\nprint(min_cells_to_change(n, m, k, table))",
        "result": "failed: testcase 0"
    },
    "3012": {
        "body": "import sys\n\nMOD = 1000000007\n\n    dp = [[0] * (a11 + a12) for _ in range(2)]\n    dp[0][0] = a11\n    dp[1][0] = a12\n    for i in range(N - 1):\n        ndp = [[0] * (a11 + a12) for _ in range(2)]\n        for s in range(2):\n            for j in range(a11 + a12):\n                if s == 0:\n                    c = min(j, dp[s][j])\n                    ndp[1 - s][c] += dp[s][j]\n                    if c < a21 and dp[s][j] > 0 and (i == N - 2 or j != 0):\n                        ndp[0][a21] += dp[s][j]\n                else:\n                    c = min(j, dp[s][j])\n                    ndp[1 - s][c] += dp[s][j]\n        dp = ndp\n    ans = 0\n    for i in range(2):\n        for j in range(a11 + a12):\n            if (i == 0 and j < a21) or (i == 1 and j > 0):\n                continue\n            ans += dp[i][j]\n    return ans % MOD\n\na11, a12, a21, a22, N = map(int, sys.stdin.readline().split())\nprint(num_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0"
    },
    "3745": {
        "body": "    n, m = map(int, input().split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, input().split())\n        edges.append((u - 1, v - 1))\n\n    color = [0] * n\n    visited = [False] * n\n\n        visited[node] = True\n        for i in range(n):\n            if (color[i] == 0 and abs(i - node) <= 1 or\n                    edges.count((i, node)) != 0 and color[i] != 0):\n                continue\n            color[i] = node % 3 + 1\n            if not visited[i]:\n                dfs(i)\n\n    for i in range(n):\n        if not visited[i]:\n            color[i] = 1\n            dfs(i)\n            break\n\n    for u, v in edges:\n        if (color[u] == 0 or color[v] == 0 or\n                abs(color[u] - color[v]) > 1 or\n                ((color[u] == 1 and color[v] != 2) and (color[u] == 2 and color[v] != 1))):\n            return False\n\n    ans = ['a'] * n\n    for i in range(n):\n        ans[i] = chr(97 + (color[i] - 1))\n\n    print('Yes')\n    print(''.join(ans))\n    return True",
        "result": "failed: testcase 0"
    },
    "3028": {
        "body": "import sys\n\n    rows = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        rows.append(row)\n    moves = 0\n    sequence = []\n\n    while True:\n        max_val = [max(row) for row in rows]\n        if all(val == p - 1 for val in max_val):\n            print(len(sequence))\n            print(*sequence[1:])\n            return\n\n        for i in range(n):\n            for j in range(m):\n                if rows[i][j] == p - 1:\n                    target = (max_val[i], max_val[j])\n                    sequence.append(target[0] * m + target[1])\n\n                    for k in range(n):\n                        for l in range(m):\n                            if (k != i) or (l != j):\n                                rows[k][l] += 1\n                                if rows[k][l] == p:\n                                    rows[k][l] = 1\n\n        moves += 1\n        if moves > p * m * n:\n            print(-1)\n            return\n\nprimonimo(*map(int, input().split()))",
        "result": "failed: testcase 0"
    },
    "3196": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    roads = [[] for _ in range(n+1)]\n    visited = [0] * (n + 1)\n    for i in range(m):\n        a, b = map(int, input().split())\n        roads[a].append(b)\n\n    ways = [0] * (n + 1)\n    stack = [(1, -1)]\n    while len(stack) > 0:\n        town, prev_town = stack.pop()\n        if visited[town] <= i:\n            continue\n        visited[town] = i\n        for neighbor in roads[town]:\n            if neighbor != prev_town:\n                stack.append((neighbor, town))\n                ways[neighbor] += ways[town]\n\n    result = 0\n    for way in ways[1:]:\n        if way > 0:\n            result += 1\n\n    if result == n - 2:\n        print(\"inf\")\n    else:\n        ans = str(result)\n        while len(ans) < 9 or len(ans) > 10:\n            if len(ans) < 9:\n                ans += \"0\"\n            else:\n                ans = ans[-9:]\n        print(ans)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3405": {
        "body": "import sys\nimport math\n\n    numbers = []\n    for i in range(1, 10**8):\n        str_i = str(i)\n        if len(str_i) > 8:\n            break\n        first_digit = int(str_i[0])\n        new_str_i = str_i[1:] + str(first_digit)\n        new_i = float(new_str_i)\n        if math.isclose(new_i * X, float(new_str_i), rel_tol=1e-9):\n            numbers.append(i)\n    return numbers\n\nX = float(input())\nresult = get_numbers(X)\n\nif result:\n    for num in sorted(result):\n        print(num)\nelse:\n    print(\"No solution\")",
        "result": "failed: testcase 0"
    },
    "3126": {
        "body": "    n = len(frogs)\n    changes = [0] * n\n    total_jumps = 0\n\n    for i in range(n):\n        jumps = 1 + (frogs[i] - tower) // (i + 1)\n        total_jumps += jumps\n        changes[i] = jumps\n\n    return total_jumps\n\nn, tower = map(int, input().split())\nfrogs = list(map(int, input().split()))\n\nfor _ in range(int(input())):\n    action = input().split()\n    if action[0] == '+':\n        new_frog = int(action[1])\n        changes.append(1 + (new_frog - tower) // len(frogs))\n        frogs.append(new_frog)\n    elif action[0] == '-':\n        index = [i for i, frog in enumerate(frogs) if frog == int(action[1])]\n        del frogs[index[0]]\n        del changes[-1]\n    else:\n        new_tower = int(action[1])\n        total_jumps = 0\n        for i in range(len(frogs)):\n            jumps = 1 + (frogs[i] - new_tower) // (i + 1)\n            total_jumps += jumps\n        changes[-1] = total_jumps\n\n    print(sum(changes))",
        "result": "failed: testcase 0"
    },
    "3279": {
        "body": "    marking = [[None] * (n + 1) for _ in range(n)]\n    column_fill = [False] * n\n    row_fill = [False] * n\n\n    for i in range(n):\n        row = list(map(int, input().split()))\n        if sum(row) == 0:\n            continue\n        group_count = 0\n        prev_end = -1\n        for j in range(len(row)):\n            num = row[j]\n            start = prev_end + 1\n            end = start + num - 1\n            for k in range(start, end + 1):\n                marking[i][k] = True\n                column_fill[k - 1] = True\n            group_count += 1\n            prev_end = end\n\n    for j in range(n):\n        col = list(map(int, input().split()))\n        if sum(col) == 0:\n            continue\n        group_count = 0\n        prev_end = -1\n        for i in range(len(col)):\n            num = col[i]\n            start = prev_end + 1\n            end = start + num - 1\n            for k in range(start, end + 1):\n                if not column_fill[k]:\n                    marking[k][j] = True\n                    row_fill[j] = True\n            group_count += 1\n            prev_end = end\n\n    for i in range(n):\n        if row_fill[i]:\n            print(''.join(['1' if x else '0' for x in marking[i]]))\n        else:\n            print('0' * (n + 1))\n\nn = int(input())\ngenerate_marking(n, [input().split() for _ in range(n)], [input().split() for _ in range(n)])",
        "result": "failed: testcase 0"
    },
    "3599": {
        "body": "import sys\n\n    time = 0\n    stage_time = [0] * n\n    for i in range(n):\n        for j in range(breaks[i]):\n            if len([x for x in stage_time if x == -1]) < 3:\n                stage_time[i] = time\n            else:\n                break\n            time += 1\n            while any(stage_time[k] == time for k in range(n)):\n                time += 1\n        if i > 0 and stage_time[i-1] != -1:\n            stage_time[i] = max(stage_time[i], stage_time[i-1] + breaks[i-1])\n    for i in range(n):\n        while stage_time[i] < breaks[i]:\n            stage_time[i] += 1\n    return ' '.join(map(str, stage_time))\n\nt, n = map(int, input().split())\nbreaks = list(map(int, input().split()))\nprint(schedule_breaks(t, n, breaks))",
        "result": "failed: testcase 0"
    },
    "3687": {
        "body": "import sys\n\n    n, q, s = map(int, input().split())\n    queue_sizes = [0] * q\n    sensors_to_queues = [None] * s\n    for i in range(s):\n        sensor_queue = int(input()) - 1\n        sensors_to_queues[i] = sensor_queue\n        queue_sizes[sensor_queue] += 1\n\n    data_sizes = [[] for _ in range(q)]\n    for line in range(n):\n        window_size, *data_transferred = map(int, input().split())\n        for i, data in enumerate(data_transferred[:-1]):\n            sensors_to_queues[i].append((data, line))\n        queue_sizes = [size + sum(d[0] for d in data_sizes[q]) for q, size in enumerate(queue_sizes)]\n\n    for i in range(s):\n        sensor_queue = sensors_to_queues[i]\n        if any(data[0] > queue_sizes[sensor_queue[k][1]] for k, (data, _) in enumerate(sensor_queue)):\n            return False\n\n    return True\n\nprint(\"possible\" if can_transfer_data() else \"impossible\")",
        "result": "failed: testcase 0"
    },
    "3864": {
        "body": "import sys\nMOD = 998244353\n\n    if n <= 3:\n        return [3 * pow(2, -1, MOD) % MOD]\n    ans = [0] * (n + 1)\n    for j in range(2, n + 1):\n        for k in range(j - 1):\n            ans[j] += ((pow(2, k + 1, MOD) - pow(2, j - k, MOD)) % MOD *\n                       (ans[k + 1] + ans[min(k + 3, j - 1)]) % MOD)\n        ans[j] = ans[j] % MOD\n    return [6 * pow(2, i - 1, MOD) % MOD for i in range(1, n + 1)]\n\nn = int(input())\nprint(*solve(n))",
        "result": "failed: testcase 0"
    },
    "3504": {
        "body": "import sys\n\n    D, S = map(int, input().split())\n    sensors = []\n    droplets = []\n\n    for _ in range(D):\n        x, y = map(int, input().split())\n        droplets.append((x, y))\n\n    for _ in range(S):\n        x1, x2, y = map(int, input().split())\n        sensors.append((x1, x2, y))\n\n    sensors.sort(key=lambda s: (s[2], -s[0]))\n    droplets.sort(key=lambda d: d[1])\n\n    result = []\n    i = 0\n    for d in droplets:\n        while i < len(sensors) and sensors[i][2] == d[1]:\n            x, y, _ = sensors.pop(i)\n            if x <= d[0] <= y:\n                result.append(d[1])\n                break\n        else:\n            result.append(0)\n\n    for r in result:\n        print(r)\n\nwill_disintegrate()",
        "result": "failed: testcase 0"
    },
    "3451": {
        "body": "import sys\n\n    open_cost = []\n    close_cost = []\n    balance = 0\n    for i in range(n):\n        c = int(input())\n        if s[i] == '(':\n            balance += 1\n            open_cost.append(c)\n        else:\n            balance -= 1\n            close_cost.append(c)\n\n        if balance < 0 and k > 0:\n            return -1\n\n    for i in range(n):\n        if (s[i] == ')' and open_cost[i] <= close_cost[i]) or (s[i] == '(' and open_cost[i] >= close_cost[i]):\n            s = s[:i] + s[i+1:]\n\n    open_balance = 0\n    close_balance = 0\n    min_open = float('inf')\n    min_close = float('inf')\n    for i in range(n):\n        if s[i] == '(':\n            open_balance += 1\n            min_open = min(min_open, open_cost[i])\n        else:\n            close_balance += 1\n            min_close = min(min_close, close_cost[i])\n\n    if max(open_balance, close_balance) > k or n - max(open_balance, close_balance) <= k:\n        return '?'\n\n    s = list(s)\n    for i in range(n):\n        if open_balance < close_balance and open_cost[i] == min_open and open_balance <= k:\n            s[i] = ')'\n            open_balance += 1\n        elif close_balance < open_balance and close_cost[i] == min_close and close_balance <= k:\n            s[i] = '('\n            close_balance += 1\n\n    total = 0\n    for i in range(n):\n        if s[i] != s[i]:\n            total -= open_cost[i]\n        else:\n            total += close_cost[i]\n\n    return total",
        "result": "failed: testcase 0"
    },
    "3156": {
        "body": "import sys\n\n    N = int(input())\n    K = int(input())\n\n    store_items = [[] for _ in range(N)]\n    for i in range(K):\n        index, item = input().split()\n        index = int(index)\n        store_items[index].append(item)\n\n    M = int(input())\n    purchased_items = []\n    for i in range(M):\n        item = input()\n        purchased_items.append(item)\n\n    current_index = 0\n    paths = {}\n    for item in purchased_items:\n        found_item = False\n        for index, items in enumerate(store_items):\n            if item in items and index > current_index:\n                if item not in paths or len(paths[item]) <= len([index for x in paths[item] if x == index]):\n                    paths[item] = [index]\n                else:\n                    paths[item].append(index)\n\n        found_item = False\n        for items in paths.values():\n            if current_index < min(items):\n                found_item = True\n                current_index = max(current_index, min(items))\n                break\n\n        if not found_item:\n            print(\"impossible\")\n            return\n\n    if len(paths) == M and all(len(x) == 1 for x in paths.values()):\n        print(\"unique\")\n    else:\n        print(\"ambiguous\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3697": {
        "body": "import sys\n\n    n, k, m, a = map(int, input().split())\n    g = list(map(int, input().split()))\n    \n    last_votes = [[] for _ in range(n + 1)]\n    \n    for i, v in enumerate(g):\n        last_votes[v].append((i, v))\n        \n    result = [0] * (n + 1)\n        \n    current_index = 0\n    for i in range(1, n + 1):\n        if len(last_votes[i]) == 0:\n            result[i] = 3\n        else:\n            max_votes = len(last_votes[i])\n            max_last_vote_time = last_votes[i][0][0]\n            \n            for last_vote in last_votes[i]:\n                if last_vote[0] > max_last_vote_time or (last_vote[0] == max_last_vote_time and len(last_vote) > max_votes):\n                    max_votes = len(last_vote)\n                    max_last_vote_time = last_vote[0]\n                    \n            if k <= current_index + max_votes:\n                result[i] = 1\n            else:\n                result[i] = 2\n                \n        current_index += max_votes\n            \n    print(' '.join(map(str, [x for x in result[1:]])))\n            \nprocess_elections()",
        "result": "failed: testcase 0"
    },
    "3647": {
        "body": "import sys\n\n    rows, cols = len(maze), len(maze[0])\n    visited = [[False for _ in range(cols)] for _ in range(rows)]\n    moves = [[-1 for _ in range(cols)] for _ in range(rows)]\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n        queue = [(start, 0)]\n        while queue:\n            x, y = queue.pop(0)\n            if maze[x][y] == 'M':\n                moves[start[0]][start[1]] = 0\n                return True\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    new_move = moves[start[0]][start[1]] + (maze[nx][ny] == '_' or maze[nx][ny] == '.')\n                    if maze[nx][ny] == '_':\n                        queue.append(((nx, ny), new_move))\n                    else:\n                        queue.append(((nx, ny), 1))\n\n    for i in range(rows):\n        for j in range(cols):\n            bfs((i, j))\n\n    return moves\n\n    lines = sys.stdin.readlines()\n    r, c = map(int, lines[0].split())\n    maze = [list(line.strip()) for line in lines[1:r+1]]\n    goal = ((r - 1), (c - 1))\n    min_moves = get_min_moves(maze, (-1, -1), goal)\n\n    for row in min_moves:\n        print(' '.join(map(str, row)))\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3699": {
        "body": "import math\nimport sys\n\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\n    bottles = []\n    for _ in range(n):\n        bottle_x, bottle_y = map(int, input().split())\n        bottles.append((bottle_x, bottle_y))\n    return bottles\n\n    total_distance = 0\n    for bottle in bottles:\n        total_distance += calculate_distance(adil_x, adil_y, bottle[0], bottle[1])\n        total_distance += calculate_distance(bera_x, bera_y, bottle[0], bottle[1])\n    total_distance += calculate_distance(adil_x, adil_y, target_x, target_y)\n    total_distance += calculate_distance(bera_x, bera_y, target_x, target_y)\n    return total_distance\n\n    adil_x, adil_y, bera_x, bera_y, target_x, target_y = map(int, input().split())\n    n = int(input())\n    bottles = get_bottles(n, [])\n    \n    min_total_distance = float('inf')\n    \n    for bottle in bottles:\n        temp_adil_x = adil_x\n        temp_adil_y = adil_y\n        \n        temp_bera_x = bera_x\n        temp_bera_y = bera_y\n        \n        current_bottle_index = bottles.index(bottle)\n        \n        for i in range(len(bottles)):\n            if i != current_bottle_index:\n                bottle_to_move_x, bottle_to_move_y = bottles[i]\n                \n                temp_adil_distance = calculate_distance(temp_adil_x, temp_adil_y, bottle_to_move_x, bottle_to_move_y) + \\\n                                    calculate_distance(bottle_to_move_x, bottle_to_move_y, target_x, target_y)\n                \n                temp_bera_distance = calculate_distance(temp_bera_x, temp_bera_y, bottle_to_move_x, bottle_to_move_y) + \\\n                                    calculate_distance(bottle_to_move_x, bottle_to_move_y, target_x, target_y)\n                \n                if temp_adil_distance < min_total_distance or temp_bera_distance < min_total_distance:\n                    bottles[current_bottle_index] = (bottle[0], bottle[1])\n                    \n                    adil_x = temp_adil_x\n                    adil_y = temp_adil_y\n                    \n                    bera_x = temp_bera_x\n                    bera_y = temp_bera_y\n                    \n                    current_min_total_distance = calculate_total_distance(bottles, adil_x, adil_y, bera_x, bera_y, target_x, target_y)\n                    \n                    if current_min_total_distance < min_total_distance:\n                        min_total_distance = current_min_total_distance\n        bottles[current_bottle_index] = (bottle[0], bottle[1])\n    \n    print(min_total_distance)",
        "result": "failed: testcase 0"
    },
    "3145": {
        "body": "import sys\n\n    x, a, b = map(int, input().split())\n    allowed_digits = set(input())\n\n        return ''.join(sorted(str(n))) <= ''.join(allowed_digits)\n\n    count = 0\n    for i in range(a, b+1):\n        if i % x == 0 and is_allowed(i):\n            count += 1\n\n    print(count)\n\ncount_multiples()",
        "result": "failed: testcase 0"
    },
    "3795": {
        "body": "    bills = [1, 2, 5, 10, 20, 50, 100]\n    euros = [5, 10, 20, 50, 100, 200]\n\n    n %= (d * 110)\n    for i in range(2000):\n        euro_count = (n - d) // e\n        if euro_count >= 0:\n            n -= euro_count * e\n\n        for bill in bills:\n            count = n // d\n            while count > 0 and n % d == 0:\n                n -= d * bill\n                count -= 1\n\n    return n",
        "result": "failed: testcase 0"
    },
    "3353": {
        "body": "    import sys\n    P, R, L = map(int, input().split())\n    graph = {}\n    for _ in range(L):\n        E1, E2 = map(int, input().split())\n        if E1 not in graph:\n            graph[E1] = []\n        if E2 not in graph:\n            graph[E2] = []\n        graph[E1].append(E2)\n        graph[E2].append(E1)\n\n    queue = [[-2, 0, P]]\n    visited = set()\n    min_time = float('inf')\n    while queue:\n        curr_boulder, time_taken, num_people = queue.pop(0)\n        if (curr_boulder, time_taken) in visited:\n            continue\n        visited.add((curr_boulder, time_taken))\n        if curr_boulder == -1 and num_people > 0:\n            min_time = min(min_time, time_taken)\n            continue\n        for neighbor in graph[curr_boulder]:\n            queue.append([neighbor, time_taken + 1, max(0, num_people - 1)])\n\n    if min_time != float('inf'):\n        return min_time\n    else:\n        return P\n\nprint(min_time_to_cross_river())",
        "result": "failed: testcase 0"
    },
    "3065": {
        "body": "import sys\nfrom math import sqrt, log, exp\n\n    N = int(input())\n    L = int(input())\n    walk = list(map(int, input().split()))\n    g = [[] for _ in range(N)]\n    for i in range(N):\n        line = list(map(int, input().split()))\n        n = line[0]\n        neighbors = line[1:]\n        for j in range(n):\n            x = neighbors[j]\n            g[i].append(x)\n            g[x].append(i)\n\n    dists = [0] * N\n    for i in range(N):\n        visited = [False] * N\n        queue = [(i, 0)]\n        while len(queue) > 0:\n            node, d = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                dists[i] += 1 / (2 ** d)\n                for neighbor in g[node]:\n                    queue.append((neighbor, d + 1))\n\n    prob = 1.0\n    for i in range(L):\n        u = walk[i]\n        v = walk[(i + 1) % L]\n        if dists[u] > dists[v]:\n            prob *= (dists[v] / dists[u])\n        elif dists[u] < dists[v]:\n            prob *= (dists[u] / dists[v])\n\n    print(prob)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3250": {
        "body": "    for m in range(1, b + 1):\n        remainder = 0\n        sign = -1 if m % 2 == 0 else 1\n        for power in range(m * (b - 1), 0, -m):\n            remainder += sign * pow(b, power, d)\n            sign *= -1\n        if remainder % d != 0:\n            return False\n    return True\n\nb, d = map(int, input().split())\nif is_valid_divisibility_hack(b, d):\n    print('yes')\nelse:\n    print('no')",
        "result": "failed: testcase 0"
    },
    "3306": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    detectors = []\n    for _ in range(n):\n        p, c = map(int, input().split())\n        detectors.append((p, c))\n\n    calls = [0] * (m + 1)\n    for p, c in detectors:\n        calls[p] += c\n        if p < m:\n            calls[m - p] -= c\n\n    total_calls = 0\n    west_calls = 0\n    east_calls = 0\n    for i in range(1, m + 1):\n        west_calls += max(calls[i] - west_calls, 0)\n        east_calls += max(calls[m - i] - east_calls, 0)\n        total_calls += min(west_calls, east_calls)\n\n    return total_calls\n\nprint(min_phone_calls())",
        "result": "failed: testcase 0"
    },
    "3970": {
        "body": "n, k = map(int, input().split())\na = sorted(map(int, input().split()))\n\nf = [0] * n\nj = -1\nfor i in range(n):\n    if a[i] % k == 0:\n        if j < 0 or a[j] != a[i]:\n            f[i] = 1\n            j += 1\n\n    elif (a[i] // k) < a[j]:\n        f[i] = 1\nprint(sum(f))",
        "result": "failed: testcase 0"
    },
    "3655": {
        "body": "import sys\n\n    max_similarity = 0\n    candidate_locations = []\n\n    for y in range(len(floor_image) - len(robot_image) + 1):\n        for x in range(len(floor_image[0]) - len(robot_image[0]) + 1):\n            similarity = 0\n\n            for i in range(len(robot_image)):\n                for j in range(len(robot_image[0])):\n                    if robot_image[i][j] == floor_image[y+i][x+j]:\n                        similarity += 1\n\n            if similarity > max_similarity:\n                max_similarity = similarity\n                candidate_locations = [(x, y)]\n            elif similarity == max_similarity:\n                candidate_locations.append((x, y))\n\n    return sorted(candidate_locations)\n\n# Read input from stdin\nw_h_robot = [int(i) for i in input().split()]\nw, h = w_h_robot[0], w_h_robot[1]\nrobot_image = []\nfor _ in range(h):\n    row = [int(i) for i in input().split()]\n    robot_image.append(row)\n\nw_h_floor = [int(i) for i in input().split()]\n_, H = w_h_floor[0], w_h_floor[1]\n\nfloor_image = []\nfor _ in range(H):\n    row = [int(i) for i in input().split()]\n    floor_image.append(row)\n\ncandidates = find_candidates(floor_image, robot_image)\nprint('\\n'.join([f'{x} {y}' for x, y in candidates]))",
        "result": "failed: testcase 0"
    },
    "3589": {
        "body": "    count = [0] * 10\n    for i in range(L, R + 1):\n        num = i\n        while True:\n            digit_sum = 0\n            while num > 0:\n                digit_sum += (num % 10)\n                num //= 10\n            if digit_sum <= 9:\n                count[digit_sum] += 1\n                break\n            num *= digit_sum\n\n    result = ' '.join(map(str, count))\n    return result\n\n\nL, R = map(int, input().split())\nprint(solve(L, R))",
        "result": "failed: testcase 0"
    },
    "3257": {
        "body": "import math\n\n    a, b, c = sorted(map(float, input().split()))\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n\n    if 0 < area <= 100 and a <= b <= c:\n        return round(area, 8)\n    else:\n        return -1\n\nprint(calculate_carpet_area())",
        "result": "failed: testcase 0"
    },
    "3927": {
        "body": "    weights.sort()\n    count = 1\n    for i in range(1, n):\n        total_weight = weights[i] + weights[0]\n        if total_weight <= 100:\n            can_learn_all_but_one_pair = True\n            for j in range(i+1, n):\n                if weights[j] == weights[i]:\n                    continue\n                if weights[j] < weights[i]:\n                    break\n                if weights[j] > weights[i] and (total_weight - weights[j]) <= 100:\n                    can_learn_all_but_one_pair = False\n                    break\n            if can_learn_all_but_one_pair:\n                return i + 1\n\n    # Try to learn as many weights as possible with different total masses\n    for k in range(2, n+1):\n        for m in range(1, 101):\n            total_weight = sum(weights[:k])\n            if total_weight == m:\n                max_learnable_weights = k\n                break\n\n    return max(count, max_learnable_weights)\n\nn = int(input())\nweights = list(map(int, input().split()))\nprint(max_weights(n, weights))",
        "result": "failed: testcase 0"
    },
    "3319": {
        "body": "    n, nx, ny, nz = map(int, input().split())\n    planetoids = []\n    for _ in range(n):\n        m, x, y, z, vx, vy, vz = map(int, input().split())\n        planetoids.append([m, x, y, z, vx, vy, vz])\n    grid = [[0] * nz for _ in range(ny)]\n    for i in range(nx):\n        for j in range(ny):\n            for k in range(nz):\n                grid[j][k] += 1\n    time = 0\n    changed = True\n    while changed:\n        changed = False\n        new_planetoids = []\n        for i, (m, x, y, z, vx, vy, vz) in enumerate(planetoids):\n            nx = (x + vx + nx) % nx\n            ny = (y + vy + ny) % ny\n            nz = (z + vz + nz) % nz\n            new_planetoids.append([m, nx, ny, nz, vx, vy, vz])\n        planetoids = []\n        for m1, x1, y1, z1, vx1, vy1, vz1 in new_planetoids:\n            if any(m2 + m1 > 0 and (x1 == x2 or\n                                   (x1 == (x2 + vx2 + nx) % nx and\n                                    y1 == (y2 + vy2 + ny) % ny and\n                                    z1 == (z2 + vz2 + nz) % nz)\n                                   ) for i, (m2, x2, y2, z2, vx2, vy2, vz2) in enumerate(new_planetoids)\n                                   if i != 0):\n                m = sum(m for m, _, _, _, _, _, _ in new_planetoids if m + m1 > 0 and\n                        (m1 == m or (x1 == x and y1 == y and z1 == z) for m, x, y, z, _, _, _ in new_planets))\n                vx = sum(vx for m, x, y, z, vx, vy, vz in new_planetoids if m + m1 > 0 and\n                         (m1 == m or (x1 == x and y1 == y and z1 == z) for m, x, y, z, _, _, _ in new_planets))\n                new_planets.append([m1 + m, x1, y1, z1, vx1 + vx // (2 if m1 + m > 0 else 1), vy1, vz1])\n            else:\n                planetoids.append([m1, x1, y1, z1, vx1, vy1, vz1])\n        time += 1\n        if len(new_planets) == len(planetoids):\n            changed = False\n    new_planetoids = []\n    for m, x, y, z, vx, vy, vz in planetoids:\n        new_planetoids.append([m, (x + vx + nx) % nx, (y + vy + ny) % ny, (z + vz + nz) % nz, vx, vy, vz])\n    planetoids = sorted(new_planetoids, reverse=True)\n    print(len(planetoids))\n    for i, (m, x, y, z, vx, vy, vz) in enumerate(planetoids):\n        print(f\"P{i}: {m} {x} {y} {z} {vx} {vy} {vz}\")",
        "result": "failed: testcase 0"
    },
    "3009": {
        "body": "import sys\n\n    n = int(input())\n    lamps = []\n    for i in range(n):\n        x, y, e = map(int, input().split())\n        lamps.append((x, y, e))\n    \n    positive_energy = [lamp[2] > 0 for lamp in lamps]\n    negative_energy = [not p for p in positive_energy]\n\n        return ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n\n    lines = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if not (positive_energy[i] == positive_energy[j]):\n                x1, y1, e1 = lamps[i]\n                x2, y2, e2 = lamps[j]\n                lines.append((distance(x1, y1, x2, y2), i, j))\n\n    lines.sort(reverse=True)\n    current_line_length = 0\n    for line in lines:\n        length, i, j = line\n        current_positive_energy = positive_energy[i] + (positive_energy[j] == True)\n        remaining_positive_lamps = sum(1 for k in range(n) if positive_energy[k])\n        if remaining_positive_lamps - current_positive_energy <= 0 and len(lines) >= n:\n            line_length = 0\n            i_prev = None\n            j_prev = None\n            for k, (length_k, i_k, j_k) in enumerate(lines):\n                x1, y1, e1 = lamps[i_k]\n                x2, y2, e2 = lamps[j_k]\n                if length_k < length:\n                    continue\n                line_length += distance(x1, y1, x2, y2)\n                current_positive_energy += positive_energy[j_k] - (positive_energy[i_k] == True)\n                if i_prev != None and j_prev != None:\n                    line_length += distance(x1, y1, lamps[i_prev][0], lamps[i_prev][1])\n                    line_length += distance(lamps[j_prev][0], lamps[j_prev][1], x2, y2)\n                i_prev = i_k\n                j_prev = j_k\n            if current_positive_energy <= remaining_positive_lamps:\n                return round(line_length, 6)\n\n    return \"IMPOSSIBLE\"\n\nprint(find_balancing_line())",
        "result": "failed: testcase 0"
    },
    "3896": {
        "body": "import sys\n\n    n = len(x)\n    MOD = 1000000007\n    ans = 0\n    for i in range(n):\n        ai = int(x[i])\n        j = (1 << n) - 2 * (i + 1) + 1\n        while j >= 0:\n            bi = int(x[j] != '0')\n            if ai < bi:\n                ans += ((1 << i) * (1 << (n - j - 1))) % MOD\n            j -= 2\n    return ans % MOD\n\nx = input().strip()\nprint(dance_complexity(x))",
        "result": "failed: testcase 0"
    },
    "3509": {
        "body": "import sys\n\n        dist = [float('inf')] * (n + 1)\n        prev = [-1] * (n + 1)\n\n        for i in range(1, n + 1):\n            if dist[i] == float('inf'):\n                dist[i] = -dist[i]\n\n        for _ in range(n):\n            u = min(range(1, n + 1), key=lambda x: dist[x])\n            dist[u] = -dijkstra_dist[u]\n            del dijkstra_dist[u]\n\n            if dist[u] < float('inf'):\n                for v, t in roads.get(u, []):\n                    cost = dist[u] + t\n                    if cost < dist[v]:\n                        dist[v] = cost\n                        prev[v] = u\n\n        return dist[n]\n\n        dist = [float('inf')] * (n + 1)\n        for i in range(1, n + 1):\n            dist[i] = -dijkstra_dist[i]\n        return dist\n\n    dijkstra_dist()\n    a_dist = dijkstra()\n\n    dijkstra()\n    b_dist = dijkstra()\n\n    min_waiting = b\n    for i in range(a, b + 1):\n        if i <= a_dist[1]:\n            continue\n        if i > max(b_dist[1], min_waiting):\n            return -i\n\n    return min_waiting\n\na, b = map(int, input().split())\nn, m = map(int, input().split())\n\nroads = {}\nfor _ in range(m):\n    u, v, t = map(int, input().split())\n    if u not in roads:\n        roads[u] = []\n    roads[u].append((v, t))\n\nprint(min_waiting_time(a, b, n, m, roads))",
        "result": "failed: testcase 0"
    },
    "3547": {
        "body": "import math\n\n    n = int(input())\n    land = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        land.append((x1, y1, x2, y2))\n    actual_area = 0\n    for j in range(n):\n        sx1, sy1, sx2, sy2 = land[j]\n        max_x = -100000\n        min_x = 100000\n        max_y = -100000\n        min_y = 100000\n        for k in range(n):\n            if j != k:\n                x1, y1, x2, y2 = land[k]\n                min_x = min(min_x, max(x1, sx1))\n                max_x = max(max_x, min(x2, sx2))\n                min_y = min(min_y, max(y1, sy1))\n                max_y = max(max_y, min(y2, sy2))\n        if (max_x - min_x) * (max_y - min_y) > 0:\n            actual_area += ((max_x - min_x) <= 1000 and (max_y - min_y) <= 1000)\n    print(\"{:.2f}\".format(actual_area * (10000)))\n\ntotal_actual_area()",
        "result": "failed: testcase 0"
    },
    "3017": {
        "body": "    power = [int(d) for d in bin(2 ** e)[2:]]\n    total = 0\n    for i in range(len(power)):\n        max_num = n // (10 ** (len(power) - i))\n        min_num = max_num * 10**i + 1\n        for k in range(max_num, min_num - 1, -1):\n            str_k = str(k)\n            found = True\n            j = len(str_k) - 1\n            for d in power:\n                index = str_k.find(str(d))\n                if index == -1 or (j > index and str_k[index + 1] != '0'):\n                    found = False\n                    break\n                j = index\n            if found:\n                total += 1\n    return total",
        "result": "failed: testcase 0"
    },
    "3076": {
        "body": "import sys\n\n    jewels = []\n    for _ in range(n):\n        s, v = map(int, input().split())\n        jewels.append((s, v))\n    max_values = [0] * (k + 1)\n    for s, v in sorted(jewels, reverse=True):\n        for i in range(k, s - 1, -1):\n            if max_values[i] < max_values[i - s] + v:\n                max_values[i] = max_values[i - s] + v\n    return ' '.join(map(str, max_values[1:]))\n\nn, k = map(int, input().split())\nprint(max_jewel_value(n, k))",
        "result": "failed: testcase 0"
    },
    "3923": {
        "body": "import sys\n\nN, A, B = map(int, input().split())\n\n    P = [0] * (N + 1)\n    if A == B:\n        for i in range(2, N + 1):\n            P[i] = i - 1\n        P[1] = max(A, B)\n    elif A < B and N >= A + B - 2:\n        k = 0\n        i = A\n        while True:\n            j = i * 2 - A - k\n            if j <= N and (j < A or j > B):\n                P[j] = A\n                i += 1\n                k += 1\n            else:\n                for j in range(A, B + 1):\n                    if j not in [P[i] for i in range(1, N + 1)]:\n                        P[j] = j\n                        break\n                for i in range(B + 1, N + 1):\n                    if i not in [P[j] for j in range(1, N + 1)]:\n                        P[i] = i\n                        break\n            for i in range(1, N + 1):\n                P[i] = max(A, B) if P[i] == A or P[P[i]] != A else min(A, B) if P[i] == B or P[P[i]] != B else i\n            found = True\n            for i in range(1, N + 1):\n                if P[i] == i:\n                    continue\n                found = False\n                break\n            if found:\n                break\n    else:\n        print(-1)\n        return\n\n    for i in range(1, N + 1):\n        sys.stdout.write(str(P[i]) + ' ')\n    sys.stdout.write('\\n')\n\nmy_function()",
        "result": "failed: testcase 0"
    },
    "3332": {
        "body": "import sys\n\n    streams = []\n    for _ in range(n):\n        s, d, p = map(int, input().split())\n        end = s + d\n        streams.append((s, end, p))\n\n    streams.sort()\n    stack = []\n    dp = [0] * (n + 1)\n    max_total_priority = 0\n\n    for i in range(n):\n        if not stack or streams[i][0] >= stack[-1]:\n            while len(stack) > 0 and streams[i][0] >= stack[-1]:\n                top = stack.pop()\n                dp[i] = max(dp[i], dp[top-1])\n            stack.append(i)\n            dp[i] += max_total_priority\n        else:\n            while i < n and streams[i][0] < stack[-1] and streams[i][1] > stack[-1]:\n                max_total_priority = max(max_total_priority, dp[stack.pop()])\n            stack.append(i)\n\n    return max(max(dp) for dp in dp)\n\nprint(max_streams(int(input())))",
        "result": "failed: testcase 0"
    },
    "3240": {
        "body": "import sys\n\n    max_bv = -1\n    for bv in range(2 ** k):\n        exp_positions = 0\n        for i in range(len(voters) - 1):\n            p, b_i = voters[i]\n            if p == 1:\n                exp_positions += (b_i >> (k - 1)) & 1\n        b_v = bv\n        for i in range(len(voters) - 1):\n            p, b_i = voters[i]\n            if p != 0 and ((bv >> (len(voters) - i - 2) & 1) == 0 or p < 1):\n                b_v += b_i << (len(voters) - i - 2)\n        exp_positions += (b_v >> (k - 1)) & 1\n        if exp_positions > max_bv:\n            max_bv = exp_positions\n    return max_bv\n\n    k, v = map(int, input().split())\n    voters = []\n    for _ in range(v - 1):\n        p, bi = map(float, input().split())\n        voters.append((p, int(bi)))\n    print(calculate_max_positions(k, voters))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3368": {
        "body": "import sys\n\n    n, m = map(int, input().split())\n    animal_counts = {}\n    animal_enclosures = {}\n\n    for i in range(n):\n        type_, count_str, *enclosure_types = input().split()\n        count = int(count_str)\n        if count == 0:\n            continue\n        animal_counts[type_] = animal_counts.get(type_, 0) + count\n        animal_enclosures[i] = set(enclosure_types)\n\n    possible = True\n\n    for i in range(n):\n        type_ = min(animal_enclosures[i], key=lambda x: (animal_counts[x], x))\n        animals_to_move = list(filter(lambda x: x != type_, animal_enclosures[i]))\n        j = i\n        while len(animals_to_move) > 0:\n            if j in animal_enclosures and any(x in animal_enclosures[j] for x in animals_to_move):\n                for k, enclosure_types in animal_enclosures.items():\n                    if type_ in enclosure_types and len(enclosure_types) == animal_counts[type_]:\n                        del animal_counts[type_]\n                        del animal_enclosures[k]\n                break\n            j = (j + 1) % n\n\n        if len(animals_to_move) > 0:\n            possible = False\n            break\n\n    print(\"POSSIBLE\" if possible else \"IMPOSSIBLE\")\n\nis_possIBLE()",
        "result": "failed: testcase 0"
    },
    "3538": {
        "body": "    return frog['leap'] > depth\n\n    piles = []\n    for frog in sorted(frogs, key=lambda x: (x['leap'], -x['weight']), reverse=True):\n        i = 0\n        for p in piles:\n            if can_escape({'leap': frog['leap'], 'height': max([f['height'] for f in p]) + frog['height'], 'weight': sum([f['weight'] for f in p])}, depth):\n                i += 1\n            else:\n                break\n        pile = []\n        for _ in range(len(frogs)):\n            if len(pile) < i and can_escape({'leap': frogs[_]['leap'], 'height': max([f['height'] for f in pile]) + frogs[_]['height'], 'weight': sum([f['weight'] for f in pile]) + frogs[_]['weight']}, depth):\n                pile.append(frogs[_])\n        piles.append(pile)\n    return len([p for p in piles if can_escape({'leap': max([f['leap'] for f in p]), 'height': sum([f['height'] for f in p])}, depth)])\n\nn, d = map(int, input().split())\nfrogs = []\nfor _ in range(n):\n    l, w, h = map(int, input().split())\n    frogs.append({'leap': l, 'weight': w, 'height': h})\nprint(max_escapes(frogs, d))",
        "result": "failed: testcase 0"
    },
    "3183": {
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    flow = [0] * n\n    dist = [-1] * n\n    parent = [-1] * n\n    queue = deque()\n\n    while True:\n        for i in range(n):\n            dist[i] = -1\n        dist[s] = 0\n        queue.append(s)\n        while queue:\n            u = queue.popleft()\n            if u == t:\n                break\n            for v, c, w in graph[u]:\n                if flow[v] < c and dist[v] == -1:\n                    dist[v] = dist[u] + 1\n                    parent[v] = u\n                    queue.append(v)\n        if dist[t] == -1:\n            break\n\n        min_capacity = float('inf')\n        v = t\n        while v != s:\n            u = parent[v]\n            for v2, c, w in graph[u]:\n                if v2 == v:\n                    min_capacity = min(min_capacity, c - flow[v])\n            v = u\n        flow[t] += min_capacity\n\n        v = t\n        while v != s:\n            u = parent[v]\n            for v2, c, w in graph[u]:\n                if v2 == v and c - flow[v] > 0:\n                    graph[u].remove((v2, c - flow[v], w))\n                    graph[v2].append((u, c - flow[v], w))\n            v = u\n\n    return sum(flow)\n\n    cost = 0\n    for u in range(n):\n        for v, c, w in graph[u]:\n            if v == t:\n                cost += c * (flow[t] - flow[v])\n    return cost\n\n    global flow\n    n, m, s, t = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v, c, w = map(int, input().split())\n        graph[u].append((v, c, w))\n        graph[v].append((u, 0, -w))\n\n    flow = max_flow(graph, n + 1, s, t)\n    print(flow, min_cost(graph, n + 1, s, t))\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3916": {
        "body": "import math\nfrom collections import defaultdict\n\n    factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors\n\n    min_sum_dict = defaultdict(int)\n\n    for node in paths:\n        sum_path_len = 0\n        while True:\n            factor = get_prime_factors(node)[-1]\n            next_node = math.factorial(factor)\n            if next_node == 1:\n                break\n            else:\n                sum_path_len += len(paths[next_node])\n                node = next_node\n        min_sum_dict[node] = sum_path_len\n\n    max_val_node = max(min_sum_dict, key=min_sum_dict.get)\n\n    total_paths_len = sum(len(paths[node]) for node in paths) - 1\n    if total_paths_len < max_val_node:\n        return total_paths_len + len(paths[max_val_node])\n    else:\n        return total_paths_len\n\nn = int(input())\nk_values = list(map(int, input().split()))\npaths = defaultdict(int)\nfor k in k_values:\n    paths[k] += 1\nprint(find_node_with_min_sum(paths))",
        "result": "failed: testcase 0"
    },
    "3195": {
        "body": "import math\nfrom fractions import Fraction\n\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n\n    lights_color_change_times = []\n    for _ in range(n):\n        t, c = input().split()\n        t = int(t)\n        if c == 'green':\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r))\n        elif c == 'yellow':\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r) + T_g)\n        else:\n            lights_color_change_times.append((t - 1) % (T_g + T_y + T_r) + T_g + T_y)\n\n    t_q, c_q = map(str.strip, input().split())\n\n    possible_T_values = []\n    for time in range(T_g + T_y + T_r):\n        count = sum(1 for i in lights_color_change_times if (i - time) % (T_g + T_y + T_r) == 0)\n        if count >= 3:\n            possible_T_values.append(time)\n\n    t_q_real_time = int(t_q) % (T_g + T_y + T_r)\n\n    result = Fraction(1, len(possible_T_values))\n    for T in possible_T_values:\n        diff = t_q_real_time - T\n        if diff >= 0 and diff <= T_g:\n            result += Fraction(diff / (T_g + T_y + T_r))\n\n    return str(float(result))\n\nprint(calculate_probability())",
        "result": "failed: testcase 0"
    },
    "3998": {
        "body": "import sys\n\n    max_rating = max(ratings)\n    if max_rating == 0:\n        return [max_rating, 0] + [[1 if i > j else 0 for j in range(n)] for _ in range(n)]\n\n    groups = []\n    for k in range(2, min(6, n) + 1):\n        group_ratings = sorted(ratings[:k])\n        group_max = max(group_ratings)\n        group_count = len([r for r in group_ratings if r == group_max])\n        groups.append((group_ratings, group_max, group_count))\n\n    groups.sort(key=lambda x: (x[2], x[1]))\n\n    final_rating = 0\n    num_matches = 0\n\n    while True:\n        match_played = False\n        for group in groups:\n            if any(r <= final_rating for r in group[0]):\n                continue\n            group_max, _, _ = group\n            new_ratings = [max(group_max - (group_max - r), final_rating) for r in ratings]\n            num_new_changes = sum(new_ratings[i] != ratings[i] for i in range(n))\n            if num_new_changes > 1:\n                match_played = True\n                final_rating += 1\n                for i, new_r in enumerate(new_ratings):\n                    ratings[i] = new_r\n\n        if not match_played or any(r == max_rating for r in ratings):\n            break\n\n    return [final_rating, num_matches] + format_matchups(n, ratings)\n\n    if n is None:\n        n = len(j)\n    ones = []\n    for index, value in enumerate(j):\n        if index not in (i, i+j-k, i+j+1-k, i+j+2-k):\n            ones.append(value)\n    return ''.join('1' if index in (i, i+j-k, i+j+1-k, i+j+2-k) else '0' for index, value in enumerate(ones))\n\n    max_index = 0\n    while True:\n        max_index = next(i for i, r in enumerate(ratings) if r > ratings[max_index])\n        matchup = format_matchup(max_index, [r for r in ratings if r != ratings[max_index]])\n        yield matchup\n        ratings[max_index] += 1\n\n    n = int(input())\n    ratings = list(map(int, input().split()))\n    result = equal_ratings(n, ratings)\n    print(result[0])\n    print(result[1])\n    for matchup in result[2:]:\n        print(matchup)\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3150": {
        "body": "import sys\n\n    n = int(input())\n    lines = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        if x1 == x2:\n            slope = float('inf')\n        else:\n            slope = (y2 - y1) / (x2 - x1)\n        lines.append((slope, 1 if x1 < x2 else -1))\n    lines.sort()\n    curr_slope = None\n    count = 0\n    for slope, direction in lines:\n        if slope == curr_slope:\n            continue\n        curr_slope = slope\n        left, right = set(), set()\n        for i in range(len(lines)):\n            if lines[i][0] != slope or (direction < 0 and lines[i][1] > 0) or \\\n               (direction > 0 and lines[i][1] < 0):\n                continue\n            if lines[i][1] == direction:\n                left.add(i)\n            else:\n                right.add(i)\n        for l in left:\n            for r in right:\n                count += 1\n\n    print(count)\n\ncount_ways()",
        "result": "failed: testcase 0"
    },
    "3566": {
        "body": "    for _ in range(q):\n        i, x = map(int, input().split())\n        huts[i] = x\n        left_queue_sum = 0\n        right_queue_sum = 0\n        best_position = -1\n        queue_differences = []\n        for j in range(n):\n            if j < i:\n                left_queue_sum += huts[j]\n                queue_differences.append(left_queue_sum - (right_queue_sum + huts[i] - huts[j]))\n            elif j > i:\n                right_queue_sum += huts[j]\n                queue_differences.append(right_queue_sum - (left_queue_sum + huts[i] - huts[j]))\n        min_difference = min(queue_differences)\n        best_positions = [j for j in range(n) if queue_differences[j] == min_difference]\n        print(min(best_positions))\n\nimport sys\nn, q = map(int, input().split())\nhuts = list(map(int, input().split()))\nfood_truck(n, q, huts)",
        "result": "failed: testcase 0"
    },
    "3401": {
        "body": "import sys\nfrom heapq import heappush, heappop\n\n    n, s, t, q = map(int, input().split())\n    springs = [0] * (n + 1)\n    towns = [0] * (n + 1)\n    hills = []\n    for i in range(n):\n        x, y, h = map(int, input().split())\n        hills.append((x, y, h))\n    for i in range(s):\n        springs[ int(input()) ] = 1\n    for i in range(t):\n        towns[ int(input()) ] = 1\n\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n):\n        x, y, h = hills[i]\n        for j in range(i+1, n):\n            other_x, other_y, _ = hills[j]\n            dx = abs(other_x - x)\n            dy = abs(other_y - y)\n            len_ = (h + hills[j][2] - 1) // 2\n            if len_ <= q and dx + dy > 0:\n                graph[i+1].append((j+1, len_))\n                graph[j+1].append((i+1, len_))\n\n    dist = [-1] * (n + 1)\n    pq = [(0, 1)]\n    while pq:\n        d, node = heappop(pq)\n        if dist[node] != -1: continue\n        dist[node] = d\n        for neighbor, w in graph[node]:\n            if springs[neighbor]: continue\n            if towns[neighbor]: continue\n            heappush(pq, (d + w, neighbor))\n\n    ans = float('inf')\n    for i in range(1, n+1):\n        if not springs[i] and not towns[i]: continue\n        if dist[i] == -1: continue\n        j = i\n        path = [i]\n        while springs[j]:\n            best = -1\n            for neighbor, w in graph[j]:\n                if dist[neighbor] != -1:\n                    length = (dist[neighbor] + w) * 2\n                    if best == -1 or length < best: best = length\n            ans = min(ans, float(best))\n            j = path[-1]\n            for neighbor, w in graph[j]:\n                if dist[neighbor] != -1:\n                    length = (dist[neighbor] + w) * 2\n                    if best == -1 or length < best: best = length\n                    if springs[neighbor]: continue\n                    if len(path) >= 2 and path[-2] == neighbor: continue\n                    path.append(neighbor)\n                    break\n\n    print(ans if ans != float('inf') else 'IMPOSSIBLE')\n\nmain()",
        "result": "failed: testcase 0"
    },
    "3660": {
        "body": "import sys\n\n    n = len(stickers)\n    dp = [[float('inf')] * 1001 for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(len(message) + 1):\n            if dp[i - 1][j] < float('inf'):\n                for k in range(min(j + 2, len(stickers[i - 1]))):\n                    l = min(max(k, j - 1), len(message))\n                    r = max(l, j)\n                    if message[j:r] == stickers[i - 1][k:l]:\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + stickers[i - 1][k] * (r - l))\n    return 'IMPOSSIBLE' if dp[n][len(message)] >= float('inf') else dp[n][len(message)]\n\nmessage = input().strip()\nn = int(input())\nstickers = []\nfor _ in range(n):\n    word, price = input().split()\n    stickers.append((word, int(price)))\nprint(can_write(message, stickers))",
        "result": "failed: testcase 0"
    },
    "3721": {
        "body": "import sys\n\n    n, m, q = map(int, input().split())\n    elements = set()\n    for _ in range(q):\n        r, c = map(int, input().split())\n        elements.add((r, c))\n    visited = [False] * (n * m + 1)\n    result = len(elements)\n\n        if (r, c) not in elements:\n            return\n        for dr, dc in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            rr, cc = r + dr, c + dc\n            if 1 <= rr <= n and 1 <= cc <= m and not visited[rr * m + cc]:\n                dfs(rr, cc)\n        visited[r * m + c] = True\n\n    for r in range(1, n + 1):\n        for c in range(1, m + 1):\n            if (r, c) in elements:\n                dfs(r, c)\n\n    print(result - len(elements))\n\nmin_elements_to_purchase()",
        "result": "failed: testcase 0"
    },
    "3811": {
        "body": "import sys\nimport math\n\n    n = int(input())\n    pairs = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        pairs.append((a, b))\n    \n        while b > 0:\n            a, b = b, a % b\n        return a\n    \n    max_wcd = -1\n    for w in range(2, min(max(p[0], p[1]) for p in pairs) + 1):\n        can_divide = True\n        for p in pairs:\n            if not (w == p[0] or w == p[1]):\n                if w % gcd(p[0], p[1]) != 0:\n                    can_divide = False\n                    break\n        if can_divide:\n            max_wcd = w\n            break\n    \n    print(max_wcd)\n\nfind_wcd()",
        "result": "failed: testcase 0"
    },
    "3528": {
        "body": "import sys\n\n    x_coords = sorted([nail[0] for nail in nails])\n    y_coords = sorted([nail[1] for nail in nails])\n\n    areas = []\n\n    left_index = 0\n    right_index = n - 1\n    top_index = n - 1\n    bottom_index = 0\n\n    for picked_char in picked:\n        if picked_char == 'L':\n            left_index = x_coords.index(nails[picked[left_index]][0])\n        elif picked_char == 'R':\n            right_index = x_coords.index(nails[picked[right_index]][0])\n        elif picked_char == 'U':\n            top_index = y_coords.index(nails[picked[top_index]][1])\n        elif picked_char == 'D':\n            bottom_index = y_coords.index(nails[picked[bottom_index]][1])\n\n        area = (right_index - left_index) * (top_index - bottom_index)\n\n        if right_index > left_index and top_index > bottom_index:\n            area = abs((x_coords[right_index] - x_coords[left_index]) * (y_coords[top_index] - y_coords[bottom_index]))\n\n        areas.append(area)\n\n    return areas\n\nn = int(input())\nnails = []\n\nfor i in range(n):\n    nail = list(map(int, input().split()))\n    nails.append(nail)\n\npicked = list(input())\n\nareas = calculate_area(nails, picked)\n\nfor area in areas:\n    print('%.1f' % area)",
        "result": "failed: testcase 0"
    },
    "3890": {
        "body": "import sys\nMOD = 1000000007\n\n    n, k = map(int, input().split())\n    if n == k:\n        return \"0\"\n    if k == 1:\n        return str(((n - 1) * (n - 2)) % MOD)\n    ways = 0\n    for i in range(1, k):\n        ways = (ways + (((k - i) * (n - k)) % MOD)) % MOD\n    return str((ways * pow(n - k + 1, n - k, MOD)) % MOD)\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "3534": {
        "body": "import sys\n\n    n = len(a)\n    max_k = -1\n    max_count = 0\n    for k in range(2*10**9+1):\n        dp = [False] * (n + 1)\n        dp[0] = True\n        prev_diff = a[0]\n        curr = a[0]\n        count = 0\n        for i in range(1, n):\n            if a[i] == curr:\n                dp[i] = dp[i - 1]\n            else:\n                diff = a[i] - a[i - 1]\n                new_diff = (diff // k + 2) * k - prev_diff\n                if abs(new_diff) <= abs(diff):\n                    dp[i] = dp[i - 1] or dp[i - 1 + (new_diff > 0)]\n                    count += int(dp[i])\n                    curr = a[i]\n                    prev_diff = new_diff\n        for k1 in range(k, 2*10**9+1):\n            if max_count < count:\n                max_k = k1\n                max_count = count\n    return str(max_count), str(max_k)",
        "result": "failed: testcase 0"
    },
    "3371": {
        "body": "import sys\n\n    n, c = map(int, input().split())\n    first_meet = {}\n    for i in range(c):\n        a, b, y = map(int, input().split())\n        if a > b:\n            a, b = b, a\n        pair = (a, b)\n        first_meet[pair] = y\n\n    groups_before_y = [0]*(10**5+1)\n    groups_after_y = [0]*(10**5+1)\n\n    for i in range(2008, 1948, -1):\n        for a in range(1, n + 1):\n            for b in range(a + 1, n + 1):\n                if (a, b) not in first_meet or first_meet[(a, b)] >= i:\n                    groups_before_y[i] += 1\n\n    for pair, y in first_meet.items():\n        a, b = pair\n        groups_after_y[y] += 1\n\n    for year in range(2008, 1948, -1):\n        before = sum(groups_before_y[:year])\n        after = sum(groups_after_y[year:])\n        if before <= (2*n)//3 and after <= (2*n)//3:\n            return year\n\nprint(\"Impossible\" if solve() == None else solve())",
        "result": "failed: testcase 0"
    },
    "3621": {
        "body": "import sys\nMOD = 10**9 + 7\n\n    n = int(input())\n    color_matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        row = [int(c) for c in input().split()]\n        for j in range(n):\n            if i == j:\n                continue\n            color_matrix[i][j] = row[j]\n\n    result = 0\n    for mask in range(1, (1 << n)):\n        possible_colors = []\n        for i in range(n):\n            k = mask >> i & 1\n            for j in range(i + 1, n):\n                if not k:\n                    continue\n                l = mask >> j & 1\n                color = color_matrix[i][j]\n                if l and (mask >> color & 1) == 0:\n                    possible_colors.append(color)\n        count = len(possible_colors)\n        for c in set(possible_colors):\n            sub_mask = mask | (c << n)\n            result += min(count, (sub_mask.bit_count() + 1) * ((sub_mask ^ mask).bit_count()))\n    return result % MOD\n\nprint(solve())",
        "result": "failed: testcase 0"
    },
    "3392": {
        "body": "        return 0 <= i < N and 0 <= j < N\n\n    tree_set = set()\n    visited = [[False for _ in range(N)] for _ in range(N)]\n\n    max_height = -1\n    largest_group_size = 0\n\n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                current_height = heights[i][j]\n                current_speed = speeds[i][j]\n\n                height_diffs = {(i, j)}\n                queue = [(i, j)]\n\n                while queue:\n                    x, y = queue.pop(0)\n\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n\n                        if is_valid(nx, ny) and not visited[nx][ny]:\n                            height_diff = current_height + current_speed * (\n                                max(0, heights[nx][ny] - current_height) / current_speed)\n\n                            if abs(height_diff - (current_height + current_speed)) <= 1e-6:\n                                visited[nx][ny] = True\n                                tree_set.add((nx, ny))\n\n                                height_diffs.add((nx, ny))\n                                queue.append((nx, ny))\n\n                largest_group_size = max(largest_group_size, len(height_diffs))\n\n    return largest_group_size",
        "result": "failed: testcase 0"
    },
    "3095": {
        "body": "import sys\n\n    R = len(matrix)\n    S = len(matrix[0])\n    max_elements = 0\n    for r in range(2, R + 1):\n        for s in range(2, S + 1):\n            is_cool = True\n            for i in range(R - r + 1):\n                for j in range(S - s + 1):\n                    submatrix_sum = sum(sum(matrix[i+k][j:j+s]) for k in range(r))\n                    if (i == 0 and j == 0) or (submatrix_sum > matrix[0][s] + matrix[r][0]):\n                        is_cool = False\n                        break\n                if not is_cool:\n                    break\n            if is_cool:\n                max_elements = max(max_elements, r * s)\n    return max_elements\n\nR, S = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(R)]\nprint(count_extremely_cool_submatrices(matrix))",
        "result": "failed: testcase 0"
    },
    "3769": {
        "body": "import sys\nimport random\n\n    p, k = map(int, input().split())\n    MOD = 10**9 + 7\n    dp = [0] * p\n    dp[0] = 1\n    for x in range(p):\n        if (k * dp[x]) % p != 0:\n            for y in range(x, p - 1, x + 1):\n                dp[y] += dp[x]\n                dp[y] %= MOD\n    return sum(dp) % MOD\n\nprint(count_functions())",
        "result": "failed: testcase 0"
    },
    "3563": {
        "body": "import sys\n\n    n = int(input().split()[0])\n    holes = list(map(int, input().split()))\n    parent = {}\n    rank = {}\n\n        if x not in parent:\n            parent[x] = x\n            rank[x] = 0\n        elif parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n        root_x = find(x)\n        root_y = find(y)\n        if root_x != root_y:\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]:\n                    rank[root_y] += 1\n\n    for i in range(n):\n        x1, y1 = holes[i*2], holes[i*2+1]\n        for j in range(i+1, n):\n            x2, y2 = holes[j*2], holes[j*2+1]\n            if (x2-x1)*(y1-y2) != (y2-y1)*(x1-x2):\n                union((x1, y1), (x2, y2))\n\n    count = {}\n    for i in range(n):\n        x, y = holes[i*2], holes[i*2+1]\n        root = find((x, y))\n        if root not in count:\n            count[root] = 0\n        count[root] += 1\n\n    return len(count)\n\nprint(min_lines())",
        "result": "failed: testcase 0"
    },
    "3618": {
        "body": "import sys\n\n    MOD = 998244353\n    max_val = 9 * (10 ** n) - 1\n    dp = [[0] * n for _ in range(max_val + 2)]\n    for i in range(10, max_val + 1):\n        dp[i][i % n] = 1\n\n    for i in range(10, max_val + 1):\n        for j in range(n - 1):\n            last_digit = (i // 10 ** j) * 9\n            if i < last_digit:\n                continue\n            dp[last_digit][(j + 2) % n] += dp[i][j]\n            current_digit = (last_digit // 10 ** (j + 1)) * 9 + 1\n            if current_digit == last_digit and j > 0:\n                continue\n            dp[current_digit][(j + 1) % n] += dp[i][j]\n\n    return sum(dp[10 ** i - 1][i % n] for i in range(n)) % MOD\n\nn = int(input())\nprint(get_best_friend_pairs(n))",
        "result": "failed: testcase 0"
    },
    "3830": {
        "body": "    n = int(input())\n    s = input()\n\n    directions = []\n    for i in range(n):\n        if s[i] == '>':\n            directions.append((1, 0))\n        elif s[i] == '<':\n            directions.append((-1, 0))\n\n    can_enter = [False]*n\n    can_exit = [False]*n\n\n    direction = 0\n    for i in range(n):\n        if can_enter[i]:\n            continue\n        j = (i + n - direction) % n\n        if (direction == 0 or directions[j][0] != 0) and s[j] == '-':\n            can_exit[i] = True\n\n        k = (j + n - direction) % n\n        if can_enter[k]:\n            continue\n        if directions[j][0] != 0 and s[k] == '-':\n            can_enter[j] = True\n\n    return sum(1 for i in range(n) if can_exit[i])\n\nt = int(input())\nfor _ in range(t):\n    print(count_returnable_rooms())",
        "result": "failed: testcase 0"
    },
    "3912": {
        "body": "    freq = [0] * 150\n    for c in s:\n        freq[ord(c)] += 1\n    odd_count = 0\n    max_freq = 0\n    for f in freq:\n        if f % 2 != 0:\n            odd_count += 1\n        if f > max_freq:\n            max_freq = f\n\n    min_palindrome_len = (n + odd_count - 1) // (max_freq + odd_count)\n    result = []\n    start_idx = 0\n    while start_idx < n:\n        end_idx = start_idx + min_palindrome_len * 2 - 1\n        if end_idx > n:\n            end_idx -= 1\n\n        palindrome = ''\n        for i in range(min_palindrome_len):\n            c1 = chr(freq[ord(s[start_idx])])\n            c2 = chr(freq[ord(s[end_idx-i])])\n            palindrome += c1 + c2\n            freq[ord(c1)] -= 1\n            if s[start_idx] == s[end_idx - i]:\n                palindrome += s[start_idx]\n                freq[ord(s[start_idx])] -= 1\n\n        start_idx = end_idx + 1\n        result.append(palindrome)\n\n    return min_palindrome_len, ' '.join(result)\n\nn = int(input())\ns = input()\nprint(min_palindromes(n, s)[0])\nprint(min_palindromes(n, s)[1])",
        "result": "failed: testcase 0"
    },
    "3878": {
        "body": "    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    selected_guests = []\n    min_steps = n - 2\n\n        for i in range(1, len(adj_list)):\n            if i not in visited:\n                continue\n            for j in adj_list[i]:\n                if j not in visited and i < j:\n                    return False\n        return True\n\n        max_degree = 0\n        max_degree_node = None\n        for i in range(1, len(adj_list)):\n            if i in visited:\n                continue\n            degree = len(adj_list[i])\n            if degree > max_degree:\n                max_degree = degree\n                max_degree_node = i\n        return max_degree_node\n\n        nonlocal min_steps\n        for _ in range(n - 1):\n            max_degree_node = find_max_degree_node(adj_list, selected_guests)\n            if is_all_pairs_friends(adj_list, selected_guests | {max_degree_node}, selected_guests):\n                return\n            selected_guests.append(max_degree_node)\n\n    find_min_steps()\n    min_steps -= (len(selected_guests) - 1)\n    print(min_steps)\n    for guest in selected_guests:\n        print(guest, end=' ')",
        "result": "failed: testcase 0"
    },
    "3010": {
        "body": "import sys\n\n    n = int(input())\n    points = []\n    for i in range(n):\n        x0, y0, x1, y1 = map(int, input().split())\n        if (x0 == x1 and y0 < y1) or (y0 == y1 and x0 < x1):\n            slope = float('inf')\n        else:\n            slope = (y1 - y0) / (x1 - x0)\n        points.append((slope, i))\n\n        slope, index = points[line_index]\n        return slope\n\n    intersections = []\n    for i in range(n):\n        slope_i = line_slope(i)\n        for j in range(i + 1, n):\n            slope_j = line_slope(j)\n            if slope_i == slope_j:\n                continue\n            denominator = (slope_j - slope_i)\n            numerator_x = (points[i][0] * slope_j) - (points[j][0] * slope_i)\n            numerator_y = (points[i][1]) - (points[j][1])\n            x_numerator = (numerator_x < 0 and numerator_x <= denominator) or \\\n                (numerator_x >= 0 and numerator_x > denominator)\n            y_numerator = (numerator_y < 0 and numerator_y <= denominator) or \\\n                (numerator_y >= 0 and numerator_y > denominator)\n            if x_numerator != y_numerator:\n                intersections.append((slope_i, slope_j))\n\n    distinct_points = set()\n    for line1_slope, line2_slope in intersections:\n        if line1_slope == float('inf') or line2_slope == float('inf'):\n            continue\n        numerator_x = (points[intersections.index((line1_slope, line2_slope))][0] * line2_slope) - \\\n                      (points[intersections.index((line2_slope, line1_slope))][0] * line1_slope)\n        numerator_y = points[intersections.index((line1_slope, line2_slope))][1] - points[\n            intersections.index((line2_slope, line1_slope))][1]\n        denominator = (line2_slope - line1_slope)\n        x_denominator = abs(numerator_x) <= abs(denominator)\n        y_denominator = abs(numerator_y) <= abs(denominator)\n        if x_denominator != y_denominator:\n            continue\n        distinct_points.add(points[intersections.index((line1_slope, line2_slope))])\n\n    return len(distinct_points)\n\nprint(count_intersections())",
        "result": "failed: testcase 0"
    },
    "3068": {
        "body": "    N = int(input())\n    if N == 0:\n        return 2600\n    suspects = set(chr(i) for i in range(65, 91))\n    circles = 0\n    investigations = [tuple(map(str, input().split())) for _ in range(N)]\n    for suspect1, suspect2, player, reply in investigations:\n        if int(reply) == 0:\n            suspects -= {suspect1, suspect2}\n        elif int(reply) == 1:\n            if player == '1':\n                suspects.discard(suspect1)\n                suspects.discard(suspect2)\n            else:\n                suspects -= {suspect1, suspect2} - suspects\n        else:\n            if player == '1':\n                suspects &= {suspect1, suspect2}\n            else:\n                suspects = {suspect1, suspect2} & suspects\n    for suspect1 in sorted(list(suspects)):\n        for suspect2 in sorted(list(suspects - {suspect1}))[:]:\n            for suspect3 in sorted(list(suspects - {suspect1, suspect2})):\n                admissible = True\n                for suspect4, suspect5, player, reply in investigations:\n                    count = int(reply)\n                    if count == 0 and {suspect4, suspect5} & {suspect1, suspect2, suspect3} != set():\n                        continue\n                    elif count == 1 and (player == '1' and suspect4 not in {suspect1, suspect2, suspect3}) or \\\n                         (player == '2' and suspect4 in {suspect1, suspect2, suspect3}):\n                        continue\n                    elif count == 2 and (player == '1' and {suspect4, suspect5} != {suspect1, suspect2, suspect3}) or \\\n                         (player == '2' and {suspect4, suspect5} == {suspect1, suspect2, suspect3}):\n                        continue\n                    admissible = False\n                if admissible:\n                    circles += 1\n    return circles\n\nprint(count_admissible_solutions())",
        "result": "failed: testcase 0"
    },
    "3030": {
        "body": "import sys\n\n    ancestors = [0] * n\n    counts = [1] * n\n\n    for i in range(2, n + 1):\n        j = parents[i - 1]\n        if values[j] <= values[i]:\n            counts[i] += counts[j]\n\n    max_count = 0\n    for i in range(n):\n        max_count = max(max_count, counts[i])\n\n    return max_count\n\nn = int(input())\nvalues = []\nparents = []\n\nfor _ in range(n):\n    v, p = map(int, input().split())\n    values.append(v)\n    parents.append(p)\n\nresult = max_heap(n, values, parents)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3630": {
        "body": "    n = len(s1)\n    dp = [[float('inf')] * (n + 1) for _ in range(2)]\n    dp[0][0] = 0\n    for i in range(n):\n        for j in range(min(i + 1, n)):\n            for k in [0, 1]:\n                if j == 0:\n                    cost = abs(ord(s1[i]) - ord(s2[i]))\n                else:\n                    s = ''\n                    for x in range(j):\n                        if 'z' in s1[i-x:i+1] and k == 0 or 'a' in s1[i-x:i+1] and k == 1:\n                            break\n                        s = s1[i-x:i+1]\n                    cost = 0\n                    for x, y in zip(s, s2[i-j:i]):\n                        if ord(y) - ord(x) != 1:\n                            cost += abs(ord(y) - ord(x))\n                dp[k][j+1] = min(dp[k][j+1], dp[1-k][j] + cost)\n        for j in range(2):\n            dp[j].sort()\n    return dp[0][-1]\n\ns1, s2 = input().split()\nprint(min_moves(s1, s2))",
        "result": "failed: testcase 0"
    },
    "3133": {
        "body": "    seen = False\n    for i in range(len(visits)):\n        if visits[i] == 1:\n            if i == tower_index:\n                return True\n            seen = True\n        elif seen:\n            return False\n    return False\n\n    n, a, b = map(int, input().split())\n    paths_a = [[0 for _ in range(n)] for _ in range(n)]\n    paths_b = [[0 for _ in range(n)] for _ in range(n)]\n\n    tower_index = -1\n    for i in range(n):\n        l, r, t = map(int, input().split())\n        if t == 1:\n            tower_index = i\n\n        left_path_a = [a]\n        right_path_a = [a]\n\n        for j in range(n-1):\n            if l not in left_path_a and l != a:\n                left_path_a.append(l)\n            elif r not in left_path_a and r != a:\n                left_path_a.append(r)\n\n            if l not in right_path_a and l != a:\n                right_path_a.append(l)\n            elif r not in right_path_a and r != a:\n                right_path_a.append(r)\n\n        paths_a[i][left_path_a[0]] = 1\n        paths_a[i][right_path_a[0]] = 2\n\n        left_path_b = [b]\n        right_path_b = [b]\n\n        for j in range(n-1):\n            if l not in left_path_b and l != b:\n                left_path_b.append(l)\n            elif r not in left_path_b and r != b:\n                left_path_b.append(r)\n\n            if l not in right_path_b and l != b:\n                right_path_b.append(l)\n            elif r not in right_path_b and r != b:\n                right_path_b.append(r)\n\n        paths_b[i][left_path_b[0]] = 1\n        paths_b[i][right_path_b[0]] = 2\n\n    turns_a_to_tower = [float('inf') for _ in range(n)]\n    turns_b_to_tower = [float('inf') for _ in range(n)]\n\n    if tower_index != -1:\n        visited_a = []\n        current_pos_a = a\n        while True:\n            if paths_a[tower_index][current_pos_a] == 1:\n                left_path = list(reversed(paths_a[tower_index][0:current_pos_a]))\n                for i in left_path[1:]:\n                    visited_a.append(i)\n                    turns_a_to_tower[i] = min(turns_a_to_tower[i], len(left_path) - 1 + left_path.index(i))\n            elif paths_a[tower_index][current_pos_a] == 2:\n                right_path = list(reversed(paths_a[tower_index][0:current_pos_a]))\n                for i in right_path[1:]:\n                    visited_a.append(i)\n                    turns_a_to_tower[i] = min(turns_a_to_tower[i], len(right_path) - 1 + right_path.index(i))\n\n            if current_pos_a not in paths_a[tower_index]:\n                break\n            else:\n                next_pos = list(set(paths_a[tower_index][current_pos_a]) & set(visited_a))\n                if next_pos:\n                    current_pos_a = next_pos[0]\n\n    visited_b = []\n    current_pos_b = b\n    while True:\n        if paths_b[tower_index][current_pos_b] == 1:\n            left_path = list(reversed(paths_b[tower_index][0:current_pos_b]))\n            for i in left_path[1:]:\n                visited_b.append(i)\n                turns_b_to_tower[i] = min(turns_b_to_tower[i], len(left_path) - 1 + left_path.index(i))\n        elif paths_b[tower_index][current_pos_b] == 2:\n            right_path = list(reversed(paths_b[tower_index][0:current_pos_b]))\n            for i in right_path[1:]:\n                visited_b.append(i)\n                turns_b_to_tower[i] = min(turns_b_to_tower[i], len(right_path) - 1 + right_path.index(i))\n\n        if current_pos_b not in paths_b[tower_index]:\n            break\n        else:\n            next_pos = list(set(paths_b[tower_index][current_pos_b]) & set(visited_b))\n            if next_pos:\n                current_pos_b = next_pos[0]\n\n    result_a = 0\n    for i in range(n):\n        if can_see_tower(turns_a_to_tower, i) and not can_see_tower(turns_b_to_tower, i):\n            result_a = turns_a_to_tower[i]\n            break\n\n    result_b = 0\n    for i in range(n):\n        if can_see_tower(turns_b_to_tower, i) and not can_see_tower(turns_a_to_tower, i):\n            result_b = turns_b_to_tower[i]\n            break\n\n    if result_a != float('inf') and result_b == float('inf'):\n        print(result_a)\n    elif result_a == float('inf') and result_b != float('inf'):\n        print(result_b)\n    else:\n        print(\"indistinguishable\")",
        "result": "failed: testcase 0"
    },
    "3480": {
        "body": "import sys\n\n    lines = []\n    delays = []\n\n    for _ in range(L):\n        line1 = input().strip()\n        syllables = line1.split()\n\n        line2 = input().split()\n        time_units = list(map(int, line2))\n\n        start_time = 0\n        for i in range(len(syllables)):\n            lines.append((syllables[i], start_time))\n            delays.append(time_units[i])\n            start_time += time_units[i]\n\n    result = []\n    start_line = 0\n    for i in range(L):\n        line1 = ''\n        line2 = ''\n\n        delay_index = D // 16 * 4 + (D % 16) // 4\n\n        current_time = delays[delay_index]\n        index = delay_index\n        while current_time > start_line and index < len(delays):\n            syllable, time = lines[index]\n\n            if time <= current_time:\n                line1 += '_' * (current_time - time)\n                line2 += syllable + '_'\n\n                for j in range(index + 1, min(len(lines), index + 16)):\n                    syllable2, time2 = lines[j]\n                    if time2 > current_time:\n                        break\n                    diff = time2 - current_time\n                    line2 += '_' * (diff) + syllable2 + '_'\n            else:\n                line1 += syllable + '___'\n\n            start_line += delays[delay_index]\n            index += 1\n\n        result.append(line1)\n        if line2 != '':\n            result.append(line2[:-1])\n        else:\n            result.append('/')\n\n    for line in result:\n        print(line)\n\ndisplay_round(int(input().split()[0]), int(input().split()[1]))",
        "result": "failed: testcase 0"
    },
    "3389": {
        "body": "from collections import defaultdict\n\n    n, k = map(int, input().split())\n    video_types = list(input())\n\n    groups = defaultdict(list)\n    for i in range(n):\n        groups[video_types[i]].append(i)\n\n    clicks = 0\n    prev_group_size = 1\n    for group in sorted(groups.values(), key=len, reverse=True):\n        if len(group) > prev_group_size:\n            clicks += 1\n        if group:\n            group.sort()\n            for i in range(1, len(group)):\n                if video_types[group[i]] != video_types[group[i - 1]]:\n                    clicks += 1\n        prev_group_size = len(group)\n\n    return clicks\n\nprint(min_clicks())",
        "result": "failed: testcase 0"
    },
    "3925": {
        "body": "    n = len(s)\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        max_len = 0\n        cur_max_len = 0\n        if s[i - 1] == 'b':\n            cur_max_len = 2 if i >= 2 and s[i - 2] == 'w' else 1\n        elif s[i - 1] == 'w':\n            max_len = 2 if i >= 2 and s[i - 2] == 'b' else 1\n        for j in range(1, i):\n            cur_max_len = max(cur_max_len + 1, dp[j], dp[j - 1])\n            if (s[j - 1] != s[i - 1]) and (j >= 2 and s[j - 2] == s[i - 1]):\n                cur_max_len = min(cur_max_len + 1, max(dp[j - 1], dp[j]))\n        dp[i] = cur_max_len\n    return max(dp)\n\ns = input()\nprint(longest_zebra(s))",
        "result": "failed: testcase 0"
    },
    "3700": {
        "body": "import sys\n\n    num_ways = 0\n    i = 1\n    while i <= n:\n        if 2 * i <= k and k - 2 * i < n:\n            j_max = (k - 2 * i) // 1\n            if j_max >= i:\n                num_ways += (j_max - i + 1)\n        i += 1\n    return num_ways\n\nn, k = map(int, input().split())\nprint(calculate_ways(n, k))",
        "result": "failed: testcase 0"
    },
    "3944": {
        "body": "    mod = 10**9 + 7\n    dp = [[0] * (K+1) for _ in range((M+1))]\n    \n    for n in range(1, N+1):\n        for m in range(1, M+1):\n            for k in range(1, K+1):\n                if n == 1 and m == 1 and k == 1:\n                    dp[n][m] = 9\n                elif n == 1 and m == 1 and k > 1:\n                    dp[n][m] += (k-1) * 3 + max(0, k - ((K-k+1)//2))\n                elif n == 1 and m > 1 and k == 1:\n                    dp[m][n] = (M-m+1)*3 + max(0, M-(M-m+1)//2)\n                elif n > 1 and m == 1 and k == 1:\n                    dp[n][m] += (N-n+1) * 3 + max(0, N-(N-n+1)//2)\n                else:\n                    p = (dp[m][k-1]*(M-m+1))%mod if n == 1 else ((n-1)*(dp[m][k-1]+(m==K))%mod)%mod\n                    dp[n][m] += (p * 3)%mod\n                dp[n][m] %= mod\n\n    return dp[N][M]%mod",
        "result": "failed: testcase 0"
    },
    "3821": {
        "body": "import sys\n    max_prob = 0.0\n    for i in range(1 << n):\n        prob = 1.0\n        upset = False\n        for j in range(n):\n            if (i >> j) & 1:\n                prob *= p[j]\n                if prob >= 1.0 or prob > max_prob:\n                    upset = True\n        if not upset and prob > max_prob:\n            max_prob = prob\n    return round(max_prob, 12)\n\nn = int(input())\np = [float(x) for x in input().split()]\nprint(best_strategy(n, p))",
        "result": "failed: testcase 0"
    },
    "3667": {
        "body": "    w, p = map(int, input().split())\n    wells = []\n    for i in range(w):\n        x, y = map(int, input().split())\n        wells.append((x, y))\n\n    pipes = []\n    for i in range(p):\n        s, x, y = map(int, input().split())\n        pipes.append((s - 1, x, y))\n\n    graph = [[] for _ in range(w)]\n    edge_count = [0] * w\n    for pipe in pipes:\n        well_start = wells[pipe[0]]\n        end_x, end_y = pipe[1], pipe[2]\n        for i in range(len(graph)):\n            start_x, start_y = wells[i]\n            if (end_x == start_x and end_y <= start_y) or \\\n               (end_y == start_y and end_x <= start_x):\n                edge_count[i] += 1\n                graph[i].append((pipe[0], pipe))\n\n    visited = [False] * w\n    for i in range(w):\n        if not visited[i]:\n            count = 0\n            stack = [(i, -1)]\n            while len(stack) > 0:\n                node, parent = stack.pop()\n                if edge_count[node] % 2 == 0 and parent != -1:\n                    count += 1\n                for neighbor in graph[node]:\n                    if neighbor[0] not in visited:\n                        visited[neighbor[0]] = True\n                        stack.append((neighbor[0], node))\n            if count > 0:\n                return \"possible\"\n\n    return \"impossible\"",
        "result": "failed: testcase 0"
    },
    "3959": {
        "body": "from collections import defaultdict\nimport sys\n\nMOD = 10**9 + 7\n\n    n, m = map(int, input().split())\n    g = [defaultdict(lambda: 0) for _ in range(n)]\n\n    for i in range(n):\n        gi, *gi_types = list(map(int, input().split()))\n        for j in range(gi):\n            x = gi_types[j]\n            g[i][x] += 1\n\n    cnt = [0]*m\n    for gym in g:\n        for x in gym:\n            cnt[x] += gym[x]\n\n    if max(cnt) % n != 0:\n        print(0)\n        return\n\n    num = 1\n    for c in cnt:\n        num *= (c // n)\n\n    factors = [num]\n    for p in range(2, int(num**.5)+1):\n        while num % p == 0:\n            factors.append(p)\n            num //= p\n    if num > 1:\n        factors.append(num)\n\n    total_factors = 1\n    curr_factor = 1\n    for f in factors:\n        total_factors *= (curr_factor ** ((m - len(factors)) // f))\n        curr_factor *= f\n\n    print(total_factors % MOD)\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3692": {
        "body": "import sys\n    n = int(input())\n    circles = []\n    for i in range(n):\n        x, y, r = map(int, input().split())\n        circles.append((x, y, r))\n    circles.sort(key=lambda x: x[0])\n    parent = {}\n    rank = {}\n        if x not in parent:\n            parent[x] = x\n            rank[x] = 0\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n        root_x = find(x)\n        root_y = find(y)\n        if root_x != root_y:\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]:\n                    rank[root_y] += 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(circles[i][0] - circles[j][0]) <= circles[i][2] + circles[j][2] and \\\n               abs(circles[i][1] - circles[j][1]) <= circles[i][2] + circles[j][2]:\n                union((circles[i][0], circles[i][1]), (circles[j][0], circles[j][1]))\n    root = find((circles[0][0], circles[0][1]))\n    return len([x for x in parent if x != root]) + 1\nprint(count_regions())",
        "result": "failed: testcase 0"
    },
    "3894": {
        "body": "import sys\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    cow_remain = n\n    for i in range(n):\n        if a[i] % 2 == 0:\n            temp = a[i]\n            while temp % (k + 1) != 0:\n                temp += 1\n            cow_remain -= temp // (k + 1)\n            a[i] //= k + 1\n    if cow_remain % 2 == 0:\n        return \"Nicky\"\n    else:\n        return \"Kevin\"\n\nprint(find_winner())",
        "result": "failed: testcase 0"
    },
    "3856": {
        "body": "import sys\n\n    n = int(input())\n    sizes = []\n    for i in range(n):\n        w, h = map(int, input().split())\n        sizes.append((w, h))\n    areas = [min(w * h, h * w) for w, h in sizes]\n    max_h = 0\n    count = [0] * (n + 1)\n    total_w = 0\n    area = 0\n    for i in range(n):\n        w, h = sizes[i]\n        if count[h] < n // 2:\n            count[h] += 1\n            total_w += w\n            max_h = max(max_h, h)\n            area += areas[i]\n        else:\n            temp_area = (n - count[h]) * (max_h * total_w + max_h ** 2) - area\n            if temp_area > areas[i]:\n                area = areas[i]\n                total_w = w\n                max_h = max(max_h, h)\n    return total_w * max_h\n\nprint(min_photo_area())",
        "result": "failed: testcase 0"
    },
    "3282": {
        "body": "    P = int(input())\n\n    max_bills = []\n    unique_bills = set()\n    for beverage in range(1, P + 1):\n        for main_dish in range(beverage, P + 1):\n            if len(set(str(beverage)) & set(str(main_dish))) == 0 and len(set(str(beverage)) | set(str(main_dish))) == 3:\n                total = beverage + main_dish\n                bill = str(total) + ' ' + str(beverage) + ' ' + str(main_dish)\n                if bill not in unique_bills:\n                    unique_bills.add(bill)\n                    max_bills.append((beverage, main_dish))\n\n    max_bills.sort(key=lambda x: x[0])\n    return len(max_bills), [str(x[0]) + ' ' + str(x[1]) for x in max_bills[:5000]]\n\n\nprint(*count_free_desserts())",
        "result": "failed: testcase 0"
    },
    "3596": {
        "body": "    a, b, c = map(float, input().split())\n    t1, t2, t3, t4 = map(int, input().split())\n    n, k, r, s, l = map(int, input().split())\n\n        gamma_x = 0\n        for i in range(1000): # approximation for Gamma(z)\n            gamma_x += (x**i) / math.factorial(i+1)\n        erf_x = 2 / math.sqrt(math.pi) * sum(((-1)**j) * (x**(2*j+1)) / math.factorial(2*j+1) for j in range(100))\n        J_k_x = 0\n        for i in range(100):\n            J_k_x += (math.cos(k*i - x*math.sin(i))) / math.pi\n        return t1 * gamma_x + ((t2**-1) * math.log(erf_x))**(0.5) - (J_k_x ** t4)\n\n        result = 0\n        for i in range(r+1):\n            result += (((f(i / (r+n))) / math.factorial(i)) * x**i)\n        return result\n\n        p = P(0, s, r+s)\n        for _ in range(s + 1):\n            p = P(p, s, r+s)\n        return p.derivative().eval(n)\n\n    return str(((g(l) + l)**2 / (math.pi * math.e)) + (1/(l+1)))[:7]",
        "result": "failed: testcase 0"
    },
    "3540": {
        "body": "import sys\n\n    for i in range(4):\n        if rows[i] != 'RGBY'[i % 2 + (0 if i // 2 == 1 else 3)] * 4:\n            return False\n    return True\n\n    lines = [list(input().strip()) for _ in range(4)]\n    queue, visited = [(lines, 0)], set()\n    while queue:\n        state, steps = queue.pop(0)\n        if state not in visited:\n            visited.add(state)\n            if is_solved(state):\n                return steps\n            for i in range(8):\n                new_state = []\n                for j in range(4):\n                    new_row = list(state[j])\n                    for k in range(4):\n                        if i & (1 << k) and k != 2:\n                            new_index = (j + k) % 4\n                            new_row[new_index], new_row[(new_index - 1) % 4] = new_row[(new_index - 1) % 4], new_row[new_index]\n                        if i & (1 << k) and k == 2:\n                            new_index = (j + k) % 4\n                            new_row[new_index], new_row[(new_index + 1) % 4] = new_row[(new_index + 1) % 4], new_row[new_index]\n                    new_state.append(''.join(new_row))\n                queue.append((tuple(new_state), steps + 1))\n\nprint(min_moves())",
        "result": "failed: testcase 0"
    },
    "3354": {
        "body": "import math\nimport sys\n\n    sandwich_area = math.pi * s ** 2\n    pickle_area = math.pi * r ** 2\n    max_pickle_count = 0\n\n    for i in range(1, n + 1):\n        total_pickle_area = pickle_area * i\n        if (total_pickle_area / sandwich_area) * 100 <= z:\n            max_pickle_count = i\n\n    return max_pickle_count\n\ns, r = map(float, input().split())\nn, z = map(int, input().split())\n\nprint(calculate_max_pickles(s, r, n, z))",
        "result": "failed: testcase 0"
    },
    "3217": {
        "body": "    grid = [[False for _ in range(11)] for _ in range(11)]\n    coords = []\n    x_min, y_min, z_min = float('inf'), float('inf'), float('inf')\n    x_max, y_max, z_max = -float('inf'), -float('inf'), -float('inf')\n\n    for _ in range(n):\n        x, y, z = map(int, input().split())\n        grid[x][y][z] = True\n        coords.append((x, y, z))\n        x_min, y_min, z_min = min(x_min, x), min(y_min, y), min(z_min, z)\n        x_max, y_max, z_max = max(x_max, x), max(y_max, y), max(z_max, z)\n\n    panels_x, panels_y, panels_z = 0, 0, 0\n\n    for x in range(x_min - 1, x_max + 2):\n        for y in range(y_min - 1, y_max + 2):\n            for z in range(z_min - 1, z_max + 2):\n                min_x, min_y, min_z = float('inf'), float('inf'), float('inf')\n                max_x, max_y, max_z = -float('inf'), -float('inf'), -float('inf')\n\n                for i in range(len(coords)):\n                    x_c, y_c, z_c = coords[i]\n                    if (x <= x_c <= x + 1 and\n                        y <= y_c <= y + 1 and\n                        z <= z_c <= z + 1):\n                        min_x, min_y, min_z = min(min_x, x_c), min(min_y, y_c), min(min_z, z_c)\n                        max_x, max_y, max_z = max(max_x, x_c), max(max_y, y_c), max(max_z, z_c)\n\n                    panels_z += 2 * (max_x - min_x + 1) + 2 * (max_y - min_y + 1) + 2 * (max_z - min_z + 1)\n                for i in range(len(coords)):\n                    x_c, y_c, z_c = coords[i]\n                    if (x <= x_c <= x + 1 and\n                        y <= y_c <= y + 1 and\n                        z <= z_c <= z + 1):\n                        panels_x += abs(x_c - min_x) + abs(y_c - min_y) + abs(z_c - min_z)\n\n    print(panels_x + panels_y + panels_z)",
        "result": "failed: testcase 0"
    },
    "3520": {
        "body": "    times = []\n    for t, x, y in pills:\n        if not times or t < times[-1][0]:\n            times.append((t, x, y))\n        else:\n            times[-1] = (times[-1][0], max(times[-1][1], x), min(times[-1][2], y))\n\n    dp = [[-float('inf')] * len(times) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(len(times)):\n            if times[j][1] <= i:\n                take_time = (i - times[j][1]) * times[j][2]\n                not_take_time = dp[i][j] + c\n                dp[i][j] = max(take_time, not_take_time)\n\n    for j in range(1, len(times)):\n        dp[n][j] += n\n\n    ans = 0\n    for j in range(len(times)):\n        ans = max(ans, dp[n][j] / (n + times[j][1]))\n\n    return round(max(ans, dp[n][0]) + c, 6)\n\nn, p, c = map(int, input().split())\npills = [tuple(map(int, input().split())) for _ in range(p)]\nprint(max_life_time(n, p, c, pills))",
        "result": "failed: testcase 0"
    },
    "3475": {
        "body": "import sys\n\n    t, n = map(int, input().split())\n    d_min = [0] * t\n    a_max = [0] * t\n    for i in range(t):\n        d_min[i], a_max[i] = map(int, input().split())\n    distances = []\n    headings = []\n    for _ in range(n-1):\n        di, hi = map(int, input().split())\n        distances.append(di)\n        headings.append(hi)\n\n    if len(distances) == 0:\n        return \"IMPOSSIBLE\"\n\n    switches = [False] * n\n    num_switches = 0\n\n    for i in range(1, n):\n        total_distance = sum(distances[:i])\n        heading_diff = abs(headings[i-1] - headings[0])\n\n        if total_distance < d_min[0]:\n            continue\n\n        if heading_diff > a_max[0]:\n            switches[i] = True\n            num_switches += 1\n            for j in range(t):\n                if d_min[j] <= total_distance and abs(headings[i-1] - headings[i]) <= (a_max[j]/1000):\n                    break\n\n        i_prev = i\n        while i < n:\n            total_distance += distances[i]\n            heading_diff = abs(headings[i] - headings[i_prev])\n\n            if total_distance >= d_min[0]:\n                if heading_diff > a_max[0]:\n                    switches[i+1] = True\n                    num_switches += 1\n                    for j in range(t):\n                        if d_min[j] <= total_distance and abs(headings[i] - headings[i_prev]) <= (a_max[j]/1000):\n                            break\n\n            i += 1\n\n    ans = sum(1 for s in switches if s)\n    return str(ans)\n\nprint(transportation_switching_scheme())",
        "result": "failed: testcase 0"
    },
    "3977": {
        "body": "    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    visited = [False] * (n + 1)\n    count = 0\n    for i in range(1, n + 1):\n        if not visited[i]:\n            queue = [i]\n            visited[i] = True\n            while queue:\n                node = queue.pop()\n                for neighbor in adj_list[node]:\n                    if not visited[neighbor]:\n                        queue.append(neighbor)\n                        visited[neighbor] = True\n\n    for gov in gov_nodes:\n        count += len(adj_list[gov])\n\n    return m - count",
        "result": "failed: testcase 0"
    },
    "3626": {
        "body": "import sys\n\n    n = int(input())\n    boxes = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        boxes.append([x1, y1, x2, y2])\n\n        if box1[0] <= box2[2] and box2[0] <= box1[2] and box1[1] <= box2[3] and box2[1] <= box1[3]:\n            return True\n        return False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if check_intersect(boxes[i], boxes[j]):\n                return 1\n\n    return 0\n\nprint(rectangles_intersect())",
        "result": "failed: testcase 0"
    },
    "3584": {
        "body": "    N, M, K = [int(x) for x in input().split()]\n    onions = [[int(x) for x in input().split()] for _ in range(N)]\n    posts = [[int(x) for x in input().split()] for _ in range(M)]\n\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) <= (p3[0] - p1[0]) * (p2[1] - p1[1])\n\n        n = len(posts)\n        if n < 4:\n            return posts\n        hull = [posts[0], posts[1]]\n        for i in range(2, n):\n            while len(hull) > 1 and orientation(hull[-2], hull[-1], posts[i]):\n                hull.pop()\n            hull.append(posts[i])\n        return hull\n\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    hull = convex_hull(posts)\n    onions_in_hull = set()\n    for i in range(len(hull)):\n        for j in range(i + 1, len(hull)):\n            for onion in onions:\n                if orientation(onion, hull[i], hull[j]):\n                    onions_in_hull.add((distance(onion, hull[i]) + distance(onion, hull[j])) / (2 * distance(hull[i], hull[j])))\n    onions_in_hull = sorted(list(onions_in_hull))\n\n    max_protected = 0\n    for i in range(min(K, len(hull))):\n        start = 0 if i == 0 else onions_in_hull[i - 1]\n        end = float('inf') if i == len(hull) - 1 else onions_in_hull[i + 1]\n        max_protected = max(max_protected, sum(1 for onion in onions if start <= (distance(onion, hull[i]) + distance(onion, hull[(i + 1) % len(hull)]) / (2 * distance(hull[i], hull[(i + 1) % len(hull)]))) <= end))\n\n    return max_protected",
        "result": "failed: testcase 0"
    },
    "3950": {
        "body": "    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    pos = [[] for _ in range(q + 1)]\n    for i, v in enumerate(a):\n        pos[v].append(i)\n\n    vis = [0] * n\n    curq = -1\n\n    ans = [-1] * n\n    for v in range(1, q + 1):\n        if not pos[v]:\n            continue\n        l = len(pos[v])\n        for i in range(l):\n            j = l - i - 1\n            if vis[pos[v][i]] == 0:\n                curq += 1\n                ans[pos[v][i]] = curq + 1\n                if j > 0 and pos[v][j] < pos[v][i]:\n                    print('NO')\n                    return\n                for k in range(pos[v][i] + 1, pos[v][j] + 1):\n                    vis[k] = curq + 1\n\n    for i in a:\n        if not (0 <= i <= q):\n            print('NO')\n            return\n    print('YES')\n    print(*ans)\n\n\nsolve()",
        "result": "failed: testcase 0"
    },
    "3075": {
        "body": "import sys\n\n    distances = []\n    costs = []\n\n    for _ in range(n):\n        d, c = map(int, input().split())\n        distances.append(d)\n        costs.append(c)\n\n    dp = [0] * n\n    best_gas_station = 0\n\n    for i in range(1, n):\n        min_cost_to_reach_i = float('inf')\n        for j in range(best_gas_station + 1, i + 1):\n            cost_to_travel_j_to_i = (distances[i] - distances[j]) * costs[j]\n            if dp[j-1] < g:\n                cost_to_refuel_at_j = min_cost_to_reach_j + cost_to_travel_j_to_i\n                min_cost_to_reach_i = min(min_cost_to_reach_i, cost_to_refuel_at_j)\n\n        if min_cost_to_reach_i == float('inf'):\n            return \"cancel road trip\"\n        dp[i] = min_cost_to_reach_i\n        best_gas_station = i\n\n    if dp[-1] > g:\n        return \"cancel road trip\"\n\n    return dp[-1]\n\nn, g = map(int, input().split())\nprint(min_cost_to_travel(n, g))",
        "result": "failed: testcase 0"
    },
    "3711": {
        "body": "import sys\n\n    if k > n * m - min(n, m):\n        return -1\n    elif k == 1:\n        return min(n, m) ** 2\n    else:\n        return (k // 2 + 1) ** 2\n\nn, m, k = map(int, input().split())\nresult = max_area_smallest_piece(n, m, k)\nprint(result)",
        "result": "failed: testcase 0"
    }
}