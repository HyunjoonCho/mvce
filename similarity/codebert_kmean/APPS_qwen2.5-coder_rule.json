{
    "4693": {
        "body": "a, b = map(int, input().split())\nresult = a + b\nif result >= 10:\n    print(\"error\")\nelse:\n    print(result)",
        "result": "passed"
    },
    "4077": {
        "body": "from collections import Counter\n\n    left = [0] * (n + 1)\n    right = [0] * (n + 1)\n    prefix_count = Counter()\n    \n    for i in range(n):\n        prefix_count[a[i]] += 1\n        for j in range(m - 1, -1, -1):\n            left[i + 1] += prefix_count[j]\n        \n        prefix_count[a[n - i - 1]] += 1\n        for j in range(m + 2, n):\n            right[i + 1] += prefix_count[j]\n    \n    count = 0\n    for i in range(n):\n        if a[i] == m:\n            count += (i + 1) * (n - i)\n        else:\n            count += left[i] * (n - i) - right[i] * (i + 1)\n    \n    return count\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_median_pairs(n, m, a))",
        "result": "failed: testcase 0"
    },
    "4006": {
        "body": "    reachable = set()\n    current = n\n    while True:\n        reachable.add(current)\n        current += 1\n        while current % 10 == 0:\n            current //= 10\n        if current in reachable:\n            break\n    return len(reachable)\n\n# Read input from stdin\nn = int(input().strip())\n\n# Print the result\nprint(count_reachable_numbers(n))",
        "result": "failed: testcase 0"
    },
    "4556": {
        "body": "    s = input()\n    x = s[0]\n    print(x + \"BC\")\n\nabbreviate_contest_name()",
        "result": "failed: testcase 0"
    },
    "4571": {
        "body": "import sys\n\n    N, M = map(int, input().split())\n    total_time = 0\n    for i in range(1, M + 1):\n        total_time += (2 * i - 1) * 1900 / (2 ** (i - 1))\n    for i in range(M, N):\n        total_time += 100\n    print(int(total_time))\n\nexpected_execution_time()",
        "result": "failed: testcase 0"
    },
    "4019": {
        "body": "import sys\n\n    edges = []\n    for _ in range(m):\n        v, u = map(int, input().split())\n        edges.append((v, u))\n\n        from collections import defaultdict, deque\n        graph = defaultdict(list)\n        for v, u in tree_edges:\n            graph[v].append(u)\n            graph[u].append(v)\n\n        visited = [False] * (n + 1)\n        queue = deque([1])\n        visited[1] = True\n\n        while queue:\n            current = queue.popleft()\n            degree = len(graph[current])\n            if degree != d and current == 1:\n                return False\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n        return all(visited[i] for i in range(2, n + 1))\n\n    for i in range(n - 1):\n        remaining_edges = [edges[j] for j in range(m) if j != i]\n        if is_valid_tree(remaining_edges):\n            print(\"YES\")\n            for j in range(m):\n                if j != i:\n                    v, u = edges[j]\n                    print(v, u)\n            return\n\n    print(\"NO\")\n\nif __name__ == \"__main__\":\n    n, m, d = map(int, input().split())\n    find_spanning_tree(n, m, d)",
        "result": "failed: testcase 0"
    },
    "4265": {
        "body": "    operations = 0\n    for char_s, char_t in zip(s, t):\n        if char_s != char_t:\n            operations += 1\n    return operations\n\n# Read input from stdin\ns = input().strip()\nt = input().strip()\n\n# Print the result\nprint(min_operations(s, t))",
        "result": "failed: testcase 0"
    },
    "4657": {
        "body": "    odd_count = sum(1 for x in a if x % 2 != 0)\n    if odd_count < k or odd_count % 2 != 0:\n        return \"NO\"\n    \n    result = []\n    current_sum = 0\n    current_index = 0\n    \n    for i in range(n):\n        current_sum += a[i]\n        if current_sum % 2 != 0 and (i == n - 1 or a[i + 1] % 2 == 0):\n            result.append(i + 1)\n            current_sum = 0\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    q = int(data[index])\n    index += 1\n    results = []\n    \n    for _ in range(q):\n        n = int(data[index])\n        k = int(data[index + 1])\n        a = list(map(int, data[index + 2:index + 2 + n]))\n        index += 2 + n\n        \n        result = can_split_into_odd_sum_subsegments(n, k, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4599": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    dp = [[0] * 2 for _ in range(n + 1)]\n    \n    for i in range(n - 1, -1, -1):\n        for j in range(2):\n            if (i + j) % 2 == 0:\n                dp[i][j] = max(a[i] + dp[i + 1][(j + 1) % 2], a[i + 1] + dp[i + 2][(j + 1) % 2])\n            else:\n                dp[i][j] = min(-a[i] + dp[i + 1][(j + 1) % 2], -a[i + 1] + dp[i + 2][(j + 1) % 2])\n    \n    print(dp[0][0])\n\nif __name__ == \"__main__\":\n    optimal_game_score()",
        "result": "failed: testcase 0"
    },
    "4774": {
        "body": "import sys\n\noperators = ['+', '-', '*', '/']\n\n    results = []\n    for op1 in operators:\n        for op2 in operators:\n            if op2 == '/' and (c == 0 or d == 0):\n                continue\n            expr = f\"{a} {op1} {b} = {c} {op2} {d}\"\n            if eval(f\"{a}{op1}{b} == {c}{op2}{d}\"):\n                results.append(expr)\n    return sorted(results)\n\n    input_line = input().strip()\n    a, b, c, d = map(int, input_line.split())\n    results = check_equation(a, b, c, d)\n    if not results:\n        print(\"problems ahead\")\n    else:\n        for result in results:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4851": {
        "body": "    digit_sum = sum(int(digit) for digit in str(num))\n    return num % digit_sum == 0\n\nn = int(input())\nwhile not is_harshad_number(n):\n    n += 1\nprint(n)",
        "result": "failed: testcase 0"
    },
    "4655": {
        "body": "import sys\n\n    piles = sorted([a, b, c])\n    if piles[2] % 2 == 0:\n        return piles[2] // 2 + piles[1]\n    else:\n        return (piles[2] - 1) // 2 + piles[1]\n\nq = int(input())\nfor _ in range(q):\n    a, b, c = map(int, input().split())\n    print(max_candies(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4132": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    while len(a) > 1:\n        a.sort()\n        x = a.pop(0)\n        y = a.pop(0)\n        a.append(x + y)\n    \n    print(a[0])\n\nmin_final_health()",
        "result": "failed: testcase 0"
    },
    "4085": {
        "body": "import math\nfrom collections import defaultdict\n\n    divisors = sorted(divisors)\n    n = len(divisors)\n    \n    # Check if the smallest divisor is not 2, it's impossible to reconstruct the number\n    if divisors[0] != 2:\n        return -1\n    \n    # Initialize variables\n    min_x = float('inf')\n    divisor_count = defaultdict(int)\n    \n    # Count occurrences of each divisor\n    for d in divisors:\n        divisor_count[d] += 1\n    \n    # Try to reconstruct the number\n    for i in range(2, int(math.sqrt(divisors[-1])) + 1):\n        if divisor_count[i] > 0:\n            product = i\n            count = divisor_count[i]\n            while product * i <= divisors[-1]:\n                product *= i\n                count += divisor_count[product]\n                if count == n:\n                    min_x = min(min_x, product)\n                    break\n    \n    return min_x if min_x != float('inf') else -1\n\n    t = int(input().strip())\n    results = []\n    \n    for _ in range(t):\n        n = int(input().strip())\n        divisors = list(map(int, input().strip().split()))\n        result = find_min_x(divisors)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4399": {
        "body": "    a_stations = [i+1 for i, c in enumerate(s) if c == 'A']\n    b_stations = [i+1 for i, c in enumerate(s) if c == 'B']\n    \n    for a_station in a_stations:\n        for b_station in b_stations:\n            if a_station < b_station:\n                print(\"Yes\")\n                return\n    print(\"No\")\n\n# Read input from stdin\ns = input()\ncheck_bus_service(s)",
        "result": "failed: testcase 0"
    },
    "4999": {
        "body": "    operations = 0\n    while a < b:\n        if b % 2 == 0:\n            b //= 2\n        else:\n            b += 1\n        operations += 1\n    return operations + (a - b)\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(min_operations(a, b))",
        "result": "failed: testcase 0"
    },
    "4727": {
        "body": "    if direction == 0:  # left\n        for row in grid:\n            non_zero = [x for x in row if x != 0]\n            merged = []\n            i = 0\n            while i < len(non_zero):\n                if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                    merged.append(non_zero[i] * 2)\n                    i += 2\n                else:\n                    merged.append(non_zero[i])\n                    i += 1\n            row[:] = merged + [0] * (4 - len(merged))\n    elif direction == 1:  # up\n        grid_t = list(zip(*grid[::-1]))\n        for col in grid_t:\n            non_zero = [x for x in col if x != 0]\n            merged = []\n            i = 0\n            while i < len(non_zero):\n                if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                    merged.append(non_zero[i] * 2)\n                    i += 2\n                else:\n                    merged.append(non_zero[i])\n                    i += 1\n            grid_t[col.index(min(col))][::-1][:len(merged)] = merged\n        grid = [list(x) for x in zip(*grid_t)]\n    elif direction == 2:  # right\n        for row in grid:\n            non_zero = [x for x in row if x != 0]\n            merged = []\n            i = 0\n            while i < len(non_zero):\n                if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                    merged.append(non_zero[i] * 2)\n                    i += 2\n                else:\n                    merged.append(non_zero[i])\n                    i += 1\n            row[:] = [0] * (4 - len(merged)) + merged[::-1]\n    elif direction == 3:  # down\n        grid_t = list(zip(*grid))\n        for col in grid_t:\n            non_zero = [x for x in col if x != 0]\n            merged = []\n            i = 0\n            while i < len(non_zero):\n                if i + 1 < len(non_zero) and non_zero[i] == non_zero[i + 1]:\n                    merged.append(non_zero[i] * 2)\n                    i += 2\n                else:\n                    merged.append(non_zero[i])\n                    i += 1\n            grid_t[col.index(max(col))][::-1][:len(merged)] = merged\n        grid = [list(x) for x in zip(*grid_t)]\n    return grid\n\nif __name__ == \"__main__\":\n    grid = []\n    for _ in range(4):\n        row = list(map(int, input().split()))\n        grid.append(row)\n    direction = int(input())\n    result = move_grid(grid, direction)\n    for row in result:\n        print(*row)",
        "result": "failed: testcase 0"
    },
    "4906": {
        "body": "import sys\n\n    encoded = []\n    count = 1\n    for i in range(1, len(input_message)):\n        if input_message[i] == input_message[i - 1]:\n            count += 1\n        else:\n            encoded.append(f\"{input_message[i-1]}{count}\")\n            count = 1\n    encoded.append(f\"{input_message[-1]}{count}\")\n    return ''.join(encoded)\n\n    decoded = []\n    i = 0\n    while i < len(input_message):\n        char = input_message[i]\n        i += 1\n        num = ''\n        while i < len(input_message) and input_message[i].isdigit():\n            num += input_message[i]\n            i += 1\n        decoded.append(char * int(num))\n    return ''.join(decoded)\n\n    action, message = input().strip().split(' ', 1)\n    if action == 'E':\n        result = run_length_encoding(message)\n    elif action == 'D':\n        result = run_length_decoding(message)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4011": {
        "body": "    max_num = int(a)\n    for i in range(n):\n        for j in range(i, n):\n            segment = a[i:j+1]\n            new_segment = ''.join(str(f[int(digit) - 1]) for digit in segment)\n            new_num = int(a[:i] + new_segment + a[j+1:])\n            if new_num > max_num:\n                max_num = new_num\n    return max_num\n\n# Read input from stdin\nn = int(input())\na = input().strip()\nf = list(map(int, input().split()))\n\n# Print the result\nprint(max_possible_number(n, a, f))",
        "result": "failed: testcase 0"
    },
    "4099": {
        "body": "import sys\n\n    total_score_needed = N * M\n    current_total_score = sum(A)\n    points_needed = total_score_needed - current_total_score\n    \n    if points_needed < 0 or points_needed > K:\n        return -1\n    else:\n        return points_needed\n\n# Read input from stdin\nN, K, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Calculate and print the result\nresult = min_points_needed(N, K, M, A)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4465": {
        "body": "    a, b = map(int, input().split())\n    area = (a - 1) * (b - 1)\n    print(area)\n\ncalculate_yard_area()",
        "result": "failed: testcase 0"
    },
    "4315": {
        "body": "import math\n\n    radius = int(input())\n    circumference = 2 * math.pi * radius\n    print(f\"{circumference:.10f}\")\n\ncalculate_circumference()",
        "result": "failed: testcase 0"
    },
    "4633": {
        "body": "    moves = 0\n    while sum(int(digit) for digit in str(n)) > s:\n        n += 1\n        moves += 1\n    return moves\n\nt = int(input())\nfor _ in range(t):\n    n, s = map(int, input().split())\n    print(min_moves(n, s))",
        "result": "failed: testcase 0"
    },
    "4734": {
        "body": "    if y.endswith('ex'):\n        return y + p\n    elif y[-1] in 'aeiou':\n        return y[:-1] + 'ex' + p\n    else:\n        return y + 'ex' + p\n\n# Read input from stdin\ny, p = input().split()\n\n# Print the result\nprint(extend_apaxian_name(y, p))",
        "result": "failed: testcase 0"
    },
    "4229": {
        "body": "    total = 0\n    for i in range(1, n + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            continue\n        elif i % 3 == 0:\n            continue\n        elif i % 5 == 0:\n            continue\n        else:\n            total += i\n    print(total)\n\n# Read input from stdin\nn = int(input())\ncalculate_fizzbuzz_sum(n)",
        "result": "failed: testcase 0"
    },
    "4321": {
        "body": "    for _ in range(k):\n        if n % 10 != 0:\n            n -= 1\n        else:\n            n //= 10\n    return n\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result\nprint(tanya_decrease(n, k))",
        "result": "failed: testcase 0"
    },
    "4503": {
        "body": "import sys\n\n    moves = sorted(A)\n    for i in range(N):\n        H -= moves[i]\n        if H <= 0:\n            return \"Yes\"\n    return \"No\"\n\n# Read input\nH, N = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Output result\nprint(can_win(H, N, A))",
        "result": "failed: testcase 0"
    },
    "4855": {
        "body": "import math\n\n    current_citations = articles * (target_impact - 1)\n    bribes_needed = max(0, math.ceil(current_citations) - articles)\n    return bribes_needed\n\n# Read input from stdin\nA, I = map(int, input().split())\n\n# Calculate and print the result\nprint(calculate_bribes(A, I))",
        "result": "failed: testcase 0"
    },
    "4704": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    total_sum = sum(a)\n    min_diff = float('inf')\n    \n    for i in range(1, n):\n        snuke_sum = sum(a[:i])\n        raccoon_sum = total_sum - snuke_sum\n        diff = abs(snuke_sum - raccoon_sum)\n        if diff < min_diff:\n            min_diff = diff\n    \n    print(min_diff)\n\nmin_difference()",
        "result": "failed: testcase 0"
    },
    "4829": {
        "body": "    if left == 0 and right == 0:\n        return \"Not a moose\"\n    elif left == right:\n        points = left + right\n        return f\"Even {points}\"\n    else:\n        max_tines = max(left, right)\n        points = max_tines * 2\n        return f\"Odd {points}\"\n\n# Read input\nleft, right = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_moose_points(left, right)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4730": {
        "body": "    length = int(input())\n    program = input()\n    \n    stack = []\n    mapping = {')': '(', ']': '[', '}': '{'}\n    \n    for i, char in enumerate(program):\n        if char in '([{':\n            stack.append((char, i))\n        elif char in ')]}':\n            if not stack or stack[-1][0] != mapping[char]:\n                print(f\"{char} {i}\")\n                return\n            stack.pop()\n    \n    if stack:\n        print(f\"{stack[0][0]} {stack[0][1]}\")\n    else:\n        print(\"ok so far\")\n\nvalidate_delimiters()",
        "result": "failed: testcase 0"
    },
    "4729": {
        "body": "    password_chars = list(password)\n    msg_index = 0\n    \n    for char in message:\n        if msg_index >= len(password_chars):\n            break\n        if char == password_chars[msg_index]:\n            msg_index += 1\n            \n    return \"PASS\" if msg_index == len(password_chars) else \"FAIL\"\n\n# Read input from stdin\npassword, message = input().strip().split()\n\n# Print the result\nprint(check_valid_message(password, message))",
        "result": "failed: testcase 0"
    },
    "4582": {
        "body": "import sys\n\n    if a == 'H':\n        if b == 'H':\n            return 'H'\n        else:\n            return 'D'\n    else:\n        if b == 'H':\n            return 'D'\n        else:\n            return 'H'\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    a, b = input_data.split()\n    result = determine_top_co_deer_honesty(a, b)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4910": {
        "body": "import sys\n\n    n = int(input())\n    costumes = []\n    \n    for _ in range(n):\n        costume = input().strip()\n        costumes.append(costume)\n    \n    category_count = {}\n    \n    for costume in costumes:\n        if costume not in category_count:\n            category_count[costume] = 0\n        category_count[costume] += 1\n    \n    max_count = max(category_count.values())\n    best_costumes = sorted([costume for costume, count in category_count.items() if count == max_count])\n    \n    print('\\n'.join(best_costumes))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4323": {
        "body": "import sys\n\n    songs.sort(key=lambda x: x[0] - x[1])\n    total = sum(song[0] for song in songs)\n    if total <= m:\n        return 0\n    \n    compressed = [song[1] for song in songs]\n    total_compressed = sum(compressed)\n    min_to_compress = float('inf')\n    \n    for i in range(n):\n        if total - (total_compressed + songs[i][0]) <= m:\n            min_to_compress = min(min_to_compress, n - i)\n        total_compressed += songs[i][1]\n    \n    return min_to_compress if min_to_compress != float('inf') else -1\n\n# Read input\nn, m = map(int, input().split())\nsongs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(min_compressions(n, m, songs))",
        "result": "failed: testcase 0"
    },
    "4626": {
        "body": "    for _ in range(q):\n        a, b, c = map(int, input().split())\n        positions = sorted([a, b, c])\n        a_prime, b_prime, c_prime = positions[0] + 1, positions[1], positions[2] - 1\n        print(abs(a_prime - b_prime) + abs(a_prime - c_prime) + abs(b_prime - c_prime))\n\n# Read input and call the function\nq = int(input())\nmin_pairwise_distance(q)",
        "result": "failed: testcase 0"
    },
    "4400": {
        "body": "    max_count = 0\n    current_count = 0\n    \n    for char in s:\n        if char == 'R':\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    print(max_count)\n\n# Read input from stdin\ns = input().strip()\nmax_consecutive_rainy_days(s)",
        "result": "failed: testcase 0"
    },
    "4794": {
        "body": "import sys\n\n    parking_count = [0] * 5\n    \n    for i in range(r - 1):\n        for j in range(c - 1):\n            if grid[i][j] == '.' and grid[i + 1][j] == '.' and grid[i][j + 1] == '.' and grid[i + 1][j + 1] == '.':\n                count = sum(grid[x][y] == 'X' for x in range(i, i + 2) for y in range(j, j + 2))\n                parking_count[count] += 1\n                \n    return parking_count\n\nif __name__ == \"__main__\":\n    r, c = map(int, input().split())\n    grid = [input().strip() for _ in range(r)]\n    \n    result = count_parking_spaces(r, c, grid)\n    print(\"\\n\".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "4096": {
        "body": "    a.sort(reverse=True)\n    days = 0\n    pages_written = 0\n    \n    for i in range(n):\n        if pages_written >= m:\n            break\n        pages_written += max(0, a[i] - days)\n        if pages_written < m:\n            days += 1\n    \n    return days if pages_written >= m else -1\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output result\nprint(min_days_to_complete_coursework(n, m, a))",
        "result": "failed: testcase 0"
    },
    "4530": {
        "body": "import sys\n\n    skill_count = {}\n    for skill in skills:\n        if skill in skill_count:\n            skill_count[skill] += 1\n        else:\n            skill_count[skill] = 1\n    \n    unique_skills = list(skill_count.keys())\n    \n    max_x = 0\n    for i in range(len(unique_skills)):\n        team_size_1 = len(set(unique_skills[:i+1]))\n        if team_size_1 > n // 2:\n            break\n        for j in range(i+1, len(unique_skills) + 1):\n            if sum(skill_count[skill] for skill in unique_skills[i:j]) >= n - 2 * team_size_1:\n                max_x = max(max_x, team_size_1)\n    \n    return max_x\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        skills = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = max_team_size(n, skills)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4724": {
        "body": "r = int(input())\ng = int(input())\n\nrequired_performance = (2 * g - r) // 1\n\nprint(required_performance)",
        "result": "passed"
    },
    "4276": {
        "body": "import sys\n\n    min_cost = float('inf')\n    \n    for route in routes:\n        cost, time = route\n        if time <= T:\n            min_cost = min(min_cost, cost)\n    \n    return min_cost if min_cost != float('inf') else 'TLE'\n\nif __name__ == \"__main__\":\n    N, T = map(int, input().split())\n    routes = [tuple(map(int, input().split())) for _ in range(N)]\n    \n    result = find_min_cost_route(N, T, routes)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4708": {
        "body": "import sys\n\n    n = int(input())\n    k = int(input())\n    x = int(input())\n    y = int(input())\n\n    total_cost = 0\n    for i in range(n):\n        if i < k:\n            total_cost += x\n        else:\n            total_cost += y\n\n    print(total_cost)\n\ncalculate_accommodation_fee()",
        "result": "failed: testcase 0"
    },
    "4396": {
        "body": "import sys\n\n    n = int(input())\n    total_yen = 0.0\n    btc_rate = 380000.0\n    \n    for _ in range(n):\n        x, u = input().split()\n        x = float(x)\n        \n        if u == 'JPY':\n            total_yen += x\n        elif u == 'BTC':\n            total_yen += x * btc_rate\n    \n    print(total_yen)\n\ncalculate_total_yen()",
        "result": "failed: testcase 0"
    },
    "4155": {
        "body": "import sys\n\n    operations = 0\n    current_heights = [0] * n\n    for i in range(n):\n        if h[i] > current_heights[i]:\n            operations += (h[i] - current_heights[i])\n            current_heights[i] = h[i]\n            if i < n - 1:\n                current_heights[i + 1] -= (h[i] - current_heights[i])\n    return operations\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    h = list(map(int, data[1:]))\n    print(min_watering_operations(n, h))",
        "result": "failed: testcase 0"
    },
    "4557": {
        "body": "import sys\n\n    if A <= X <= A + B:\n        return \"YES\"\n    else:\n        return \"NO\"\n\n# Read input from stdin\nA, B, X = map(int, input().split())\n\n# Print the result\nprint(check_cats(A, B, X))",
        "result": "failed: testcase 0"
    },
    "4930": {
        "body": "    vowels = \"aeiou\"\n    decoded_word = \"\"\n    i = 0\n    while i < len(encoded_sentence):\n        if encoded_sentence[i] in vowels:\n            decoded_word += encoded_sentence[i-1:i+3]\n            i += 4\n        else:\n            decoded_word += encoded_sentence[i]\n            i += 1\n    return decoded_word.strip()\n\n# Read input from stdin and print the result\nprint(decode_sentence(input().strip()))",
        "result": "failed: testcase 0"
    },
    "4715": {
        "body": "    colors = {a, b, c}\n    return len(colors)\n\n# Read input\na, b, c = map(int, input().split())\n\n# Output the result\nprint(count_colors(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4008": {
        "body": "    if len(set(a)) < k:\n        return \"NO\"\n    \n    colors = {}\n    for i in range(k):\n        colors[i + 1] = []\n    \n    distinct_values = sorted(list(set(a)))\n    color_index = 0\n    \n    for value in distinct_values:\n        while len(colors[color_index + 1]) >= k:\n            color_index += 1\n        for _ in range(min(k, n)):\n            if value in a:\n                index = a.index(value)\n                colors[color_index + 1].append(index + 1)\n                a[index] = None\n    \n    result = [0] * n\n    for color, indices in colors.items():\n        for index in indices:\n            result[index - 1] = color\n    \n    return \"YES\\n\" + \" \".join(map(str, result))\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(color_array(n, k, a))",
        "result": "failed: testcase 0"
    },
    "4257": {
        "body": "import sys\n\nA, B = map(int, input().split())\nprint(A * B)",
        "result": "passed"
    },
    "4584": {
        "body": "import sys\n\n    subordinates = [0] * (N + 1)\n    for i in range(2, N + 1):\n        subordinates[A[i - 1]] += 1\n    return subordinates[1:]\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int, input().split()))\n    result = count_subordinates(N, A)\n    for num in result:\n        print(num)",
        "result": "failed: testcase 0"
    },
    "4195": {
        "body": "    count = 0\n    num = 1\n    while True:\n        if D == 0 and num % 100 != 0:\n            count += 1\n        elif D == 1 and num % 100 == 0:\n            count += 1\n        elif D == 2 and (num // 100) % 100 == 0:\n            count += 1\n        if count == N:\n            return num\n        num += 1\n\n# Read input from stdin\nD, N = map(int, input().split())\n\n# Print the result\nprint(find_happy_number(D, N))",
        "result": "failed: testcase 0"
    },
    "4176": {
        "body": "import math\n\n    return a * b // math.gcd(a, b)\n    \na, b = map(int, input().split())\nprint(min_snack_pieces(a, b))",
        "result": "failed: testcase 0"
    },
    "4166": {
        "body": "import sys\n\n    digits = [0] * N\n    constraints = sorted(conditions, key=lambda x: -x[0])\n    \n    for s, c in constraints:\n        if digits[s-1] == 0 and c != 0:\n            digits[s-1] = c\n            break\n        elif digits[s-1] == c:\n            continue\n        else:\n            return -1\n    \n    for i in range(1, N):\n        if digits[i-1] == 0:\n            digits[i-1] = 1\n            break\n    \n    result = int(''.join(map(str, digits)))\n    return result\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    conditions = [(int(data[2*i+2]), int(data[2*i+3])) for i in range(M)]\n    \n    result = find_smallest_integer(N, M, conditions)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4827": {
        "body": "import sys\n\n    units = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    teens = [\"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    hundreds = [\"\", \"onehundred\", \"twohundred\", \"threehundred\", \"fourhundred\", \"fivehundred\", \"sixhundred\", \"sevenhundred\", \"eighthundred\", \"ninehundred\"]\n\n    if num < 10:\n        return units[num]\n    elif num < 20:\n        return teens[num - 11]\n    elif num < 100:\n        return tens[num // 10] + (units[num % 10] if num % 10 != 0 else \"\")\n    else:\n        return hundreds[num // 100] + (number_to_words(num % 100) if num % 100 != 0 else \"\")\n\n    n = int(input().strip())\n    words = [input().strip() for _ in range(n)]\n    \n    total_length = sum(len(word) for word in words)\n    min_num = number_to_words(total_length)\n    \n    for i, word in enumerate(words):\n        if word == '$':\n            words[i] = min_num\n    \n    print(' '.join(words))\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0"
    },
    "4871": {
        "body": "import sys\n\n    total_score = sum(s * (4/5)**i for i, s in enumerate(scores))\n    average_new_group_score = 0\n    for i in range(n):\n        new_total_score = total_score - scores[i] * (4/5)**i + scores[i]\n        average_new_group_score += new_total_score / (n-1)\n    return total_score / 5, average_new_group_score / n\n\n    input = sys.stdin.read\n    data = input().split()\n    n = int(data[0])\n    scores = list(map(int, data[1:]))\n    \n    current_group_score, average_new_group_score = calculate_group_score(n, scores)\n    \n    print(current_group_score)\n    print(average_new_group_score)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4148": {
        "body": "import sys\n\n    result = []\n    for char in S:\n        if 'A' <= char <= 'Z':\n            shifted = chr((ord(char) - ord('A') + N) % 26 + ord('A'))\n            result.append(shifted)\n        else:\n            result.append(char)\n    return ''.join(result)\n\n# Read input\nN = int(input().strip())\nS = input().strip()\n\n# Output the result\nprint(shift_string(N, S))",
        "result": "failed: testcase 0"
    },
    "4316": {
        "body": "    char_count = {}\n    for char in S:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    unique_chars = list(char_count.values())\n    if len(unique_chars) == 2 and unique_chars[0] == 2 and unique_chars[1] == 2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n# Read input from stdin\nS = input()\ncheck_string(S)",
        "result": "failed: testcase 0"
    },
    "4397": {
        "body": "N, i = map(int, input().split())\nj = N - i + 1\nprint(j)",
        "result": "passed"
    },
    "4180": {
        "body": "    N -= N // 1000 * 1000\n    return N\n\nN = int(input())\nprint(calculate_change(N))",
        "result": "failed: testcase 0"
    },
    "4907": {
        "body": "    if n % 2 == 0:\n        return \"Bob\", 1\n    else:\n        return \"Alice\", 1\n\nn = int(input())\nwinner, move = determine_winner_and_move(n)\nprint(winner)\nif winner == \"Alice\":\n    print(move)",
        "result": "failed: testcase 0"
    },
    "4839": {
        "body": "import sys\n\n    canisters.sort()\n    balloons = list(range(1, n + 1))\n    balloons.sort(reverse=True)\n    \n    for i in range(n):\n        if canisters[i] < balloons[i]:\n            return \"impossible\"\n    \n    total_helium = sum(canisters)\n    total_capacity = sum(balloons)\n    min_fraction = max(canister / balloon for canister, balloon in zip(canisters, balloons))\n    \n    return round(min_fraction, 6)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    canisters = list(map(int, input().split()))\n    print(max_fraction(n, canisters))",
        "result": "failed: testcase 0"
    },
    "4665": {
        "body": "from collections import namedtuple\n\n    n = int(input())\n    columns = input().split()\n    Student = namedtuple('Student', columns)\n    total_marks = 0\n    \n    for _ in range(n):\n        student_data = input().split()\n        student = Student(*student_data)\n        total_marks += float(student.MARKS)\n    \n    average_marks = total_marks / n\n    print(f\"{average_marks:.2f}\")\n\ncalculate_average_marks()",
        "result": "failed: testcase 0"
    },
    "4785": {
        "body": "    word = input()\n    for i in range(len(word) - 1):\n        if word[i] == 's' and word[i + 1] == 's':\n            print(\"hiss\")\n            return\n    print(\"no hiss\")\n\ncheck_consecutive_s()",
        "result": "failed: testcase 0"
    },
    "4272": {
        "body": "    n = int(input())\n    s = input()\n    count = 0\n    for i in range(n - 2):\n        if s[i:i+3] == \"ABC\":\n            count += 1\n    print(count)\n\ncount_abc()",
        "result": "failed: testcase 0"
    },
    "4092": {
        "body": "import sys\n\n    insertions = 0\n    current_sum = 0\n    seen_sums = set()\n    \n    for num in a:\n        current_sum += num\n        if current_sum in seen_sums:\n            insertions += 1\n            current_sum = num\n            seen_sums.clear()\n        seen_sums.add(current_sum)\n    \n    return insertions\n\ninput_line = input().strip()\nn = int(input_line)\na = list(map(int, input().strip().split()))\n\nresult = min_insertions_to_avoid_zero_sum_subsegments(n, a)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "4023": {
        "body": "    max_height = max(a)\n    total_bricks_needed = 0\n    \n    for height in a:\n        if height < max_height:\n            total_bricks_needed += (max_height - height) // 2\n    \n    return \"YES\" if total_bricks_needed % 2 == 0 else \"NO\"\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Output result\nprint(can_complete_wall(n, a))",
        "result": "failed: testcase 0"
    },
    "4160": {
        "body": "import sys\n\n    balance = 100\n    years = 0\n    \n    while balance < x:\n        balance += int(balance * 0.01)\n        years += 1\n    \n    return years\n\nif __name__ == \"__main__\":\n    x = int(input())\n    print(years_to_reach_balance(x))",
        "result": "failed: testcase 0"
    },
    "4815": {
        "body": "import sys\n\n    n, p, m = map(int, input().split())\n    players = {}\n    for _ in range(n):\n        name = input()\n        players[name] = 0\n    \n    scores = []\n    for _ in range(m):\n        line = input().split()\n        name = line[0]\n        points = int(line[1])\n        if name in players:\n            players[name] += points\n            if players[name] >= p:\n                scores.append(name)\n    \n    if scores:\n        for winner in scores:\n            print(f\"{winner} wins!\")\n    else:\n        print(\"No winner!\")\n\nfind_winners()",
        "result": "failed: testcase 0"
    },
    "4514": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    p = [0] + list(map(int, data[2:n+1]))\n    \n    tree = defaultdict(list)\n    for i in range(2, n + 1):\n        tree[p[i]].append(i)\n    \n        order = []\n        stack = [(u, -1)]\n        \n        while stack:\n            u, parent = stack.pop()\n            if u != parent:\n                order.append(u)\n            for v in tree[u]:\n                stack.append((v, u))\n        \n        return order\n    \n    results = []\n    \n    index = n + 2\n    for _ in range(q):\n        u_i = int(data[index])\n        k_i = int(data[index + 1])\n        index += 2\n        \n        if u_i == 1:\n            order = dfs(u_i)\n        else:\n            subordinates = tree[u_i]\n            sub_orders = [dfs(v) for v in subordinates]\n            combined_order = []\n            while sub_orders:\n                min_sub = None\n                for i, sub_order in enumerate(sub_orders):\n                    if not min_sub or sub_order and sub_order[0] < min_sub[0]:\n                        min_sub = sub_order\n                combined_order.extend(min_sub)\n                sub_orders.remove(min_sub)\n            \n            order = [u_i] + combined_order\n        \n        if k_i - 1 < len(order):\n            results.append(order[k_i - 1])\n        else:\n            results.append(-1)\n    \n    print(\"\\n\".join(map(str, results)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4585": {
        "body": "import math\n\n    n = 1\n    while True:\n        if X <= n * (n + 1) // 2:\n            return n\n        n += 1\n\nif __name__ == \"__main__\":\n    X = int(input())\n    print(find_earliest_time_to_reach_nest(X))",
        "result": "failed: testcase 0"
    },
    "4781": {
        "body": "    players = list(range(1, 9))\n    current_index = players.index(k)\n    \n    for _ in range(n):\n        time_passed, answer = questions.pop(0)\n        if answer == 'P':\n            continue\n        current_index = (current_index + 1) % len(players)\n    \n    return players[current_index]\n\n# Read input\nk = int(input())\nn = int(input())\nquestions = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Determine and print the exploding player\nprint(determine_exploding_player(k, n, questions))",
        "result": "failed: testcase 0"
    },
    "4551": {
        "body": "    A, B, C, D = map(int, input().split())\n    L = A + B\n    R = C + D\n    if L > R:\n        print(\"Left\")\n    elif L < R:\n        print(\"Right\")\n    else:\n        print(\"Balanced\")\n\nbalance_scale()",
        "result": "failed: testcase 0"
    },
    "4345": {
        "body": "    increasing = []\n    decreasing = []\n    \n    i = 0\n    while i < n:\n        if not increasing or a[i] >= increasing[-1]:\n            increasing.append(a[i])\n            i += 1\n        elif not decreasing or a[i] <= decreasing[-1]:\n            decreasing.append(a[i])\n            i += 1\n        else:\n            return \"NO\", []\n    \n    res = [0] * n\n    for num in a:\n        if num in increasing:\n            res[increasing.index(num)] = 1\n    \n    return \"YES\", res\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\n\n# Find sequences and print result\nresult, res = find_sequences(n, a)\nprint(result)\nif result == \"YES\":\n    print(\" \".join(map(str, res)))",
        "result": "failed: testcase 0"
    },
    "4075": {
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    switch_bulb_map = [[] for _ in range(N)]\n    bulb_parity = []\n    \n    index = 2\n    for i in range(M):\n        k_i = int(data[index])\n        for _ in range(k_i):\n            s_ij = int(data[index + 1]) - 1\n            switch_bulb_map[s_ij].append(i)\n        index += k_i + 1\n    \n    bulb_parity = list(map(int, data[index:]))\n\n        for i in range(M):\n            on_count = sum(1 for s in switch_bulb_map[i] if state[s])\n            if (on_count % 2) != bulb_parity[i]:\n                return False\n        return True\n\n    count = 0\n    for state in range(1 << N):\n        if is_valid(state):\n            count += 1\n    \n    print(count)\n\ncount_combinations()",
        "result": "failed: testcase 0"
    },
    "4408": {
        "body": "    cards_count = [0] * 100001\n    for card in cards:\n        cards_count[card] += 1\n    \n    players_joy = [0] * n\n    for i in range(k):\n        joy = joy_levels[i]\n        for j in range(n):\n            if cards_count[favorites[j]] > 0:\n                players_joy[j] += joy\n                cards_count[favorites[j]] -= 1\n    \n    return sum(players_joy)\n\n# Read input\nn, k = map(int, input().split())\ncards = list(map(int, input().split()))\nfavorites = list(map(int, input().split()))\njoy_levels = list(map(int, input().split()))\n\n# Output result\nprint(max_joy_levels(n, k, cards, favorites, joy_levels))",
        "result": "failed: testcase 0"
    },
    "4282": {
        "body": "from collections import defaultdict, deque\n\n    adjacency_list = defaultdict(list)\n    in_degree = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        x1, x2 = remembered_kids[i - 1]\n        adjacency_list[x1].append(x2)\n        in_degree[x2] += 1\n    \n    queue = deque([i for i in range(1, n + 1) if in_degree[i] == 0])\n    \n    result = []\n    while queue:\n        current = queue.popleft()\n        result.append(current)\n        \n        for neighbor in adjacency_list[current]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n\n# Read input\nn = int(input())\nremembered_kids = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output the result\nprint(*reconstruct_dance_order(n, remembered_kids))",
        "result": "failed: testcase 0"
    },
    "4331": {
        "body": "    n = int(input())\n    for i in str(n):\n        if i == '7':\n            print(\"Yes\")\n            return\n    print(\"No\")\n\ncheck_digit_7()",
        "result": "failed: testcase 0"
    },
    "4550": {
        "body": "    total_candies = a + b + c\n    if total_candies % 2 != 0:\n        return \"No\"\n    target = total_candies // 2\n    for i in range(target + 1):\n        for j in range(target - i + 1):\n            k = target - i - j\n            if a >= i and b >= j and c >= k:\n                return \"Yes\"\n    return \"No\"\n\n# Read input from stdin\na, b, c = map(int, input().split())\n\n# Print the result\nprint(can_distribute_candies(a, b, c))",
        "result": "failed: testcase 0"
    },
    "4271": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    \n    total_points = 0\n    \n    for i in range(n):\n        total_points += b[a[i] - 1]\n        if i < n - 1 and a[i] == a[i + 1] - 1:\n            total_points += c[a[i] - 1]\n    \n    print(total_points)\n\ncalculate_satisfaction_points()",
        "result": "failed: testcase 0"
    },
    "4848": {
        "body": "    for m in range(2, n):\n        if all(m % i != 0 or n % (i * i) != 0 for i in range(2, int(m**0.5) + 1)):\n            return m\n\nn = int(input())\nprint(find_notes_per_beat(n))",
        "result": "failed: testcase 0"
    },
    "4694": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    a.sort()\n    \n    min_dist = float('inf')\n    \n    for i in range(n):\n        dist = 0\n        for j in range(i, n):\n            dist += abs(a[j] - a[i])\n        if dist < min_dist:\n            min_dist = dist\n    \n    print(min_dist)\n\nmin_distance_to_travel()",
        "result": "failed: testcase 0"
    },
    "4213": {
        "body": "import sys\n\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    min_val = sys.maxsize\n    max_diff = 0\n    \n    for i in range(n):\n        if a[i] < min_val:\n            min_val = a[i]\n        elif a[i] - min_val > max_diff:\n            max_diff = a[i] - min_val\n    \n    print(max_diff)\n\nmax_absolute_difference()",
        "result": "failed: testcase 0"
    },
    "4471": {
        "body": "    while True:\n        if all(h <= 0 for h in heights):\n            return \"YES\"\n        placed = False\n        for i in range(n):\n            if heights[i] > 0:\n                heights[i] += 2\n                placed = True\n                break\n        if not placed:\n            return \"NO\"\n        for j in range(n):\n            heights[j] -= 1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        heights = list(map(int, data[index:index + n]))\n        index += n\n        \n        result = can_clear_field(n, heights)\n        results.append(result)\n    \n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4802": {
        "body": "import sys\n\n    if M < 45:\n        H -= 1\n        M += 60 - 45\n    else:\n        M -= 45\n    if H < 0:\n        H += 24\n    return H, M\n\nif __name__ == \"__main__\":\n    input_line = input().strip()\n    H, M = map(int, input_line.split())\n    new_H, new_M = adjust_time(H, M)\n    print(new_H, new_M)",
        "result": "failed: testcase 0"
    },
    "4890": {
        "body": "import sys\nfrom typing import List\n\n    total_bottles = sum(c)\n    \n    if total_bottles + n < m:\n        return \"impossible\"\n    \n    remaining_students = m\n    new_bottles_placed = [0] * s\n    \n    for i in range(s):\n        while remaining_students > 0 and c[i] == d:\n            remaining_students -= 1\n            if remaining_students == 0:\n                break\n            c[i] = 0\n        \n        if remaining_students <= 0:\n            break\n        \n        bottles_to_place = min(n, remaining_students * (d - c[i]))\n        new_bottles_placed[i] = bottles_to_place\n        n -= bottles_to_place\n        remaining_students -= bottles_to_place\n    \n    return \" \".join(map(str, new_bottles_placed))\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    lines = input_data.split(\"\\n\")\n    n, m, s, d = map(int, lines[0].split())\n    c = list(map(int, lines[1].split()))\n    \n    result = refill_fridge(n, m, s, d, c)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4286": {
        "body": "import heapq\n\n    edges = []\n    for x, y, w in offers:\n        edges.append((w, x - 1, y - 1))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] != a[j]:\n                edges.append((a[i] + a[j], i, j))\n    \n    edges.sort()\n    \n    parent = list(range(n))\n    rank = [0] * n\n    \n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            elif rank[rootX] < rank[rootY]:\n                parent[rootX] = rootY\n            else:\n                parent[rootY] = rootX\n                rank[rootX] += 1\n    \n    total_cost = 0\n    for w, x, y in edges:\n        if find(x) != find(y):\n            union(x, y)\n            total_cost += w\n            if len(set(find(i) for i in range(n))) == 1:\n                break\n    \n    return total_cost\n\n# Read input\nn, m = map(int, input().split())\na = list(map(int, input().split()))\noffers = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(min_cost_to_connect(n, m, a, offers))",
        "result": "failed: testcase 0"
    },
    "4713": {
        "body": "import sys\n\n    x = 0\n    max_x = 0\n    \n    for char in S:\n        if char == 'I':\n            x += 1\n        elif char == 'D':\n            x -= 1\n        if x > max_x:\n            max_x = x\n            \n    return max_x\n\n# Read input from stdin\nN = int(input().strip())\nS = input().strip()\n\n# Output the result\nprint(max_value_after_operations(N, S))",
        "result": "failed: testcase 0"
    },
    "4698": {
        "body": "import sys\n\n    n = int(input())\n    t = list(map(int, input().split()))\n    m = int(input())\n    drinks = []\n    \n    for _ in range(m):\n        p, x = map(int, input().split())\n        drinks.append((p - 1, x))\n    \n    results = []\n    for i in range(n):\n        total_time = sum(t[j] if j != drinks[p][0] else t[j] - drinks[p][1] for j in range(n))\n        results.append(total_time)\n    \n    for result in results:\n        print(result)\n\ncalculate_times()",
        "result": "failed: testcase 0"
    },
    "4841": {
        "body": "    expected = -1\n    for word in words:\n        if word == \"mumble\":\n            if expected != -1:\n                return \"something is fishy\"\n        else:\n            num = int(word)\n            if expected == -1:\n                expected = num\n            elif num != expected + 1:\n                return \"something is fishy\"\n            expected += 1\n    return \"makes sense\"\n\nn = int(input())\nwords = input().split()\nprint(check_arild_counting(n, words))",
        "result": "failed: testcase 0"
    },
    "4865": {
        "body": "import sys\n\n    results = []\n    for _ in range(test_cases):\n        direction, minutes, hour, minute = input().split()\n        minutes = int(minutes)\n        hour = int(hour)\n        minute = int(minute)\n\n        if direction == 'F':\n            total_minutes = (hour * 60 + minute) + minutes\n            new_hour = total_minutes // 60 % 24\n            new_minute = total_minutes % 60\n        else:\n            total_minutes = (hour * 60 + minute) - minutes\n            new_hour = total_minutes // 60 % 24\n            new_minute = total_minutes % 60\n\n        results.append(f\"{new_hour} {new_minute}\")\n\n    return results\n\nif __name__ == \"__main__\":\n    test_cases = int(input())\n    results = calculate_new_time(test_cases)\n    for result in results:\n        print(result)",
        "result": "failed: testcase 0"
    },
    "4957": {
        "body": "import sys\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                found = False\n                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'E':\n                        found = True\n                        break\n                if not found:\n                    grid[i] = grid[i][:j] + 'E' + grid[i][j+1:]\n    return grid\n\n    input = sys.stdin.read\n    data = input().split()\n    n, m = int(data[0]), int(data[1])\n    grid = data[2:n+2]\n    \n    result = place_coffee_shops(n, m, grid)\n    for row in result:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "4382": {
        "body": "import sys\n\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            for k in range(1, n+1):\n                count += 1\n    print(count)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    calculate_passwords(n)",
        "result": "failed: testcase 0"
    },
    "4456": {
        "body": "import sys\n\n    if n < k * 2 - 1:\n        return \"NO\"\n    \n    chars = list(range(97, 97 + min(k, 26)))\n    s = [''] * n\n    \n    i, j = 0, 0\n    for l in range(n):\n        if p[i] < q[j]:\n            s[p[i] - 1] = chr(chars.pop(0))\n            i += 1\n        else:\n            s[q[j] - 1] = chr(chars.pop(0))\n            j += 1\n    \n    if i < n:\n        for pos in sorted(p[i:], reverse=True):\n            s[pos - 1] = chr(chars.pop(0))\n    \n    if j < n:\n        for pos in sorted(q[j:], reverse=True):\n            s[pos - 1] = chr(chars.pop(0))\n    \n    return \"YES\\n\" + ''.join(s)\n\n# Read input from stdin\nn, k = map(int, input().split())\np = list(map(int, input().split()))\nq = list(map(int, input().split()))\n\n# Print the result\nprint(restore_string(n, k, p, q))",
        "result": "failed: testcase 0"
    },
    "4594": {
        "body": "import sys\n\n    d.sort()\n    max_layers = 1\n    current_layer_diameter = d[0]\n    \n    for i in range(1, N):\n        if d[i] < current_layer_diameter:\n            max_layers += 1\n            current_layer_diameter = d[i]\n    \n    return max_layers\n\nif __name__ == \"__main__\":\n    N = int(input())\n    d = [int(input()) for _ in range(N)]\n    print(max_layers(N, d))",
        "result": "failed: testcase 0"
    },
    "4560": {
        "body": "import sys\n\n    for i in range(A + 1):\n        if (N - 500 * i) % 1 == 0:\n            return \"Yes\"\n    return \"No\"\n\nif __name__ == \"__main__\":\n    N = int(input())\n    A = int(input())\n    print(can_pay_exactly(N, A))",
        "result": "failed: testcase 0"
    },
    "4320": {
        "body": "    k = 2\n    while True:\n        if n % ((1 << k) - 1) == 0:\n            return n // ((1 << k) - 1)\n        k += 1\n\nimport sys\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nresults = []\nfor i in range(t):\n    n = int(data[i + 1])\n    results.append(find_x(n))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4500": {
        "body": "import sys\n\n    if A + B >= C:\n        return \"Yes\"\n    else:\n        return \"No\"\n\nif __name__ == \"__main__\":\n    A, B, C = map(int, input().split())\n    result = can_buy_toy(A, B, C)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "4739": {
        "body": "import sys\n\n    speeds = set()\n    distances = []\n\n    for i in range(M - 1):\n        time_diff = T[i + 1] - T[i]\n        dist_diff = X[T.index(T[i]) + 1] - X[T.index(T[i])]\n        speed = dist_diff / time_diff\n        if speed not in speeds:\n            speeds.add(speed)\n            distances.append(dist_diff)\n\n    print(len(speeds))\n    print(' '.join(map(str, sorted(distances))))\n\nif __name__ == \"__main__\":\n    M, N = map(int, input().split())\n    T = list(map(int, input().split()))\n    X = list(map(int, input().split()))\n    calculate_speeds(M, N, T, X)",
        "result": "failed: testcase 0"
    },
    "4410": {
        "body": "import sys\n\n    count = 0\n    last_occupied = -k - 1\n    for i in range(n):\n        if s[i] == '0' and i > last_occupied + k:\n            count += 1\n            last_occupied = i\n    return count\n\n    t = int(input())\n    results = []\n    for _ in range(t):\n        n, k = map(int, input().split())\n        s = input()\n        results.append(max_occupied_tables(n, k, s))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2441": {
        "body": "import sys\n\n    MOD = 10**9 + 7\n    \n    # Initialize adjacency list for the graph\n    adj_list = [[] for _ in range(n)]\n    for u, v in roads:\n        adj_list[u-1].append(v-1)\n    \n    # Initialize DP arrays\n    dp_cost = [float('inf')] * n\n    dp_count = [0] * n\n    \n        if not adj_list[node]:\n            dp_cost[node] = costs[node]\n            dp_count[node] = 1\n            return dp_cost[node], dp_count[node]\n        \n        total_cost = costs[node]\n        total_ways = 1\n        \n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                cost, ways = dfs(neighbor, node)\n                dp_cost[node] += min(cost, dp_cost[node])\n                dp_count[node] = (dp_count[node] + ways) % MOD\n                \n        return dp_cost[node], dp_count[node]\n    \n    dfs(0, -1)\n    \n    return dp_cost[0], dp_count[0]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    costs = list(map(int, input().split()))\n    m = int(input())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    \n    min_cost, min_ways = min_security_cost_and_ways(n, costs, roads)\n    print(min_cost, min_ways)",
        "result": "failed: testcase 0"
    },
    "276": {
        "body": "    gems = ['purple', 'green', 'blue', 'orange', 'red', 'yellow']\n    seen_colors = set(input().strip() for _ in range(int(input())))\n    absent_gems = [gem.title() for gem in gems if gem not in seen_colors]\n    print(len(absent_gems))\n    for gem in absent_gems:\n        print(gem)\n\nfind_absent_gems()",
        "result": "failed: testcase 0"
    },
    "2635": {
        "body": "    m, n = len(matrix), len(matrix[0])\n    top, bottom = 0, m - 1\n    left, right = 0, n - 1\n    result = []\n    \n    while True:\n        for i in range(left, right + 1):\n            result.append(matrix[top][i])\n        top += 1\n        if top > bottom:\n            break\n        \n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n        if left > right:\n            break\n        \n        for i in range(right, left - 1, -1):\n            result.append(matrix[bottom][i])\n        bottom -= 1\n        if top > bottom:\n            break\n        \n        for i in range(bottom, top - 1, -1):\n            result.append(matrix[i][left])\n        left += 1\n        if left > right:\n            break\n    \n    return result\n\n# Read input from stdin\nmatrix_str = input().strip()\nmatrix = [list(map(int, row.split(','))) for row in matrix_str.strip('[]').split('][')]\n\n# Print the result\nprint(spiralOrder(matrix))",
        "result": "failed: testcase 0"
    },
    "281": {
        "body": "import math\n\n    if a == b:\n        return 1\n    elif a == 0:\n        return 1\n    else:\n        last_digit = 1\n        for i in range(a + 1, b + 1):\n            last_digit = (last_digit * (i % 10)) % 10\n        return last_digit\n\n# Read input from stdin\na, b = map(int, input().split())\n\n# Print the result\nprint(last_digit_of_factorial_division(a, b))",
        "result": "failed: testcase 0"
    },
    "2300": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    a = list(map(int, data[2:2+n]))\n    \n    operations = []\n    index = 2 + n\n    for _ in range(m):\n        t = int(data[index])\n        if t == 1:\n            x = int(data[index+1]) - 1\n            v = int(data[index+2])\n            operations.append((t, x, v))\n        elif t == 2:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            operations.append((t, l, r))\n        else:\n            l = int(data[index+1]) - 1\n            r = int(data[index+2])\n            d = int(data[index+3])\n            operations.append((t, l, r, d))\n        index += (3 if t == 1 else 4)\n    \n        if i < 2:\n            return 1\n        f_values = [0] * (n + 1)\n        f_values[0], f_values[1] = 1, 1\n        for j in range(2, i + 1):\n            f_values[j] = (f_values[j - 1] - 1 + f_values[j - 2]) % 1000000000\n        return f_values[i]\n    \n    result = []\n    current_sum = sum(f(i) * a[i] for i in range(n))\n    for op in operations:\n        if op[0] == 1:\n            x, v = op[1], op[2]\n            current_sum -= f(x) * a[x]\n            a[x] = v\n            current_sum += f(x) * a[x]\n        elif op[0] == 2:\n            l, r = op[1], op[2]\n            new_sum = current_sum - sum(f(i) * a[i] for i in range(l, r))\n            current_sum = new_sum + sum(f(i) * (a[i] + 0) for i in range(l, r))\n        else:\n            l, r, d = op[1], op[2], op[3]\n            current_sum += d * (r - l)\n    \n    for value in result:\n        print(value)\n\nif __name__ == \"__main__\":\n    solve()",
        "result": "failed: testcase 0"
    },
    "2104": {
        "body": "import math\nimport sys\n\n    pairs = []\n    for i in range(l, l + (r - l) // 2 + 1):\n        if math.gcd(i, r - i + 1) == 1:\n            pairs.append((i, r - i + 1))\n    if len(pairs) != (r - l) // 2:\n        print(\"NO\")\n    else:\n        print(\"YES\")\n        for pair in pairs:\n            print(pair[0], pair[1])\n\nif __name__ == \"__main__\":\n    l, r = map(int, input().split())\n    find_pairs(l, r)",
        "result": "failed: testcase 0"
    },
    "1995": {
        "body": "    for l, r, k in queries:\n        substring = s[l-1:r]\n        rotated_substring = substring[-k:] + substring[:-k]\n        s = s[:l-1] + rotated_substring + s[r:]\n    return s\n\n# Read input\ns = input().strip()\nm = int(input())\nqueries = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Process queries and print result\nresult = process_queries(s, queries)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "2064": {
        "body": "    sections = [6, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n    digits = []\n    for i in range(9, -1, -1):\n        while n >= sections[i]:\n            digits.append(i)\n            n -= sections[i]\n    return int(''.join(map(str, digits)))\n\n# Read input\nn = int(input())\n\n# Print the result\nprint(max_number(n))",
        "result": "failed: testcase 0"
    },
    "1715": {
        "body": "import sys\n\n    # Initialize a list to store the minimum distance for each query\n    results = []\n    \n    # Iterate over each query\n    for xi in x:\n        # Find the closest shrine and temple to xi\n        min_dist = float('inf')\n        \n        for si in s:\n            dist_to_shrine = abs(xi - si)\n            if dist_to_shrine < min_dist:\n                min_dist = dist_to_shrine\n        \n        for ti in t:\n            dist_to_temple = abs(xi - ti)\n            if dist_to_temple < min_dist:\n                min_dist = dist_to_temple\n        \n        # Append the result to the list\n        results.append(min_dist)\n    \n    return results\n\n# Read input from stdin\nA, B, Q = map(int, input().split())\ns = [int(input()) for _ in range(A)]\nt = [int(input()) for _ in range(B)]\nx = [int(input()) for _ in range(Q)]\n\n# Calculate the minimum distances and print them\nresults = min_distance_to_shrine_and_temple(A, B, Q, s, t, x)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2074": {
        "body": "import sys\n\n    min_costs = [min(row) for row in costs]\n    max_min_cost = max(min_costs)\n    return max_min_cost\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    costs = []\n    \n    index = 2\n    for _ in range(n):\n        row = [int(data[index + i]) for i in range(m)]\n        costs.append(row)\n        index += m\n    \n    result = find_dinner_cost(n, m, costs)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2921": {
        "body": "import sys\n\n    drinks = []\n    for _ in range(d):\n        name, strength, size, price = input().split()\n        strength = float(strength)\n        if size == '1/1':\n            volume = 1\n        elif size == '1/2':\n            volume = 0.5\n        else:\n            volume = 1 / 3\n        cost_per_unit = (strength * volume) / price\n        drinks.append((name, cost_per_unit))\n\n    dp = [[float('inf')] * (u + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n    buy_count = [[[] for _ in range(u + 1)] for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(u + 1):\n            dp[i][j] = dp[i - 1][j]\n            buy_count[i][j] = buy_count[i - 1][j]\n\n            for name, cost_per_unit in drinks:\n                if i >= cost_per_unit and j >= 1:\n                    new_units = j\n                    while new_units > 0 and dp[i][new_units] > dp[i - cost_per_unit][new_units - 1] + 1:\n                        new_units -= 1\n                    if new_units == j:\n                        break\n\n                    if dp[i - cost_per_unit][new_units - 1] + 1 < dp[i][j]:\n                        dp[i][j] = dp[i - cost_per_unit][new_units - 1] + 1\n                        buy_count[i][j] = buy_count[i - cost_per_unit][new_units - 1].copy()\n                        buy_count[i][j].append((name, 1))\n                    elif dp[i - cost_per_unit][new_units - 1] + 1 == dp[i][j]:\n                        for k in range(1, j):\n                            if dp[i - cost_per_unit][k] + new_units - k < dp[i][j]:\n                                dp[i][j] = dp[i - cost_per_unit][k] + new_units - k\n                                buy_count[i][j] = buy_count[i - cost_per_unit][k].copy()\n                                buy_count[i][j].append((name, 1))\n\n    if dp[m][u] == float('inf'):\n        print(\"IMPOSSIBLE\")\n    else:\n        for name, count in buy_count[m][u]:\n            print(f\"{name} {count}\")\n\nif __name__ == \"__main__\":\n    m, u, d = map(float, input().split())\n    buy_drinks(m, u, int(d))",
        "result": "failed: testcase 0"
    },
    "1642": {
        "body": "import sys\n\n    max_d = 0\n    for i in range(n):\n        x1, y1 = vertices[i]\n        x2, y2 = vertices[(i + 1) % n]\n        dx = x2 - x1\n        dy = y2 - y1\n        d = (dx ** 2 + dy ** 2) ** 0.5 / 2\n        max_d = max(max_d, d)\n    return max_d\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    vertices = []\n    for _ in range(n):\n        x, y = map(int, input().strip().split())\n        vertices.append((x, y))\n    \n    result = max_distance(n, vertices)\n    print(f\"{result:.15f}\")",
        "result": "failed: testcase 0"
    },
    "947": {
        "body": "import math\n\n    if n % 2 == 0:\n        return n // 2, n // 2\n    else:\n        return (n - 1) // 2, (n + 1) // 2\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a, b = find_min_lcm(n)\n    print(a, b)",
        "result": "failed: testcase 0"
    },
    "743": {
        "body": "    for i in range(n):\n        for j in range(i + 1, n):\n            if numbers[i] > numbers[j]:\n                numbers[i] -= numbers[j]\n    return sum(numbers)\n\n# Read input from stdin\nn = int(input())\nnumbers = list(map(int, input().split()))\n\n# Print the result\nprint(min_sum(n, numbers))",
        "result": "failed: testcase 0"
    },
    "1397": {
        "body": "import sys\n\n    roads = []\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in forbidden and (j, i) not in forbidden:\n                roads.append((i, j))\n    \n    return len(roads), roads\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    forbidden = set()\n    \n    for i in range(m):\n        a = int(data[2 + 2 * i]) - 1\n        b = int(data[3 + 2 * i]) - 1\n        forbidden.add((a, b))\n        forbidden.add((b, a))\n    \n    result_count, result_roads = min_roads(n, m, forbidden)\n    print(result_count)\n    for road in result_roads:\n        print(road[0] + 1, road[1] + 1)",
        "result": "failed: testcase 0"
    },
    "1144": {
        "body": "    t = \"ab\" * (m // 2) + \"a\" if m % 2 != 0 else \"ab\" * (m // 2)\n    \n        count = 0\n        for i in range(n - m + 1):\n            if all(s[i + j] == '?' or s[i + j] == t[j % m] for j in range(m)):\n                count += 1\n        return count\n    \n        needed = 0\n        for i in range(n - m + 1):\n            if not all(s[i + j] == '?' or s[i + j] == t[j % m] for j in range(m)):\n                needed += 1\n        return needed\n    \n    max_beauty = 0\n    min_replacements = float('inf')\n    \n    for start in range(n - m + 1):\n        current_t = t[(n - start) % len(t):]\n        occurrences = count_occurrences(s[start:], current_t)\n        replacements = replace_needed(s[start:], current_t)\n        if occurrences > max_beauty:\n            max_beauty = occurrences\n            min_replacements = replacements\n    \n    return min_replacements\n\n# Read input from stdin\nn = int(input())\ns = input().strip()\nm = int(input().strip())\n\n# Print the result\nprint(min_replacements_to_max_beauty(n, s, m))",
        "result": "failed: testcase 0"
    },
    "890": {
        "body": "from itertools import combinations\n\n    count = 0\n    for r in range(2, n + 1):\n        for combo in combinations(difficulties, r):\n            if min(combo) + x <= max(combo) and l <= sum(combo) <= r:\n                count += 1\n    return count\n\n# Read input\nn, l, r, x = map(int, input().split())\ndifficulties = list(map(int, input().split()))\n\n# Print the result\nprint(count_problemsets(n, l, r, x, difficulties))",
        "result": "failed: testcase 0"
    },
    "2410": {
        "body": "import sys\n\n    prefix_sum = [0] * (n + 1)\n    for i in range(1, n + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + a[i - 1]\n    \n    min_adel_tastiness = float('inf')\n    for l in range(n):\n        for r in range(l, n - 1):\n            segment_tastiness = prefix_sum[r + 1] - prefix_sum[l]\n            if segment_tastiness < min_adel_tastiness:\n                min_adel_tastiness = segment_tastiness\n    \n    total_yasser_tastiness = prefix_sum[n]\n    return total_yasser_tastiness > min_adel_tastiness\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        if can_yasser_be_happy(n, a):\n            results.append(\"YES\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "1004": {
        "body": "import sys\n\n    balance = 0\n    days = []\n    day_length = 0\n    \n    for event in events:\n        if event > 0:\n            balance += 1\n        else:\n            balance -= 1\n        \n        day_length += 1\n        \n        if balance == 0:\n            days.append(day_length)\n            day_length = 0\n    \n    if balance != 0:\n        return -1\n    \n    print(len(days))\n    print(' '.join(map(str, days)))\n\nif __name__ == \"__main__\":\n    n = int(input())\n    events = list(map(int, input().split()))\n    partition_events(n, events)",
        "result": "failed: testcase 0"
    },
    "531": {
        "body": "import sys\n\n    min_val = min(x)\n    max_val = max(x)\n    target_avg = sum(x) / n\n    equal_count = 0\n    y = []\n    \n    for val in x:\n        if val == target_avg:\n            equal_count += 1\n            y.append(target_avg)\n        else:\n            diff = abs(val - target_avg)\n            if diff <= max_val - min_val:\n                if val < target_avg:\n                    y.append(int(target_avg))\n                else:\n                    y.append(int(target_avg) + 1)\n    \n    return equal_count, y\n\nn = int(input())\nx = list(map(int, input().split()))\nequal_count, y = min_equal_measurements(n, x)\n\nprint(equal_count)\nprint(*y)",
        "result": "failed: testcase 0"
    },
    "510": {
        "body": "import sys\n\n    # Ensure a <= b <= c for easier calculation\n    if a > b:\n        a, b = b, a\n    if b > c:\n        b, c = c, b\n    if a > b:\n        a, b = b, a\n    \n    # Calculate the minimum distance needed for each pair to be at least d\n    min_dist_ab = max(0, (d - (b - a)) // 2)\n    min_dist_bc = max(0, (d - (c - b)) // 2)\n    \n    # The total minimum duration is the sum of the individual minimum distances\n    return min_dist_ab + min_dist_bc\n\n# Read input from stdin\na, b, c, d = map(int, input().split())\n\n# Print the result\nprint(min_duration(a, b, c, d))",
        "result": "failed: testcase 0"
    },
    "2555": {
        "body": "import sys\n\n        arr.sort()\n        return sum(arr[i] if i % 2 == 0 else -arr[i] for i in range(len(arr)))\n    \n    results = [calculate_max_strength(a)]\n    for l, r in swaps:\n        l -= 1\n        r -= 1\n        a[l], a[r] = a[r], a[l]\n        results.append(calculate_max_strength(a))\n    \n    return results\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nt = int(data[0])\nindex = 1\nresults = []\n\nfor _ in range(t):\n    n = int(data[index])\n    q = int(data[index + 1])\n    index += 2\n    a = list(map(int, data[index:index + n]))\n    index += n\n    \n    swaps = []\n    for _ in range(q):\n        l = int(data[index])\n        r = int(data[index + 1])\n        swaps.append((l, r))\n        index += 2\n    \n    results.extend(max_strength_of_army(n, q, a, swaps))\n\n# Print output\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "324": {
        "body": "import sys\n\n    a = n + 2\n    while True:\n        if not is_prime(a):\n            b = a - n\n            if b >= 2 and not is_prime(b):\n                return a, b\n        a += 1\n\n    if num < 2:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ninput_n = int(input().strip())\na, b = find_composite_pair(input_n)\nprint(a, b)",
        "result": "failed: testcase 0"
    },
    "2912": {
        "body": "import sys\ninput = sys.stdin.read\ndata = input().split()\n\nN = int(data[0])\nstrings = data[1:N+1]\noperations = [(int(data[N+i*2])-1, int(data[N+i*2+1])-1) for i in range(N-1)]\n\nfor a, b in operations:\n    strings[a] += strings[b]\n    strings[b] = \"\"\n\nprint(strings[0])",
        "result": "failed: testcase 0"
    },
    "9": {
        "body": "    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    d = int(data[0])\n    n, m = map(int, data[1:3])\n    sofas = []\n    for i in range(d):\n        x1, y1, x2, y2 = map(int, data[6*i+3:6*(i+1)])\n        sofas.append(((x1, y1), (x2, y2)))\n    \n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, data[-4:])\n    \n    for i in range(d):\n        left, right, top, bottom = 0, 0, 0, 0\n        x1, y1 = sofas[i][0]\n        x2, y2 = sofas[i][1]\n        for j in range(d):\n            if i == j:\n                continue\n            x3, y3 = sofas[j][0]\n            x4, y4 = sofas[j][1]\n            if (x1 == x3 and abs(y1 - y3) == 1) or (y1 == y3 and abs(x1 - x3) == 1):\n                if y3 < y1 <= y2:\n                    top += 1\n                elif y3 > y2 >= y1:\n                    bottom += 1\n            elif (x2 == x4 and abs(y2 - y4) == 1) or (y2 == y4 and abs(x2 - x4) == 1):\n                if y4 < y2 <= y1:\n                    top += 1\n                elif y4 > y1 >= y2:\n                    bottom += 1\n        \n        if left == cnt_l and right == cnt_r and top == cnt_t and bottom == cnt_b:\n            print(i + 1)\n            return\n    \n    print(-1)\n\nfind_sofa()",
        "result": "failed: testcase 0"
    },
    "249": {
        "body": "import sys\n\n    required_distances = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            required_distances.add(abs(a[j] - a[i]))\n    \n    if x not in required_distances:\n        required_distances.add(x)\n    if y not in required_distances:\n        required_distances.add(y)\n    \n    additional_marks = sorted(required_distances.difference({0, l}))\n    return len(additional_marks), additional_marks\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\nl = int(data[1])\nx = int(data[2])\ny = int(data[3])\na = list(map(int, data[4:]))\n\n# Get the result\nv, p = min_additional_marks(n, l, x, y, a)\n\n# Print the result\nprint(v)\nprint(' '.join(map(str, p)))",
        "result": "failed: testcase 0"
    },
    "2999": {
        "body": "import sys\n\n    dp = [False] * (s + 1)\n    dp[0] = True\n    \n    for _, bet in sorted(participants, key=lambda x: x[1]):\n        for j in range(s, bet - 1, -1):\n            dp[j] = dp[j] or dp[j - bet]\n    \n    winners = [t for t, _ in participants if dp[_]]\n    \n    return len(winners), winners\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = int(data[1])\n    \n    participants = []\n    index = 2\n    for _ in range(n):\n        t = data[index]\n        b = int(data[index + 1])\n        participants.append((t, b))\n        index += 2\n    \n    k, winners = find_winners(n, s, participants)\n    \n    print(k)\n    for winner in winners:\n        print(winner)",
        "result": "failed: testcase 0"
    },
    "2239": {
        "body": "    return x // 2\n\nt = int(input())\nresults = [min_rolls_to_score(int(input())) for _ in range(t)]\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2615": {
        "body": "import math\nfrom typing import List\n\n    if n <= 2:\n        return 1\n    sieve = [True] * (n + 1)\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        if sieve[i]:\n            for j in range(i*i, n + 1, 2*i):\n                sieve[j] = False\n    primes = [i for i in range(3, n + 1, 2) if sieve[i]]\n    elegant_count = 0\n    power_counts = [0] * len(primes)\n    \n    for k in range(n // primes[-1] + 1):\n        product = 1\n        gcd = 1\n        for i in range(len(primes)):\n            count = (n - k) // (primes[i] ** (i + 1))\n            if count > power_counts[i]:\n                power_counts[i] = count\n                gcd *= primes[i]\n            else:\n                break\n            product *= primes[i] ** (power_counts[i])\n        if gcd == 1 and product <= n:\n            elegant_count += 1\n    \n    return elegant_count\n\n    T = int(input())\n    results = []\n    for _ in range(T):\n        n = int(input())\n        results.append(count_elegant_numbers(n))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2542": {
        "body": "    n = len(s)\n    for i in range(n):\n        if s[:i] == s[i+1:]:\n            return n - 2 * i - 1\n    return n\n\nt = int(input())\nresults = []\nfor _ in range(t):\n    s = input()\n    results.append(min_erasure_to_good_string(s))\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "511": {
        "body": "import math\n\n    if b == 0:\n        return 0\n    else:\n        return 1 + f(a, b - math.gcd(a, b))\n\n# Read input\nx, y = map(int, input().split())\n\n# Calculate and print the result\nprint(f(x, y))",
        "result": "failed: testcase 0"
    },
    "1409": {
        "body": "import sys\n\n    valid_teams = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for l in range(j + 1, n):\n                if participants[i] <= 5 and participants[j] <= 5 and participants[l] <= 5:\n                    count = sum(1 for x in participants if x >= k)\n                    if count == 3:\n                        valid_teams += 1\n    return valid_teams\n\nn, k = map(int, input().split())\nparticipants = list(map(int, input().split()))\nprint(max_teams(n, k, participants))",
        "result": "failed: testcase 0"
    },
    "2274": {
        "body": "import sys\n\n    changes = 0\n    for i in range(n):\n        for j in range(m):\n            if directions[i][j] == 'R' and (i != n-1 or j != m-2):\n                changes += 1\n            elif directions[i][j] == 'D' and (i != n-2 or j != m-1):\n                changes += 1\n    return changes\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n, m = map(int, data[index:index+2])\n        index += 2\n        directions = [data[index:index+m] for _ in range(n)]\n        index += m\n        \n        result = min_changes_to_functional(n, m, directions)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2420": {
        "body": "import sys\n\n    max_points = 0\n    \n    for i in range(n):\n        count = 0\n        for j in range(n):\n            if abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) <= r:\n                count += 1\n        max_points = max(max_points, count)\n    \n    return max_points\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    r = int(data[1])\n    points = []\n    for i in range(2, 2 * n + 2, 2):\n        points.append((int(data[i]), int(data[i + 1])))\n    \n    result = max_points_in_l1_ball(n, r, points)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "1267": {
        "body": "from itertools import combinations\n\n    total_ways = 0\n    max_score = max(scores)\n    \n    for i in range(1, n + 1):\n        for subset in combinations(range(n), i):\n            if all(scores[j] == 0 or j in subset and scores[k] >= scores[j] for k in range(n)):\n                total_ways += 1\n                \n    return total_ways\n\n# Read input\nn = int(input())\nscores = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(count_ways(n, scores))",
        "result": "failed: testcase 0"
    },
    "2356": {
        "body": "import random\n\n    n = len(arr)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j - arr[j] == i - arr[i]:\n                return False\n    return True\n\n    while not is_good(arr):\n        random.shuffle(arr)\n    return arr\n\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    a = list(map(int, input().split()))\n    good_arr = shuffle_to_good(a)\n    print(n)\n    print(*good_arr)",
        "result": "failed: testcase 0"
    },
    "108": {
        "body": "import sys\n\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    s_len, a_len = len(s), len(alphabet)\n    target_index = 0\n    \n    for i in range(s_len):\n        if s[i] == alphabet[target_index]:\n            target_index += 1\n            if target_index == a_len:\n                return \"\".join(sorted(set(s)))\n    \n    return \"-1\"\n\ninput_string = input().strip()\nresult = find_subsequence(input_string)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1833": {
        "body": "import sys\n\n    mod = 10**9 + 7\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in a:\n        for i in range(n, 0, -1):\n            dp[i] = (dp[i] + dp[i-1]) % mod\n    \n    result = sum(dp) - 1\n    return result % mod\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    a = list(map(int, input().strip().split()))\n    print(count_good_subsequences(n, a))",
        "result": "failed: testcase 0"
    },
    "2324": {
        "body": "    n = len(s)\n    dp = [[[0 for _ in range(n)] for _ in range(n)] for _ in range(n)]\n    \n    for length in range(1, n + 1):\n        for start in range(n - length + 1):\n            end = start + length - 1\n            if length == 1:\n                dp[start][end][0] = dp[start][end][1] = 1\n            elif s[start] == s[end]:\n                dp[start][end][0] = 2 * dp[start + 1][end - 1][0] + (length >= 3)\n                dp[start][end][1] = dp[start][end - 1][1] + dp[start + 1][end][1]\n            else:\n                dp[start][end][0] = max(dp[start + 1][end][0], dp[start][end - 1][0])\n                dp[start][end][1] = dp[start][end - 1][1] + dp[start + 1][end][1]\n    \n    result = []\n    for k in range(n):\n        count = 0\n        for start in range(n):\n            if dp[start][start + k][1] > 0:\n                count += dp[start][start + k][1]\n        result.append(count)\n    \n    print(\" \".join(map(str, result)))\n\n# Read input from stdin\ns = input().strip()\npalindromic_characteristics(s)",
        "result": "failed: testcase 0"
    },
    "2372": {
        "body": "import sys\n\n        return 0 <= x < h and 0 <= y < w and grid[x][y] == '.'\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    queue = [(c_h, c_w, 0)]\n    visited = set()\n    visited.add((c_h, c_w))\n    \n    while queue:\n        x, y, magic_count = queue.pop(0)\n        \n        if (x, y) == (d_h, d_w):\n            return magic_count\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, magic_count))\n        \n        if magic_count < 2:\n            for i in range(max(0, x-2), min(h, x+3)):\n                for j in range(max(0, y-2), min(w, y+3)):\n                    if is_valid(i, j) and (i, j) not in visited:\n                        visited.add((i, j))\n                        queue.append((i, j, magic_count + 1))\n    \n    return -1\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    h = int(data[0])\n    w = int(data[1])\n    c_h = int(data[2]) - 1\n    c_w = int(data[3]) - 1\n    d_h = int(data[4]) - 1\n    d_w = int(data[5]) - 1\n    \n    grid = data[6:]\n    \n    result = min_magic_moves(h, w, c_h, c_w, d_h, d_w, grid)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "1984": {
        "body": "import sys\n\n    levels = []\n    for _ in range(k):\n        level = [input().strip() for _ in range(n)]\n        levels.append(level)\n\n        return sum(1 for i in range(n) for j in range(m) if a[i][j] != b[i][j])\n\n        if level in memo:\n            return memo[level]\n        min_cost = float('inf')\n        best_transfer = None\n        for prev_level in transferred:\n            diff = calculate_diff(levels[prev_level - 1], levels[level])\n            cost = diff * w\n            if cost < min_cost:\n                min_cost = cost\n                best_transfer = prev_level\n        if min_cost >= n * m:\n            min_cost = n * m\n            best_transfer = None\n        memo[level] = (min_cost, best_transfer)\n        return memo[level]\n\n    transferred = []\n    memo = {}\n    total_traffic = 0\n\n    for i in range(k):\n        cost, transfer = dfs(i + 1, transferred, memo)\n        total_traffic += cost\n        transferred.append(i + 1)\n\n    print(total_traffic)\n    for t in transferred:\n        if t == 1:\n            print(f\"{t} 0\")\n        else:\n            print(f\"{t} {transferred.index(t) + 2}\")\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    index = 0\n\n    n = int(data[index])\n    m = int(data[index + 1])\n    k = int(data[index + 2])\n    w = int(data[index + 3])\n    index += 4\n\n    min_traffic(n, m, k, w)",
        "result": "failed: testcase 0"
    },
    "1253": {
        "body": "import sys\n\n    min_abs = float('inf')\n    for i in range(n):\n        if abs(a[i]) < min_abs:\n            min_abs = abs(a[i])\n    \n    if k % 2 == 1:\n        return sum(a) + 2 * min_abs\n    else:\n        return sum(a)\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(max_income(n, k, a))",
        "result": "failed: testcase 0"
    },
    "523": {
        "body": "import sys\n\n    max_length = 0\n    longest_palindrome = \"\"\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            combined = strings[i] + strings[j]\n            reversed_combined = combined[::-1]\n            if combined == reversed_combined:\n                if len(combined) > max_length:\n                    max_length = len(combined)\n                    longest_palindrome = combined\n            for k in range(j + 1, n):\n                tripled = strings[i] + strings[j] + strings[k]\n                reversed_tripled = tripled[::-1]\n                if tripled == reversed_tripled and len(tripled) > max_length:\n                    max_length = len(tripled)\n                    longest_palindrome = tripled\n    \n    return max_length, longest_palindrome\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    \n    strings = []\n    for i in range(n):\n        strings.append(data[2 + i])\n    \n    result_length, result_palindrome = find_longest_palindrome(n, m, strings)\n    \n    if result_length > 0:\n        print(result_length)\n        print(result_palindrome)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2934": {
        "body": "import sys\n\n    MOD = 10**9\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        new_dp = [0] * (m + 1)\n        for j in range(m + 1):\n            if j >= 1:\n                new_dp[j] += dp[j - 1]\n            if j >= 2:\n                new_dp[j] += dp[j - 2]\n            new_dp[j] %= MOD\n        dp = new_dp[:]\n    return dp[m]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    m = int(input())\n    print(count_tilings(n, m))",
        "result": "failed: testcase 0"
    },
    "1745": {
        "body": "import sys\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    ways = 0\n    \n        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n    \n        nonlocal ways\n        if (x, y, dx, dy, turns) in visited:\n            return\n        visited.add((x, y, dx, dy, turns))\n        \n        if x == 0 or x == n - 1 or y == 0 or y == m - 1:\n            if not is_valid(x + dx, y + dy):\n                return\n            if turns >= 2:\n                ways += 1\n            return\n        \n        for ndx, ndy in directions:\n            if ndx == dx and ndy == dy:\n                continue\n            if turns >= 2 or (turns == 0 and not (dx == 0 and ndy == 0) and not (dy == 0 and ndx == 0)):\n                continue\n            if is_valid(x + ndx, y + ndy):\n                dfs(x + ndx, y + ndy, ndx, ndy, turns + 1)\n    \n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                for dx, dy in directions:\n                    if is_valid(i + dx, j + dy):\n                        dfs(i + dx, j + dy, dx, dy, 0)\n    \n    return ways\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    grid = [input().strip() for _ in range(n)]\n    print(count_ways(n, m, grid))",
        "result": "failed: testcase 0"
    },
    "1422": {
        "body": "    weights = [i + 1 for i in range(10) if weight_types[i] == '1']\n    left_sum = 0\n    right_sum = 0\n    result = []\n\n    for _ in range(m):\n        found = False\n        for w in weights:\n            if (w != result[-1] if result else True) and ((left_sum < right_sum and w > max(result)) or (right_sum < left_sum and w < min(result))):\n                if (left_sum < right_sum and w + left_sum > right_sum) or (right_sum < left_sum and w + right_sum > left_sum):\n                    if _ % 2 == 0:\n                        left_sum += w\n                    else:\n                        right_sum += w\n                    result.append(w)\n                    found = True\n                    break\n        if not found:\n            return \"NO\"\n\n    return \"YES\\n\" + ' '.join(map(str, result))\n\n# Read input from stdin\nweight_types = input().strip()\nm = int(input().strip())\n\n# Print the result\nprint(can_place_weights(weight_types, m))",
        "result": "failed: testcase 0"
    },
    "1763": {
        "body": "import sys\n\n    total_bricks = sum(heights)\n    target_height = total_bricks // N\n    operations = 0\n    \n    for height in heights:\n        diff = height - target_height\n        if diff < 0:\n            operations += diff * R\n        else:\n            operations += diff * M\n    \n    return operations\n\n# Read input\nN, A, R, M = map(int, input().split())\nheights = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_cost_to_restore_wall(N, A, R, M, heights))",
        "result": "failed: testcase 0"
    },
    "974": {
        "body": "import sys\n\n    add_commands = [int(cmd[1]) for cmd in commands if cmd[0] == 'add']\n    remove_commands = [int(cmd[1]) for cmd in commands if cmd[0] == 'remove']\n    \n    stack = []\n    reorders = 0\n    i, j = 0, 0\n    \n    while i < n or j < n:\n        if i < n and (not stack or stack[-1] != remove_commands[j]):\n            stack.append(add_commands[i])\n            i += 1\n        elif j < n and stack and stack[-1] == remove_commands[j]:\n            stack.pop()\n            j += 1\n        else:\n            reorders += 1\n            while stack and stack[-1] != remove_commands[j]:\n                stack.pop()\n            if stack:\n                stack.pop()\n            j += 1\n    \n    return reorders\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    commands = [input().strip().split() for _ in range(2 * n)]\n    result = min_reorders(n, commands)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2343": {
        "body": "import sys\n\n    if n == 1:\n        return False, None\n    target_n = (k - 1).bit_length()\n    if n < target_n:\n        return False, None\n    if (n - target_n) * (n - target_n + 1) // 2 >= k - (1 << target_n):\n        return True, target_n\n    return False, None\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    results = []\n    index = 1\n    \n    for _ in range(t):\n        n = int(data[index])\n        k = int(data[index + 1])\n        index += 2\n        \n        possible, path_length = can_split(n, k)\n        if possible:\n            results.append(f\"YES {path_length}\")\n        else:\n            results.append(\"NO\")\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "627": {
        "body": "    n = len(s)\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            return s[:i] + s[i + 1:]\n    return s[:-1]\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Output result\nprint(min_string(s))",
        "result": "failed: testcase 0"
    },
    "1655": {
        "body": "import sys\n\n    alive = [True] * n\n    for i in range(n):\n        if alive[i]:\n            for j in range(max(0, i - lengths[i]), i):\n                alive[j] = False\n    return sum(alive)\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    lengths = list(map(int, input().strip().split()))\n    print(count_alive_people(n, lengths))",
        "result": "failed: testcase 0"
    },
    "2124": {
        "body": "import sys\n\n    results = []\n    \n    for chat in chats:\n        n, users = map(int, input().split())\n        usernames = input().split()\n        \n        m = int(input())\n        messages = [input() for _ in range(m)]\n        \n        possible = True\n        recovered_messages = []\n        last_sender = None\n        \n        for message in messages:\n            if message.startswith('?'):\n                remaining_users = set(usernames) - {last_sender}\n                if not remaining_users:\n                    possible = False\n                    break\n                sender = remaining_users.pop()\n                recovered_message = f\"{sender}:{message[2:]}\"\n                recovered_messages.append(recovered_message)\n                last_sender = sender\n            else:\n                sender, text = message.split(':', 1)\n                recovered_messages.append(message)\n                last_sender = sender\n        \n        if possible:\n            results.extend(recovered_messages)\n        else:\n            results.append(\"Impossible\")\n    \n    for result in results:\n        print(result)\n\n# Read input and call the function\nt = int(input())\nchats = [input() for _ in range(t)]\nrecover_senders(chats)",
        "result": "failed: testcase 0"
    },
    "1093": {
        "body": "import sys\n\n    max_climb = 0\n    max_descent = 0\n    current_height = 0\n    \n    for col in range(m):\n        height = 0\n        is_peak = False\n        for row in range(n):\n            if profile[row][col] == '*':\n                height += 1\n                is_peak = True\n        if is_peak:\n            if height > current_height:\n                max_climb = max(max_climb, height - current_height)\n            elif height < current_height:\n                max_descent = max(max_descent, current_height - height)\n            current_height = height\n    \n    print(max_climb, max_descent)\n\n# Read input\nn, m = map(int, input().split())\nprofile = [input().strip() for _ in range(n)]\n\n# Call function with input\nfind_extremes(n, m, profile)",
        "result": "failed: testcase 0"
    },
    "899": {
        "body": "import heapq\n\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            current_dist, u = heapq.heappop(pq)\n            if current_dist > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                distance = current_dist + weight\n                if distance < dist[v]:\n                    dist[v] = distance\n                    heapq.heappush(pq, (distance, v))\n        return dist\n\n    all_paths = [dijkstra(i) for i in range(1, n + 1)]\n    used_edges = set()\n    \n    for u in range(1, n + 1):\n        for v in range(u + 1, n + 1):\n            for w in range(v + 1, n + 1):\n                if all_paths[u][v] == all_paths[u][w] + all_paths[w][v]:\n                    used_edges.add((u, v))\n                    used_edges.add((v, u))\n\n    return len(edges) - len(used_edges)\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Print the result\nprint(find_not_in_shortest_path(n, edges))",
        "result": "failed: testcase 0"
    },
    "551": {
        "body": "    y.sort()\n    for i in range(2, n + 1):\n        if y[i - 1] - y[i - 2] != y[1] - y[0]:\n            return \"No\"\n    return \"Yes\"\n\nn = int(input())\ny = list(map(int, input().split()))\nprint(can_draw_lines(n, y))",
        "result": "failed: testcase 0"
    },
    "1772": {
        "body": "    odd_count = sum(1 for f in flowers if f % 2 != 0)\n    even_count = n - odd_count\n    return min(odd_count, even_count)\n\n# Read input from stdin\nn = int(input())\nflowers = list(map(int, input().split()))\n\n# Print the result\nprint(max_large_bouquets(n, flowers))",
        "result": "failed: testcase 0"
    },
    "1339": {
        "body": "import sys\n\n    n = int(input().strip())\n    segments = []\n    \n    for _ in range(n):\n        l, r = map(int, input().strip().split())\n        segments.append((l, r))\n    \n    segments.sort()\n    max_end = -1\n    covering_index = -1\n    \n    for i, (l, r) in enumerate(segments):\n        if l > max_end:\n            if covering_index != -1:\n                break\n            covering_index = i + 1\n        max_end = max(max_end, r)\n    \n    print(covering_index)\n\nif __name__ == \"__main__\":\n    find_covering_segment()",
        "result": "failed: testcase 0"
    },
    "440": {
        "body": "import sys\n\n    vowels = \"aeiouy\"\n    n = len(word)\n    i = 0\n    \n    while i < n - 1:\n        if word[i] in vowels and word[i + 1] in vowels:\n            if i > 0 and word[i - 1] in vowels:\n                word = word[:i] + word[i+1:]\n                n -= 1\n                i -= 1\n            else:\n                i += 1\n        else:\n            i += 1\n    \n    return word\n\n# Read input from stdin\nn = int(input().strip())\nword = input().strip()\n\n# Correct the word and print the result\ncorrected_word = correct_word(word)\nprint(corrected_word)",
        "result": "failed: testcase 0"
    },
    "2801": {
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    graph = defaultdict(list)\n    for s, t in connections:\n        graph[s].append(t)\n    \n        stack = [node]\n        visited = set()\n        total_satisfaction = 0.0\n        fraction_eaten = 1.0\n        \n        while stack:\n            current_node = stack.pop()\n            if current_node not in visited:\n                visited.add(current_node)\n                for neighbor in graph[current_node]:\n                    stack.append(neighbor)\n                satisfaction_per_pizza = c[node] * fraction_eaten\n                total_satisfaction += satisfaction_per_pizza\n                fraction_eaten /= 2\n        \n        return total_satisfaction\n    \n    max_sat = 0.0\n    for i in range(n):\n        max_sat = max(max_sat, dfs(i))\n    \n    return max_sat\n\n# Read input from stdin\nn, m = map(int, input().split())\nc = list(map(int, input().split()))\nconnections = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the result\nprint(max_satisfaction(n, m, c, connections))",
        "result": "failed: testcase 0"
    },
    "2749": {
        "body": "import sys\nfrom typing import List\n\n    grid = [[0] * w for _ in range(h)]\n    colors = list(range(1, n + 1))\n    \n        if x < 0 or x >= h or y < 0 or y >= w or grid[x][y] != 0:\n            return False\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == color:\n                return True\n        return False\n\n        count = a[color - 1]\n        for i in range(h):\n            for j in range(w):\n                if grid[i][j] == 0 and is_valid_color(i, j, color):\n                    grid[i][j] = color\n                    count -= 1\n                    if count == 0:\n                        return True\n        return False\n\n    for color in colors:\n        if not paint_color(color):\n            raise ValueError(\"Failed to paint all squares with the given constraints\")\n\n    for row in grid:\n        print(' '.join(map(str, row)))",
        "result": "failed: testcase 0"
    },
    "2319": {
        "body": "    n = len(s)\n    for i in range(n):\n        if s[i:] + s[:i] == t:\n            return i\n    return -1\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        t = data[index + 2]\n        index += 3\n        result = min_operations(s, t)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2121": {
        "body": "import sys\nfrom typing import List\n\n    max_grade = float('-inf')\n    \n    for root in range(1, n + 1):\n        grade = float('inf')\n        visited = [False] * (n + 1)\n        stack = [(root, 0)]\n        \n        while stack:\n            node, index = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                grade = min(grade, times[node - 1])\n                if len(stack) < k - index - 1:\n                    stack.extend((child + 1, index + 1) for child in edges[node - 1] if child != node // 2)\n        \n        max_grade = max(max_grade, grade)\n    \n    return max_grade\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    times = list(map(int, data[2:2 + n]))\n    edges = [[] for _ in range(n)]\n    \n    index = 2 + n\n    for _ in range(n - 1):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        edges[u].append(v)\n        edges[v].append(u)\n        index += 2\n    \n    result = find_max_grade(n, k, times, edges)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2617": {
        "body": "    if n % 2 != 0:\n        return -1, []\n    \n    days = 0\n    split_counts = []\n    current_mass = 1\n    \n    while current_mass < n:\n        split_count = 0\n        for mass in range(current_mass // 2 + 1, current_mass):\n            if (current_mass + mass) % 2 == 0 and (n - current_mass) % mass == 0:\n                split_count = (n - current_mass) // mass\n                break\n        days += 1\n        split_counts.append(split_count)\n        current_mass *= 2\n    \n    return days, split_counts\n\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        result = min_nights_to_mass(n)\n        if result == -1:\n            results.append((-1,))\n        else:\n            results.append((result[0],) + tuple(result[1]))\n    \n    for result in results:\n        print(len(result))\n        print(*result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "175": {
        "body": "    while a > 0 and b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        elif b >= 2 * a:\n            b -= 2 * a\n        else:\n            break\n    print(a, b)\n\n# Read input from stdin\nn, m = map(int, input().split())\n\n# Call the function with the input values\nprocess(n, m)",
        "result": "failed: testcase 0"
    },
    "995": {
        "body": "import sys\n\n    n = len(a)\n        product = x * y\n        return int(product**0.5)**2 == product\n    \n        count = 0\n        for i in range(n - k + 1):\n            groups = [a[i]]\n            for j in range(i + 1, i + k):\n                if is_perfect_square_product(groups[-1], a[j]):\n                    groups.append(a[j])\n                else:\n                    break\n            if len(groups) == k:\n                count += 1\n        return count\n    \n    result = [count_subarrays_with_k_groups(k) for k in range(1, n + 1)]\n    return result\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    a = list(map(int, data[1:]))\n    \n    result = min_groups(a)\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "582": {
        "body": "import sys\n\n    n = len(publications)\n    unique_counts = set()\n    additional_time = 0\n    \n    for i in range(n):\n        while publications[i] in unique_counts:\n            publications[i] += 1\n            additional_time += times[i]\n            unique_counts.add(publications[i])\n    \n    return additional_time\n\n# Read input\nn = int(input().strip())\npublications = list(map(int, input().strip().split()))\ntimes = list(map(int, input().strip().split()))\n\n# Calculate and print the result\nprint(min_time_to_differentiate(publications, times))",
        "result": "failed: testcase 0"
    },
    "1402": {
        "body": "from collections import Counter\n\n    MOD = 10**9 + 7\n        greater = False\n        less = False\n        for i in range(n):\n            if s[i] != '?' and w[i] != '?':\n                if int(s[i]) > int(w[i]):\n                    greater = True\n                elif int(s[i]) < int(w[i]):\n                    less = True\n                if greater and less:\n                    return True\n        return False\n\n    if not is_comparable(s, w):\n        return 1\n    \n    s_counts = Counter(s)\n    w_counts = Counter(w)\n    \n    total_ways = 1\n    for char in set(s + w):\n        if char != '?':\n            s_count = s_counts[char]\n            w_count = w_counts[char]\n            if s_count > 0 and w_count > 0:\n                total_ways = (total_ways * pow(2, n - s_count - w_count, MOD)) % MOD\n    return total_ways\n\nn = int(input())\ns = input().strip()\nw = input().strip()\n\nresult = count_incomparable_templates(n, s, w)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1141": {
        "body": "    for l, r, c_1, c_2 in operations:\n        for i in range(l - 1, r):\n            if s[i] == c_1:\n                s = s[:i] + c_2 + s[i+1:]\n    return s\n\n# Read input\nn, m = map(int, input().split())\ns = input()\noperations = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Get result and print it\nresult = modify_string(n, m, s, operations)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "2836": {
        "body": "    max_distance = -1\n    best_name = None\n    \n    for X in range(A, B + 1):\n        if X % 2 != 0:\n            min_distance = float('inf')\n            for P in boys:\n                distance = abs(X - P)\n                if distance < min_distance:\n                    min_distance = distance\n            if min_distance > max_distance:\n                max_distance = min_distance\n                best_name = X\n                \n    return best_name\n\n# Read input\nN = int(input())\nboys = list(map(int, input().split()))\nA, B = map(int, input().split())\n\n# Output result\nprint(find_girl_name(boys, A, B))",
        "result": "failed: testcase 0"
    },
    "1109": {
        "body": "    period = a[:k]\n    changes = 0\n    \n    for i in range(k, n, k):\n        if a[i:i+k] != period:\n            changes += sum(a[i:i+k]) // 2\n    \n    return changes\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print result\nprint(min_changes_to_k_periodic(n, k, a))",
        "result": "failed: testcase 0"
    },
    "2125": {
        "body": "    flag_count = 0\n    \n    for top_row in range(n - 2):\n        for bottom_row in range(top_row + 1, n - 1):\n            if grid[top_row][0] == grid[bottom_row][0]:\n                continue\n            \n            for col in range(m):\n                if (grid[top_row][col] != grid[top_row + 1][col] or\n                    grid[top_row + 1][col] != grid[bottom_row][col]):\n                    break\n                \n                flag_count += 1\n    \n    return flag_count\n\n# Read input\nn, m = map(int, input().split())\ngrid = [input() for _ in range(n)]\n\n# Output result\nprint(count_flags(n, m, grid))",
        "result": "failed: testcase 0"
    },
    "1746": {
        "body": "import sys\n\n    num_children = [0] * (n + 1)\n    \n    for i in range(1, n):\n        num_children[parent[i]] += 1\n    \n    leaves = sum(1 for i in range(2, n) if num_children[i] == 0)\n    \n    for i in range(2, n):\n        if num_children[i] >= 3 and leaves < 3:\n            return \"No\"\n        leaves -= num_children[i]\n    \n    return \"Yes\"\n\nif __name__ == \"__main__\":\n    n = int(input())\n    parent = [int(input()) for _ in range(n - 1)]\n    print(is_spruce(n, parent))",
        "result": "failed: testcase 0"
    },
    "1294": {
        "body": "    working_buttons = set()\n    for char in s:\n        if char not in working_buttons:\n            working_buttons.add(char)\n    return ''.join(sorted(working_buttons))\n\nimport sys\ninput = sys.stdin.read\ndata = input().splitlines()\n\nt = int(data[0])\nresults = []\nfor i in range(t):\n    s = data[i + 1]\n    results.append(determine_working_buttons(s))\n\nprint('\\n'.join(results))",
        "result": "failed: testcase 0"
    },
    "1159": {
        "body": "import math\n\n    if num <= 1:\n        return False\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            return False\n    return True\n\n    target_edges = sum(is_prime(i) for i in range(1, n))\n    if not is_prime(target_edges):\n        return -1\n    \n    edges = []\n    degrees = [0] * n\n    for u in range(n):\n        for v in range(u + 1, n):\n            if (degrees[u] < 2 and degrees[v] < 2) or (u == v and degrees[u] < 1):\n                edges.append((u + 1, v + 1))\n                degrees[u] += 1\n                degrees[v] += 1\n    \n    return target_edges, edges\n\n    n = int(input())\n    result = find_prime_edges(n)\n    if result == -1:\n        print(-1)\n    else:\n        m, edges = result\n        print(m)\n        for u, v in edges:\n            print(u, v)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "2025": {
        "body": "import sys\n\n    if n < 4:\n        return -1\n    count = 0\n    while n >= 4:\n        n -= 4\n        count += 1\n    if n == 2 or n == 3:\n        return -1\n    return count\n\n    q = int(input())\n    results = []\n    for _ in range(q):\n        n = int(input())\n        results.append(max_composite_summands(n))\n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "1429": {
        "body": "import sys\n\n    complementary_pairs = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    count = 0\n    \n    for start in range(n):\n        for end in range(start + 1, n + 1):\n            substring = s[start:end]\n            permuted_substring = ''.join(sorted(substring))\n            if all(complementary_pairs[permuted_substring[i]] == permuted_substring[-i - 1] for i in range(len(permuted_substring) // 2)):\n                count += 1\n                \n    return count\n\nif __name__ == \"__main__\":\n    n = int(input())\n    s = input().strip()\n    print(count_complementary_substrings(n, s))",
        "result": "failed: testcase 0"
    },
    "1950": {
        "body": "import sys\n\n    total_penalty = 0\n    for i in range(n):\n        if a[i] <= 3:\n            total_penalty += a[i]\n        else:\n            total_penalty += a[i] % 2 + (a[i] // 2) * 3\n    return total_penalty\n\nif __name__ == \"__main__\":\n    n = int(input())\n    a = list(map(int, input().split()))\n    print(min_penalty(n, a))",
        "result": "failed: testcase 0"
    },
    "631": {
        "body": "import sys\n\n    results = []\n    \n    for n, m in test_cases[:t]:\n        a = test_cases[t*2+n]\n        \n            max_sum = 0\n            for i in range(n):\n                current_sum = sum(a[j] / (j + 1) for j in range(i, n))\n                if current_sum > max_sum:\n                    max_sum = current_sum\n            return max_sum == m\n        \n        results.append(\"YES\" if is_possible(sorted(a), m) else \"NO\")\n    \n    return results\n\n# Read input from stdin\ninput_data = sys.stdin.read().strip()\nlines = input_data.split('\\n')\n\nt = int(lines[0])\ntest_cases = []\nfor i in range(t):\n    n, m = map(int, lines[2*i+1].split())\n    a = list(map(int, lines[2*i+2].split()))\n    test_cases.extend([n, m] + a)\n\n# Get results\nresults = can_reorder_to_match_sum(t, test_cases)\n\n# Print results\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "2480": {
        "body": "from collections import defaultdict\n\n    prefix_remainders = defaultdict(int)\n    prefix_remainders[0] = 1\n    current_sum = 0\n    count = 0\n    \n    for i in range(n):\n        current_sum += a[i]\n        remainder = (current_sum % k + k) % k\n        target = (remainder * 2 - i - 1) % k\n        \n        if target in prefix_remainders:\n            count += prefix_remainders[target]\n        \n        prefix_remainders[remainder] += 1\n    \n    return count\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Output the result\nprint(count_subsequences(n, k, a))",
        "result": "failed: testcase 0"
    },
    "2363": {
        "body": "    results = []\n    for a, b in pairs:\n        operations = 0\n        while a > 0 and b > 0:\n            if a < b:\n                b -= a\n            else:\n                a -= b\n            operations += 1\n        results.append(operations)\n    return results\n\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\nresults = count_operations(pairs)\n\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "909": {
        "body": "    return max(a * (b + c), (a + b) * c, a * b * c)\n\n# Read input\na = int(input())\nb = int(input())\nc = int(input())\n\n# Print the maximum value\nprint(max_value(a, b, c))",
        "result": "failed: testcase 0"
    },
    "154": {
        "body": "MOD = 998244353\n\n    if n <= 1:\n        return 0\n    dp = [0] * (n + 1)\n    dp[0], dp[1] = 1, 0\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * ((i - 1) // 2 + 1)) % MOD\n    return dp[n]\n\nn = int(input())\nprint(count_perfectly_balanced_striped_trees(n))",
        "result": "failed: testcase 0"
    },
    "39": {
        "body": "    n = len(s)\n    max_length = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            substring = s[i:j+1]\n            if substring != substring[::-1] and len(substring) > max_length:\n                max_length = len(substring)\n\n    return max_length",
        "result": "failed: testcase 0"
    },
    "1885": {
        "body": "import math\n\n    total_variants = 0\n    for group_size in range(5, 8):\n        total_variants += math.comb(n, group_size)\n    return total_variants\n\nn = int(input())\nprint(count_group_variants(n))",
        "result": "failed: testcase 0"
    },
    "1180": {
        "body": "import sys\n\n    MOD = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    \n    for i in range(1, n + 1):\n        dp[i][0] = dp[i-1][0]\n        if digits[i-1] != '0':\n            for j in range(1, min(i, k) + 1):\n                dp[i][j] = (dp[i-1][j-1] + dp[i-1][j]) % MOD\n    \n    result = 0\n    for j in range(k + 1):\n        value = int(digits[j:i])\n        if value > 0:\n            result = (result + value * dp[n][j]) % MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    n, k = map(int, input().split())\n    digits = input()\n    print(calculate_sum(n, k, digits))",
        "result": "failed: testcase 0"
    },
    "1856": {
        "body": "import sys\nfrom collections import defaultdict\n\n    graph = defaultdict(set)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = passwords[i], passwords[j]\n            if any(c in a and c in b for c in 'abcdefghijklmnopqrstuvwxyz'):\n                graph[a].add(b)\n                graph[b].add(a)\n                \n    visited = set()\n    components = 0\n    \n        stack = [node]\n        while stack:\n            node = stack.pop()\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        stack.append(neighbor)\n    \n    for password in passwords:\n        if password not in visited:\n            components += 1\n            dfs(password)\n            \n    return components\n\nn = int(input().strip())\npasswords = [input().strip() for _ in range(n)]\nprint(min_passwords(n, passwords))",
        "result": "failed: testcase 0"
    },
    "522": {
        "body": "    MOD = 10**9 + 7\n    f = [f_1, f_2, f_3]\n    \n    for i in range(3, n):\n        next_value = (c**2 * f[i-3] * f[i-2] * f[i-1]) % MOD\n        f.append(next_value)\n        \n    return f[-1]\n\n# Read input from stdin\nn, f_1, f_2, f_3, c = map(int, input().split())\n\n# Calculate and print the result\nresult = calculate_f_n(n, f_1, f_2, f_3, c)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "1719": {
        "body": "    MOD = 10**9 + 7\n    dp = [[[[0] * 4 for _ in range(2)] for _ in range(2)] for _ in range(2)]\n    \n    # Initialize base case\n    for a in range(4):\n        for b in range(4):\n            for c in range(4):\n                if (a != 2 or b != 1 or c != 0) and (a != 3 or b != 1 or c != 2):\n                    dp[0][0][0][a] = 1\n    \n    # Fill the DP table\n    for n in range(1, N):\n        new_dp = [[[[0] * 4 for _ in range(2)] for _ in range(2)] for _ in range(2)]\n        for i in range(2):\n            for j in range(2):\n                for k in range(2):\n                    for a in range(4):\n                        for b in range(4):\n                            if (a != 2 or b != 1 or c != 0) and (a != 3 or b != 1 or c != 2):\n                                new_dp[i][j][k][b] = (new_dp[i][j][k][b] + dp[i][j][k][a]) % MOD\n        dp = new_dp\n    \n    # Sum up all valid strings of length N\n    result = sum(dp[0][0][0]) % MOD\n    print(result)\n\n# Read input from stdin and call the function\nN = int(input())\ncount_valid_strings(N)",
        "result": "failed: testcase 0"
    },
    "1842": {
        "body": "import math\n\n    discriminant = b**2 - 4*a*c\n    root1 = (-b + math.sqrt(discriminant)) / (2*a)\n    root2 = (-b - math.sqrt(discriminant)) / (2*a)\n    return max(root1, root2), min(root1, root2)\n\na, b, c = map(int, input().split())\noptimistic, pessimistic = solve_quadratic(a, b, c)\nprint(optimistic)\nprint(pessimistic)",
        "result": "failed: testcase 0"
    },
    "806": {
        "body": "    MOD = 10**9 + 7\n    total_sum = n * (l + r) // 2\n    if total_sum % 3 != 0:\n        return 0\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for num in range(l, r + 1):\n        new_dp = [0] * (n + 1)\n        for i in range(n - 1, -1, -1):\n            new_dp[i] += dp[i]\n            if i + num <= n:\n                new_dp[i + num] += dp[i]\n            new_dp[i] %= MOD\n        dp = new_dp\n    \n    return dp[0]\n\n# Read input from stdin\nn, l, r = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, l, r))",
        "result": "failed: testcase 0"
    },
    "365": {
        "body": "    total_length = sum(a)\n    if total_length != x:\n        return \"NO\"\n    \n    current_start = 0\n    for length in a:\n        if current_start + length > x:\n            return \"NO\"\n        current_start += length\n    \n    if current_start < x:\n        return \"NO\"\n    \n    return \"YES\"\n\n# Read input\nn, x = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print result\nprint(is_unique_crossword(n, x, a))",
        "result": "failed: testcase 0"
    },
    "1158": {
        "body": "import sys\n\n    max_dishes = n // k\n    utensil_count = [0] * 101\n    \n    for utensil in utensils:\n        utensil_count[utensil] += 1\n    \n    stolen_utensils = 0\n    \n    for count in utensil_count:\n        if count > max_dishes:\n            stolen_utensils += count - max_dishes\n    \n    return stolen_utensils\n\n# Read input from stdin\nn, k = map(int, input().split())\nutensils = list(map(int, input().split()))\n\n# Print the result\nprint(min_stolen_utensils(n, k, utensils))",
        "result": "failed: testcase 0"
    },
    "33": {
        "body": "    common_count = 0\n    for x in range(L, R + 1):\n        if (x - b1) % a1 == 0 and (x - b2) % a2 == 0:\n            common_count += 1\n    return common_count\n\n# Read input from stdin\na1, b1, a2, b2, L, R = map(int, input().split())\n\n# Print the result\nprint(count_common_integers(a1, b1, a2, b2, L, R))",
        "result": "failed: testcase 0"
    },
    "2498": {
        "body": "import math\n\n    semi_common_multiples = set()\n    \n    for a in A:\n        p = 1\n        while True:\n            X = a * (p + 0.5)\n            if X > M:\n                break\n            semi_common_multiples.add(int(X))\n            p += 1\n    \n    return len(semi_common_multiples)\n\n# Read input from stdin\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print the result\nprint(count_semi_common_multiples(N, M, A))",
        "result": "failed: testcase 0"
    },
    "2309": {
        "body": "    vowels = set(\"aeiou\")\n    return sum(1 for char in word if char in vowels)\n\n    for i in range(len(word) - 1, -1, -1):\n        if word[i] in \"aeiou\":\n            return i\n    return -1\n\n    from collections import defaultdict\n    word_count = defaultdict(int)\n    vowel_count_first_word = defaultdict(int)\n    vowel_count_second_word = defaultdict(int)\n    last_vowel_index = {}\n    \n    for word in words:\n        word_count[word] += 1\n        num_vowels = count_vowels(word)\n        vowel_count_first_word[num_vowels] += 1\n        last_vowel_index[word] = last_vowel(word)\n    \n    max_lyrics = []\n    used_words = [0] * len(words)\n    \n    for i in range(len(words)):\n        if used_words[i]:\n            continue\n        word = words[i]\n        num_vowels = count_vowels(word)\n        lvi = last_vowel_index[word]\n        \n        for j in range(i + 1, len(words)):\n            if used_words[j] or word_count[words[j]] <= 0:\n                continue\n            other_word = words[j]\n            other_num_vowels = count_vowels(other_word)\n            other_lvi = last_vowel_index[other_word]\n            \n            if num_vowels == other_num_vowels and lvi == other_lvi:\n                used_words[i] += 1\n                used_words[j] += 1\n                max_lyrics.append((word, other_word))\n                break\n    \n    return len(max_lyrics), max_lyrics\n\nn = int(input())\nwords = [input() for _ in range(n)]\nm, lyrics = max_beautiful_lyrics(words)\nprint(m)\nfor line in lyrics:\n    print(\" \".join(line))",
        "result": "failed: testcase 0"
    },
    "1326": {
        "body": "import math\n\n    total_sum = 0\n    for k in range(1, n + 1):\n        divisors_count = 0\n        for i in range(1, int(math.sqrt(k)) + 1):\n            if k % i == 0:\n                divisors_count += 2 if i != k // i else 1\n        total_sum += k * divisors_count\n    return total_sum\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(sum_of_divisor_products(n))",
        "result": "failed: testcase 0"
    },
    "2950": {
        "body": "    charges = 0\n    while max(h) > 0:\n        max_height = max(h)\n        for i in range(n):\n            if h[i] >= max_height:\n                h[i] -= max_height\n                if h[i] == 0:\n                    h[i] = 1\n        charges += 1\n    return charges\n\n# Read input\nn = int(input())\nh = list(map(int, input().split()))\n\n# Output the result\nprint(min_charges_to_tear_down_blocks(n, h))",
        "result": "failed: testcase 0"
    },
    "1983": {
        "body": "import sys\n\n    if not arr:\n        return 0\n    \n    dp = [1] * len(arr)\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] > arr[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        a = list(map(int, data[index:index + n]))\n        index += n\n        \n        original_lis_length = length_of_lis(a)\n        new_array_lis_length = original_lis_length * 2 - (a[-1] <= a[0])\n        \n        results.append(new_array_lis_length)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "1767": {
        "body": "    max_sum = 0\n    for l in range(n):\n        current_or_a = 0\n        current_or_b = 0\n        for r in range(l, n):\n            current_or_a |= a[r]\n            current_or_b |= b[r]\n            max_sum = max(max_sum, current_or_a + current_or_b)\n    return max_sum\n\n# Read input\nn = int(input())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(max_bitwise_or_sum(n, a, b))",
        "result": "failed: testcase 0"
    },
    "2382": {
        "body": "from collections import Counter\nimport sys\n\n    target = Counter(S)\n    slimes = [1]\n    \n    for _ in range(N):\n        new_slimes = []\n        for health in slimes:\n            for j in range(health // 2, 0, -1):\n                if health % j == 0 and target[j] > 0:\n                    new_slimes.append(j)\n                    target[j] -= 1\n                    break\n        slimes.extend(new_slimes)\n    \n    return len(slimes) == 2**N and all(v == 0 for v in target.values())\n\nif __name__ == \"__main__\":\n    N = int(input())\n    S = list(map(int, input().split()))\n    result = \"Yes\" if can_reproduce(N, S) else \"No\"\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3907": {
        "body": "import sys\n\n    # Sort coupons by cost in ascending order\n    coupons.sort(key=lambda x: x[1])\n    \n    # Initialize an array to keep track of the count of each number used\n    count = [0] * (max(coupon[0] for coupon in coupons) + 2)\n    \n    total_money = 0\n    \n    # Iterate through each coupon and add the necessary numbers to the array\n    for q, w in coupons:\n        if q <= n:\n            count[q] += 1\n            total_money += w\n    \n    return total_money\n\n# Read input from stdin\nn, m = map(int, input().split())\ncoupons = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Calculate and print the maximum amount of money Sereja can pay\nprint(max_money_to_dima(n, m, coupons))",
        "result": "failed: testcase 0"
    },
    "3676": {
        "body": "    if R <= 0 or C <= 0:\n        return 0\n    \n    dp = [[0 for _ in range(C + 1)] for _ in range(R + 1)]\n    \n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            dp[r][c] = dp[r - 1][c] + dp[r][c - 1]\n            if r > 1 and c > 1:\n                dp[r][c] += dp[r - 2][c - 2]\n    \n    return dp[R][C]\n\n# Read input\nR, C = map(int, input().split())\n\n# Output the result\nprint(count_polygons(R, C))",
        "result": "failed: testcase 0"
    },
    "3293": {
        "body": "    n = int(input())\n    snacks = []\n    \n    for _ in range(n):\n        f, p, m, s = map(int, input().split())\n        snacks.append((f-1, p, m, s))\n    \n    profit = 0\n    \n    for i in range(n):\n        if snacks[i][3] > 0:\n            max_price = 0\n            for j in range(i+1, n):\n                if snacks[j][0] == i and snacks[j][3] > 0 and snacks[j][2] > max_price:\n                    max_price = snacks[j][2]\n            \n            if max_price > snacks[i][1]:\n                profit += (max_price - snacks[i][1]) * snacks[i][3]\n    \n    print(profit)\n\nmax_profit()",
        "result": "failed: testcase 0"
    },
    "3587": {
        "body": "    if N == 1 and len(taboo_strings[0]) == 1:\n        return -1\n    \n    max_length = 2 ** 31 - 1\n    for i in range(max_length + 1):\n        binary_string = bin(i)[2:].zfill(32)\n        valid = True\n        for taboo in taboo_strings:\n            if taboo in binary_string:\n                valid = False\n                break\n        if valid and len(binary_string) > max_length:\n            max_length = len(binary_string)\n    \n    return bin(max_length)[2:]\n\nN = int(input())\ntaboo_strings = [input().strip() for _ in range(N)]\nprint(longest_clue(N, taboo_strings))",
        "result": "failed: testcase 0"
    },
    "3530": {
        "body": "import sys\n\n    n = int(input())\n    coasters = []\n    \n    for _ in range(n):\n        a, b, t = map(int, input().split())\n        coasters.append((a, b, t))\n    \n    q = int(input())\n    times = [int(input()) for _ in range(q)]\n    \n    results = []\n    for T in times:\n        total_fun = 0\n        used_time = 0\n        \n        for a, b, t in sorted(coasters, key=lambda x: -x[0]):\n            if used_time + t > T:\n                break\n            \n            max_rides = (T - used_time) // t\n            for k in range(1, max_rides + 1):\n                fun = a - (k - 1) ** 2 * b\n                if fun <= 0:\n                    break\n                total_fun += fun\n            used_time += t\n        \n        results.append(total_fun)\n    \n    for result in results:\n        print(result)\n\nmax_fun()",
        "result": "failed: testcase 0"
    },
    "3900": {
        "body": "import sys\n\n    suspects = set()\n    for x, y in opinions:\n        suspects.add(x)\n        suspects.add(y)\n    \n    m = len(suspects)\n    count = 0\n    \n    for i in range(m):\n        for j in range(i + 1, m):\n            if sum(1 for x, y in opinions if x in (i+1, j+1) or y in (i+1, j+1)) >= p:\n                count += 1\n                \n    return count\n\n# Read input\nn, p = map(int, input().split())\nopinions = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print the result\nprint(count_suspect_sets(n, p, opinions))",
        "result": "failed: testcase 0"
    },
    "3996": {
        "body": "import math\nfrom fractions import Fraction\n\n    MOD = 10**9 + 7\n    probability = Fraction(1, 1)\n    \n    for i in range(k):\n        probability *= Fraction(a[i], 2)\n        probability += Fraction(a[i] - 1, 2) * (probability - Fraction(1, 1))\n        probability %= MOD\n    \n    return f\"{probability.numerator % MOD}/{probability.denominator % MOD}\"\n\nif __name__ == \"__main__\":\n    k = int(input())\n    a = list(map(int, input().split()))\n    print(calculate_probability(k, a))",
        "result": "failed: testcase 0"
    },
    "3276": {
        "body": "import sys\n\n    for i in range(N - 2):\n        for j in range(M - 2):\n            if art[i][j] != 'W':\n                continue\n            stamp = [art[x][y] for x in range(i, i+3) for y in range(j, j+3)]\n            if len(set(stamp)) == 1:\n                continue\n            for color in 'RGB':\n                new_art = [list(row) for row in art]\n                for x in range(i, i+3):\n                    for y in range(j, j+3):\n                        new_art[x][y] = color\n                if all(new_art[x][y] != 'W' or new_art[x][y] == color for x in range(N) for y in range(M)):\n                    return \"YES\"\n    return \"NO\"\n\nif __name__ == \"__main__\":\n    N, M = map(int, input().split())\n    art = [input() for _ in range(N)]\n    print(can_reproduce_art(N, M, art))",
        "result": "failed: testcase 0"
    },
    "3834": {
        "body": "    changes = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 1:\n                count = 1\n                for x in range(i + 1, n):\n                    if table[x][j] != 1:\n                        break\n                    count += 1\n                for y in range(j + 1, m):\n                    if table[i][y] != 1 or (x > i and table[x][y] != table[x - 1][y]):\n                        break\n                    count += 1\n                area = count\n                if area < (i + 1) * (j + 1):\n                    changes += (i + 1) * (j + 1) - area\n    return changes if changes <= k else -1\n\n# Read input\nn, m, k = map(int, input().split())\ntable = [list(map(int, input().split())) for _ in range(n)]\n\n# Print output\nprint(min_changes_to_rectangle(n, m, k, table))",
        "result": "failed: testcase 0"
    },
    "3012": {
        "body": "MOD = 1000000007\n\n    if N == 0:\n        return 1\n    \n    dp = [[[0, 0] for _ in range(3)] for _ in range(3)]\n    dp[1][2][0] = a11\n    dp[2][1][0] = a21\n\n    for _ in range(N - 1):\n        new_dp = [[[0, 0] for _ in range(3)] for _ in range(3)]\n        \n        for i in range(1, 3):\n            for j in range(1, 3):\n                if dp[i][j][0]:\n                    new_dp[j][i][0] += dp[i][j][0]\n                    new_dp[j][i][1] += dp[i][j][1] * (a22 + a21)\n                    \n                    if dp[i][j][1] >= 3:\n                        for k in range(1, 3):\n                            if k != i and k != j:\n                                new_dp[k][j][0] += dp[i][j][1]\n                                new_dp[j][k][0] += dp[i][j][1]\n                    \n                    if a22 > 0:\n                        for k in range(1, 3):\n                            if k != i and k != j:\n                                new_dp[k][i][0] += dp[i][j][1]\n                                new_dp[i][k][0] += dp[i][j][1]\n                    \n                    if a21 > 0:\n                        for k in range(1, 3):\n                            if k != i and k != j:\n                                new_dp[j][k][0] += dp[i][j][1]\n                                new_dp[k][i][0] += dp[i][j][1]\n        \n        dp = new_dp\n    \n    result = 0\n    for i in range(1, 3):\n        for j in range(1, 3):\n            result += dp[i][j][0]\n    \n    return result % MOD\n\n# Read input from stdin\na11, a12, a21, a22, N = map(int, input().split())\n\n# Print the result\nprint(count_sequences(a11, a12, a21, a22, N))",
        "result": "failed: testcase 0"
    },
    "3745": {
        "body": "import sys\n\n    if n == 1:\n        return \"Yes\\na\"\n    \n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Check if the graph can be formed by a string of 'a', 'b', and 'c'\n        visited[node] = True\n        node_char = ord(char) - ord('a')\n        \n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if (ord(graph[node][0]) - ord('a') != node_char + 1 and \n                    ord(graph[node][0]) - ord('a') != node_char - 1):\n                    return False\n                if not dfs(neighbor, node, chr(node_char + 1)):\n                    return False\n            elif neighbor == parent:\n                continue\n            else:\n                return False\n        \n        return True\n    \n    visited = [False] * (n + 1)\n    if not dfs(1, -1, 'a'):\n        return \"No\"\n    \n    # Construct the string\n    result = [''] * n\n        node_char = ord(graph[node][0]) - ord('a')\n        for neighbor in graph[node]:\n            if neighbor != parent:\n                result[neighbor-1] = chr(node_char + 1)\n                build_string(neighbor, node)\n    \n    build_string(1, -1)\n    return \"Yes\\n\" + ''.join(result)\n\n# Read input\nn, m = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output result\nprint(can_form_string(n, m, edges))",
        "result": "failed: testcase 0"
    },
    "3028": {
        "body": "import sys\n\n    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                moves.append((i + 1) * m + (j + 1))\n                for k in range(n):\n                    board[k][j] = (board[k][j] % p) + 1\n                for k in range(m):\n                    board[i][k] = (board[i][k] % p) + 1\n    return len(moves), moves\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    p = int(data[2])\n    board = []\n    \n    index = 3\n    for i in range(n):\n        row = list(map(int, data[index:index + m]))\n        board.append(row)\n        index += m\n    \n    result = find_winning_sequence(n, m, p, board)\n    print(result[0])\n    if result[0] != -1:\n        print(' '.join(map(str, result[1])))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3196": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    for a, b in roads:\n        graph[a].append(b)\n    \n    queue = deque([(1, 1)])\n    visited = set()\n    routes = 0\n    \n    while queue:\n        current, count = queue.popleft()\n        if current == n:\n            routes += count\n        else:\n            for neighbor in graph[current]:\n                if (neighbor, count) not in visited:\n                    visited.add((neighbor, count))\n                    queue.append((neighbor, count + 1))\n    \n    return routes % 1000000009 if routes < float('inf') else 'inf'\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    result = count_routes(n, m, roads)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3405": {
        "body": "import sys\n\n    X_str = str(X)\n    X_int = int(X_str.split('.')[1])\n    results = []\n    \n    for i in range(1, 10**8):\n        num_str = str(i)\n        if len(num_str) > 8:\n            continue\n        moved_num = int(num_str[1:] + num_str[0])\n        if moved_num == i * X_int:\n            results.append(i)\n    \n    return sorted(results)\n\n    X = float(input())\n    results = find_numbers(X)\n    if not results:\n        print(\"No solution\")\n    else:\n        for result in results:\n            print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3126": {
        "body": "import sys\n\n    frogs.sort()\n    n = len(frogs)\n    min_jumps = float('inf')\n    \n    for i in range(n + 1):\n        left_frogs = frogs[:i]\n        right_frogs = frogs[i:]\n        \n        left_sum = sum(abs(p - tower_position) for p in left_frogs)\n        right_sum = sum(abs(p - tower_position) for p in right_frogs)\n        \n        total_jumps = (sum(range(1, i + 1)) if i > 0 else 0) + left_sum + right_sum\n        min_jumps = min(min_jumps, total_jumps)\n    \n    return min_jumps\n\n    input_lines = sys.stdin.readlines()\n    n, t = map(int, input_lines[0].split())\n    frogs = list(map(int, input_lines[1].split()))\n    C = int(input_lines[2])\n    changes = input_lines[3:C + 3]\n    \n    results = []\n    \n    for change in changes:\n        if change.startswith('+'):\n            a = int(change.split()[1])\n            frogs.append(a)\n        elif change.startswith('-'):\n            a = int(change.split()[1])\n            frogs.remove(a)\n        else:\n            t = int(change.split()[1])\n        \n        min_jumps = calculate_min_jumps(frogs, t)\n        results.append(min_jumps)\n    \n    for result in results:\n        print(result)\n\nprocess_changes()",
        "result": "failed: testcase 0"
    },
    "3279": {
        "body": "    # Initialize the grid with zeros\n    vertical_grid = [[0] * n for _ in range(n)]\n    horizontal_grid = [[0] * n for _ in range(n)]\n\n    # Function to check if a vertical bar can be placed at (i, j)\n        if i == 0 or i == n - 1:\n            return True\n        return vertical_grid[i-1][j] == 0 and vertical_grid[i+1][j] == 0\n\n    # Function to check if a horizontal bar can be placed at (i, j)\n        if j == 0 or j == n - 1:\n            return True\n        return horizontal_grid[i][j-1] == 0 and horizontal_grid[i][j+1] == 0\n\n    # Place vertical bars\n    for i in range(n):\n        start = 0\n        count = 0\n        while start < len(vertical_specifications[i]):\n            if vertical_specifications[i][start] == 0:\n                break\n            group_size = vertical_specifications[i][start]\n            for j in range(start, start + group_size):\n                if can_place_vertical(i, j):\n                    vertical_grid[i][j] = 1\n                else:\n                    return \"No solution\"\n            start += group_size\n\n    # Place horizontal bars\n    for j in range(n):\n        start = 0\n        count = 0\n        while start < len(horizontal_specifications[j]):\n            if horizontal_specifications[j][start] == 0:\n                break\n            group_size = horizontal_specifications[j][start]\n            for i in range(start, start + group_size):\n                if can_place_horizontal(i, j):\n                    horizontal_grid[i][j] = 1\n                else:\n                    return \"No solution\"\n            start += group_size\n\n    # Output the result\n    for row in vertical_grid:\n        print(''.join(map(str, row)))\n    for row in horizontal_grid:\n        print(''.join(map(str, row)))\n\n# Read input\nn = int(input())\nvertical_specifications = [list(map(int, input().split())) for _ in range(n)]\nhorizontal_specifications = [list(map(int, input().split())) for _ in range(n)]\n\n# Solve and output the result\nsolve_bar_code(n, vertical_specifications, horizontal_specifications)",
        "result": "failed: testcase 0"
    },
    "3599": {
        "body": "import sys\n\n    remaining_time = T\n    on_stage = [0] * N\n    \n    for i in range(N):\n        break_length = breaks[i]\n        if remaining_time >= break_length:\n            on_stage[i] = remaining_time - break_length\n            remaining_time -= break_length\n    \n    return on_stage\n\n# Read input from stdin\nT, N = map(int, input().split())\nbreaks = list(map(int, input().split()))\n\n# Get the result\nresult = schedule_breaks(T, N, breaks)\n\n# Print the result\nprint(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3687": {
        "body": "import sys\n\n    n, q, s = map(int, input().split())\n    sensor_queues = list(map(int, input().split()))\n    queue_sizes = list(map(int, input().split()))\n    \n    for _ in range(n):\n        d, *a = map(int, input().split())\n        total_transmitted = 0\n        for i in range(s):\n            if a[i] <= queue_sizes[sensor_queues[i]-1]:\n                queue_sizes[sensor_queues[i]-1] -= a[i]\n                total_transmitted += a[i]\n            else:\n                break\n        if total_transmitted != d:\n            print(\"impossible\")\n            return\n    if any(queue_sizes):\n        print(\"impossible\")\n    else:\n        print(\"possible\")\n\ncan_transfer_all_data()",
        "result": "failed: testcase 0"
    },
    "3864": {
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n    return (dp[n] * 2) % MOD\n\nn = int(input())\nfor s in range(1, n + 1):\n    print(expected_black_stones(n))",
        "result": "failed: testcase 0"
    },
    "3504": {
        "body": "    disintegrate_y = []\n    \n    for x, y in droplets:\n        hit_sensor = False\n        for x1, x2, y_s in sensors:\n            if x >= x1 and x <= x2 and y == y_s:\n                disintegrate_y.append(y_s)\n                hit_sensor = True\n                break\n        \n        if not hit_sensor:\n            disintegrate_y.append(0)\n    \n    return disintegrate_y\n\n# Read input from stdin\nD, S = map(int, input().split())\ndroplets = [tuple(map(int, input().split())) for _ in range(D)]\nsensors = [tuple(map(int, input().split())) for _ in range(S)]\n\n# Calculate and print the results\nresults = find_disintegration_y(droplets, sensors)\nfor result in results:\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3451": {
        "body": "import sys\n\n        stack = []\n        for char in current_seq:\n            if char == '(':\n                stack.append(char)\n            else:\n                if stack and stack[-1] == '(':\n                    stack.pop()\n                elif max_moves > 0:\n                    max_moves -= 1\n                else:\n                    return False\n        return len(stack) <= max_moves\n\n    min_effort = float('inf')\n    for i in range(n):\n        new_seq = seq[:i] + ')' + seq[i+1:]\n        if not can_balance(new_seq, k):\n            effort = sum(costs)\n            if effort < min_effort:\n                min_effort = effort\n    return min_effort if min_effort != float('inf') else '?'\n\nn, k = map(int, input().split())\nseq = input().strip()\ncosts = [int(input()) for _ in range(n)]\n\nresult = min_effort_to_impossible(n, k, seq, costs)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3156": {
        "body": "from collections import defaultdict, deque\n\n    store_inventory = [defaultdict(list) for _ in range(n)]\n    for i, item in stores:\n        store_inventory[i][item].append(i)\n\n    path_count = 0\n    visited = set()\n    \n        nonlocal path_count\n        if len(current_path) == m:\n            if path_count == 0:\n                path_count = 1\n            elif path_count > 1:\n                return\n            visited.add(tuple(current_path))\n            return\n        \n        for item in bought_items[len(current_path)]:\n            if store_inventory[current_store][item]:\n                next_store = store_inventory[current_store][item].pop()\n                dfs(next_store, current_path + [item])\n                store_inventory[current_store][item].append(next_store)\n    \n    for i in range(n):\n        dfs(i, [])\n    \n    if path_count == 0:\n        return \"impossible\"\n    elif len(visited) == 1:\n        return \"unique\"\n    else:\n        return \"ambiguous\"\n\n# Read input\nn = int(input())\nk = int(input())\nstores = [tuple(input().split()) for _ in range(k)]\nm = int(input())\nbought_items = [input() for _ in range(m)]\n\n# Output result\nprint(find_shopping_path(n, k, stores, m, bought_items))",
        "result": "failed: testcase 0"
    },
    "3697": {
        "body": "    votes = [0] * (n + 1)\n    last_vote_time = [-1] * (n + 1)\n    \n    for j in range(a):\n        candidate = int(input())\n        votes[candidate] += 1\n        if last_vote_time[candidate] < j:\n            last_vote_time[candidate] = j\n    \n    top_candidates = sorted(range(1, n + 1), key=lambda x: (-votes[x], -last_vote_time[x]))\n    \n    result = [0] * (n + 1)\n    guaranteed = top_candidates[:k]\n    chance = []\n    no_chance = []\n    \n    for candidate in range(1, n + 1):\n        if candidate in guaranteed:\n            result[candidate] = 1\n        elif candidate in top_candidates and len(guaranteed) + len(chance) < k:\n            chance.append(candidate)\n            result[candidate] = 2\n        else:\n            no_chance.append(candidate)\n            result[candidate] = 3\n    \n    return result[1:]\n\n# Read input from stdin\nn, k, m, a = map(int, input().split())\nfor _ in range(a):\n    int(input())\n\n# Print the results\nfor outcome in election_outcomes(n, k, m, a):\n    print(outcome)",
        "result": "failed: testcase 0"
    },
    "3647": {
        "body": "import sys\nfrom collections import deque\n\n    rows, cols = len(maze), len(maze[0])\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    moves_needed = [[-1] * cols for _ in range(rows)]\n    \n    goal_pos = None\n    for r in range(rows):\n        for c in range(cols):\n            if maze[r][c] == 'M':\n                goal_pos = (r, c)\n                break\n    \n    queue = deque([goal_pos])\n    moves_needed[goal_pos[0]][goal_pos[1]] = 0\n    \n    while queue:\n        r, c = queue.popleft()\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < rows and 0 <= nc < cols and moves_needed[nr][nc] == -1:\n                if maze[nr][nc] == '#':\n                    continue\n                elif maze[nr][nc] == '.':\n                    queue.append((nr, nc))\n                    moves_needed[nr][nc] = moves_needed[r][c]\n                else:  # maze[nr][nc] == '_'\n                    while 0 <= nr + dr < rows and 0 <= nc + dc < cols and maze[nr + dr][nc + dc] != '#':\n                        nr += dr\n                        nc += dc\n                        if moves_needed[nr][nc] != -1:\n                            break\n                    queue.append((nr, nc))\n                    moves_needed[nr][nc] = moves_needed[r][c] + 1\n    \n    return moves_needed\n\n    input = sys.stdin.read\n    data = input().splitlines()\n    \n    C = int(data[0].split()[1])\n    R = int(data[0].split()[0])\n    maze = data[1:]\n    \n    result = min_moves_to_goal(maze)\n    for row in result:\n        print(\" \".join(map(str, row)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3699": {
        "body": "import math\nimport sys\n\n    n = len(bottles)\n    \n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    \n    min_distance = float('inf')\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            adil_path = distance((ax, ay), bottles[i]) + distance(bottles[i], (tx, ty)) + distance((tx, ty), bottles[j]) + distance(bottles[j], (bx, by))\n            bera_path = distance((bx, by), bottles[j]) + distance(bottles[j], (tx, ty)) + distance((tx, ty), bottles[i]) + distance(bottles[i], (ax, ay))\n            total_distance = adil_path + bera_path\n            if total_distance < min_distance:\n                min_distance = total_distance\n    \n    return min_distance\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    ax, ay = int(data[0]), int(data[1])\n    bx, by = int(data[2]), int(data[3])\n    tx, ty = int(data[4]), int(data[5])\n    n = int(data[6])\n    \n    bottles = []\n    for i in range(n):\n        x, y = int(data[7 + 2 * i]), int(data[8 + 2 * i])\n        bottles.append((x, y))\n    \n    result = calculate_min_distance(ax, ay, bx, by, tx, ty, bottles)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3145": {
        "body": "import sys\n\n    count = 0\n    for num in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(num)) and num % X == 0:\n            count += 1\n    return count\n\n# Read input from stdin\nX, A, B = map(int, input().split())\nallowed_digits = set(input().strip())\n\n# Output the result\nprint(count_multiples(X, A, B, allowed_digits))",
        "result": "failed: testcase 0"
    },
    "3795": {
        "body": "    min_rubles = n\n    for euro in range(0, n // e + 1):\n        remaining_rubles = n - euro * e\n        dollars = remaining_rubles // d\n        total_bills = euro + dollars\n        if total_bills < min_rubles:\n            min_rubles = total_bills\n    return n - min_rubles\n\nn = int(input())\nd = int(input())\ne = int(input())\n\nprint(min_rubles(n, d, e))",
        "result": "failed: testcase 0"
    },
    "3353": {
        "body": "import sys\n\n    left_bank = [-2]\n    right_bank = [-1]\n    boulders = list(range(0, R))\n    \n    # Create adjacency list for logs\n    adj_list = [[] for _ in range(R + 2)]\n    for e1, e2 in logs:\n        adj_list[e1].append(e2)\n        adj_list[e2].append(e1)\n    \n        if node == -1:\n            return True\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n    \n    # Check if all people can cross\n        visited = [False] * (R + 2)\n        return dfs(-2, visited)\n    \n    if not can_cross_all():\n        n_left_behind = P - sum(1 for i in range(R) if adj_list[i])\n        print(n_left_behind)\n        sys.exit()\n    \n    # Calculate minimum time to cross\n    time_to_cross = 0\n    visited = [False] * (R + 2)\n    \n    while P > 0:\n        # Sally crosses from left bank to boulder\n        for boulder in boulders:\n            if not visited[boulder]:\n                visited[boulder] = True\n                P -= 1\n                time_to_cross += 1\n                break\n        \n        # People cross from one boulder to another\n        new_visited = visited[:]\n        for i in range(R + 2):\n            if visited[i]:\n                for neighbor in adj_list[i]:\n                    if not new_visited[neighbor]:\n                        new_visited[neighbor] = True\n                        P -= 1\n                        time_to_cross += 1\n                        break\n        \n        # Update visited array\n        visited = new_visited\n    \n    print(time_to_cross)\n\n# Read input\nP, R, L = map(int, input().split())\nlogs = [tuple(map(int, input().split())) for _ in range(L)]\n\nmin_time_to_cross(P, R, L, logs)",
        "result": "failed: testcase 0"
    },
    "3065": {
        "body": "import sys\nfrom collections import deque, defaultdict\n\n    start = walk[0]\n    end = walk[-1]\n    total_paths = 0\n    valid_paths = 0\n    \n    queue = deque([(start, [start])])\n    \n    while queue:\n        node, path = queue.popleft()\n        if len(path) == L:\n            total_paths += 1\n            if node != end or (node == end and len(set(path)) < L):\n                valid_paths += 1\n            continue\n        \n        for neighbor in graph[node]:\n            if neighbor not in path:\n                queue.append((neighbor, path + [neighbor]))\n    \n    probability = valid_paths / total_paths if total_paths > 0 else 0\n    return probability\n\n    N = int(input().strip())\n    L = int(input().strip())\n    walk = list(map(int, input().strip().split()))\n    \n    graph = defaultdict(list)\n    for i in range(N):\n        n_i = int(input().strip())\n        neighbors = list(map(int, input().strip().split()))\n        for neighbor in neighbors:\n            graph[i].append(neighbor)\n    \n    probability = bfs_probability(N, L, walk, graph)\n    print(f\"{probability:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3250": {
        "body": "import math\n\n    for m in range(1, b):\n        if all((pow(b, k, d) - pow(b, k-m, d)) % d == 0 for k in range(m, b)):\n            return \"yes\"\n    return \"no\"\n\n# Read input\nb, d = map(int, input().split())\n\n# Output the result\nprint(is_valid_divisibility_hack(b, d))",
        "result": "failed: testcase 0"
    },
    "3306": {
        "body": "import sys\n\n    N, M = map(int, input().split())\n    detectors = []\n    \n    for _ in range(N):\n        P_i, C_i = map(int, input().split())\n        detectors.append((P_i, C_i))\n    \n    detectors.sort()\n    \n    min_calls = float('inf')\n    current_calls = 0\n    i = 0\n    \n    for j in range(M - 1):\n        while i < N and detectors[i][0] <= j:\n            current_calls += detectors[i][1]\n            i += 1\n        \n        if i == 0 or (i > 0 and detectors[i-1][0] != j):\n            min_calls = min(min_calls, current_calls)\n    \n    print(min_calls)\n\nmin_phone_calls()",
        "result": "failed: testcase 0"
    },
    "3970": {
        "body": "    a.sort()\n    max_size = 0\n    for i in range(n):\n        count = 1\n        for j in range(i+1, n):\n            if a[j] % a[i] != 0:\n                count += 1\n            else:\n                break\n        max_size = max(max_size, count)\n    return max_size\n\n# Read input from stdin\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the result\nprint(largest_k_multiple_free_subset(n, k, a))",
        "result": "failed: testcase 0"
    },
    "3655": {
        "body": "    max_matches = 0\n    candidates = []\n\n    for y in range(floor_h - robot_h + 1):\n        for x in range(floor_w - robot_w + 1):\n            matches = 0\n            for i in range(robot_h):\n                for j in range(robot_w):\n                    if robot_img[i][j] == floor_img[y+i][x+j]:\n                        matches += 1\n            if matches > max_matches:\n                max_matches = matches\n                candidates = [(x, y)]\n            elif matches == max_matches:\n                candidates.append((x, y))\n\n    candidates.sort()\n    for candidate in candidates:\n        print(f\"{candidate[0]} {candidate[1]}\")\n\n# Read input\nrobot_w, robot_h = map(int, input().split())\nrobot_img = [list(map(int, input().split())) for _ in range(robot_h)]\nfloor_w, floor_h = map(int, input().split())\nfloor_img = [list(map(int, input().split())) for _ in range(floor_h)]\n\n# Find and print candidates\nfind_candidates(robot_w, robot_h, robot_img, floor_w, floor_h, floor_img)",
        "result": "failed: testcase 0"
    },
    "3589": {
        "body": "import sys\n\n    while n >= 10:\n        product = 1\n        while n > 0:\n            digit = n % 10\n            if digit != 0:\n                product *= digit\n            n //= 10\n        n = product\n    return n\n\n    count = [0] * 10\n    for x in range(L, R + 1):\n        dp = digit_product(x)\n        if 1 <= dp <= 9:\n            count[dp] += 1\n    return count\n\nif __name__ == \"__main__\":\n    L, R = map(int, input().split())\n    result = count_digit_products(L, R)\n    print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3257": {
        "body": "import math\n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1.0\n    s = (a + b + c) / 2\n    area = math.sqrt(s * (s - a) * (s - b) * (s - c))\n    return area\n\n    input_data = input().split()\n    a, b, c = map(float, input_data)\n    result = calculate_area(a, b, c)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3927": {
        "body": "    weights.sort()\n    target_mass = sum(weights) // 2\n    count = 0\n    for i in range(n):\n        if weights[i] <= target_mass:\n            count += 1\n    return count\n\n# Read input from stdin\nn = int(input())\nweights = list(map(int, input().split()))\n\n# Print the result\nprint(max_weights_revealed(n, weights))",
        "result": "failed: testcase 0"
    },
    "3319": {
        "body": "import sys\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    n, nx, ny, nz = int(data[index]), int(data[index+1]), int(data[index+2]), int(data[index+3])\n    index += 4\n    \n    planetoids = []\n    for _ in range(n):\n        m, x, y, z, vx, vy, vz = map(int, data[index:index+7])\n        planetoids.append((m, x, y, z, vx, vy, vz))\n        index += 7\n    \n    while True:\n        collisions = {}\n        for i in range(n):\n            for j in range(i+1, n):\n                px1, py1, pz1, vx1, vy1, vz1 = planetoids[i]\n                px2, py2, pz2, vx2, vy2, vz2 = planetoids[j]\n                \n                # Calculate future positions\n                fx1, fy1, fz1 = (px1 + int(vx1 * t) % nx, py1 + int(vy1 * t) % ny, pz1 + int(vz1 * t) % nz for t in range(1, 2))\n                fx2, fy2, fz2 = (px2 + int(vx2 * t) % nx, py2 + int(vy2 * t) % ny, pz2 + int(vz2 * t) % nz for t in range(1, 2))\n                \n                if fx1 == fx2 and fy1 == fy2 and fz1 == fz2:\n                    key = tuple(sorted([i, j]))\n                    if key not in collisions:\n                        collisions[key] = []\n                    collisions[key].append((planetoids[i], planetoids[j]))\n        \n        if not collisions:\n            break\n        \n        new_planetoids = []\n        for (i, j), pair in collisions.items():\n            m1, x1, y1, z1, vx1, vy1, vz1 = pair[0]\n            m2, x2, y2, z2, vx2, vy2, vz2 = pair[1]\n            new_m = m1 + m2\n            new_vx = (vx1 + vx2) // 2\n            new_vy = (vy1 + vy2) // 2\n            new_vz = (vz1 + vz2) // 2\n            new_planetoids.append((new_m, x1, y1, z1, new_vx, new_vy, new_vz))\n        \n        planetoids = new_planetoids\n    \n    planetoids.sort(key=lambda x: (-x[0], x[1], x[2]))\n    \n    print(len(planetoids))\n    for i, (m, x, y, z, vx, vy, vz) in enumerate(planetoids):\n        print(f\"P{i}: {m} {x} {y} {z} {vx} {vy} {vz}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3009": {
        "body": "from typing import List, Tuple\nimport math\n\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    positive_lamps = [lamp for lamp in lamps if lamp[2] > 0]\n    negative_lamps = [lamp for lamp in lamps if lamp[2] < 0]\n\n    min_length = float('inf')\n    for i in range(len(positive_lamps)):\n        for j in range(len(negative_lamps)):\n            p1, e1 = positive_lamps[i]\n            p2, e2 = negative_lamps[j]\n            length = calculate_distance(p1, p2)\n            if length < min_length:\n                min_length = length\n\n    return min_length if min_length != float('inf') else \"IMPOSSIBLE\"\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    lamps = []\n    for _ in range(n):\n        x, y, e = map(int, input().strip().split())\n        lamps.append((x, y, e))\n    \n    result = find_shortest_dividing_line(lamps)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3896": {
        "body": "    n = len(x)\n    count_0, count_1 = 0, 0\n    complexity = 0\n    \n    for i in range(n):\n        if x[i] == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n    \n    mod = 10**9 + 7\n    \n    for i in range(count_0):\n        complexity = (complexity + count_1 * (count_1 - 1) // 2) % mod\n    \n    return complexity\n\n# Read input\nx = input().strip()\n\n# Calculate and print the result\nprint(calculate_complexity(x))",
        "result": "failed: testcase 0"
    },
    "3509": {
        "body": "import heapq\n\n    INF = float('inf')\n    \n    # Build adjacency list\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v, t in roads:\n        adj_list[u].append((v, t))\n    \n    # Initialize distances from Richard's house to all other intersections\n    dist_to_janet = [INF] * (n + 1)\n    dist_to_janet[1] = 0\n    \n    # Dijkstra's algorithm to find the shortest path from Richard's house to Janet's house\n    pq = [(0, 1)]\n    while pq:\n        current_dist, u = heapq.heappop(pq)\n        if current_dist > dist_to_janet[u]:\n            continue\n        for v, t in adj_list[u]:\n            new_dist = current_dist + t\n            if new_dist < dist_to_janet[v]:\n                dist_to_janet[v] = new_dist\n                heapq.heappush(pq, (new_dist, v))\n    \n    # Calculate the worst case waiting time\n    max_wait_time = 0\n    for t in range(a, b + 1):\n        if dist_to_janet[n] - t < 0:\n            max_wait_time = max(max_wait_time, t)\n    \n    return max_wait_time\n\n# Read input from stdin\na, b = map(int, input().split())\nn, m = map(int, input().split())\nroads = [tuple(map(int, input().split())) for _ in range(m)]\n\n# Output the result\nprint(min_worst_case_waiting_time(a, b, n, m, roads))",
        "result": "failed: testcase 0"
    },
    "3547": {
        "body": "import sys\n\n    n = int(input())\n    plots = []\n    \n    for _ in range(n):\n        x1, y1, x2, y2 = map(float, input().split())\n        plots.append((x1, y1, x2, y2))\n    \n    total_area = 0.0\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            x1_i, y1_i, x2_i, y2_i = plots[i]\n            x1_j, y1_j, x2_j, y2_j = plots[j]\n            \n            if x2_i <= x1_j or y2_i <= y1_j:\n                continue  # No overlap\n            \n            overlap_x1 = max(x1_i, x1_j)\n            overlap_y1 = max(y1_i, y1_j)\n            overlap_x2 = min(x2_i, x2_j)\n            overlap_y2 = min(y2_i, y2_j)\n            \n            overlap_area = (overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1)\n            total_area += overlap_area\n    \n    print(f\"{total_area:.2f}\")\n\ncalculate_area_of_land()",
        "result": "failed: testcase 0"
    },
    "3017": {
        "body": "import sys\n\n    power_of_2 = str(2 ** e)\n    count = 0\n    \n    for i in range(n + 1):\n        if power_of_2 in str(i):\n            count += 1\n            \n    return count\n\nif __name__ == \"__main__\":\n    n, e = map(int, input().split())\n    result = count_numbers_with_power_of_2(n, e)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3076": {
        "body": "import sys\n\n    dp = [[0] * (k + 1) for _ in range(k + 1)]\n    \n    for i in range(1, n + 1):\n        s, v = jewels[i - 1]\n        for j in range(1, k + 1):\n            if j >= s:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - s] + v)\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    result = [dp[n][j] for j in range(1, k + 1)]\n    return result\n\n    n, k = map(int, input().split())\n    jewels = []\n    for _ in range(n):\n        s, v = map(int, input().split())\n        jewels.append((s, v))\n    \n    result = max_jewel_values(n, k, jewels)\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3923": {
        "body": "import sys\n\n    if N < max(A, B):\n        return -1\n    \n    perm = [0] * (N + 1)\n    used = [False] * (N + 1)\n    \n    for i in range(1, N + 1):\n        if i <= A:\n            target = A\n        elif i <= B:\n            target = B\n        else:\n            return -1\n        \n        for j in range(N, 0, -1):\n            if not used[j] and f(j, target) == i:\n                perm[i] = j\n                used[j] = True\n                break\n    \n    return [perm[i] for i in range(1, N + 1)]\n\n    if j == 1:\n        return i\n    else:\n        return f(i, j - 1)\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = int(data[1])\n    B = int(data[2])\n    \n    result = generate_permutation(N, A, B)\n    \n    if result == -1:\n        print(-1)\n    else:\n        print(\" \".join(map(str, result)))",
        "result": "failed: testcase 0"
    },
    "3332": {
        "body": "import sys\n\n    # Sort streams by start time\n    streams.sort(key=lambda x: x[0])\n    \n    stack = []\n    current_time = 0\n    max_priority_sum = 0\n    \n    for s, d, p in streams:\n        # Process completed streams\n        while stack and stack[-1][2] < s:\n            _, end_time, _ = stack.pop()\n            if end_time <= current_time:\n                current_time += end_time - current_time\n        \n        # Push new stream onto the stack\n        stack.append((s + d, s + d, p))\n        max_priority_sum += p\n    \n    return max_priority_sum\n\n# Read input\nn = int(input().strip())\nstreams = []\nfor _ in range(n):\n    s, d, p = map(int, input().strip().split())\n    streams.append((s, d, p))\n\n# Output the result\nprint(max_priority(n, streams))",
        "result": "failed: testcase 0"
    },
    "3240": {
        "body": "import sys\n\n    max_expectation = -1\n    optimal_vote = 0\n    \n    for vote in range(2**k):\n        expectation = 0\n        \n        for i in range(v-1):\n            probability = p_b[i][0]\n            if probability >= 0.5:\n                expectation += (vote & p_b[i][1] == 0) * probability\n        \n        expectation += (1 - sum(p_b[j][0] for j in range(v-1))) * ((vote & int('1' * k, 2)) != 0)\n        \n        if expectation > max_expectation:\n            max_expectation = expectation\n            optimal_vote = vote\n    \n    return optimal_vote\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    k, v = map(int, input_data[0].split())\n    p_b = [(float(p), int(b)) for p, b in (line.split() for line in input_data[1:])]\n\n    result = optimal_ballots(k, v, p_b)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3368": {
        "body": "from collections import defaultdict\n\n    target_counts = defaultdict(int)\n    current_counts = defaultdict(int)\n    \n    for i in range(n):\n        animal_type, count, *animals = input().split()\n        target_counts[animal_type] += int(count)\n        current_counts[animal_type] += len(animals)\n    \n    for animal_type in target_counts:\n        if target_counts[animal_type] != current_counts[animal_type]:\n            return \"IMPOSSIBLE\"\n    \n    return \"FALSE ALARM\" if all(count == 0 for count in current_counts.values()) else \"POSSIBLE\"\n\n# Read input\nn, m = map(int, input().split())\n\n# Call the function and print the result\nprint(can_restore_animals(n, m, range(n)))",
        "result": "failed: testcase 0"
    },
    "3538": {
        "body": "    frogs.sort(key=lambda x: (-x[0], x[1]))\n    piles = []\n    for l, w, h in frogs:\n        added = False\n        for pile in piles:\n            if sum(f[1] for f in pile) + w <= l:\n                pile.append((l, w, h))\n                added = True\n                break\n        if not added:\n            piles.append([(l, w, h)])\n    return sum(1 for pile in piles if pile[-1][0] > d)\n\n# Read input\nn, d = map(int, input().split())\nfrogs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Print result\nprint(max_frogs_to_escape(n, d, frogs))",
        "result": "failed: testcase 0"
    },
    "3183": {
        "body": "import heapq\n\n    graph = [[] for _ in range(n)]\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n    \n        dist = [float('inf')] * n\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, c, w in graph[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n    \n        flow = 0\n        cost = 0\n        while True:\n            dist = dijkstra()\n            if dist[t] == float('inf'):\n                break\n            f = min(c for _, c, _ in graph[s])\n            for u in range(n):\n                for v, c, w in graph[u]:\n                    if dist[v] > dist[u] + w and c > 0:\n                        flow += min(f, c)\n                        cost += min(f, c) * (dist[v] - dist[u])\n                        for u2, c2, w2 in graph[v]:\n                            if u2 == u and c2 > 0:\n                                graph[v].remove((u2, c2, w2))\n                                graph[v].append((u2, max(0, c2 - min(f, c)), w2))\n                                break\n                        break\n        return flow, cost\n    \n    return path_flow()\n\nn, m, s, t = map(int, input().split())\nedges = [tuple(map(int, input().split())) for _ in range(m)]\nprint(min_cost_flow(n, m, s, t, edges))",
        "result": "failed: testcase 0"
    },
    "3916": {
        "body": "import math\n\n    if x % 2 == 0:\n        return 2\n    for i in range(3, int(math.sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return i\n    return x\n\n    graph = {}\n    visited = set()\n    \n        if node in visited:\n            return\n        visited.add(node)\n        for next_node in [node // find_lowest_prime_divisor(node)]:\n            if next_node not in graph:\n                graph[next_node] = []\n            graph[next_node].append(node)\n            dfs(next_node)\n    \n    max_node = max(math.factorial(k) for k in k_values)\n    dfs(max_node)\n    \n    distances = {node: float('inf') for node in range(1, max_node + 1)}\n    distances[1] = 0\n    \n    queue = [1]\n    while queue:\n        current_node = queue.pop(0)\n        for neighbor in graph.get(current_node, []):\n            if distances[current_node] + 1 < distances[neighbor]:\n                distances[neighbor] = distances[current_node] + 1\n                queue.append(neighbor)\n    \n    min_path_sum = sum(distances[k_i!] for k_i in k_values)\n    return min_path_sum\n\n# Read input\nn = int(input())\nk_values = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(calculate_min_path_sum(n, k_values))",
        "result": "failed: testcase 0"
    },
    "3195": {
        "body": "import sys\n\n    total_period = T_g + T_y + T_r\n    count_color = [0] * 3\n    \n    for t, c in observations:\n        if (t - T_q) % total_period == 0:\n            index = {'green': 0, 'yellow': 1, 'red': 2}[c]\n            count_color[index] += 1\n    \n    if c_q == 'green':\n        probability = count_color[0] / n\n    elif c_q == 'yellow':\n        probability = count_color[1] / n\n    else:\n        probability = count_color[2] / n\n    \n    return probability\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    T_g = int(data[0])\n    T_y = int(data[1])\n    T_r = int(data[2])\n    n = int(data[3 + 2 * n])\n    \n    observations = []\n    index = 3 + 2 * n + 1\n    for _ in range(n):\n        t = int(data[index])\n        c = data[index + 1]\n        observations.append((t, c))\n        index += 2\n    \n    t_q = int(data[index])\n    c_q = data[index + 1]\n    \n    result = calculate_probability(T_g, T_y, T_r, n, observations, t_q, c_q)\n    print(f\"{result:.3f}\")",
        "result": "failed: testcase 0"
    },
    "3998": {
        "body": "import sys\n\n    n = len(ratings)\n    max_rating = 0\n    \n    for rating in ratings:\n        if rating > max_rating:\n            max_rating = rating\n    \n    t = (n * max_rating - sum(ratings)) // (max_rating - 1) + (n * max_rating - sum(ratings)) % (max_rating - 1)\n    \n    matches = []\n    remaining_ratings = [max_rating] * n\n    for _ in range(t):\n        current_match = []\n        for i in range(n):\n            if remaining_ratings[i] > max_rating:\n                continue\n            current_match.append(1)\n            remaining_ratings[i] += 1\n        matches.append(current_match)\n    \n    return max_rating, len(matches), matches\n\nif __name__ == \"__main__\":\n    n = int(input())\n    ratings = list(map(int, input().split()))\n    \n    final_rating, num_matches, match_details = maximize_rating(ratings)\n    \n    print(final_rating)\n    print(num_matches)\n    for match in match_details:\n        print(''.join(map(str, match)))",
        "result": "failed: testcase 0"
    },
    "3150": {
        "body": "        while b:\n            a, b = b, a % b\n        return a\n\n        return a * b // gcd(a, b)\n\n        x1, y1 = p1\n        x2, y2 = p2\n        x3, y3 = p3\n        return (y2 - y1) * (x3 - x1) == (y3 - y1) * (x2 - x1)\n\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if on_line(trenches[i], trenches[j]):\n                continue\n            for k in range(j + 1, n):\n                if on_line(trenches[i], trenches[k]) or on_line(trenches[j], trenches[k]):\n                    continue\n                ways += 1\n\n    return ways\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    trenches = [(int(data[i * 4 + 1]), int(data[i * 4 + 2]), int(data[i * 4 + 3]), int(data[i * 4 + 4])) for i in range(n)]\n    \n    result = count_ways_to_place_guards(n, trenches)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3566": {
        "body": "import sys\nfrom collections import deque\n\n    for _ in range(q):\n        i, x = map(int, input().split())\n        huts[i] = x\n        \n        left_sum = sum(huts[:i])\n        right_sum = sum(huts[i+1:])\n        \n        diff = abs(left_sum - right_sum)\n        min_diff = float('inf')\n        optimal_pos = -1\n        \n        for j in range(n):\n            new_left_sum = left_sum + huts[j] - huts[i]\n            new_right_sum = right_sum - huts[j]\n            new_diff = abs(new_left_sum - new_right_sum)\n            \n            if new_diff < min_diff:\n                min_diff = new_diff\n                optimal_pos = j\n        \n        print(optimal_pos)\n\n# Read input\nn, q = map(int, input().split())\nhuts = list(map(int, input().split()))\n\noptimal_food_truck_position(n, q, huts)",
        "result": "failed: testcase 0"
    },
    "3401": {
        "body": "import sys\nfrom collections import defaultdict, deque\n\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n        \n        return dist\n\n    graph = defaultdict(list)\n    \n    for i in range(n):\n        x1, y1, h1 = hills[i]\n        for j in range(i + 1, n):\n            x2, y2, h2 = hills[j]\n            dist = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n            if abs(h1 - h2) <= q and dist <= q:\n                graph[i + 1].append((j + 1, abs(h1 - h2)))\n                graph[j + 1].append((i + 1, abs(h1 - h2)))\n\n    min_length = float('inf')\n    \n    for spring in spring_hills:\n        for town in town_hills:\n            if spring == town:\n                continue\n            dist_spring = dijkstra(spring)\n            dist_town = dijkstra(town)\n            if dist_spring[town] != float('inf') and dist_town[spring] != float('inf'):\n                min_length = min(min_length, dist_spring[town] + dist_town[spring])\n    \n    return \"IMPOSSIBLE\" if min_length == float('inf') else f\"{min_length:.6f}\"\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    s = int(data[1])\n    t = int(data[2])\n    q = int(data[3])\n    \n    hills = []\n    for i in range(n):\n        x = int(data[4 + 3 * i])\n        y = int(data[5 + 3 * i])\n        h = int(data[6 + 3 * i])\n        hills.append((x, y, h))\n    \n    spring_hills = [int(data[4 + 3 * n + i]) for i in range(s)]\n    town_hills = [int(data[4 + 3 * n + s + i]) for i in range(t)]\n    \n    result = find_min_aqueduct_length(n, s, t, q, hills, spring_hills, town_hills)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3660": {
        "body": "    message = input().strip()\n    n = int(input())\n    stickers = []\n    \n    for _ in range(n):\n        word, price = input().strip().split()\n        stickers.append((word, int(price)))\n    \n    stickers.sort(key=lambda x: len(x[0]), reverse=True)\n    dp = [[float('inf')] * (len(message) + 1) for _ in range(len(message) + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, len(message) + 1):\n        for j in range(i + 1):\n            if dp[i - j][j] != float('inf'):\n                for word, price in stickers:\n                    if message[j - 1:i - 1] == word and j - 1 >= j - 2:\n                        dp[i][j] = min(dp[i][j], dp[i - j][j] + price)\n    \n    if dp[len(message)][0] != float('inf'):\n        print(dp[len(message)][0])\n    else:\n        print(\"IMPOSSIBLE\")\n\nmin_cost_message()",
        "result": "failed: testcase 0"
    },
    "3721": {
        "body": "import sys\n\n    required = set((r, c) for r in range(1, n+1) for c in range(1, m+1))\n    available = set(elements)\n    \n        for r2 in range(1, n+1):\n            if r2 == r:\n                continue\n            if (r2, c) not in available:\n                return False\n        for c2 in range(1, m+1):\n            if c2 == c:\n                continue\n            if (r, c2) not in available:\n                return False\n        return True\n    \n    purchase_count = 0\n    \n    while len(available) < n * m:\n        purchased = False\n        for r in range(1, n+1):\n            for c in range(1, m+1):\n                if (r, c) not in available and can_produce_element(r, c):\n                    available.add((r, c))\n                    purchase_count += 1\n                    purchased = True\n            if purchased:\n                break\n    \n    return purchase_count\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    q = int(data[2])\n    elements = [(int(data[3 + 2*i]), int(data[4 + 2*i])) for i in range(q)]\n    \n    result = min_elements_to_purchase(n, m, q, elements)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3811": {
        "body": "    while b != 0:\n        a, b = b, a % b\n    return a\n\n    if n == 0:\n        return -1\n    \n    current_gcd = pairs[0][0] * pairs[0][1]\n    \n    for i in range(1, n):\n        a, b = pairs[i]\n        pair_gcd = gcd(a, b)\n        if pair_gcd <= 1:\n            return -1\n        current_gcd = gcd(current_gcd, pair_gcd)\n        \n    return current_gcd\n\n# Read input\nn = int(input())\npairs = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the WCD\nwcd = find_wcd(n, pairs)\nprint(wcd)",
        "result": "failed: testcase 0"
    },
    "3528": {
        "body": "import sys\nfrom typing import List, Tuple\n\n    x_coords = sorted([nail[0] for nail in nails])\n    y_coords = sorted([nail[1] for nail in nails])\n    return (x_coords[-1] - x_coords[0]) * (y_coords[-1] - y_coords[0])\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    nails = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    pick_order = [data[N*2+i] for i in range(N-2)]\n    \n    areas = []\n    while len(nails) > 2:\n        area = calculate_area(nails)\n        areas.append(area)\n        \n        if pick_order.pop(0) == 'L':\n            nails.remove(min(nails, key=lambda x: x[0]))\n        elif pick_order.pop(0) == 'R':\n            nails.remove(max(nails, key=lambda x: x[0]))\n        elif pick_order.pop(0) == 'U':\n            nails.remove(max(nails, key=lambda x: x[1]))\n        else:\n            nails.remove(min(nails, key=lambda x: x[1]))\n    \n    for area in areas:\n        print(f\"{area:.1f}\")\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3890": {
        "body": "    MOD = 10**9 + 7\n    if n == 1:\n        return 1\n    \n    # Initialize the dp array with zeros\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    \n    for i in range(2, k + 1):\n        dp[i] = (i - 1) * (dp[i - 1] + sum(dp[j] for j in range(i - 1)) % MOD) % MOD\n    \n    for i in range(k + 1, n + 1):\n        dp[i] = (i - k - 1) * (dp[i - 1] + sum(dp[j] for j in range(k, i - 1)) % MOD) % MOD\n    \n    return dp[n]\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result modulo 10^9 + 7\nprint(count_ways(n, k))",
        "result": "failed: testcase 0"
    },
    "3534": {
        "body": "import sys\n\n    max_correct = 0\n    best_K = 0\n    \n    for K in range(2 * 10**9 + 1):\n        correct_count = 1\n        prev_key = a[0]\n        \n        for i in range(1, N):\n            if a[i] > prev_key:\n                next_key = prev_key + K\n            elif a[i] < prev_key:\n                next_key = prev_key - K\n            else:\n                next_key = prev_key\n            \n            if abs(next_key - a[i]) <= K:\n                correct_count += 1\n                prev_key = next_key\n        \n        if correct_count > max_correct:\n            max_correct = correct_count\n            best_K = K\n    \n    return max_correct, best_K\n\n# Read input\nN = int(input().strip())\na = list(map(int, input().strip().split()))\n\n# Get the result\nresult = max_correct_keys(N, a)\n\n# Print output\nprint(result[0])\nprint(result[1])",
        "result": "failed: testcase 0"
    },
    "3371": {
        "body": "import sys\n\n    if n <= 2:\n        return 1948\n    \n    edges = [[] for _ in range(n + 1)]\n    for a, b, y in encounters:\n        edges[a].append((b, y))\n        edges[b].append((a, y))\n    \n        visited[node] = True\n        parts[part].add(node)\n        \n        for neighbor, encounter_year in edges[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, encounter_year, 1 - part)\n    \n    for Y in range(2007, 1947, -1):\n        visited = [False] * (n + 1)\n        parts = [{}, {}]\n        \n        for i in range(1, n + 1):\n            if not visited[i]:\n                dfs(i, float('inf'), 0)\n        \n        part1_size = len(parts[0])\n        part2_size = len(parts[1])\n        \n        if part1_size <= (2 * n) // 3 and part2_size <= (2 * n) // 3:\n            return Y\n    \n    return 'Impossible'\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    c = int(data[1])\n    encounters = []\n    index = 2\n    for _ in range(c):\n        a = int(data[index]) - 1\n        b = int(data[index + 1]) - 1\n        y = int(data[index + 2])\n        encounters.append((a, b, y))\n        index += 3\n    \n    result = find_division_year(n, c, encounters)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3621": {
        "body": "import sys\n\n    mod = 10**9 + 7\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n        if node == n:\n            return count\n        result = count\n        for neighbor in range(n):\n            if c[node][neighbor] == color and neighbor != parent:\n                result = max(result, dfs(neighbor, node, color, count + 1))\n        for neighbor in range(n):\n            if c[node][neighbor] != color and neighbor != parent:\n                result = max(result, dfs(neighbor, node, neighbor, 1))\n        return result\n    \n    total_sum = 0\n    for mask in range(1, 1 << n):\n        nodes = []\n        for i in range(n):\n            if (mask >> i) & 1:\n                nodes.append(i)\n        max_size = 0\n        for node in nodes:\n            for color in set(c[node]):\n                size = dfs(node, -1, color, 1)\n                max_size = max(max_size, size)\n        total_sum += max_size * (1 << len(nodes) - 1)\n    \n    return total_sum % mod\n\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nc = [[0] * n for _ in range(n)]\nindex = 1\nfor i in range(n):\n    for j in range(n):\n        c[i][j] = int(data[index])\n        index += 1\n\nresult = max_subset_size(n, c)\nprint(result)",
        "result": "failed: testcase 0"
    },
    "3392": {
        "body": "        return 0 <= x < N and 0 <= y < N\n\n        queue = [(start_i, start_j)]\n        visited = set([(start_i, start_j)])\n        size = 1\n        while queue:\n            i, j = queue.pop(0)\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + di, j + dj\n                if is_valid(ni, nj) and (ni, nj) not in visited:\n                    if heights[ni][nj] == heights[i][j]:\n                        queue.append((ni, nj))\n                        visited.add((ni, nj))\n                        size += 1\n        return size\n\n    max_size = 0\n    for i in range(N):\n        for j in range(N):\n            max_size = max(max_size, bfs(i, j))\n    return max_size\n\nN = int(input())\nheights = [list(map(int, input().split())) for _ in range(N)]\ngrowth_speeds = [list(map(int, input().split())) for _ in range(N)]\n\nprint(find_largest_group(N, heights, growth_speeds))",
        "result": "failed: testcase 0"
    },
    "3095": {
        "body": "import sys\n\n    r, s = len(matrix), len(matrix[0])\n    return matrix[r1][c1] + matrix[r2][c2] <= matrix[r1][c2] + matrix[r2][c1]\n\n    r, s = len(matrix), len(matrix[0])\n    max_size = 0\n    for r1 in range(r-1):\n        for c1 in range(s-1):\n            for r2 in range(r1+1, r):\n                for c2 in range(c1+1, s):\n                    if is_cool_submatrix(matrix, r1, c1, r2, c2):\n                        max_size = max(max_size, (r2 - r1 + 1) * (c2 - c1 + 1))\n    return max_size\n\nif __name__ == \"__main__\":\n    R, S = map(int, input().split())\n    matrix = [list(map(int, input().split())) for _ in range(R)]\n    result = max_extremely_cool_submatrix_size(matrix)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3769": {
        "body": "    MOD = 10**9 + 7\n    if k == 0:\n        return 1\n    else:\n        return pow(p, p - 2, MOD)\n\n# Read input from stdin\np, k = map(int, input().split())\n\n# Print the result\nprint(count_functions(p, k))",
        "result": "failed: testcase 0"
    },
    "3563": {
        "body": "import sys\n\n    # Sort coordinates to ensure they are in order\n    sorted_coords = sorted(coords)\n    \n    # Initialize the count of lines\n    line_count = 0\n    \n    # Iterate through the sorted coordinates\n    i = 0\n    while i < len(sorted_coords) - 1:\n        # If the next coordinate is directly above or below, skip it\n        if abs(sorted_coords[i + 1] - sorted_coords[i]) <= 1:\n            i += 2\n        else:\n            # Otherwise, a new line is needed\n            line_count += 1\n            i += 1\n    \n    return line_count\n\n# Read input\nn = int(input())\ncoords = list(map(int, input().split()))\n\n# Calculate and print the result\nprint(min_lines_to_cover_holes(n, coords))",
        "result": "failed: testcase 0"
    },
    "3618": {
        "body": "MOD = 998244353\n\n    if n == 1:\n        return 10\n    dp = [0] * (n + 1)\n    dp[1] = 10\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] * 8) % MOD\n    return dp[n]\n\nif __name__ == \"__main__\":\n    n = int(input())\n    print(count_best_friend_pairs(n))",
        "result": "failed: testcase 0"
    },
    "3830": {
        "body": "import sys\n\n    returnable_count = 0\n    for i in range(n):\n        if s[i] == '-' or (s[(i - 1) % n] == '>' and s[i] == '<'):\n            returnable_count += 1\n    return returnable_count\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    t = int(data[0])\n    index = 1\n    \n    results = []\n    for _ in range(t):\n        n = int(data[index])\n        s = data[index + 1]\n        index += 2\n        \n        result = count_returnable_rooms(n, s)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
        "result": "failed: testcase 0"
    },
    "3912": {
        "body": "    n = len(s)\n    freq = {}\n    for char in s:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    \n    total_chars = sum(freq.values())\n    max_length = total_chars // (n + 1) + 1\n    \n    result = []\n    current_palindrome = ''\n    for _ in range(max_length):\n        new_char = s[0]\n        if new_char not in freq:\n            continue\n        current_palindrome += new_char\n        freq[new_char] -= 1\n        if freq[new_char] == 0:\n            del freq[new_char]\n    \n    result.append(current_palindrome)\n    remaining_chars = ''.join(s for char, count in freq.items() for _ in range(count))\n    result.extend(min_palindromes(remaining_chars))\n    \n    return result\n\n# Read input\nn = int(input())\ns = input().strip()\n\n# Get the minimum number of palindromes and the palindromes themselves\nresult = min_palindromes(s)\n\n# Print the result\nprint(len(result))\nfor palindrome in result:\n    print(palindrome)",
        "result": "failed: testcase 0"
    },
    "3878": {
        "body": "import sys\n\n    graph = [[] for _ in range(n)]\n    for u, v in friends:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n        return all(len(graph[i]) == n - 1 for i in range(n))\n\n    steps = []\n    while not is_all_friends(graph):\n        max_friends = 0\n        selected_guest = -1\n        for i in range(n):\n            if len(graph[i]) > max_friends:\n                max_friends = len(graph[i])\n                selected_guest = i\n\n        steps.append(selected_guest + 1)\n        for friend in graph[selected_guest]:\n            for ffriend in graph[friend]:\n                if ffriend not in graph[friend]:\n                    graph[friend].append(ffriend)\n                    graph[ffriend].append(friend)\n\n    print(len(steps))\n    print(' '.join(map(str, steps)))\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    m = int(data[1])\n    friends = [(int(data[2 + 2 * i]) - 1, int(data[3 + 2 * i]) - 1) for i in range(m)]\n    \n    find_min_steps(n, m, friends)",
        "result": "failed: testcase 0"
    },
    "3010": {
        "body": "    points = set()\n    for i in range(n):\n        x0, y0, x1, y1 = lines[i]\n        if x0 == x1:\n            min_y = min(y0, y1)\n            max_y = max(y0, y1)\n            for j in range(min_y, max_y + 1):\n                points.add((x0, j))\n        else:\n            slope = (y1 - y0) / (x1 - x0)\n            intercept = y0 - slope * x0\n            for j in range(n):\n                if i != j:\n                    x2, y2, x3, y3 = lines[j]\n                    if x2 == x3:\n                        y = int(slope * x2 + intercept)\n                        if y == y2 or y == y3:\n                            points.add((x2, y))\n        if len(points) > 1000000:\n            return -1\n    return len(points)\n\nn = int(input())\nlines = [tuple(map(int, input().split())) for _ in range(n)]\nprint(count_distinct_points(n, lines))",
        "result": "failed: testcase 0"
    },
    "3068": {
        "body": "from itertools import combinations\n\n    n = int(input())\n    investigations = []\n    \n    for _ in range(n):\n        investigation = input().split()\n        investigations.append((investigation[0], investigation[1], int(investigation[2])))\n\n    suspects = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ')\n    valid_solutions = 0\n\n    for black_vienna in combinations(suspects, 3):\n        is_valid = True\n        for suspect_pair, player_number, reply in investigations:\n            count_in_hand = sum(1 for s in black_vienna if s in (suspect_pair[0], suspect_pair[1])) == reply\n            if not count_in_hand and player_number == 1 or count_in_hand and player_number == 2:\n                is_valid = False\n                break\n        \n        if is_valid:\n            valid_solutions += 1\n\n    print(valid_solutions)\n\ncount_admissible_solutions()",
        "result": "failed: testcase 0"
    },
    "3030": {
        "body": "import sys\n\n    heap_size = [0] * n\n    \n    for i in range(1, n):\n        parent = nodes[i][1]\n        if nodes[parent][0] < nodes[i][0]:\n            heap_size[i] = heap_size[parent] + 1\n    \n    return max(heap_size) + 1\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    nodes = [tuple(map(int, input().strip().split())) for _ in range(n)]\n    \n    result = max_heap_subset(n, nodes)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3630": {
        "body": "    n = len(s1)\n    moves = 0\n    \n    for i in range(n):\n        if s1[i] != s2[i]:\n            diff = (ord(s2[i]) - ord(s1[i])) % 26\n            \n            if diff > 13:\n                diff = 26 - diff\n            \n            moves += diff\n    \n    return moves\n\n# Read input\ns1, s2 = input().split()\n\n# Output the result\nprint(min_moves(s1, s2))",
        "result": "failed: testcase 0"
    },
    "3133": {
        "body": "import sys\n\n    stack_a = [a]\n    stack_b = [b]\n    \n    while True:\n        if not stack_a or not stack_b:\n            return \"indistinguishable\"\n        \n        current_a = stack_a.pop()\n        current_b = stack_b.pop()\n        \n        for _ in range(2):\n            next_a = intersections[current_a][0] if _ == 0 else intersections[current_a][1]\n            next_b = intersections[current_b][0] if _ == 0 else intersections[current_b][1]\n            \n            if next_a != current_a and next_b != current_b:\n                stack_a.append(next_a)\n                stack_b.append(next_b)\n    \n    return \"indistinguishable\"\n\n# Read input\nn, a, b = map(int, input().split())\nintersections = []\nfor _ in range(n):\n    l, r, t = map(int, input().split())\n    intersections.append((l, r, t))\n\n# Calculate and print result\nprint(min_turns_to_distinguish(n, a, b, intersections))",
        "result": "failed: testcase 0"
    },
    "3480": {
        "body": "import sys\n\n    for i in range(L):\n        first_voice = lines[2 * i].split()\n        second_voice_times = list(map(int, lines[2 * i + 1].split()))\n        output_line_1 = \"\"\n        output_line_2 = \"\"\n        \n        j = 0\n        k = D\n        \n        for syllable in first_voice:\n            if j < len(second_voice_times):\n                time = second_voice_times[j]\n                while k >= time and j < len(second_voice_times):\n                    k -= time\n                    j += 1\n                    if j < len(second_voice_times):\n                        time = second_voice_times[j]\n            \n            output_line_1 += syllable + \"_\"\n            output_line_2 += \" \" * max(0, k) + syllable\n        \n        print(output_line_1.rstrip('_'))\n        print(output_line_2.rstrip())\n\nif __name__ == \"__main__\":\n    L, D = map(int, input().split())\n    lines = [input().strip() for _ in range(2 * L)]\n    generate_round(L, D, lines)",
        "result": "failed: testcase 0"
    },
    "3389": {
        "body": "import sys\n\n    clicks = 0\n    current_type = None\n    \n    for video in video_list:\n        if video != current_type:\n            clicks += 1\n            current_type = video\n            \n    return clicks\n\n# Read input from stdin\nn, k = map(int, input().split())\nvideo_list = input().strip()\n\n# Output the result\nprint(min_clicks_to_watch_videos(n, k, video_list))",
        "result": "failed: testcase 0"
    },
    "3925": {
        "body": "    n = len(s)\n    max_len = 0\n    for i in range(n):\n        current_len = 1\n        for j in range(i + 1, n):\n            if s[j] != s[j - 1]:\n                current_len += 1\n            else:\n                break\n        max_len = max(max_len, current_len)\n    return max_len\n\n# Read input from stdin\ns = input().strip()\n\n# Print the result\nprint(max_zebra_length(s))",
        "result": "failed: testcase 0"
    },
    "3700": {
        "body": "    ways = 0\n    for i in range(1, n):\n        j = k - i\n        if j > i <= n:\n            ways += 1\n    return ways\n\n# Read input from stdin\nn, k = map(int, input().split())\n\n# Print the result\nprint(count_ways(n, k))",
        "result": "failed: testcase 0"
    },
    "3944": {
        "body": "    MOD = 1_000_000_007\n    total_patterns = pow(3, n + m + k, MOD)\n    win_patterns = 0\n    \n    for a in range(3):\n        for b in range(3):\n            for c in range(3):\n                if (a == 0 and (b == 1 or c == 2)) or (a == 1 and (b == 0 or c == 2)) or (a == 2 and (b == 0 or c == 1)):\n                    win_patterns += 1\n                    \n    return win_patterns % MOD\n\nif __name__ == \"__main__\":\n    n, m, k = map(int, input().split())\n    print(alice_victory_count(n, m, k))",
        "result": "failed: testcase 0"
    },
    "3821": {
        "body": "import itertools\nimport sys\n\n    max_probability = 0\n    for k in range(1, n + 1):\n        for subset in itertools.combinations(p, k):\n            probability = 1 * (1 - sum(subset)) ** (n - k)\n            for prob in subset:\n                probability *= prob\n            if probability > max_probability:\n                max_probability = probability\n    return max_probability\n\ninput = sys.stdin.read\ndata = input().split()\nn = int(data[0])\np = list(map(float, data[1:]))\n\nprint(f\"{max_prob(n, p):.12f}\")",
        "result": "failed: testcase 0"
    },
    "3667": {
        "body": "    intersections = set()\n    \n    for s, x, y in pipes:\n        for well_x, well_y in wells:\n            if (x, y) == (well_x, well_y):\n                continue\n            if (x - well_x) * (y - well_y) == 0:\n                intersections.add((s, x, y))\n    \n    visited = set()\n    \n        if pipe in visited:\n            return False\n        visited.add(pipe)\n        for s, x, y in pipes:\n            if s != pipe and (x, y) in intersections:\n                if not dfs(s, visited):\n                    return False\n        return True\n    \n    for i in range(w):\n        if not dfs(i + 1, visited):\n            return \"impossible\"\n    \n    return \"possible\"\n\nimport sys\n\n# Read input from stdin\nw, p = map(int, input().split())\nwells = [tuple(map(int, input().split())) for _ in range(w)]\npipes = [tuple(map(int, input().split())) for _ in range(p)]\n\n# Output the result\nprint(can_clean_all_intersections(w, p, wells, pipes))",
        "result": "failed: testcase 0"
    },
    "3959": {
        "body": "import sys\nfrom collections import Counter\n\n    MOD = 10**9 + 7\n    \n        result = 1\n        for i in range(2, x + 1):\n            result = (result * i) % MOD\n        return result\n    \n    type_counts = Counter()\n    \n    for gym in gyms:\n        types = set(gym[1:])\n        for t in types:\n            type_counts[t] += 1\n    \n    valid_plans = factorial(m)\n    for count in type_counts.values():\n        valid_plans = (valid_plans * pow(factorial(count), MOD - 2, MOD)) % MOD\n    \n    return valid_plans\n\n# Read input\nn, m = map(int, input().split())\ngyms = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Output result\nprint(count_evolution_plans(n, m, gyms))",
        "result": "failed: testcase 0"
    },
    "3692": {
        "body": "import sys\n\n    regions = 1  # Start with one infinite region\n    for i in range(n):\n        for j in range(i + 1, n):\n            xi, yi, ri = circles[i]\n            xj, yj, rj = circles[j]\n            distance = ((xi - xj) ** 2 + (yi - yj) ** 2) ** 0.5\n            if distance < ri + rj:\n                regions += 1\n    return regions\n\nif __name__ == \"__main__\":\n    n = int(input().strip())\n    circles = []\n    for _ in range(n):\n        x, y, r = map(int, input().strip().split())\n        circles.append((x, y, r))\n    \n    result = count_regions(n, circles)\n    print(result)",
        "result": "failed: testcase 0"
    },
    "3894": {
        "body": "    total_cows = sum(a)\n    if total_cows % 2 == 0:\n        return \"Kevin\"\n    else:\n        return \"Nicky\"\n\n# Read input\nn, k = map(int, input().split())\na = list(map(int, input().split()))\n\n# Determine and print the winner\nprint(determine_winner(n, k, a))",
        "result": "failed: testcase 0"
    },
    "3856": {
        "body": "import sys\n\n    friends.sort()\n    vertical = sorted([(w, h) for w, h in friends])\n    horizontal = [(h, w) for w, h in friends]\n    vertical.sort(reverse=True)\n    \n    min_area = float('inf')\n    \n    for i in range(0, n + 1, 2):\n        if i > n // 2:\n            break\n        area = sum(w * max(h, vertical[i + j][1]) for j in range(i)) + sum(w * max(h, horizontal[j][1]) for j in range(n - i))\n        min_area = min(min_area, area)\n    \n    return min_area\n\nif __name__ == \"__main__\":\n    n = int(input())\n    friends = [tuple(map(int, input().split())) for _ in range(n)]\n    print(min_photo_area(n, friends))",
        "result": "failed: testcase 0"
    },
    "3282": {
        "body": "import sys\n\n    digits = set(str(P))\n    valid_bills = []\n    for beverage in range(1, P // 2):\n        if str(beverage).intersection(digits):\n            continue\n        for main_dish in range(beverage + 1, P - beverage):\n            if str(main_dish).intersection(digits):\n                continue\n            total = beverage + main_dish\n            if str(total).intersection(digits) or total != P:\n                continue\n            valid_bills.append((beverage, main_dish))\n    return len(valid_bills), valid_bills[:5000]\n\nif __name__ == \"__main__\":\n    P = int(input())\n    count, bills = count_desserts(P)\n    print(count)\n    for bill in bills:\n        print(f\"{bill[0]} {bill[1]}\")",
        "result": "failed: testcase 0"
    },
    "3596": {
        "body": "import math\nfrom scipy.special import erf, gamma, jn\n\n        return c * (t1 * gamma(x) + x**(1/t2) * math.log(erf(t3 * x)) - jn(k, x)**t4)\n    \n        p = 0\n        for i in range(r + 1):\n            coeff = f(math.factorial(i))\n            p += coeff / math.factorial(i) * x**i\n        return p\n    \n    Ps = P(n)\n    g = Ps\n    for _ in range(s):\n        g = sum(Ps(i) * x**i for i, x in enumerate(range(r + s + 1)))\n    \n    degree = r + s\n    diff_g = 0\n    for i in range(degree, -1, -1):\n        diff_g *= n\n        if i > 0:\n            diff_g += g / i\n    \n    location = (diff_g + l)**2 / math.pi * math.e + 1 / (l + 1)\n    return round(location, 2)\n\n# Read input from stdin\na, b, c = map(float, input().split())\nt1, t2, t3, t4 = map(int, input().split())\nn, k, r, s, l = map(int, input().split())\n\n# Calculate and print the location of Arnar's opponent\nlocation = calculate_location(a, b, c, t1, t2, t3, t4, n, k, r, s, l)\nprint(location)",
        "result": "failed: testcase 0"
    },
    "3540": {
        "body": "    grid = [list(input().strip()) for _ in range(4)]\n    \n    target = ['R', 'G', 'B', 'Y']\n    min_moves = float('inf')\n    \n    for r in range(4):\n        for c in range(4):\n            moves = 0\n            current_grid = [row[:] for row in grid]\n            \n            # Move rows to the correct position\n            for i in range(4):\n                if current_grid[i] != target:\n                    diff = [x != y for x, y in zip(current_grid[i], target)]\n                    move_count = sum(diff)\n                    moves += min(move_count // 2, (4 - move_count) // 2)\n                    current_grid[i] = target[:]\n            \n            # Move columns to the correct position\n            for j in range(4):\n                col = [current_grid[i][j] for i in range(4)]\n                if col != target:\n                    diff = [x != y for x, y in zip(col, target)]\n                    move_count = sum(diff)\n                    moves += min(move_count // 2, (4 - move_count) // 2)\n                    for i in range(4):\n                        current_grid[i][j] = target[i]\n            \n            min_moves = min(min_moves, moves)\n    \n    print(min_moves)\n\nsolve_puzzle()",
        "result": "failed: testcase 0"
    },
    "3354": {
        "body": "import math\n\n    area_sandwich = math.pi * s**2\n    area_pickle = math.pi * r**2\n    max_area_covered = (z / 100) * area_sandwich\n    \n    count = 0\n    for _ in range(n):\n        if area_sandwich <= max_area_covered:\n            break\n        area_sandwich -= area_pickle\n        count += 1\n    \n    return count\n\n# Read input from stdin\ns, r, n, z = map(float, input().split())\nn, z = int(n), int(z)\n\n# Print the result\nprint(max_pickles(s, r, n, z))",
        "result": "failed: testcase 0"
    },
    "3217": {
        "body": "    if not defective_cells:\n        return 0\n    \n    x_min = y_min = z_min = float('inf')\n    x_max = y_max = z_max = -1\n    \n    for cell in defective_cells:\n        x, y, z = cell\n        if x < x_min: x_min = x\n        if y < y_min: y_min = y\n        if z < z_min: z_min = z\n        if x > x_max: x_max = x\n        if y > y_max: y_max = y\n        if z > z_max: z_max = z\n    \n    width = x_max - x_min + 1\n    height = y_max - y_min + 1\n    depth = z_max - z_min + 1\n    \n    return (width * 2) + (height * 2) + (depth * 2)\n\n# Read input from stdin\nn = int(input())\n\n# Output the result\nprint(min_panels(defective_cells))",
        "result": "failed: testcase 0"
    },
    "3520": {
        "body": "import sys\n\n    # Initialize variables\n    time = 0\n    current_pill_age = 0\n    best_age = 0\n    \n    for t, x, y in pills:\n        if time < t:\n            # Age without pill\n            age_without_pill = (t - time) * n\n            best_age += max(age_without_pill + current_pill_age, best_age)\n        \n        # Switch to new pill\n        age_with_new_pill = (x - y) * n + c\n        best_age += age_with_new_pill\n        \n        # Update current pill age and time\n        current_pill_age = age_with_new_pill\n        time = t\n    \n    # Age without pill until the end\n    if time < n:\n        age_without_pill = (n - time) * n\n        best_age += max(age_without_pill + current_pill_age, best_age)\n    \n    return best_age\n\n# Read input\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\np = int(data[1])\nc = int(data[2])\n\npills = []\nfor i in range(p):\n    t = int(data[3 + 3 * i])\n    x = int(data[4 + 3 * i])\n    y = int(data[5 + 3 * i])\n    pills.append((t, x, y))\n\n# Calculate and print the result\nprint(max_life(n, p, c, pills))",
        "result": "failed: testcase 0"
    },
    "3475": {
        "body": "    t, n = map(int, input().split())\n    transport_types = [tuple(map(int, input().split())) for _ in range(t)]\n    distances_angles = [tuple(map(int, input().split())) for _ in range(n-1)]\n\n        current_angle = 0\n        total_distance = 0\n        for i in range(start_index, end_index + 1):\n            distance, angle = distances_angles[i]\n            if abs(current_angle - angle) > r_max:\n                return False\n            total_distance += distance\n            current_angle = angle\n        return total_distance >= d_min\n\n    min_switches = float('inf')\n    for start_type in range(t):\n        for end_index in range(n-1):\n            if is_valid_transport(start_type, end_index):\n                switches = (end_index - start_type) // 2 + 1\n                min_switches = min(min_switches, switches)\n\n    print(min_switches if min_switches != float('inf') else \"IMPOSSIBLE\")\n\nmin_transports()",
        "result": "failed: testcase 0"
    },
    "3977": {
        "body": "import sys\n\n    # Create adjacency list for the graph\n    adj = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    # Find the number of connected components in the graph\n    visited = [False] * (n + 1)\n    component_count = 0\n    \n        if not visited[node]:\n            visited[node] = True\n            for neighbor in adj[node]:\n                dfs(neighbor)\n    \n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n            component_count += 1\n    \n    # Calculate the maximum number of edges that can be added\n    remaining_edges = m - component_count + 1\n    max_addable_edges = min(k * (k - 1) // 2, remaining_edges)\n    \n    return max_addable_edges\n\n# Read input from stdin\ninput = sys.stdin.read\ndata = input().split()\n\nn = int(data[0])\nm = int(data[1])\nk = int(data[2])\n\nc = list(map(int, data[3:3 + k]))\n\nedges = []\nfor i in range(m):\n    u = int(data[3 + k + 2 * i]) - 1\n    v = int(data[3 + k + 2 * i + 1]) - 1\n    edges.append((u + 1, v + 1))\n\n# Calculate and print the result\nprint(max_edges(n, m, k, c, edges))",
        "result": "failed: testcase 0"
    },
    "3626": {
        "body": "import sys\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, x2, y2 = rectangles[i]\n            x3, y3, x4, y4 = rectangles[j]\n            if not (x2 <= x3 or x4 <= x1 or y2 <= y3 or y4 <= y1):\n                return 1\n    return 0\n\nif __name__ == \"__main__\":\n    n = int(input())\n    rectangles = [tuple(map(int, input().split())) for _ in range(n)]\n    print(do_rectangles_intersect(n, rectangles))",
        "result": "failed: testcase 0"
    },
    "3584": {
        "body": "import sys\nfrom itertools import combinations\n\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0:\n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\n    n = len(points)\n    points.sort()\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and orientation(lower[-2], lower[-1], p) != 2:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and orientation(upper[-2], upper[-1], p) != 2:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]\n\n    hull = convex_hull(posts)\n    n_hull = len(hull)\n    \n    max_protected = 0\n    \n    for i in range(K + 1):\n        if i <= n_hull and (K - i) <= (M - n_hull):\n            protected_by_current = 0\n            for onion in onions:\n                inside = False\n                j, k = 0, 1\n                while not inside and k < n_hull + i:\n                    x = hull[k % n_hull][0]\n                    y = hull[k % n_hull][1]\n                    if orientation(post, onion, (x, y)) == 0 and min(hull[k % n_hull][0], post[0]) <= onion[0] <= max(hull[k % n_hull][0], post[0]):\n                        inside = True\n                    k += 1\n                if inside:\n                    protected_by_current += 1\n            max_protected = max(max_protected, protected_by_current)\n    \n    return max_protected\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    K = int(data[2])\n    \n    onions = []\n    index = 3\n    for _ in range(N):\n        X = int(data[index])\n        Y = int(data[index + 1])\n        onions.append((X, Y))\n        index += 2\n    \n    posts = []\n    for _ in range(M):\n        A = int(data[index])\n        B = int(data[index + 1])\n        posts.append((A, B))\n        index += 2\n    \n    print(max_onions(N, M, K, onions, posts))",
        "result": "failed: testcase 0"
    },
    "3950": {
        "body": "    if any(x == 0 for x in a):\n        return \"NO\"\n    \n    result = [0] * n\n    queries = []\n    \n    for i in range(q):\n        segment = list(range(1, n + 1))\n        for j in range(n):\n            if a[j] <= i + 1:\n                segment.remove(j + 1)\n        \n        if not segment:\n            return \"NO\"\n        \n        l = min(segment) - 1\n        r = max(segment)\n        queries.append((l, r))\n        for k in range(l, r + 1):\n            result[k] = i + 1\n    \n    return \"YES\\n\" + ' '.join(map(str, result))\n\n# Read input from stdin\nn, q = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print the output\nprint(can_be_obtained(n, q, a))",
        "result": "failed: testcase 0"
    },
    "3075": {
        "body": "import sys\n\n    gas_stations.sort()\n    total_cost = 0\n    current_fuel = g\n    \n    for d, c in gas_stations:\n        if d > current_fuel:\n            return \"cancel road trip\"\n        refuel_amount = max(0, d - current_fuel)\n        total_cost += refuel_amount * c\n        current_fuel -= refuel_amount\n        current_fuel += g\n    \n    return total_cost\n\n# Read input\nn, g = map(int, input().split())\ngas_stations = [tuple(map(int, input().split())) for _ in range(n)]\n\n# Calculate and print the result\nprint(min_cost_to_travel(n, g, gas_stations))",
        "result": "failed: testcase 0"
    },
    "3711": {
        "body": "    if k >= (n - 1) * (m - 1):\n        return -1\n    cuts = sorted([n - 1, m - 1], reverse=True)\n    for _ in range(k):\n        cuts[0] -= 1\n        cuts.sort(reverse=True)\n    return min(cuts)\n\n# Read input\nn, m, k = map(int, input().split())\n\n# Output the result\nprint(max_smallest_piece(n, m, k))",
        "result": "failed: testcase 0"
    }
}